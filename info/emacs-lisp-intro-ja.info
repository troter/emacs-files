-*-coding:utf-8-*-
This is emacs-lisp-intro-ja.info, produced by makeinfo version 4.13
from emacs-lisp-intro.texi.

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Emacs Lisp Intro ja: (emacs-lisp-intro-ja).
  			A simple introduction to Emacs Lisp programming.
END-INFO-DIR-ENTRY

   これはプログラマではない人のための `Emacs Lisp プログラミング' 解 説書である．

   Edition 2.04, 2001 Dec 17

   Copyright (C) 1990, '91, '92, '93, '94, '95, '97, 2001 Free Software
Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Section being the Preface, with the Front-Cover Texts being
no Front-Cover Texts, and with the Back-Cover Texts being no Back-Cover
Texts.  A copy of the license is included in the section entitled "GNU
Free Documentation License".


File: emacs-lisp-intro-ja.info,  Node: Top,  Next: Preface,  Prev: (dir),  Up: (dir)

An Introduction to Programming in Emacs Lisp
********************************************

これはプログラマではない人のための `Emacs Lisp プログラミング' 解 説書である．

   以下にあるメニューは各章のリストである．ここにはすべての章のすべての節 を一覧してある．

* Menu:

* PrePreface::                  訳者まえがき
* Preface::                     What to look for.
* List Processing::             What is Lisp?
* Practicing Evaluation::       Running several programs.
* Writing Defuns::              How to write function definitions.
* Buffer Walk Through::         Exploring a few buffer-related functions.
* More Complex::                A few, even more complex functions.
* Narrowing & Widening::        Restricting your and Emacs attention to
                                    a region.
* car cdr & cons::              Fundamental functions in Lisp.
* Cutting & Storing Text::      Removing text and saving it.
* List Implementation::         How lists are implemented in the computer.
* Yanking::                     Pasting stored text.
* Loops & Recursion::           How to repeat a process.
* Regexp Search::               Regular expression searches.
* Counting Words::              A review of repetition and regexps.
* Words in a defun::            Counting words in a `defun'.
* Readying a Graph::            A prototype graph printing function.
* Emacs Initialization::        How to write a `.emacs' file.
* Debugging::                   How to run the Emacs Lisp debuggers.
* Conclusion::                  Now you have the basics.
* the-the::                     An appendix: how to find reduplicated words.
* Kill Ring::                   An appendix: how the kill ring works.
* Full Graph::                  How to create a graph with labelled axes.
* GNU Free Documentation License::
* Index::
* About the Author::

 --- The Detailed Node Listing ---

Preface

* Why::                         Why learn Emacs Lisp?
* On Reading this Text::        Read, gain familiarity, pick up habits....
* Who You Are::                 For whom this is written.
* Lisp History::
* Note for Novices::            You can read this as a novice.
* Thank You::

List Processing

* Lisp Lists::                  What are lists?
* Run a Program::               Any list in Lisp is a program ready to run.
* Making Errors::               Generating an error message.
* Names & Definitions::         Names of symbols and function definitions.
* Lisp Interpreter::            What the Lisp interpreter does.
* Evaluation::                  Running a program.
* Variables::                   Returning a value from a variable.
* Arguments::                   Passing information to a function.
* set & setq::                  Setting the value of a variable.
* Summary::                     The major points.
* Error Message Exercises::

Lisp Lists

* Numbers Lists::               List have numbers, other lists, in them.
* Lisp Atoms::                  Elemental entities.
* Whitespace in Lists::         Formating lists to be readable.
* Typing Lists::                How GNU Emacs helps you type lists.

The Lisp Interpreter

* Complications::               Variables, Special forms, Lists within.
* Byte Compiling::              Specially processing code for speed.

Evaluation

* Evaluating Inner Lists::      Lists within lists...

Variables

* fill-column Example::
* Void Function::               The error message for a symbol
                                  without a function.
* Void Variable::               The error message for a symbol without a value.

Arguments

* Data types::                  Types of data passed to a function.
* Args as Variable or List::    An argument can be the value
                                  of a variable or list.
* Variable Number of Arguments::  Some functions may take a
                                  variable number of arguments.
* Wrong Type of Argument::      Passing an argument of the wrong type
                                  to a function.
* message::                     A useful function for sending messages.

Setting the Value of a Variable

* Using set::                   Setting values.
* Using setq::                  Setting a quoted value.
* Counting::                    Using `setq' to count.

Practicing Evaluation

* How to Evaluate::             Typing editing commands or C-x C-e
                                  causes evaluation.
* Buffer Names::                Buffers and files are different.
* Getting Buffers::             Getting a buffer itself, not merely its name.
* Switching Buffers::           How to change to another buffer.
* Buffer Size & Locations::     Where point is located and the size of
                                the buffer.
* Evaluation Exercise::

How To Write Function Definitions

* Primitive Functions::
* defun::                       The `defun' special form.
* Install::                     Install a function definition.
* Interactive::                 Making a function interactive.
* Interactive Options::         Different options for `interactive'.
* Permanent Installation::      Installing code permanently.
* let::                         Creating and initializing local variables.
* if::                          What if?
* else::                        If--then--else expressions.
* Truth & Falsehood::           What Lisp considers false and true.
* save-excursion::              Keeping track of point, mark, and buffer.
* Review::
* defun Exercises::

Install a Function Definition

* Effect of installation::
* Change a defun::              How to change a function definition.

Make a Function Interactive

* Interactive multiply-by-seven::  An overview.
* multiply-by-seven in detail::  The interactive version.

`let'

* Prevent confusion::
* Parts of let Expression::
* Sample let Expression::
* Uninitialized let Variables::

The `if' Special Form

* if in more detail::
* type-of-animal in detail::    An example of an `if' expression.

Truth and Falsehood in Emacs Lisp

* nil explained::               `nil' has two meanings.

`save-excursion'

* Point and mark::              A review of various locations.
* Template for save-excursion::

A Few Buffer--Related Functions

* Finding More::                How to find more information.
* simplified-beginning-of-buffer::  Shows `goto-char',
                                `point-min', and `push-mark'.
* mark-whole-buffer::           Almost the same as `beginning-of-buffer'.
* append-to-buffer::            Uses `save-excursion' and
                                `insert-buffer-substring'.
* Buffer Related Review::       Review.
* Buffer Exercises::

The Definition of `mark-whole-buffer'

* mark-whole-buffer overview::
* Body of mark-whole-buffer::   Only three lines of code.

The Definition of `append-to-buffer'

* append-to-buffer overview::
* append interactive::          A two part interactive expression.
* append-to-buffer body::       Incorporates a `let' expression.
* append save-excursion::       How the `save-excursion' works.

A Few More Complex Functions

* copy-to-buffer::              With `set-buffer', `get-buffer-create'.
* insert-buffer::               Read-only, and with `or'.
* beginning-of-buffer::         Shows `goto-char',
                                `point-min', and `push-mark'.
* Second Buffer Related Review::
* optional Exercise::

The Definition of `insert-buffer'

* insert-buffer code::
* insert-buffer interactive::   When you can read, but not write.
* insert-buffer body::          The body has an `or' and a `let'.
* if & or::                     Using an `if' instead of an `or'.
* Insert or::                   How the `or' expression works.
* Insert let::                  Two `save-excursion' expressions.

The Interactive Expression in `insert-buffer'

* Read-only buffer::            When a buffer cannot be modified.
* b for interactive::           An existing buffer or else its name.

Complete Definition of `beginning-of-buffer'

* Optional Arguments::
* beginning-of-buffer opt arg::  Example with optional argument.
* beginning-of-buffer complete::

`beginning-of-buffer' with an Argument

* Disentangle beginning-of-buffer::
* Large buffer case::
* Small buffer case::

Narrowing and Widening

* Narrowing advantages::        The advantages of narrowing
* save-restriction::            The `save-restriction' special form.
* what-line::                   The number of the line that point is on.
* narrow Exercise::

`car', `cdr', `cons': Fundamental Functions

* Strange Names::               An historical aside: why the strange names?
* car & cdr::                   Functions for extracting part of a list.
* cons::                        Constructing a list.
* nthcdr::                      Calling `cdr' repeatedly.
* nth::
* setcar::                      Changing the first element of a list.
* setcdr::                      Changing the rest of a list.
* cons Exercise::

`cons'

* Build a list::
* length::                      How to find the length of a list.

Cutting and Storing Text

* Storing Text::                Text is stored in a list.
* zap-to-char::                 Cutting out text up to a character.
* kill-region::                 Cutting text out of a region.
* Digression into C::           Minor note on C programming language macros.
* defvar::                      How to give a variable an initial value.
* copy-region-as-kill::         A definition for copying text.
* cons & search-fwd Review::
* search Exercises::

`zap-to-char'

* Complete zap-to-char::        The complete implementation.
* zap-to-char interactive::     A three part interactive expression.
* zap-to-char body::            A short overview.
* search-forward::              How to search for a string.
* progn::                       The `progn' special form.
* Summing up zap-to-char::      Using `point' and `search-forward'.

`kill-region'

* Complete kill-region::        The function definition.
* condition-case::              Dealing with a problem.
* delete-and-extract-region::   Doing the work.

Initializing a Variable with `defvar'

* See variable current value::
* defvar and asterisk::         An old-time convention.

`copy-region-as-kill'

* Complete copy-region-as-kill::  The complete function definition.
* copy-region-as-kill body::    The body of `copy-region-as-kill'.

The Body of `copy-region-as-kill'

* last-command & this-command::
* kill-append function::
* kill-new function::

How Lists are Implemented

* Lists diagrammed::
* Symbols as Chest::            Exploring a powerful metaphor.
* List Exercise::

Yanking Text Back

* Kill Ring Overview::          The kill ring is a list.
* kill-ring-yank-pointer::      The `kill-ring-yank-pointer' variable.
* yank nthcdr Exercises::

Loops and Recursion

* while::                       Causing a stretch of code to repeat.
* dolist dotimes::
* Recursion::                   Causing a function to call itself.
* Looping exercise::

`while'

* Looping with while::          Repeat so long as test returns true.
* Loop Example::                A `while' loop that uses a list.
* print-elements-of-list::      Uses `while', `car', `cdr'.
* Incrementing Loop::           A loop with an incrementing counter.
* Decrementing Loop::           A loop with a decrementing counter.

A Loop with an Incrementing Counter

* Incrementing Example::        Counting pebbles in a triangle.
* Inc Example parts::           The parts of the function definition.
* Inc Example altogether::      Putting the function definition together.

Loop with a Decrementing Counter

* Decrementing Example::        More pebbles on the beach.
* Dec Example parts::           The parts of the function definition.
* Dec Example altogether::      Putting the function definition together.

Save your time: `dolist' and `dotimes'

* dolist::
* dotimes::

Recursion

* Building Robots::             Same model, different serial number ...
* Recursive Definition Parts::  Walk until you stop ...
* Recursion with list::         Using a list as the test whether to recurse.
* Recursive triangle function::
* Recursion with cond::
* Recursive Patterns::          Often used templates.
* No Deferment::                Don't store up work ...
* No deferment solution::

Recursion in Place of a Counter

* Recursive Example arg of 1 or 2::
* Recursive Example arg of 3 or 4::

Recursive Patterns

* Every::
* Accumulate::
* Keep::

Regular Expression Searches

* sentence-end::                The regular expression for `sentence-end'.
* re-search-forward::           Very similar to `search-forward'.
* forward-sentence::            A straightforward example of regexp search.
* forward-paragraph::           A somewhat complex example.
* etags::                       How to create your own `TAGS' table.
* Regexp Review::
* re-search Exercises::

`forward-sentence'

* Complete forward-sentence::
* fwd-sentence while loops::    Two `while' loops.
* fwd-sentence re-search::      A regular expression search.

`forward-paragraph': a Goldmine of Functions

* forward-paragraph in brief::  Key parts of the function definition.
* fwd-para let::                The `let*' expression.
* fwd-para while::              The forward motion `while' loop.
* fwd-para between paragraphs::  Movement between paragraphs.
* fwd-para within paragraph::   Movement within paragraphs.
* fwd-para no fill prefix::     When there is no fill prefix.
* fwd-para with fill prefix::   When there is a fill prefix.
* fwd-para summary::            Summary of `forward-paragraph' code.

Counting: Repetition and Regexps

* Why Count Words::
* count-words-region::          Use a regexp, but find a problem.
* recursive-count-words::       Start with case of no words in region.
* Counting Exercise::

The `count-words-region' Function

* Design count-words-region::   The definition using a `while' loop.
* Whitespace Bug::              The Whitespace Bug in `count-words-region'.

Counting Words in a `defun'

* Divide and Conquer::
* Words and Symbols::           What to count?
* Syntax::                      What constitutes a word or symbol?
* count-words-in-defun::        Very like `count-words'.
* Several defuns::              Counting several defuns in a file.
* Find a File::                 Do you want to look at a file?
* lengths-list-file::           A list of the lengths of many definitions.
* Several files::               Counting in definitions in different files.
* Several files recursively::   Recursively counting in different files.
* Prepare the data::            Prepare the data for display in a graph.

Count Words in `defuns' in Different Files

* lengths-list-many-files::     Return a list of the lengths of defuns.
* append::                      Attach one list to another.

Prepare the Data for Display in a Graph

* Sorting::                     Sorting lists.
* Files List::                  Making a list of files.
* Counting function definitions::

Readying a Graph

* Columns of a graph::
* graph-body-print::            How to print the body of a graph.
* recursive-graph-body-print::
* Printed Axes::
* Line Graph Exercise::

Your `.emacs' File

* Default Configuration::
* Site-wide Init::              You can write site-wide init files.
* defcustom::                   Emacs will write code for you.
* Beginning a .emacs File::     How to write a `.emacs file'.
* Text and Auto-fill::          Automatically wrap lines.
* Mail Aliases::                Use abbreviations for email addresses.
* Indent Tabs Mode::            Don't use tabs with TeX
* Keybindings::                 Create some personal keybindings.
* Keymaps::                     More about key binding.
* Loading Files::               Load (i.e., evaluate) files automatically.
* Autoload::                    Make functions available.
* Simple Extension::            Define a function; bind it to a key.
* X11 Colors::                  Colors in version 19 in X.
* Miscellaneous::
* Mode Line::                   How to customize your mode line.

Debugging

* debug::                       How to use the built-in debugger.
* debug-on-entry::              Start debugging when you call a function.
* debug-on-quit::               Start debugging when you quit with C-g.
* edebug::                      How to use Edebug, a source level debugger.
* Debugging Exercises::

Handling the Kill Ring

* rotate-yank-pointer::         Move a pointer along a list and around.
* yank::                        Paste a copy of a clipped element.
* yank-pop::                    Insert first element pointed to.

The `rotate-yank-pointer' Function

* Understanding rotate-yk-ptr::
* rotate-yk-ptr body::          The body of `rotate-yank-pointer'.

The Body of `rotate-yank-pointer'

* Digression concerning error::  How to mislead humans, but not computers.
* rotate-yk-ptr else-part::     The else-part of the `if' expression.
* Remainder Function::          The remainder, `%', function.
* rotate-yk-ptr remainder::     Using `%' in `rotate-yank-pointer'.
* kill-rng-yk-ptr last elt::    Pointing to the last element.

`yank'

* rotate-yk-ptr arg::           Pass the argument to `rotate-yank-pointer'.
* rotate-yk-ptr negative arg::  Pass a negative argument.

A Graph with Labelled Axes

* Labelled Example::
* print-graph Varlist::         `let' expression in `print-graph'.
* print-Y-axis::                Print a label for the vertical axis.
* print-X-axis::                Print a horizontal label.
* Print Whole Graph::           The function to print a complete graph.

The `print-Y-axis' Function

* Height of label::             What height for the Y axis?
* Compute a Remainder::         How to compute the remainder of a division.
* Y Axis Element::              Construct a line for the Y axis.
* Y-axis-column::               Generate a list of Y axis labels.
* print-Y-axis Penultimate::    A not quite final version.

The `print-X-axis' Function

* Similarities differences::    Much like `print-Y-axis', but not exactly.
* X Axis Tic Marks::            Create tic marks for the horizontal axis.

Printing the Whole Graph

* The final version::           A few changes.
* Test print-graph::            Run a short test.
* Graphing words in defuns::    Executing the final code.
* lambda::                      How to write an anonymous function.
* mapcar::                      Apply a function to elements of a list.
* Another Bug::                 Yet another bug ... most insidious.
* Final printed graph::         The graph itself!


File: emacs-lisp-intro-ja.info,  Node: PrePreface,  Next: Preface,  Prev: Top,  Up: Top

訳者まえがき
************

本書は、「Programming in Emacs Lisp: An Introduction」
（texinfoファイル`emacs-lisp-intro.texi'、2.04版） の翻訳である。

   ASCIIにより「Programming in Emacs Lisp: An Introduction」
（texinfoファイル`emacs-lisp-intro.texi'、1.05版、更新日1997年10月21日）
の翻訳が

     http://www.ascii.co.jp/pub/GNU/emacs-lisp-intro-jp.texi

   でGPLで公開されており、2.04版へのアップデートを行っているものです。
日本語訳をGPLにて公開されているASCIIに感謝いたします。

   日本語のTeXが利用できる環境ならば、`texi2dvi'などのコマンドで
自前でdviファイルを作成して印刷できる。 また、Muleを用いてバッファに読み込んでから
`M-x texinfo-format-buffer'を実行すれば、
日本語版のinfoファイルを作成することもできる。
ただし、このようにして作ったinfoファイルでは、
（メニューなどの）info特有の部分は未翻訳であることをあらかじめご了承願いたい。

   Mule（Multilingual Enhancement to GNU Emacs）とそのLispは、
多国語を扱うために拡張したため、 GNU EmacsやEmacs Lispと互換ではない部分がある。
詳しくはMuleのディストリビューションに含まれる`mule-jp.texi'や
`マルチリンガル環境の実現' (1)
（特に第3章「Muleによるマルチリンガル環境の実現」）を参照してほしい。
なお、本書の例題は、英数字を使用する限りはそのまま動作する。

   GNU Emacsが扱う（7ビットの）ASCIIコードの文字は、
コンピュータ内部では1文字を1バイトで表現し、
これらの文字は画面上の表示でも1文字あたり1コラムを占める。
したがって、文字数、内部表現のバイト数、表示コラム数のどれを とっても同じ値である。
また、テキストをファイルに収めたときの文字コードと GNU
Emacsのバッファ内での文字コードはまったく同じである。

   ところが、多国語を扱うMuleでは、こうはならない。
各国ごとにその国の文字を1バイトあるいは2バイトで表す規格がある。
たとえば、日本には文字コードの規格としてJIS X 0208があり 2バイトで1文字を表す。
また、ローマ字とカタカナの規格としてJIS X 0201があり 1バイトで1文字を表す。

   1つのバッファ内に複数の国の文字コードが混在してもよいように、
Muleでは1バイトないしは2バイトの文字コードのまえに識別用に
1バイト（ないしは2バイト）を付加してバッファ内に保持する。
この識別用のバイトを_リーディングキャラクタ（leading character）_と呼ぶ。
ただし、7ビットのASCIIコードの文字は、GNU Emacsと同じで、
リーディングキャラクタは付加しない。

   たとえば、日本語の「あ」は、文字数は1であるが、
内部表現には3バイト必要であり、表示には2コラム必要である。
半角の「ア」は、文字数は1であるが、内部表現には2バイト必要であり、 表示には1コラム必要である。
ASCII文字の「a」は、文字数も内部表現のバイト数も表示コラム数も1である。

   このため、Muleでは、関数 `length' （*Note length::）は、
文字列の「文字数」ではなく、 内部表現の「バイト数」を返す。 バッファ内のポイントやマーク
（*Note Buffer Size & Locations::）
の位置も、「文字数」ではなく内部表現の「バイト数」が単位である。

   一方、関数`forward-char'は、その名前から予想されるように、
文字単位でポイントを移動する。 文字列の「文字数」を調べるには関数`chars-in-string'を使い、
「表示コラム数」を調べるには関数`string-width'を使う。

     (length          "abcあいう")     => 12
     (chars-in-string "abcあいう")     =>  6
     (string-width    "abcあいう")     =>  9

   `.emacs'（*Note Emacs Initialization::）で
Muleの版を区別するには、関数`mule-version'が返す文字列を使う。
また、日本語入力に「Wnn」、「sj3」、「かんな」のどれが使えるかを判別し、
それぞれに固有の設定を行うには、 関数`featurep'を使ってつぎのようにする。

     (if (and (not (featurep 'egg)) (featurep 'canna))
         (progn 「かびな」に固有の設鎚 ... ))

     (if (and (featurep 'egg) (featurep 'wnn-egg))
         (progn 「WNN」に固有の設鎚 ... ))

     (if (and (featurep 'egg) (featurep 'sj3-egg))
         (progn 「SJ3」に固有の設鎚 ... ))

   MuleがX Window Systemのクライアントとして動作している場合、
変数`window-system'には値`x'が、
そうでない場合には`nil'が束縛されるので、つぎのように判別できる。

     (if (eq window-system 'x)
         (progn 「X WINDOW SYSTEM」に固有の設鎚 ...)
       家面端勃の礁糠の設鎚 ...)

   ---------- Footnotes ----------

   (1) ISBN4-88735-020-1、株式会社プレンティスホール出版


File: emacs-lisp-intro-ja.info,  Node: Preface,  Next: List Processing,  Prev: PrePreface,  Up: Top

はじめに
********

統合環境GNU Emacsの大部分はEmacs Lispと呼ばれるプログラミング 言語で書かれている。
このプログラミング言語で書いたコードは、ユーザーが指令を与えた
ときに何をすべきかをコンピュータに指示するソフトウェア（一連の命令）である。 Emacsは、Emacs
Lispで新たにコードを書いてエディタの拡張機能として 簡単に追加できるように設計されている。

   （Emacsは時折拡張可能なエディタ呼ばれるが、それ以上の能力を有している。
したがって、「拡張可能な計算環境」と呼ぶのがいいが、少々いいづらい。もっ
と単純にエディタと呼ぶのがいいだろう。
マヤ暦や月の満ち欠けを調べたり、多項式を簡約化したり、コードをデバッグしたり、
ファイルを管理したり、手紙を読んだり、本を書いたりなどの
Emacsで行えるすべてのことは、もっとも一般的な意味で編集である。）

   Emacs Lispはテキストエディタに関連付けて考えられがちであるが、
それ自体で1つのプログラミング言語である。 他のプログラミング言語と同様に使える。

   プログラミングを理解したい、Emacsを拡張したい、プログラマになりたいという 読者もいることであろう。
Emacs Lispの入門である本書は、プログラミングの基本を学ぶための指針を与え、
さらに重要なことは、自力で学習する方法を示すために執筆したものである。

* Menu:

* Why::                         Why learn Emacs Lisp?
* On Reading this Text::        Read, gain familiarity, pick up habits....
* Who You Are::                 For whom this is written.
* Lisp History::
* Note for Novices::            You can read this as a novice.
* Thank You::


File: emacs-lisp-intro-ja.info,  Node: Why,  Next: On Reading this Text,  Prev: Preface,  Up: Preface

Why Study Emacs Lisp?
=====================

   Emacs Lisp は大抵Emacsとだけ関連付けられているが、これは完全なプログラ
ム言語である。Emacs Lispを他のプログラム言語と同様に使うことができるの だ。

   おそらくEmacsを拡張するためやプログラマになりたいという目的でプログラ
ミングを理解しようとしているだろう。この文書はプログラミングを始め、そ
の基礎を学び、さらに重要な自分自身で学ぶ方法を紹介している。


File: emacs-lisp-intro-ja.info,  Node: On Reading this Text,  Next: Who You Are,  Prev: Why,  Up: Preface

On Reading this Text
====================

本書には、Emacsで実行できる小さな例題プログラムがある。 GNU
EmacsのInfoで読んでいる場合には、 例題プログラムに出会うたびにそれらを実行できる
（これは簡単に実行できるが、その方法は例題をあげたときに説明する）。
あるいは、Emacsが動いているコンピュータを脇に置いて、 印刷された本書を読んでいる場面もあろう
（これは、筆者の好みでもある。 筆者は印刷した書物が好きである）。
手もとでEmacsを実行できなくても本書を読む意味はある。
ただし、そのような場合には、小説や初めての国への旅行案内とみなしてほしい。
興味深いはずであるが、実際にそこにいるのとは異なる。

   本書の大部分は、GNU Emacsで使っているコードを眺める、
つまり、ウォークスルーであり、ガイド付きツアーである。 これらのツアーには2つの目的がある。
第一に、実際に動作する（日常的に使用している）コードに慣れてもらうことであり、
第二に、Emacsの動作方式に慣れてもらうことである。
統合環境の実装方式を学ぶことは興味深いはずである。
また、ソースコードを読み進む際のコツも学んでほしい。
ソースコードから学んだり、アイデアを堀り起こせるはずである。 GNU
Emacsはまさに宝の山である。

   エディタとしてのEmacsやプログラミング言語としてのEmacs Lispを学ぶことに加えて、
例題やガイド付きツアーは、Lispのプログラミング環境としてのEmacsを熟知する
機会となるはずである。 GNU Emacsは、プログラミングの支援に加えて、`M-.'
（コマンド`find-tag'を起動するキー）などの慣れると便利なツールも提供する。
環境の一部であるバッファやその他のオブジェクトについても学ぶ。
Emacsのこれらの機能を学ぶことは、読者の街の周りの道を新たに学ぶことに似ている。

   読者が知らないプログラミングの側面を学ぶためのEmacsの利用法も伝えたいと思う。
読者を惑わすことがらを理解したり、新たなことを行う方法を調べるためにも
Emacsを利用できるのである。 この独立性は好ましいだけでなく利点でもある。


File: emacs-lisp-intro-ja.info,  Node: Who You Are,  Next: Lisp History,  Prev: On Reading this Text,  Up: Preface

対象とする読者
==============

本書は、プログラマではない人向けの初歩の入門書である。
すでにプログラマである読者には、本書は物足りないであろう。
というのは、そのような読者はすでにリファレンスマニュアルを存分に読めるように
なっており、本書の構成は間延びして見えるであろう。

   経験あるプログラマは、本書をつぎのように評価してくれた。

     リファレンスマニュアルで学ぶほうが好きである。
     各段落に「飛び込んで」、段落のあいだで「息つぎ」する。

     段落を読み終えたときには、そこで取り上げた話題は完結しており、
     必要なことは（以降の段落でより詳しく説明する場合を除いて）
     すべてわかったと仮定したい。 よく構成されたリファレンスマニュアルには、
     冗長な部分がなく、必要な情報への索引が整備されているはずである。

   本書は、このような人向けではない！

   第一に、おのおののことがらを少なくとも3回は説明するように努めた。
1回目は紹介、2回目は使い方、3回目は別の使い方や復習である。

   第二に、1つの話題に関するすべての情報を1か所にまとめることはせずに、
1つの段落に詰め過ぎないようにした。
筆者の考え方では、そうしないと読者に重荷を背負わせることになるからである。
かわりに、その時点で必要なことのみを説明するように努めた
（あとで詳しく説明する場合に備えて、少々余分に説明する場面もある）。

   1回読むだけで、すべてを理解してもらえるとは考えていない。
読者は、説明内容を「わかったつもり」にしておく必要があるだろう。
重要なことがらを正しく読者に指し示し、 注意を促すように本書を構成したつもりである。

   いくつかの段落には、「飛び込んで」もらうしかなく、 それ以外に読み進む方法はない。
しかし、そのような段落の個数は少なくするように努めた。
本書は登頂困難な山ではなく、楽に歩ける小山である。

   本書`Emacs Lispプログラミング'入門には、 姉妹編と呼ぶべきドキュメント *note The GNU
Emacs Lisp Reference Manual: (elisp)Top.  がある。
リファレンスマニュアルには本書より詳しい説明がある。
リファレンスマニュアルでは、1つの話題に関する情報は1か所にすべてまとめてある。
上で述べたようなプログラマは、そちらを参照すべきである。
もちろん、本書を読み終えて自分のプログラムを書くときには、
`リファレンスマニュアル'が有用であるはずである。


File: emacs-lisp-intro-ja.info,  Node: Lisp History,  Next: Note for Novices,  Prev: Who You Are,  Up: Preface

Lispの歴史
==========

Lispは、人工知能の研究のために、 1950年代末にマサチューセッツ工科大学で初めて開発された。
Lisp言語はその強力な機能のため、 エディタコマンドや統合環境を書くなどの他の目的にも優れている。

   GNU Emacs Lispは、1960年代にMITで開発されたMaclispから多くを受け継いでいる。
1980年代に標準規格となったCommon Lispからも一部を受け継いでいる。 しかし、Emacs
Lispは、Common Lispよりもずっと単純である （Emacsの標準ディストリビューションには、
Common Lispの多くの機能をEmacs Lispに追加するための
機能拡張用ファイル`cl.el'がある）。


File: emacs-lisp-intro-ja.info,  Node: Note for Novices,  Next: Thank You,  Prev: Lisp History,  Up: Preface

初心者へ一言
============

GNU Emacsを知らない読者にも、本書は有益であろう。
しかし、たとえスクリーンの移動方法だけであってもEmacsを学ぶことを勧める。
Emacsの使い方は、オンラインのチュートリアルで自習できる。 それには、`C-h t'とタイプする
（つまり、<CTRL>キーと`h'を同時に押してから離し、 さらに、`t'を押してから離す）。

   Emacsの標準コマンドを参照するために、 `M-C-\'（`indent-region'）のように、
コマンドを起動するために押すキーに続けて括弧内にコマンド名を書く。
つまり、コマンド`indent-region'は、
慣習的には`M-C-\'とタイプすると起動できることを意味する
（望むならば、コマンドを起動するためのキーを変更することもできる。
これを"リバインド（rebinding）"という。 *Note Keymaps::）。
`M-C-\'は、<META>キー、<CTRL>キー、<\>キーの3つを
同時に押すことを意味する(最近のキーボードは<META> キーが <ALT> と印字されている)。
ピアノを演奏するときの和音になぞらえて、
このような組み合わせをキーコード（keychord）と呼ぶこともある。
<META>キーがないキーボードでは、かわりに<ESC>キーを前置キーとして使う。
このような場合には、`M-C-\'は、<ESC>キーを押して離してから、
<CTRL>キーと<\>キーの2つを同時に押すことを意味する。しかし、 `M-C-\'
は大抵<CTRL>キーと<ALT> と <\> を同時に押すこ とを意味する。

   キーコードに加えて、`C-u'とともにキー入力したものを与えることがで
きる。これを「universal argument」と呼ぶ。`C-u'は続くコマンドに引
数を渡す働きをする。それゆえ、6個のスペースでテキストのあるリージョン
をインデントすることが、リージョンを選択し、`C-u 6 M-C-\' を入
力することで可能となる(数字を指定しなければ、Emacsはコマンドに4を渡す
かコマンドをデフォルトとは違うように働かせる)。 *Note Numeric Arguments:
(emacs)Arguments 参照。

   GNU EmacsのInfoで読んでいる場合には、
スペースバー<SPC>を押すだけで全体を読み進められる （Infoについて学ぶには、`C-h
i'とタイプしてInfoを選択すればよい）。

   用語に関しての注意：単語Lispのみを使った場面では Lispのさまざまな方言全般を意味するが、
Emacs Lispを使った場面ではGNU Emacs Lispのみを意味する。


File: emacs-lisp-intro-ja.info,  Node: Thank You,  Prev: Note for Novices,  Up: Preface

謝　辞
======

本書の執筆に協力していただいた方々に感謝したい。 特に、Jim Blandy、Noah
Friedman、Jim Kingdon、Roland McGrath、
Frank Ritter、Randy Smith、Richard M. Stallman、
Melissa Weisshausに感謝したい。
辛抱強く励ましてくれたPhilip JohnsonとDavid Stampeにも感謝したい。
誤りがあれば筆者の責任である。

                                                     Robert J. Chassell


File: emacs-lisp-intro-ja.info,  Node: List Processing,  Next: Practicing Evaluation,  Prev: Preface,  Up: Top

1 リスト処理 _(2004/03/28)_
***************************

慣れていない人の目には、Lispは不可思議なプログラミング言語である。
Lispのコードには、いたるところに括弧がある。 「Lots of Isolated Silly
Parentheses（奇妙な括弧が多い）」の略であると 批判する人達もいる。
しかし、この批判は不当である。 LispはLISt
Processingの略であり、括弧で囲んだ_リスト（list）_
（および、リストのリスト）を扱うプログラミング言語である。 括弧はリストの境界を表す。
リストの直前にアポストロフィ、つまり、引用符`''を付ける場合もある。 リストはLispの基本である。

* Menu:

* Lisp Lists::                  What are lists?
* Run a Program::               Any list in Lisp is a program ready to run.
* Making Errors::               Generating an error message.
* Names & Definitions::         Names of symbols and function definitions.
* Lisp Interpreter::            What the Lisp interpreter does.
* Evaluation::                  Running a program.
* Variables::                   Returning a value from a variable.
* Arguments::                   Passing information to a function.
* set & setq::                  Setting the value of a variable.
* Summary::                     The major points.
* Error Message Exercises::


File: emacs-lisp-intro-ja.info,  Node: Lisp Lists,  Next: Run a Program,  Prev: List Processing,  Up: List Processing

1.1 Lispのリスト _(2004/03/28)_
===============================

Lispでは、リストを`'(rose violet daisy buttercup)'のように書く。
このリストの直前にはアポストロフィが1つ付いている。 これはつぎのように書くこともでき、
こちらの書き方にも慣れてほしい。

     '(rose
       violet
       daisy
       buttercup)

このリストの各要素は異なる4つの花の名前である。 個々の要素を空白で区切り、庭の花を石で囲うように括弧で囲む。 

* Menu:

* Numbers Lists::               List have numbers, other lists, in them.
* Lisp Atoms::                  Elemental entities.
* Whitespace in Lists::         Formating lists to be readable.
* Typing Lists::                How GNU Emacs helps you type lists.


File: emacs-lisp-intro-ja.info,  Node: Numbers Lists,  Next: Lisp Atoms,  Prev: Lisp Lists,  Up: Lisp Lists

Numbers, Lists inside of Lists
------------------------------

   Lispでは、データとプログラムのどちらも同じ方法で表現する。
つまり、どちらも、単語や数やリストを空白で区切って括弧で囲んだリストである
（プログラムはデータのようにも見えるので、 プログラムは容易に他のプログラムのデータとなりえる。
これは、Lispの強力な機能である）。

   （原文の2つの括弧書き
     (Since a program looks like data, one program may easily serve
      as data for another; this is a very powerful feature of Lisp.)
   や
     (Incidentally, these two parenthetical remarks are _not_
      Lisp lists, because they contain `;' and `.' as punctuation marks.)
   には、句読点記号として`;'や`.'が含まれるので Lispのリストでは_ない_。）

   つぎもリストの例であり、リストの中にリストを含む。

     '(this list has (a list inside of it))

   このリストの要素は、`this'、`list'、`has'の単語と、 リスト`(a list inside of
it)'である。 内側のリストは、`a'、`list'、`inside'、`of'、 `it'の単語からできている。


File: emacs-lisp-intro-ja.info,  Node: Lisp Atoms,  Next: Whitespace in Lists,  Prev: Numbers Lists,  Up: Lisp Lists

1.1.1 Lispのアトム _(2004/01/16)_
---------------------------------

Lispでは、これまで単語と呼んできたものを"アトム（atoms）"と呼ぶ。
この用語はアトム（原子）の歴史的な意味からきており、 「不可分」ということである。
Lispに関していえば、リストに用いてきた単語はそれ以上には小さく分割できず、
プログラムの一部として同じものを意味する。 数や`+'のような1文字の記号についてもそうである。
一方、アトムとは異なり、リストは部分に分割できる （*Note car cdr & cons::）。

   リストでは、アトムを空白で区切る。 アトムは、括弧のすぐ隣にあってもよい。

   技術的には、Lispのリストは、空白で区切ったアトムを囲む括弧、
リストを囲む括弧、アトムやリストを囲む括弧から成る。
リストは、たった1個のアトムを含むだけでも、まったく含まなくてもよい。
何も含まないリストは`()'のように書き、"空リスト（empty list）"と呼ぶ。
空リストは、それ以外のものとは異なり、アトムであると同時にリストでもある。

   アトムやリストを表示したものを"シンボリック式（symbolic expressions）"、
あるいは、より簡素には"S式（s-expressions）"と呼ぶ。
用語「"式（expression）"」そのものでは、表示したアトムやリスト、あるいは、
コンピュータ内部に格納したアトムやリストを意味する。
しばしば、これらを区別せずに用語「"式（expression）"」を使う
（さらに、多くの書籍では式の同義語として用語「"フォーム（form）"」を使う）。

   われわれの宇宙を構成するアトム（原子）は、
それらが不可分であると考えられた時代に命名されたものであるが、
物質原子は不可分ではないことが知られている。
原子の一部を分割したり、ほぼ同じ大きさに分裂させたりできる。
物質原子は、その真の性質が発見される以前に命名されたのである。
Lispでは、配列などのある種のアトムは構成部分に分割できるが、
この分割機構はリストを分割する機構とは異なる。 リスト操作に関する限り、リストのアトムは分割できない。

   英語の場合と同様に、Lispのアトムを構成する文字は、 単語を作り上げる個々の文字とは異なる。
たとえば、南米のナマケモノを表す単語`ai'（ミツユビナマケモノ）は、
2つの単語`a'と`i'とはまったく異なる。

   自然界には多種類の原子が存在するが、Lispには数種類のアトムしかない。
たとえば、37、511、1729などの"数（numbers）"、
`+'、`foo'、`forward-line'などの "シンボル（symbols）"である。
これまで例にあげた単語はすべてシンボルである。
Lispの日常の習慣では、用語「アトム」をあまり使わない。
というのは、プログラマは扱っているアトムの種類を特定しようとするからである。
Lispのプログラミングでは、リスト内のシンボル（やときには数）を扱う （括弧書き「（やときには数）」の原文`(and
sometimes numbers)'は、 アトムを空白で区切って括弧で囲んであり、
しかも、Lispの句読点記号以外は含まないのでLispのリストである）。

   さらに、二重引用符で囲まれたテキストは（文であろうと段落であろうと） アトムである。
つぎに例を示す。 

     '(this list includes "text between quotation marks.")

Lispでは、句読点記号や空白を含みこのように囲まれたテキストは単一のアトムである。
この種のアトムは"文字列（string）"と呼ばれ、
コンピュータが人間向けに出力するメッセージに使う。
文字列は、数やシンボルとは異なる別の種類のアトムであり、使い方も異なる。


File: emacs-lisp-intro-ja.info,  Node: Whitespace in Lists,  Next: Typing Lists,  Prev: Lisp Atoms,  Up: Lisp Lists

1.1.2 リスト内の空白 _(2004/01/16)_
-----------------------------------

リスト内の空白の個数はいくつでもよい。 Lisp言語の視点からすれば、

     '(this list
        looks like this)

は、つぎとまったく同等である。

     '(this list looks like this)

   どちらの例もLispにとっては同じリストであり、 `this'、`list'、`looks'、`like'、
`this'のシンボルからこの順に構成されたリストである。

   余分な空白や改行は人間がリストを見やすくするためのものである。
Lispが式を読み取るとき、余分な空白をすべて取り除く （ただし、アトムとアトムのあいだには、
これらを区切るために少なくとも1つの空白が必要である）。

   奇妙に思えるかもしれないが、これまでの例で、
Lispのすべてのリストがどのようなものであるかを見てきた。
Lispのリストは多かれ少なかれこれまでの例のようなものであり、 もっと長かったり複雑なだけである。
要約すれば、リストは括弧で囲まれたものであり、
文字列は二重引用符で囲まれたものであり、シンボルは単語のようなものであり、 数は数字列である
（鈎括弧やドットや特別な数種の文字を使う場合もあるが、 しばらくはこれらを使わない）。


File: emacs-lisp-intro-ja.info,  Node: Typing Lists,  Prev: Whitespace in Lists,  Up: Lisp Lists

1.1.3 GNU Emacsのリスト入力補佐機能 _(2004/03/28)_
--------------------------------------------------

GNU EmacsのLisp InteractionモードやEmacs LispモードでLispの式を
入力する時には、Lispの式を読みやすく整形するためのコマンドを利用できる。
たとえば、<TAB>キーを押すと、カーソルを置いた行を自動的に字下げする。
あるリージョンのコードを正しく字下げするコマンドは、 慣習的に`M-C-\'にバインドされている。
リストの各要素が、どのリストに属するかがわかりやすくなるように字下げする。
つまり、内側のリストの各要素は、 そのリストを囲むリストの要素よりも字下げされる。

   さらに、閉じ括弧をタイプするとEmacsは対応する開き括弧に一時的に
カーソルを移動して、対応関係がわかるようにする。
Lispに与える個々のリストは括弧の対応が取れている必要があるので、 これはとても便利である
(*Note Major Modes: (emacs)Major Modes, for more information about
Emacs' modes.)


File: emacs-lisp-intro-ja.info,  Node: Run a Program,  Next: Making Errors,  Prev: Lisp Lists,  Up: List Processing

1.2 プログラムの実行 _(2004/01/16)_
===================================

Lispのどんなリストも実行できるプログラムである。
それを実行する（Lispの専門用語では"評価（evaluate）"する）と、
コンピュータは、つぎの3つのうちの1つを行う。
リストそのものを返して、それ以外のことは何もしない。 エラーメッセージを出す。
リストの先頭シンボルをなんらかのコマンドとして扱う （もちろん、普通は3番目の動作を望む！）。

   前節の例においてリストの直前に付けた1つのアポストロフィ`''を
"クオート（quote）"と呼ぶ。 リストの直前にこれを付けると、
そのリストに関しては何もせずに字面どおりに扱うことをLispに指示する。
リストの直前にクオートがない場合には、リストの先頭要素を特別扱いし、
コンピュータが従うべきコマンドとなる
（Lispでは、これらのコマンドを_関数（functions）_と呼ぶ）。 まえにあげたリスト`(+ 2
2)'の直前にはクオートがないので、
Lispは、`+'がリストの残りの部分に対して行うべき操作であると解釈し、 後続の数を加算する。

   GNU EmacsのInfoで読んでいる場合には、つぎのようにしてリストを評価する。
つぎのリストの閉じ括弧の直後にカーソルを置いてから `C-x C-e'とタイプする。

     (+ 2 2)

エコー領域に数`4'が表示されるはずである
（専門用語では、たったいま「リストを評価」したのである。
エコー領域とは画面の最下行のことで、テキストを表示する場所である）。
クオートしたリストについても同じことをやってみよう。 つぎのリストの直後にカーソルを置いて`C-x
C-e'とタイプする。

     '(this is a quoted list)

エコー領域に`(this is a quoted list)'と表示されるはずである。

   いずれの場合も、GNU Emacsの内部にある "Lispインタープリタ（Lisp
interpreter）"と呼ばれるプログラムに指令、 つまり、式を評価せよという指令を与えたのである。
Lispインタープリタという名称は、表現の意味を追いかける人間の仕事、
つまり、通訳（interpreter）からきている。

   リストの一部ではないアトム、つまり、 括弧に囲まれていないアトムを評価することもできる。
この場合もLispインタープリタは人間が読める表現をコンピュータの言語に変換する。 このこと（*note
Variables::）を説明するまえに、
まちがいを起こした場合にLispインタープリタがどうするかを説明しよう。


File: emacs-lisp-intro-ja.info,  Node: Making Errors,  Next: Names & Definitions,  Prev: Run a Program,  Up: List Processing

1.3 エラーメッセージの生成 _(2004/01/16)_
=========================================

偶然引き起こした場合は気にしないでよいが、ここでは
エラーメッセージを生成するようなコマンドをLispインタープリタに与えてみる。
これは無害であり、意図してエラーメッセージを生成することにある。
専門用語を理解すれば、エラーメッセージは有益でさえある。
「エラー」メッセージと呼ぶよりは「ヘルプ」メッセージと呼ぶべきであろう。
これらは、見知らぬ国を訪れた旅行者のための道標のようなものである。
読みこなすのはたいへんであろうが、 いったん理解してしまえば道を指し示してくれる。

   エラーメッセージはEmacsに組み込まれたデバッガにより表示されます。

   リストの先頭要素に意味のあるコマンドもなく、クオートもしていないリストを 評価してみよう。
上で用いたリストとほとんど同じであるが、その直前には引用符を付けない。
このリストの直後にカーソルを置いて`C-x C-e'とタイプする。

     (this is an unquoted list)

どのように結果が表示されるかはEmacsのバージョンに依存します。Emacs 21 ではEmacs
20やそれ以前のものよりも多くの情報が表示されます。まず、最近
のEmacsでのエラーを、次にEmacs 20でのエラーを紹介します。

Emacs 21では `*Backtrace*' ウィンドウが開き、そこに以下のようなメッ
セージが表示されます。

     ---------- Buffer: *Backtrace* ----------
     Debugger entered--Lisp error: (void-function this)
       (this is an unquoted list)
       eval((this is an unquoted list))
       eval-last-sexp-1(nil)
       eval-last-sexp(nil)
       call-interactively(eval-last-sexp)
     ---------- Buffer: *Backtrace* ----------

カーソルはこのウィンドウへ移ります (表示されるまで数秒かかるかもしれま
せん)。デバッガを停止させ、そこから抜けるために、以下を入力します。

     q

すぐに `q' を押してください。そうすれば、デバッガから抜けることが
できます。それから、`C-x C-e' で再度評価すると、またデバッガに入り ます。

   すでに知っていることをもとにすれば、このエラーメッセージのほとんどを理 解できるでしょう。

   `*Backtrace*' バッファは下から読んでいきます。それがEmacsが実行し
た順番になるのです。`C-x C-e' を入力すると、`eval-last-sexp'
を対話的に呼び出します。`eval'は「evaluate(評価する)」の、 `sexp' は「symbolic
expression(シンボリック式)」の略称です。結局、
このコマンドは「最後のシンボリック式を評価する」ことを意味します。つま
り、カーソルの直前の式が評価されるのです。

   各行は次にどの式が評価されるかを表しています。Emacsが行ったことを逆方
向に(エラーのある行から遡って)確認することができることから、このバッファ
を`*Backtrace*'バッファと呼んでいます。`*Backtrace*'

   `*Backtrace*' バッファの最初の行は以下のようになっています。

     Debugger entered--Lisp error: (void-function this)

Lispインタープリタはリストのアトムである`this'という単語を評価し
ようとします。これにより、`void-function this' (this という関数は
未定義)というエラーメッセージが表示されます。

   このメッセージには`void-function' と `this' という単語が含ま れます。

   `function' は以前に取り上げました。 これは重要な用語である。
ここでは、"関数（function）"とは、コンピュータに何かを行わせるための
コンピュータに対する一連の命令であると定義しよう

   これで`void-function this' というエラーメッセージを理解することが
できます。関数(つまり、`this'という単語) にはコンピュータに実行させ
るための命令が定義されていないということです。

   メッセージ`function definition is void'の単語の使い方が
少々変わってるのは、Emacs Lispの実装方法に準じているのである。
つまり、シンボルに関数定義が与えられていない場合には、
命令列を格納する場所は「void（空）」になるのである。

   一方で、`(+ 2 2)'を評価すると2に2を加算できるので、
シンボル`+'にはコンピュータが実行すべき命令列が与えられており、
しかも、それらは`+'に続く数を加算する命令であると推理できる。

   Emacs 20やそれ以前のバージョンでは、以下のような1行のエラーメッセージ
しか表示されません。そして、このメッセージはエコー領域に以下のように表 示されます。

     Symbol's function definition is void: this

このメッセージはカーソルを移動したり、何かキーをタイプするだけでメッセー
ジは消えてしまいます。

   用語`Symbol'の意味は知っている。 これは、リストの先頭要素である単語`this'を意味する。
用語`関数（function）'はコンピュータがすべき命令であると述べた。
（技術的には、シンボルは一連の命令を探す場所を指定するのであるが、
ここではその詳細は無視できる）。

   エラーメッセージ`Symbol's function definition is void: this'
の意味を理解できるはずである。 シンボル（つまり単語`this'）には、
コンピュータが実行すべき、命令が欠けているのである。


File: emacs-lisp-intro-ja.info,  Node: Names & Definitions,  Next: Lisp Interpreter,  Prev: Making Errors,  Up: List Processing

1.4 シンボル名と関数定義
========================

これまでに説明してきたことをもとに、Lispの別の特徴を明確にすることができる。
`+'のようなシンボルは、それ自身はコンピュータが実行すべき命令列
ではないという重要な特徴である。 そのかわりに、定義、すなわち、命令列を探すために
シンボルを（一時的に）使うのである。
われわれが見ているものは、命令列を探すための名前である。 人の名前も同じように使われる。
筆者は`Bob'と呼ばれているが、私は`B'、`o'、`b'の3文字 ではなく、意識のある生命体である。
名前そのものは私ではなく、私を指すために名前を使うのである。

   Lispでは、1つの命令列に複数の名前を結び付けることができる。
たとえば、コンピュータの加算命令列をシンボル`plus'にも`+'にも
結び付けられる（そのようなLispの方言もある）。
人間の世界でも、筆者を`Bob'と呼んだり`Robert'と呼んだりでき、 それ以外の単語でもよい。

   その一方で、シンボルには1つの関数定義しか結び付けられない。
さもなければ、どちらの定義を採用すべきかコンピュータが混乱する。
これを人間の世界に当てはめると、 `Bob'という名前を持つ人は世界中で1人に限られることになる。
しかし、名前が参照する関数定義を変更するのは容易である （*Note Install::）。

   Emacs Lispは巨大なので、関数が属するEmacsの構成部分がわかるように
シンボルを命名する慣習がある。
したがって、Texinfoを扱うすべての関数の名前は`texinfo-'で始まり、
メールを読むことに関連する関数の名前は`rmail-'で始まる。


File: emacs-lisp-intro-ja.info,  Node: Lisp Interpreter,  Next: Evaluation,  Prev: Names & Definitions,  Up: List Processing

1.5 Lispインタープリタ
======================

これまでの説明をもとに、リストの評価をLispインタープリタに命じると
Lispインタープリタが何をするかを理解することができる。
まず、リストの直前にクオートがあるかどうかを調べる。
クオートがあれば、リストを返すだけである。
一方、クオートがなければ、インタープリタはリストの先頭要素を調べ、
それに関数定義があるかどうかを調べる。
関数定義があれば、インタープリタはその関数定義内の命令列を実行する。
さもなければ、インタープリタはエラーメッセージを出力する。

   これがLispの動作であり、単純である。
すぐに説明するが、これに加えて複雑なことがらもあるが、以上が基本である。
当然、Lispプログラムを書くには、関数定義の書き方、名前への結び付け方、
および、これらを読者やコンピュータに混乱のないように行う方法を知る必要がある。

* Menu:

* Complications::               Variables, Special forms, Lists within.
* Byte Compiling::              Specially processing code for speed.


File: emacs-lisp-intro-ja.info,  Node: Complications,  Next: Byte Compiling,  Prev: Lisp Interpreter,  Up: Lisp Interpreter

Complications
-------------

   では、複雑なことがらの最初のことを説明しよう。 Lispインタープリタは、リストに加えて、
クオートもせず括弧で囲まれてもいないシンボルを評価できる。 Lispインタープリタは、
"変数（variable）"としてのシンボルの値を決定しようとする。
これについては変数に関する節で説明する （*Note Variables::）。

   複雑なことがらの2番目は、特殊な関数があり、 これらは普通の方式のように動作しないことである。
これらを"スペシャルフォーム（special forms）"と呼ぶ。
関数の定義などの特殊なことを行うものであり、それらの個数は多くはない。
以下のいくつかの章では、重要なスペシャルフォームのいくつかを紹介する。

   3番目で最後の複雑なことがらはつぎのとおりである。
Lispインタープリタが探しあてた関数がスペシャルフォームでなく、
しかも、それがリストの一部である場合には、
Lispインタープリタはリストの内側にリストがあるかどうかを調べる。
内側にリストがあれば、Lispインタープリタは内側のリストを処理してから、 外側のリストを処理する。
内側のリストの内側にもリストが含まれている場合には、
それを処理してから内側のリストを処理する。 つねに、もっとも内側のリストを最初に処理する。
インタープリタはもっとも内側のリストの結果を得るためにそれを処理する。
その結果はそれを含む式で使われる。

   そうでない場合には、インタープリタは左から右への順で式を1つずつ処理する。


File: emacs-lisp-intro-ja.info,  Node: Byte Compiling,  Prev: Complications,  Up: Lisp Interpreter

1.5.1 バイトコンパイル
----------------------

インタープリタには別の側面もある。 Lispインタープリタは2種類のものを解釈できる。
本書で取り上げている人が読める形式のコードと、 特別な処理を施し人には読めない形式の
"バイトコンパイル（byte compiled）"コードである。
バイトコンパイルしたコードは、人間向けのコードに比べて実行が速い。

   `byte-compile-file'のようなコンパイルコマンドを実行すれば、
人間向けのコードをバイトコンパイルコードに変換できる。
バイトコンパイルコードは、拡張子`.el'ではなく拡張子`.elc'で
終わるファイルに収容するのが一般的である。
ディレクトリ`emacs/lisp'には両方の種類のファイルがあるが、
読むのは拡張子`.el'のファイルである。

   実用上は、Emacsを調整したり拡張したりするのがほとんどであろうから、
バイトコンパイルする必要はなく、ここではこれ以上取り上げない。
バイトコンパイルについて詳しくは*Note Byte Compilation: (elisp)Byte
Compilation。


File: emacs-lisp-intro-ja.info,  Node: Evaluation,  Next: Variables,  Prev: Lisp Interpreter,  Up: List Processing

1.6 評　価 _(2004/01/17)_
=========================

Lispインタープリタが式を処理することを"評価する（evaluation）"と呼ぶ。
インタープリタが「式を評価する」という。 これまでにも、この用語を何度か使ってきた。
この用語は日常の言葉使いからきている。 つまり、`Webster's New Collegiate
Dictionary'によれば、 「価値や量を見定める、見積もること」である。

   式を評価し終えると、Lispインタープリタは、関数定義で与えられた命令列を
コンピュータが実行した結果を"返す（return）"のが一般的であるが、
関数の処理を諦めてエラーメッセージを生成する場合もある
（インタープリタ自体を別の関数に渡したり、 「無限ループ」と呼ばれる無制限に同じことを繰り返すこともある。
これらの動作は一般的ではないので、ここでは無視することにする）。
ほとんどの場合、インタープリタは値を返す。

   インタープリタは、値を返すと同時に、
カーソルを移動したりファイルをコピーしたりなどの別の動作も行う。
この種の別の動作は、"副作用（side effect）"と呼ばれる。
結果の表示などの人間が重要と考える動作は、 Lispインタープリタによっては「副作用」であることが多い。
この用語は奇妙に聞こえるかもしれないが、 副作用の使い方を学ぶのはかなり簡単である。

   まとめると、Lispインタープリタは、
シンボリック式を評価するとほとんどの場合は値を返すが、副作用を伴うこともある。
あるいは、エラーを生成する。

* Menu:

* Evaluating Inner Lists::      Lists within lists...


File: emacs-lisp-intro-ja.info,  Node: Evaluating Inner Lists,  Prev: Evaluation,  Up: Evaluation

1.6.1 内側のリストの評価 _(2004/01/17)_
---------------------------------------

内側にリストを含んだリストを評価するときには、 内側のリストを評価して得られた値を、
外側のリストを評価するときの情報として使う場合がある。
そのために、内側の式を最初に評価するのである。 それが返した値を外側の式で使用する。

   このような評価の過程を、加算の例題で調べることにしよう。
つぎの式の直後にカーソルを置いて`C-x C-e'とタイプする。

     (+ 2 (+ 3 3))

エコー領域には数8が表示される。

   Lispインタープリタで行われることは、 まず内側の式`(+ 3
3)'を評価することであり、これは値6を返す。 続いて、外側の式を`(+ 2
6)'であるかのように評価し、これは値8を返す。 評価すべき外側の式はもうないので、
インタープリタはこの値をエコー領域に表示する。

   さて、キー列`C-x C-e'で起動されるコマンドの名前を理解するのは容易である。
コマンドの名前は`eval-last-sexp'である。 `sexp'は「シンボリック式（symbolic
expression）」の略、 `eval'は「評価（evaluate）」の略である。
コマンドの意味は、「直前のシンボリック式を評価する」である。

   式の直後の行の先頭や式の内側にカーソルを置いても式を評価できるかどうか 試してみよう。

   つぎの式で試してみる。

     (+ 2 (+ 3 3))

式の直後の空行の先頭にカーソルを置いて`C-x C-e'とタイプしても、
エコー領域には値8が表示される。 今度は、式の内側にカーソルを置いて試してみる。
最後の括弧のまえに（つまり、表示上は最後の括弧の上に）
カーソルを置いて評価すると、エコー領域には値6が表示される！　 コマンドは式`(+ 3
3)'を評価したからである。

   今度は、数の直後にカーソルを置いてみる。 `C-x C-e'とタイプすると数そのものを得る。
Lispでは、数を評価するとその数そのものを得るのである。 これが数とシンボルの違いである。
`+'のようなシンボルで始まるリストを評価すると、
`+'に結び付けた関数定義の命令列を実行した結果の値を得る。
つぎの節で説明するように、シンボルそのものを評価すると別のことが起こる。


File: emacs-lisp-intro-ja.info,  Node: Variables,  Next: Arguments,  Prev: Evaluation,  Up: List Processing

1.7 変　数 _(2004/01/17)_
=========================

Emacs Lispでは、シンボルに関数定義を結び付けるように、
シンボルに値を結び付けることもできる。 これらの2つは異なるものである。
関数定義はコンピュータが遂行する命令列である。
一方で、値は、数や名前などの何かであり、変更できる
（これが、そのようなシンボルが変数と呼ばれる理由である）。
シンボルの値としては、シンボル、数、リスト、文字列などの Lispの任意の式を取れる。
値を持つシンボルをしばしば"変数（variable）"と呼ぶ。

   シンボルには関数定義と値の両方を同時に結び付けておくことができる。あるいは一方か
他方だけを結び付けておくことができる． これら2つは別々である。
これは、ケンブリッジという名称が、マサチューセッツの都市を表すと同時に、
「偉大なプログラミングセンター」のような名前の付加属性を持つことができるのに 似ている。

   あるいは、シンボルは箪笥であると考えてほしい。
関数定義はある引き出しに入れてあり、値は別の引き出しに入れてあるのである。
関数定義を収めた引き出しの中身を変えることなく、
値を収めた引き出しの中身を変更でき、その逆もそうである。

* Menu:

* fill-column Example::
* Void Function::               The error message for a symbol
                                  without a function.
* Void Variable::               The error message for a symbol without a value.


File: emacs-lisp-intro-ja.info,  Node: fill-column Example,  Next: Void Function,  Prev: Variables,  Up: Variables

`fill-column', an Example Variable
----------------------------------

   値を持つシンボルの例として変数`fill-column'を取り上げよう。 GNU
Emacsの各バッファでは、このシンボルに72とか70の値が設定されるが、 それ以外の値の場合もある。
このシンボルの値を調べるには、それそのものを評価すればよい。 GNU
EmacsのInfoで読んでいる場合には、 シンボルの直後にカーソルを置いて`C-x
C-e'とタイプする。

     fill-column

筆者の場合、`C-x C-e'とタイプするとEmacsはエコー領域に数72を表示する。
この値は、筆者が本書を執筆中に`fill-column'に設定してある値である。
読者のInfoバッファでは異なるかもしれない。
変数の値として返された値は、関数の命令列を実行した結果返された値と
まったく同じように表示されることに注意してほしい。
Lispインタープリタの視点からは、どちらも返された値である。
値が求まってしまえば、それがどのような式から得られたかは関係ないのである。

   シンボルにはどのような値でも結び付けることができる。
専門用語を使えば、変数には、72のような数、`"such as this"'のような文字列、 `(spruce
pine oak)'のようなリストを"束縛（bind）"できる。 変数に関数定義を束縛することもできる。

   シンボルに値を束縛する方法は何通りかある。 1つの方法は、*Note set & setq::。


File: emacs-lisp-intro-ja.info,  Node: Void Function,  Next: Void Variable,  Prev: fill-column Example,  Up: Variables

1.7.1 Error Message for a Symbol Without a Function _(2004/01/17)_
------------------------------------------------------------------

`fill-column' を変数としての値を知るために評価するときには，単語の前後に括
弧は付けない．これは，関数として使うわけではないからである．

   `fill-column'がリストの先頭要素だとすると、
Lispインタープリタはこれに結び付けられた関数定義を探そうとする。
しかし、`fill-column'には関数定義はない。 つぎを評価してみよう。

     (fill-column)

Emacs 21では，`*Backtrace*'バッファが表れ，以下のように表示されるだろう．

     ---------- Buffer: *Backtrace* ----------
     Debugger entered--Lisp error: (void-function fill-column)
       (fill-column)
       eval((fill-column))
       eval-last-sexp-1(nil)
       eval-last-sexp(nil)
       call-interactively(eval-last-sexp)
     ---------- Buffer: *Backtrace* ----------

(デバッガを停止させ、そこから抜けるために、`*Backtrace*' バッファで `q'
を入力することを思い出しなさい)

   Emacs20やそれ以前もののでは、つぎのエラーメッセージを得る。

     Symbol's function definition is void: fill-column

(カーソルキーや他のキーを入力するとこのメッセージはすぐに消えてしまいます)


File: emacs-lisp-intro-ja.info,  Node: Void Variable,  Prev: Void Function,  Up: Variables

1.7.2 値のないシンボルに対するエラーメッセージ _(2004/01/17)_
-------------------------------------------------------------

値が束縛されていないシンボルを評価すると、エラーメッセージを得る。
たとえば、2足す2の例を用いて調べてみよう。
つぎの式で、最初の数2のまえの`+'の直後にカーソルを置いて `C-x C-e'をタイプすると、

     (+ 2 2)

Emacs 21では`*Backtrace*'バッファに以下のように表示されます．

     ---------- Buffer: *Backtrace* ----------
     Debugger entered--Lisp error: (void-variable +)
       eval(+)
       eval-last-sexp-1(nil)
       eval-last-sexp(nil)
       call-interactively(eval-last-sexp)
     ---------- Buffer: *Backtrace* ----------

(他の時同様，デバッガに入った時には，`*Backtrace*'バッファで`q' を入力
することでデバッガから出ることができます)

   これはまえに見た`Symbol's function definition is void: this'とは
違うエラーメッセージである。 ここでは、シンボルには変数としての値がないのである。
まえの場合は、（`this'という）シンボルには関数定義がなかったのである。

   `+'で試したことは、Lispインタープリタに`+'を評価させて、
関数定義ではなく変数の値を探させたのである。
そうするために、式を閉じる括弧の直後にカーソルを置くかわりに、
シンボルの直後にカーソルを置いた。 そのため、Lispインタープリタは直前のS式、つまり、
`+'そのものを評価したのである。

   `+'には、関数定義はあるが、値は束縛されていないので、
変数としてのシンボルの値は空（void）である旨のエラーメッセージが 報告されたのである。

   Emacs 20やそれ以前のものでは，つぎのエラーメッセージを得る。

     Symbol's value as variable is void: +

意味はEmacs 21と同じである．


File: emacs-lisp-intro-ja.info,  Node: Arguments,  Next: set & setq,  Prev: Variables,  Up: List Processing

1.8 引　数 _(2004/01/17)_
=========================

どのように関数に情報が伝えられるかを見るために、 お馴染みの2足す2の例を使ってみよう。
Lispでは、つぎのように書く。

     (+ 2 2)

   この式を評価すると、エコー領域には数4が表示される。
Lispインタープリタが行ったことは、`+'のあとに続く数の加算である。

   `+'が加算した数のことを、関数`+'の"引数（arguments）"と呼ぶ。
これらの数は、関数に与えられた、つまり、"渡された"情報である。

   「argument（引数）」という用語は数学での用法からきており、
2人のあいだの議論のことではない。 ここでは、`+'という関数へ与えられた情報を意味する。
Lispでは、関数に対する引数は、その関数のあとに続くアトムやリストである。
これらのアトムやリストを評価して返された値が関数へ渡される。 関数が異なれば、必要な引数の個数も異なり、
引数をまったく必要としない関数もある。 (1)

* Menu:

* Data types::                  Types of data passed to a function.
* Args as Variable or List::    An argument can be the value
                                  of a variable or list.
* Variable Number of Arguments::  Some functions may take a
                                  variable number of arguments.
* Wrong Type of Argument::      Passing an argument of the wrong type
                                  to a function.
* message::                     A useful function for sending messages.

   ---------- Footnotes ----------

   (1) 単語「argument」の異なる2つの意味、つまり、数学での意味と
日常語での意味がどのように成立したかを調べると興味深い。 `Oxford English
Dictionary'によれば、`to make clear, prove
（明らかにする、証明する）'を意味するラテン語が語源である。
これから、「証明として与えられた証拠」という一方の意味が派生して、
「与えられた情報」を意味するようになり、Lispでの意味になるのである。
もう一方の意味としては、「ある仮定とは反対の仮定をする」を意味するようになり、
議論するという意味になったのである （英語では異なる2つの意味が同時に1つの単語に与えられている。
対照的に、Emacs Lispでは、異なる2つの関数定義を同時にシンボルに与えることは できない）。


File: emacs-lisp-intro-ja.info,  Node: Data types,  Next: Args as Variable or List,  Prev: Arguments,  Up: Arguments

1.8.1 引数のデータ型 _(2004/01/16)_
-----------------------------------

関数に渡すデータの型は、関数が使用する情報の種類に応じて決まる。 `+'は数を加算するので、
`+'のような関数への引数は数値である必要がある。 別の関数では別の種類のデータの引数が必要である。

   たとえば、関数`concat'は複数の文字列を繋いで1つの文字列を生成する。
したがって、引数は文字列である。 文字列`abc'と`def'を繋ぐ（concatinate）と、
1つの文字列`abcdef'が作られる。 これはつぎの式を評価するとわかる。

     (concat "abc" "def")

この式を評価して得られる値は`"abcdef"'である。

   `substring'のような関数は、引数として文字列と数を取る。
この関数は文字列の一部分、つまり、第1引数の部分文字列を返す。 この関数は3つの引数を取る。
第1引数は文字列であり、第2引数と第3引数は数で、 部分文字列の開始位置と終了位置を示す。
これらの数は、文字列の先頭からの（空白や句読点を含む）文字の個数である。

   たとえば、つぎを評価すると、

     (substring "The quick brown fox jumped." 16 19)

エコー領域には`"fox"'と表示される。 引数は、1つの文字列と2つの数である。

   `substring'に渡された文字列は、
空白で区切られた複数の単語ではあるが1つのアトムである。
Lispは、2つの二重引用符のあいだにあるものを、
たとえ空白があいだにあっても文字列として扱う。
関数`substring'は、他の方法では不可分なアトムから一部分を切り出すので、
「アトム粉砕機」の一種と考えてもよい。
しかし、`substring'は、文字列である引数から部分文字列を切り出すことが
できるだけであり、数やシンボルなどのそれ以外の種類のアトムは扱えない。


File: emacs-lisp-intro-ja.info,  Node: Args as Variable or List,  Next: Variable Number of Arguments,  Prev: Data types,  Up: Arguments

1.8.2 引数としての変数やリストの値 _(2004/01/17)_
-------------------------------------------------

引数は、評価したときに値を返すシンボルでもよい。
たとえば、シンボル`fill-column'そのものを評価すると数を返す。 この数は加算に使える。

   つぎの式のうしろにカーソルを置いて`C-x C-e'とタイプする。

     (+ 2 fill-column)

`fill-column'を単独で評価した値より2だけ大きな値が得られる。
筆者の場合には、`fill-column'の値は72なので、結果は74である。

   このように、評価すると値を返すシンボルを引数に使えるのである。
さらに、評価すると値を返すリストを引数に使うこともできる。
たとえば、つぎの式では、関数`concat'への引数は、 文字列`"The "'と`" red foxes."'、
さらに、リスト`(number-to-string (+ 2 fill-column))'である。

     (concat "The " (number-to-string (+ 2 fill-column)) " red foxes.")

この式を評価すると、(もし私のEmacsのように `fill-column' が 72 になっていれ ば)
エコー領域には`"The 74 red foxes."'と表示される
（最終結果の文字列に空白が含まれるように、
単語`The'の直後と単語`red'の直前には空白が必要である．関数 `number-to-string'
は加算関数が返す整数を文字に変換する． `number-to-string' は `int-to-string'
でも同じである）。


File: emacs-lisp-intro-ja.info,  Node: Variable Number of Arguments,  Next: Wrong Type of Argument,  Prev: Args as Variable or List,  Up: Arguments

1.8.3 可変個数の引数 _(2004/01/17)_
-----------------------------------

`concat'、`+'、`*'などのある種の関数は、任意個数の引数を取る
（`*'は乗算のシンボルである）。 これは、以下の式のおのおのを通常の方法で評価するとわかる。
`=>'のあとのテキストがエコー領域に表示され、 `=>'は「の評価結果は」と読めばよい。

   まず、関数に引数がない場合にはつぎのとおりである。

     (+)       => 0

     (*)       => 1

   つぎは、関数に引数が1つの場合である。

     (+ 3)     => 3

     (* 3)     => 3

   今度は、関数に引数が3つある場合である。

     (+ 3 4 5) => 12

     (* 3 4 5) => 60


File: emacs-lisp-intro-ja.info,  Node: Wrong Type of Argument,  Next: message,  Prev: Variable Number of Arguments,  Up: Arguments

1.8.4 引数に誤った型のオブジェクトを指定 _(2004/01/17)_
-------------------------------------------------------

誤った型の引数を関数へ渡すと、Lispインタープリタはエラーメッセージを生成する。
たとえば、関数`+'は引数として数を仮定する。
数のかわりにクオートしたシンボル`hello'を与えてみよう。
つぎの式の直後にカーソルを置いて`C-x C-e'とタイプする。

     (+ 2 'hello)

そうすると、エラーメッセージを得る。
何が起こったかというと、`+'は数2に`'hello'が返す値を
加算しようとしたのだが、`'hello'が返した値はシンボル`hello'であり、 数ではない。
加算できるのは数のみである。 したがって、`+'は加算を実行できなかったのである。

   Emacs 21では `*Backtrace*' に以下のように表示される．


     ---------- Buffer: *Backtrace* ----------
     Debugger entered--Lisp error:
              (wrong-type-argument number-or-marker-p hello)
       +(2 hello)
       eval((+ 2 (quote hello)))
       eval-last-sexp-1(nil)
       eval-last-sexp(nil)
       call-interactively(eval-last-sexp)
     ---------- Buffer: *Backtrace* ----------

   普通、エラーメッセージは有用なようになっているので、 読み方がわかれば意味がわかる。

   エラーメッセージの最初の部分は簡単で、 `Wrong type
argument'、つまり、引数の型がまちがっているである。
つぎは、不思議な専門用語で`number-or-marker-p'である。
これは、`+'が仮定する引数の種類を伝えようとしているのである。

   シンボル`number-or-marker-p'の意味は、Lispインタープリタが
渡された情報（引数の値）が整数（数）かマーカー（バッファ内の位置を表す
特殊なオブジェクト）かどうかを調べようとしているということである。
つまり、加算すべき整数が`+'に与えられたかどうかを検査したのである。 このとき、引数が、Emacs
Lispに特有の機能であるマーカーかどうかも検査する
（Emacsでは、バッファ内の位置をマーカーで記録する。
コマンド`C-@'や`C-<SPC>'でマークを設定すると、 その位置はマーカーとして保存される。
マークは数として扱うことができ、 バッファの先頭からのその位置までの文字の個数である）。
Emacs Lispでは、`+'でマーカー位置の数値を数として加算できる。

   `number-or-marker-p'の`p'は、 Lispプログラミングの早い時期に始まった慣習である。
`p'は「述語（predicate）」の略である。 初期のLisp研究者が用いた専門用語では、
述語とはある性質が真か偽か調べる関数を意味する。
したがって、`p'があることで、`number-or-marker-p'は、
与えられた引数が数であるかマーカーであるかの真偽を調べる関数の名前である ことがわかる。
`p'で終わるそのほかのLispシンボルには、 引数の値が0であるかを調べる関数`zerop'、
引数がリストであるかを調べる関数`listp'がある。

   エラーメッセージの最後の部分はシンボル`hello'である。
これは`+'に渡された引数の値である。 正しい型のオブジェクトが加算に渡されれば、
渡された値は`hello'のようなシンボルではなく37のような数であるはずである。
そうであったならば、エラーメッセージが表示されることはなかったのである。

   Emacs 20やそれ以前のものでは，エコー領域に以下のように表示されます．

     Wrong type argument: number-or-marker-p, hello

   これは，言い方を変えると，`*Backtrace*' バッファの先頭行のようなものと言う
ことができる．


File: emacs-lisp-intro-ja.info,  Node: message,  Prev: Wrong Type of Argument,  Up: Arguments

1.8.5 関数`message' _(2004/01/17)_
----------------------------------

`+'のように、関数`message'は任意個数の引数を取る。
この関数はユーザーにメッセージを表示するために使うので、
ここで説明しておくのがよいであろう。

   メッセージはエコー領域に表示される。
たとえば、つぎのリストを評価すると、エコー領域にメッセージが表示される。

     (message "This message appears in the echo area!")

   二重引用符のあいだの文字列は1つの引数であり、一塊で表示される
（ここでの例では、エコー領域に表示されるメッセージは二重引用符で囲まれる。
これは、関数`message'が返した値を見ているからである。
プログラム内での`message'のほとんどの使い方では、
副作用としてエコー領域にテキストが表示されるので、 表示には引用符は含まれない。
このような例について詳しくは、 *Note multiply-by-seven in detail::）。

   さて、文字列の中に`%s'がある場合、
関数`message'は`%s'をそのとおりに表示することはなく、 文字列のあとに続く引数を調べる。
第2引数を評価し、その値を文字列の`%s'の位置に表示する。

   つぎの式の直後にカーソルを置いて`C-x C-e'とタイプしてみる。

     (message "The name of this buffer is: %s." (buffer-name))

Infoでは、エコー領域に`"The name of this buffer is: *info*."'と
表示されるはずである。 関数`buffer-name'はバッファ名を文字列として返し、
それを関数`message'が`%s'の位置に挿入する。

   値を整数として表示するには`%s'のかわりに`%d'を使う。
たとえば、`fill-column'の値を含んだメッセージをエコー領域に表示するには
つぎの式を評価する。

     (message "The value of fill-column is %d." fill-column)

筆者のシステムでは、このリストを評価するとエコー領域に `"The value of fill-column is
72."'と表示される(1)。

   文字列の中に複数の`%s'があれば、
文字列のあとに続く最初の引数の値が最初の`%s'の位置に表示され、
2番目の引数の値が2番目の`%s'の位置に表示されると続く。

   たとえば、つぎの式を評価すると

     (message "There are %d %s in the office!"
              (- fill-column 14) "pink elephants")

エコー領域に少々妙なメッセージが表示される。 筆者のシステムでは`"There are 58 pink
elephants in the office!"'となる。

   式`(- fill-column 14)'が評価され、 その結果の数が`%d'の位置に挿入される。
二重引用符の中の文字列`"pink elephants"'は
1つの引数として扱われて`%s'の位置に挿入される
（つまり、数と同様に、二重引用符で囲まれた文字列を評価するとそれ自身となる）。

   最後は少々複雑な例で、数の計算を示すとともに、
`%s'と置き換わるテキストを生成する式を式の内側で使う方法を示す。

     (message "He saw %d %s"
              (- fill-column 34)
              (concat "red "
                      (substring
                       "The quick brown foxes jumped." 16 21)
                      " leaping."))

   この例では、`message'には、文字列`"He saw %d %s"'、 式`(- fill-column
32)'、関数`concat'で始まる式の3つの引数がある。 `(- fill-column
32)'を評価した結果は`%d'の位置に挿入され、
`concat'で始まる式の値は`%s'の位置に挿入される。

   筆者の場合、この式を評価するとエコー領域に `"He saw 38 red foxes
leaping."'と表示される。

   ---------- Footnotes ----------

   (1) 実際には， `%s' を数を表示するために使うことができる．それは特別なことではない．
`%d' は整数部分だけを表示し，数ではない


File: emacs-lisp-intro-ja.info,  Node: set & setq,  Next: Summary,  Prev: Arguments,  Up: List Processing

1.9 変数への値の設定 _(2004/01/17)_
===================================

変数に値を与える方法はいくつかある。 1つの方法は関数`set'か関数`setq'を使うことである。
別の方法は`let'（*note let::）を使うことである
（この過程を専門用語では変数を値に"束縛（bind）"するという）。

   つぎの節では`set'と`setq'の動作を説明するとともに、
引数がどのように渡されるかも説明する。

* Menu:

* Using set::                   Setting values.
* Using setq::                  Setting a quoted value.
* Counting::                    Using `setq' to count.


File: emacs-lisp-intro-ja.info,  Node: Using set,  Next: Using setq,  Prev: set & setq,  Up: set & setq

1.9.1 `set'の使い方 _(2004/01/17)_
----------------------------------

シンボル`flowers'の値としてリスト`'(rose violet daisy buttercup)'を
設定するには、つぎの式の直後にカーソルを移動して`C-x C-e'とタイプして 式を評価する。

     (set 'flowers '(rose violet daisy buttercup))

エコー領域には、リスト`(rose violet daisy buttercup)'が表示される。
これは、関数`set'が_返した_ものである。
副作用として、シンボル`flowers'にリストが束縛される。
つまり、シンボル`flowers'は変数とみなされ、 その値としてリストが与えられるのである
（値を設定するこの過程は、Lispインタープリタにとっては副作用であるが、
人間にとっては興味のある主要な効果である。 各Lisp関数はエラーがなければ値を返す必要があるが、
関数の目的は副作用だけの場合もある）。

   `set'式を評価したあとは、シンボル`flowers'を評価することができ、
設定した値が返される。 つぎのシンボルの直後にカーソルを置いて`C-x C-e'とタイプする。

     flowers

`flowers'を評価すると、 エコー領域にリスト`(rose violet daisy
buttercup)'が表示される。

   `'flowers'、つまり、直前にクオートを置いた変数を評価すると、
エコー領域にはシンボル`flowers'そのものが表示される。 つぎの例を試してみよう。

     'flowers

   `set'を使う場合、いずれの引数も評価してほしくない場合には、
両方の引数をクオートする必要があることに注意してほしい。
上の例では、変数`flowers'もリスト`(rose violet daisy buttercup)'も
評価したくないので、両者をクオートした
（`set'の第1引数をクオートせずに使うと、まず最初に第1引数が評価される。
上の例でこれを行うと、`flowers'には値がないので、 `Symbol's value as variable is
void'というエラーメッセージを得る。 一方、`flowers'を評価して値が返される場合には、
`set'はその返された値に値を設定しようとする。
このように関数を動作させたい場面もあるが、そのような場面は少ない）。


File: emacs-lisp-intro-ja.info,  Node: Using setq,  Next: Counting,  Prev: Using set,  Up: set & setq

1.9.2 `setq'の使い方 _(2004/01/17)_
-----------------------------------

実用上、`set'の第1引数をほとんどつねにクオートするはずである。
`set'で第1引数をクオートする組み合わせは多用されるので、
スペシャルフォーム`setq'が用意してある。
このスペシャルフォームは`set'とほとんど同じであるが、
第1引数を自動的にクオートするので、引用符をタイプする必要はない。
さらに、便利なように、`setq'では、複数の異なる変数に異なる値を 1つの式で設定することもできる。

   `setq'を用いて、変数`carnivores'の値を リスト`'(lion tiger
leopard)'とするには、つぎの式を使う。

     (setq carnivores '(lion tiger leopard))

これは`set'を用いた場合とほぼ同じであるが、
`setq'では第1引数を自動的にクオートするのが異なる（`setq'の`q'は、
クオート（`quote'）を意味する）。

   `set'を用いる場合は、つぎのようにする。

     (set 'carnivores '(lion tiger leopard))

   さらに、`setq'は、複数の異なる変数に異なる値を代入するためにも使える。
第1引数には第2引数の値を束縛し、第3引数には第4引数の値を束縛し、……と続く。
たとえば、シンボル`trees'に樹木名のリストを、
シンボル`herbivores'にハーブの名前のリストを代入するにはつぎのようにする。

     (setq trees '(pine fir oak maple)
           herbivores '(gazelle antelope zebra))

（式を1行に書いてもよいが、ページの幅に収まらない。
人間には、適切にフォーマットしたリストは読みやすいものである。）

   「代入」という用語を用いたが、`set'や`setq'の動作を考える 別の方法もある。
つまり、`set'や`setq'は、シンボルがリストを_指す（point）_ ようにするのである。
この考え方は非常によく使われ、うしろの章では、名前の一部に「pointer」がある
シンボルを見ることになる。 この名称は、シンボルには特にリストなどの値が結び付けらている、
あるいは、シンボルがリストを「指す」ように設定されていることに由来する。


File: emacs-lisp-intro-ja.info,  Node: Counting,  Prev: Using setq,  Up: set & setq

1.9.3 数え上げ _(2004/01/17)_
-----------------------------

ここではカウンタで`setq'を使う方法を示そう。
プログラムのある部分を何回繰り返したかを数え上げるために使える。 まず、変数に0を設定する。
そして、プログラムを繰り返すたびに1を加える。
そのためには、カウンタの役割を果たす変数と2つの式、つまり、
カウンタ変数を0に初期化する`setq'を用いた式と、
評価するたびにカウンタを増加する`setq'を用いた式が必要である。

     (setq counter 0)                ; 初期化式

     (setq counter (+ counter 1))    ; 増加式

     counter                         ; カウンタ

（`;'以降のテキストは注釈である。 *Note Change a defun::。）

   これらの最初の式、つまり、初期化式`(setq counter 0)'を評価してから
3番目の式`counter'を評価すると、エコー領域には数`0'が表示される。
続いて、2番目の式、増加式`(setq counter (+ counter 1))'を評価すると、
カウンタの値は1になる。 そのため、ふたたび`counter'を評価すると
エコー領域には数`1'が表示される。 2番目の式を評価するたびに、カウンタの値は増加する。

   増加式`(setq counter (+ counter 1))'を評価するとき、
Lispインタープリタは、もっとも内側のリスト、つまり、加算を最初に評価する。
このリストを評価するには、変数`counter'と数`1'を評価する必要がある。
変数`counter'を評価するとその現在値が得られる。
この値と数`1'が`+'に渡され加算される。 この合計値がもっとも内側のリストの値として返され、
さらに、変数`counter'にこの新しい値を設定する`setq'へ渡される。
したがって、変数`counter'の値が変更されるのである。


File: emacs-lisp-intro-ja.info,  Node: Summary,  Next: Error Message Exercises,  Prev: set & setq,  Up: List Processing

1.10 まとめ _(2004/03/28)_
==========================

Lispを学ぶことは、登り始めがもっとも険しい小山を登るようなものである。
読者はもっとも困難な部分を登り終えたのであり、 あとは、先へ進むほど楽になる。

   本章をまとめるとつぎのようになる。

   * Lispプログラムは式から成り立ち、式とはリストやアトムである。

   * リストは、0個以上のアトムやリストを空白で区切って括弧で囲ったものである。 リストは空でもよい。

   * アトムとは、`forward-paragraph'のような複数個の文字のシンボル、
     `+'のような1文字のシンボル、二重引用符で囲った文字列、あるいは、数である。

   * 数を評価するとそれ自身になる。

   * 二重引用符で囲った文字列を評価するとそれ自身になる。

   * シンボルそのものを評価すると、その値が返される。

   * リストを評価するとき、Lispインタープリタはリストの先頭のシンボルを調べ、
     そのシンボルに束縛された関数定義を探す。 そして、関数定義の命令列を実行する。

   * 引用符`''は、Lispインタープリタに対して続く式を字面のとおりに
     返すことを指示し、引用符がない場合のようには評価しない。

   * 引数とは関数へ渡される情報である。
     関数への引数は、関数を先頭要素とするリストの残りの要素を評価することで 計算される。

   * 関数を評価すると（エラーがなければ）つねに値を返す。
     さらに、「副作用」と呼ばれるなんらかの動作を伴うこともある。
     多くの場合、関数の主要な目的は副作用を起こすことである。


File: emacs-lisp-intro-ja.info,  Node: Error Message Exercises,  Prev: Summary,  Up: List Processing

1.11 演習問題
=============

簡単な演習問題をあげておく。

   * 括弧の中にはない適当なシンボルを評価してエラーメッセージを生成してみよ。

   * 括弧の中に置いた適当なシンボルを評価してエラーメッセージを生成してみよ。

   * 1つずつではなく2つずつ増やすカウンタを作成せよ。

   * 評価するとエコー領域にメッセージを表示する式を書いてみよ。


File: emacs-lisp-intro-ja.info,  Node: Practicing Evaluation,  Next: Writing Defuns,  Prev: List Processing,  Up: Top

2 評価の練習 _(2004/03/28)_
***************************

Emacs Lispにおける関数定義の書き方を学ぶまえに、これまでに説明してきた
さまざまな式の評価に時間を割いてみるのも有益であろう。
リストの先頭（あるいは唯一）の要素が関数であるようなリストである。
バッファに関する関数は、単純でしかも興味深いので、これらから始めよう。
本節では、それらのいくつかを評価してみる。
他の節では、バッファに関連した数個の別の関数のコードを調べて、
それらがどのように書かれているかを見てみる。

* Menu:

* How to Evaluate::             Typing editing commands or C-x C-e
                                  causes evaluation.
* Buffer Names::                Buffers and files are different.
* Getting Buffers::             Getting a buffer itself, not merely its name.
* Switching Buffers::           How to change to another buffer.
* Buffer Size & Locations::     Where point is located and the size of
                                the buffer.
* Evaluation Exercise::


File: emacs-lisp-intro-ja.info,  Node: How to Evaluate,  Next: Buffer Names,  Prev: Practicing Evaluation,  Up: Practicing Evaluation

How to Evaluate
===============

   Emacs Lispに、カーソルの移動や画面上のスクロールなどの
編集コマンドを与えるたびに、先頭要素が関数である式を評価している。
Emacsはこのようにして動いている。

   キーをタイプすると、Lispインタープリタに式を評価させることになり、
そのようにして操作しているのである。 テキストをタイプした場合でさえも、Emacs
Lispの関数を評価しており、
タイプした文字を単に挿入する関数`self-insert-command'を使った
関数を評価しているのである。 キーをタイプすることで評価される関数は、
"対話的（interactive）"関数とか"コマンド（commands）"と呼ばれる。
関数を対話的にする方法については、関数定義の書き方の章で例を示す。 *Note
Interactive::。

   キーボードコマンドをタイプする以外にも、 式を評価する方法についてはすでに説明した。
すなわち、リストの直後にカーソルを置いて`C-x C-e'とタイプするのである。
本節の残りでは、この方法を用いる。
これ以外にも式を評価する方法があり、必要に応じて他の節で説明する。

   これからの数節で説明する関数は、評価を練習すること以外にも、 それ自体、重要なものである。
これらの関数を学ぶことで、バッファとファイルの違い、
バッファを切り替える方法、バッファ内での位置を調べる方法が明らかになる。


File: emacs-lisp-intro-ja.info,  Node: Buffer Names,  Next: Getting Buffers,  Prev: How to Evaluate,  Up: Practicing Evaluation

2.1 バッファ名 _(2004/01/17)_
=============================

2つの関数、`buffer-name'と`buffer-file-name'が、
ファイルとバッファの違いを示してくれる。
式`(buffer-name)'を評価すると、エコー領域にバッファ名が表示される。
`(buffer-file-name)'を評価すると、
バッファが参照するファイル名がエコー領域に表示される。 通常、`(buffer-name)'が返す名前は、
そのバッファが参照するファイルの名前と同じであり、
`(buffer-file-name)'が返す名前はファイルの完全パス名である。

   ファイルとバッファは異なる2つの実体である。
ファイルは（削除しない限り）コンピュータに恒久的に記録された情報である。
一方、バッファはEmacsの内部にある情報であり、
（バッファを削除するか）編集作業を終了すると消えてしまう。
通常、バッファにはファイルからコピーした情報が収められている。
これを、バッファがファイルを"訪れる（visiting）"という。
このコピーを処理したり修正したりしているのである。
バッファを変更しても保存しない限り、ファイルは変更されない。
バッファを保存すると、バッファはファイルにコピーされ、 その結果、恒久的に保存されるのである。

   GNU EmacsのInfoを使って読んでいる場合には、
つぎのそれぞれの式の直後にカーソルを置いて`C-x C-e'とタイプすれば、
それぞれの式を評価できる。

     (buffer-name)

     (buffer-file-name)

筆者がこれを行うと、`(buffer-name)'を評価して返される値は
`"introduction.texinfo"'であり、 `(buffer-file-name)'を評価して返される値は
`"/gnu/work/intro/introduction.texinfo"'である。
前者はバッファ名であり、後者はファイル名である
（各式には括弧があるので、Lispインタープリタは`buffer-name'と
`buffer-file-name'を関数として扱う。
括弧がないと、インタープリタは変数としてシンボルを評価しようとする。 *Note Variables::）。

   ファイルとバッファの違いにもかかわらず、
バッファを意味してファイルといったり、その逆のいい方をする場合が多い。
もちろん、ほとんどの人は、「すぐにファイルに保存するバッファを編集している」
というよりは、「ファイルを編集している」という。
その人が何を意図しているかは、ほとんどの場合、文脈から明らかである。
しかし、コンピュータプログラムに関していえば、 コンピュータは人間のように賢くはないので、
つねに違いを心にとめておく必要がある。

   ところで、用語「バッファ（buffer）」は、衝突力を弱めるクッションを意味する
語に由来する。 初期のコンピュータでは、ファイルとコンピュータの中央処理装置のあいだの
相互作用のクッションがバッファであった。
ファイルを格納するドラムやテープと中央処理装置とは、互いに大きく異なる
装置であり、それぞれ固有の動作速度で動いていた。
バッファにより、これらが効率よく協調動作することが可能であった。
しだいに、バッファは、中間の一時的な保管場所から、 実際の処理を行う場所へと進展していった。
これは、小さな港が大都市に発展したり、貨物を船に積み込むまえの一時的な保管倉庫
がその重要性のためにビジネスや文化の中心に進展したことに似ている。

   すべてのバッファがファイルに関連付けられるわけではない。
たとえば、ファイル名をいっさい指定せずにコマンド`emacs'だけをタイプして
Emacsを開始した場合には、画面にはバッファ`*scratch*'が表示されて Emacsが動き出す。
このバッファはいかなるファイルも訪問していない。
同様に、バッファ`*Help*'にはいかなるファイルも関連付けられていない。

   バッファ`*scratch*'に切り替えてから、`(buffer-name)'と入力して
その直後にカーソルを置いて`C-x C-e'とタイプしてこの式を評価すると、
名前`"*scratch*"'が返されてエコー領域に表示される。
`"*scratch*"'がバッファの名前である。
しかし、バッファ`*scratch*'で`(buffer-file-name)'とタイプして
これを評価すると、エコー領域には`nil'と表示される。
`nil'の語源はラテン語の「無（nothing）」を意味する単語であり、
この場合、バッファ`*scratch*'にはいかなるファイルも関連付けられていない ことを意味する
（Lispでは、`nil'は「偽（false）」をも意味し、 空リスト`()'の同義語でもある）。

   バッファ`*scratch*'を使っているときに、
式の評価結果をエコー領域ではなくバッファ`*scratch*'そのものに 表示したい場合には、`C-x
C-e'のかわりに`C-u C-x C-e'とタイプする。
これにより、式の直後に返された値が表示される。 バッファはつぎのようになる。

     (buffer-name)"*scratch*"

Infoは読み出し専用なのでバッファの内容を変更できないため、 Infoではこの方法を使えない。
しかし、編集可能なバッファならば、この方法を使える。
コードや（本書のような）文書を書くときには、この機能はとても便利である。


File: emacs-lisp-intro-ja.info,  Node: Getting Buffers,  Next: Switching Buffers,  Prev: Buffer Names,  Up: Practicing Evaluation

2.2 バッファの取得 _(2004/01/17)_
=================================

関数`buffer-name'は、バッファの_名前_を返す。 バッファ_そのもの_を取得するには、
別の関数`current-buffer'が必要である。
この関数をコードで使うと、バッファそのものを取得することになる。

   名前とその名前が表すオブジェクトや実体とは互いに異なるものである。 読者自身は読者の名前ではない。
読者は、その名前で他人が参照する「人」である。
読者がGeorgeと話したいと頼んだときに、`G'、`e'、`o'、`r'、
`g'、`e'と文字が書かれたカードを渡されたら、驚くであろうが、 満足はしないであろう。
名前と話をしたいのではなくて、その名前で参照される人と話をしたいのである。 バッファも同様である。
一時的バッファの名前は`*scratch*'であるが、 名前そのものがバッファではない。
バッファそのものを得るには`current-buffer'のような関数を使う必要がある。

   しかし、多少込み入った事情もある。
ここで試すように、式で`current-buffer'を評価すると
バッファの内容ではなくバッファの表示形式が表示される。
Emacsがこのように動作する理由は2つある。 バッファには数千もの行が含まれることもあるので、
これを簡便に表示するには長すぎる。
また、バッファの内容は同じであっても、名前が異なるバッファもありえるので、
それらを区別できる必要がある。

   例を示そう。

     (current-buffer)

いつものようにこの式を評価すると、 エコー領域には`#<buffer *info*>'と表示される。
バッファ名ではなく、バッファそのものを表す特殊な表示形式である。

   数やシンボルはプログラムに入力できるが、 バッファの表示形式を入力することはできない。
バッファそのものを得る唯一の方法は、 `current-buffer'のような関数を使うことである。

   関連する関数として`other-buffer'がある。
これは、現在使用しているバッファの直前に選択していたバッファを返す。
たとえば、バッファ`*scratch*'から現在のバッファに切り替えた場合には、
`other-buffer'はバッファ`*scratch*'を返す。

   つぎの式を評価してみよう。

     (other-buffer)

エコー領域には、`#<buffer *scratch*>'、あるいは、
今のバッファに切り替えるまえのバッファの表示形式が表示される(1)。

   ---------- Footnotes ----------

   (1) 実際には， デフォルトでは切り替える前のバッファが他のウィンドウで表示されている時，
`other-buffer' は非表示のバッファの中で極最近選択したものを選ぶ．これについ
ては私はいつも忘れてしまうのだ


File: emacs-lisp-intro-ja.info,  Node: Switching Buffers,  Next: Buffer Size & Locations,  Prev: Getting Buffers,  Up: Practicing Evaluation

2.3 バッファの切り替え _(2004/03/28)_
=====================================

関数`other-buffer'の目的は、バッファそのものを引数に必要とする
関数にバッファを与えることである。
別のバッファに切り替えるため`other-buffer'と`switch-to-buffer'とを 使ってみよう。

   まず、関数`switch-to-buffer'の概要を説明しておこう。
`(buffer-name)'を評価するためにInfoからバッファ`*scratch*'へ
切り替えるときには、`C-x b'とタイプし、ミニバッファに表示された
切り替え先バッファ名のプロンプトに`*scratch*'と入力したであろう(1)。 `C-x
b'とタイプすると、LispインタープリタはEmacs Lispの対話的関数
`switch-to-buffer'を評価する。 すでに説明したように、Emacsはこのように動作する。
キー列が異なれば、異なる関数を呼び出す、つまり、実行するのである。
たとえば、`C-f'とタイプすると`forward-char'を呼び出し、
`M-e'とタイプすると`forward-sentence'を呼び出すなどである。

   `switch-to-buffer'を書いた式に切り替え先のバッファを指定すれば、 `C-x
b'と同じようにバッファを切り替えられる。

   たとえば、つぎのLispの式である。

     (switch-to-buffer (other-buffer))

リストの先頭要素はシンボル`switch-to-buffer'であるので、
Lispインタープリタはこれを関数として扱い、それに結び付けられている 命令列を実行する。
しかし、そのまえに、インタープリタは`other-buffer'が括弧の内側にあることを
検出して、まずそのシンボルを処理する。
`other-buffer'はこのリストの先頭（かつ唯一の）要素なので、
Lispインタープリタはこの関数を呼び出す。 これは別のバッファを返す。
続いて、インタープリタは、この別のバッファを引数として
`switch-to-buffer'に渡して実行し、そのバッファへ切り替える。
Infoで読んでいる場合には、この式を評価してみてほしい （Infoのバッファに戻るには`C-x b
<RET>'とタイプする）。(2)
この場合，`other-buffer'への最初の引数は現在のバッファをスキップさせること
を指示しています．そして，2番目の引数は `other-buffer' は他のフレームなどで
表示されているバッファを表示することを許可します．`switch-to-buffer' は大抵
表示されているバッファへの移動は`C-x o' (`other-window') を使うので非表
示のバッファへ移動することになります．

   本書の以降の節のプログラム例では、関数`switch-to-buffer'よりも
関数`set-buffer'を多用する。 これは、コンピュータプログラムと人間との違いによるものである。
人間には目があるので、端末画面で作業中のバッファを見ることを期待する。
これは当然のことであり、これ以上説明する必要はなかろう。 一方、プログラムに目はない。
コンピュータプログラムがバッファを処理するときに、 端末画面でバッファが見えている必要はない。

   `switch-to-buffer'は人間向けに考えられたものであり、 異なる2つのことを行う。
Emacsの注意をバッファに向けることと、
ウィンドウに表示するバッファをそのバッファに切り替えることである。
一方、`set-buffer'は1つのことだけを行い、
コンピュータプログラムの注意をそのバッファに向けるだけである。 画面上のバッファは変更しない
（もちろん、コマンドが終了するまでは、何も起こらない）。

   ここでは、新たな専門用語"呼び出し（call）"も使った。
リストの先頭のシンボルが関数であるようなリストを評価すると、 その関数を呼び出すのである。
この用語は、鉛管工を「呼ぶ」とパイプの洩れを修理してくれるのと同じように、
関数は、「呼び出す」と何かを行ってくれる実体であるという考え方からきている。

   ---------- Footnotes ----------

   (1) あ るいは，タイプを簡略にするために，`*sc'のように名前の一部を入力し，補完する
ために`TAB'を入力するだろう．そして，`RET'を押して選択するのだ

   (2) この記
述は表示されていない最も最近表示したバッファに移動します．もし最近選択したバッファ
を表示したいのであれば，以下の式を評価する必要があります．

     (switch-to-buffer (other-buffer (current-buffer) t))



File: emacs-lisp-intro-ja.info,  Node: Buffer Size & Locations,  Next: Evaluation Exercise,  Prev: Switching Buffers,  Up: Practicing Evaluation

2.4 バッファサイズとポイントの位置 _(2004/03/28)_
=================================================

最後に、`buffer-size'、`point'、`point-min'、`point-max'
などの比較的単純な関数を見てみよう。
これらにより、バッファのサイズやバッファ内のポイントの位置に関する情報を 得ることができる。

   関数`buffer-size'は、カレントバッファのサイズを返す。
つまり、バッファ内の文字の個数を返す。

     (buffer-size)

いつものように、この式の直後にカーソルを置いて`C-x C-e'とタイプすれば、
この式を評価できる。

   Emacsでは、カーソルの現在位置を"ポイント（point）"と呼ぶ。
式`(point)'は、バッファの先頭からポイントまでの文字の個数として、 カーソルの位置を返す。

   いつものようにつぎの式を評価すると、 バッファ内でのポイントまでの文字数を調べることができる。

     (point)

筆者の場合、この値は65724であった。 本書の例では、関数`point'を多用している。

   ポイントの値は、当然であるが、バッファ内での位置に依存する。
ここでつぎの式を評価すると、より大きな数になる。

     (point)

筆者の場合、ポイントの値は66043となり、
2つの式のあいだには（空白を含めて）319文字あることがわかる。

   関数`point-min'は、`point'とほぼ同じであるが、
カレントバッファにおいて取ることが可能なポイントの最小値を返す。
"ナロイング（narrowing）"していなければ、これは数1である
（ナロイング（偏狭化）とは、プログラムなどで操作するバッファの範囲を 制限する機構である。 *Note
Narrowing & Widening::）。 同じように、関数`point-max'は、
カレントバッファにおいて取ることが可能なポイントの最大値を返す。


File: emacs-lisp-intro-ja.info,  Node: Evaluation Exercise,  Prev: Buffer Size & Locations,  Up: Practicing Evaluation

2.5 演習問題
============

適当なファイルを読み込み、その中ほどに移動する。
バッファ名、ファイル名、長さ、ファイル内での位置のそれぞれを調べてみよ。


File: emacs-lisp-intro-ja.info,  Node: Writing Defuns,  Next: Buffer Walk Through,  Prev: Practicing Evaluation,  Up: Top

3 関数定義の書き方 _(2004/08/04)_
*********************************

リストを評価するとき、Lispインタープリタは、
リストの先頭のシンボルに関数定義が結び付けられているかどうかを調べる。
いいかえれば、シンボルが関数定義を指すかどうかを調べる。
そうならば、コンピュータは定義内の命令列を実行する。
関数定義を持つシンボルを、単に関数と呼ぶ
（しかし、正確には、定義が関数であり、シンボルはそれを指すだけである）。

* Menu:

* Primitive Functions::
* defun::                       The `defun' special form.
* Install::                     Install a function definition.
* Interactive::                 Making a function interactive.
* Interactive Options::         Different options for `interactive'.
* Permanent Installation::      Installing code permanently.
* let::                         Creating and initializing local variables.
* if::                          What if?
* else::                        If--then--else expressions.
* Truth & Falsehood::           What Lisp considers false and true.
* save-excursion::              Keeping track of point, mark, and buffer.
* Review::
* defun Exercises::


File: emacs-lisp-intro-ja.info,  Node: Primitive Functions,  Next: defun,  Prev: Writing Defuns,  Up: Writing Defuns

An Aside about Primitive Functions
==================================

   すべての関数は別の関数を用いて定義されているが、 プログラミング言語Cで書かれた少数の
"基本操作（primitive）"関数はそうではない。
関数の定義を書くときには、他の関数を構成部品として用いてEmacs Lispで書く。
そのとき使用する関数は、 それ自身Emacs Lispで（読者自身が）書いたものであったり、
Cで書かれた基本操作関数である。 基本操作関数は、Emacs
Lispで書いたものとまったく同じように使え、 そのように動作する。
これらをCで書いてあるのは、Cが動く十分な能力を持ったコンピュータならば 容易にGNU
Emacsを動作できるようにするためである。

   強調しておくが、Emacs Lispでコードを書くとき、 Cで書いた関数の使い方とEmacs
Lispで書いた関数の使い方とは区別しない。 両者の違いは無関係なのである。
わざわざ言及したのは、興味深いと考えたからである。 既存の関数がEmacs
Lispで書いてあるのか、Cで書いてあるのかは、 特に調べない限りわからない。


File: emacs-lisp-intro-ja.info,  Node: defun,  Next: Install,  Prev: Primitive Functions,  Up: Writing Defuns

3.1 スペシャルフォーム`defun' _(2004/03/28)_
============================================

Lispでは、`mark-whole-buffer'のようなシンボルには、
関数として呼ばれたときにコンピュータが実行するコードが結び付けられている。
このコードを"関数定義（function definition）"と呼び、 シンボル`defun'（_define
function（関数を定義する）_の略）で始まる Lispの式を評価することで作成する。
`defun'は、その引数を通常のようには評価しないので、 "スペシャルフォーム（special
form）"と呼ばれる。

   以下の節では、`mark-whole-buffer'のようなEmacsのソースコードの
関数定義を調べる。 本節では、関数定義がどのようなものかを理解してもらうために、
簡単な関数定義を説明する。 例を簡単にするために、算術演算を使った関数定義を取り上げる。
算術演算を使った例が嫌いな人もいるであろうが、落胆しないでほしい。
残りの節で説明するコードには、算術演算や数学はほとんどない。 そのほとんどは、テキストを扱う。

   関数定義は、単語`defun'に続く最大で5つの部分から成る。

  1. 関数定義を結び付けるシンボルの名前。

  2. 関数に渡される引数のリスト。 関数に引数を渡さない場合には、空リスト`()'を指定する。

  3. 関数の説明文 （省略できるが、付けることを強く推奨する）。

  4. `M-x'に続けて関数名を入力したり、適当なキー列をタイプして使えるように、
     関数を対話的にするための式。 省略できる。

  5. コンピュータに動作を命じるコード。 関数定義の"本体（body）"。

   関数定義の5つの部分を、つぎのような雛型にまとめて考えるとわかりやすい。

     (defun 関尽名 (畏尽...)
       "省略可能な関尽の逝明文..."
       (interactive 畏尽に関すに笑篇) ;    省略可能
       本体...)

   例として、引数を7倍する関数のコードを示す （この例は、対話的関数ではない。
これについては、*Note Interactive::）。

     (defun multiply-by-seven (number)
       "Multiply NUMBER by seven."
       (* 7 number))

   この定義は、括弧とシンボル`defun'で始まり、関数名が続く。

   関数名のあとには、関数に渡される引数のリストが続く。 このリストを、"引数リスト（argument
list）"と呼ぶ。 この例では、リストには1つの要素、シンボル`number'のみがある。
関数が使われると、関数への引数として使われた値がこのシンボルに束縛される。

   引数の名前としては、単語`number'のかわりに別の名前を指定してもよい。
たとえば、単語`multiplicand'でもよい。
引数の値の種類がわかるように単語`number'を選んだ。
同様に、関数の実行において引数の役割を表す`multiplicand'（被乗数）を 選んでもよかった。
引数を`foogle'とも書けるが、これでは何を意味するか不明なのでよくない。
名前の選択はプログラマの責任であり、 関数の意味を明らかにするように選ぶべきである。

   引数リストのシンボルにはどんな名前を選んでもよく、
他の関数で使っているシンボルの名前でもよい。
引数リストに使用した名前は、その定義において私的である。
つまり、その定義において名前で参照した実体は、
その関数定義の外部で同じ名前で参照する実体とは別である。
たとえば、家族のあいだでは読者の愛称は「ショーティ」だとしよう。
家族の誰かが「ショーティ」といった場合には、読者のことである。
しかし、別の家族が「ショーティ」といった場合には、別の誰かのことである。
引数リスト中の名前は関数定義に私的なので、関数本体の内側でそのようなシンボルの
値を変更しても、関数の外部の値には影響しない。 `let'式でも同様な効果が得られる （*Note
let::）。

   引数リストには、関数の説明文である文字列が続く。
`C-h f'に続けて関数名をタイプしたときに表示されるのは、 この文字列である。
`apropos'などのある種のコマンドでは複数行の説明文のうち最初の1行のみを
表示するので、関数の説明文を書く場合には、最初の1行を1つの文にすべきである。 また、`C-h
f'（`describe-function'）で表示した場合に、
表示が変にならないように、説明文の2行目以降を字下げしないこと。
説明文は省略できるが、あると有益なので、 読者が書くほとんどの関数には指定するべきである。

   上の例の3行目は関数定義の本体である
（当然、ほとんどの関数の定義は、この例よりも長いはずである）。 ここでは、本体はリスト`(*
7 number)'であり、 NUMBERの値を7倍する （Emacs
Lispでは、`+'が加算であるように、`*'は乗算である）。

   関数`multiply-by-seven'を使うときには、
引数`number'は読者が指定した実際の数に評価される。
`multiply-by-seven'の使い方を示すが、まだ、評価しないでほしい。

     (multiply-by-seven 3)

関数を実際に使用すると、次節の関数定義に指定したシンボル`number'には、
値3が与えられる、つまり、「束縛」される。 関数定義では`number'は括弧の内側にあるが、
関数`multiply-by-seven'に渡される引数は括弧の内側にはないことに 注意してほしい。
関数定義において引数を括弧で囲むのは、コンピュータが
引数リストの終わりと関数定義の残りの部分を区別できるようにするためである。

   さて、この例を評価すると、エラーメッセージを得る （実際に試してみるとよい）。
これは、関数定義を書いたけれども、その定義をコンピュータに 与えていないからである。
つまり、関数定義をEmacsにインストール（あるいは、ロード）していないからである。
関数のインストールとは、Lispインタープリタに関数の定義を教える操作である。
次節では、インストールについて説明する。


File: emacs-lisp-intro-ja.info,  Node: Install,  Next: Interactive,  Prev: defun,  Up: Writing Defuns

3.2 関数定義のインストール
==========================

EmacsのInfoで読んでいる場合には、`multiply-by-seven'の関数定義を
評価してから`(multiply-by-seven 3)'を評価すれば、
関数`multiply-by-seven'を試すことができる。 関数定義をもう一度つぎにあげておく。
関数定義の最後の括弧の直後にカーソルを置いて`C-x C-e'とタイプする。
すると、エコー領域に`multiply-by-seven'と表示される
（関数定義を評価すると、その値として定義された関数の名前が返される）。
同時に、この操作で関数定義がインストールされるのである。

     (defun multiply-by-seven (number)
       "Multiply NUMBER by seven."
       (* 7 number))

この`defun'を評価すると、Emacsに`multiply-by-seven'をインストール したことになる。
これで、`forward-word'や編集関数などと同じく、 この関数もEmacsの一部である
（Emacsを終了するまで、`multiply-by-seven'はインストールされたままである。
Emacs起動時に自動的にコードをロードするには *note Permanent Installation::を参照）。

* Menu:

* Effect of installation::
* Change a defun::              How to change a function definition.


File: emacs-lisp-intro-ja.info,  Node: Effect of installation,  Next: Change a defun,  Prev: Install,  Up: Install

The effect of installation
--------------------------

   つぎの例を評価すれば、`multiply-by-seven'をインストールした効果がわかる。
つぎの式の直後にカーソルを置いて`C-x C-e'とタイプする。
エコー領域に数21が表示されるはずである。

     (multiply-by-seven 3)

   必要ならば、`C-h f'（`describe-function'）に続けて 関数名`
multiply-by-seven'をタイプすれば、 関数の説明文を読むことができる。
これを行うと、つぎのような内容のウィンドウ`*Help*'が画面に現れる。

     multiply-by-seven:
     Multiply NUMBER by seven.

（画面を単一のウィンドウに戻すには、`C-x 1'とタイプする。）


File: emacs-lisp-intro-ja.info,  Node: Change a defun,  Prev: Effect of installation,  Up: Install

3.2.1 関数定義の変更
--------------------

`multiply-by-seven'のコードを変更するには、書き変えればよい。
旧版のかわりに新版をインストールするには、関数定義を再度評価する。
Emacsではこのようにコードを修正すればよく、非常に簡単である。

   例として、7を掛けるかわりに、数そのものを7回足すように
関数`multiply-by-seven'を変更する。 同じ結果を得るが、その方法が異なる。
同時に、コードに注釈を加えよう。 注釈とは、Lispインタープリタは無視するテキストであるが、
人には有用であり意味を明らかにする。 この例では、「第2版」が注釈である。

     (defun multiply-by-seven (number)       ; 第2版
       "Multiply NUMBER by seven."
       (+ number number number number number number number))

   セミコロン`;'に続けて注釈を書く。
Lispでは、行の中でセミコロンに続くものはすべて注釈である。 注釈は行末で終わる。
2行以上にわたる注釈は、各行をセミコロンで始める。

   注釈に関してより詳しくは、 *note Comments: (elisp)Comments.や *Note
Beginning a .emacs File::。

   この版の関数`multiply-by-seven'をインストールするには、
最初の版を評価したのと同じように評価すればよい。
すなわち、最後の括弧の直後にカーソルを置いて`C-x C-e'とタイプする。

   まとめると、Emacs Lispでコードを書くには、 関数を書いてインストールしてテストし、
必要に応じて、修正や機能強化して再インストールする。


File: emacs-lisp-intro-ja.info,  Node: Interactive,  Next: Interactive Options,  Prev: Install,  Up: Writing Defuns

3.3 関数を対話的にする
======================

関数を対話的にするには、
関数の説明文のあとにスペシャルフォーム`interactive'で始まるリストを置く。
こうすれば、`M-x'に続けて関数名をタイプするか、
関数に束縛したキー列をタイプすれば対話的関数を起動できる。
たとえば、`next-line'を起動するには`C-n'とタイプし、
`mark-whole-buffer'を起動するには`C-x h'とタイプする。

   対話的関数を対話的に呼び出した場合には、
関数が返した値は自動的にはエコー領域に表示されない。
これは、対話的関数を呼び出すのは、単語単位や行単位の移動などの副作用の
ためであり、返された値は必要ないからである。
キーをタイプするたびに返された値をエコー領域に表示すると、とても煩わしい。

* Menu:

* Interactive multiply-by-seven::  An overview.
* multiply-by-seven in detail::  The interactive version.


File: emacs-lisp-intro-ja.info,  Node: Interactive multiply-by-seven,  Next: multiply-by-seven in detail,  Prev: Interactive,  Up: Interactive

対話的`multiply-by-seven'
-------------------------

   `multiply-by-seven'の対話的な版を作って、
スペシャルフォーム`interactive'の使い方と エコー領域に値を表示する1つの方法を示そう。

   コードはつぎのとおりである。

     (defun multiply-by-seven (number)       ; 対話的版
       "Multiply NUMBER by seven."
       (interactive "p")
       (message "The result is %d" (* 7 number)))

このコードの直後にカーソルを置いて`C-x C-e'とタイプして、 このコードをインストールする。
エコー領域には関数名が表示されるはずである。 そうすれば、`C-u'、数、`M-x
multiply-by-seven'とタイプして <RET>を押せば、このコードを使うことができる。
エコー領域には、 `The result is ...'に続けて乗算結果が表示されるはずである。

   より一般的には、このような関数を起動する方法は2つある。

  1. `C-u 3 M-x forward-sentence'のように、
     関数に渡すべき数を含む前置引数をタイプしてから、 `M-x'に続けて関数名をタイプする。
     あるいは、

  2. `C-u 3 M-e'のような関数にバインドされたキー列をタイプする。

上のキー列の例は、どちらもポイントを文単位に3つ進める
（`multiply-by-seven'にはキーがバインドされていないので、
キーバインドを使う例としては使えない）。

   （コマンドをキーにバインドする方法については *Note Keybindings::。）

   前置引数を対話的関数に渡すには、 `M-3 M-e'のようにキー<META>に続けて数をタイプするか、
`C-u 3 M-e'のように`C-u'に続けて数をタイプする
（数をタイプせずに`C-u'だけをタイプすると、デフォルトは4）。


File: emacs-lisp-intro-ja.info,  Node: multiply-by-seven in detail,  Prev: Interactive multiply-by-seven,  Up: Interactive

3.3.1 対話的 `multiply-by-seven'
--------------------------------

スペシャルフォーム`interactive'と関数`message'の使い方を
`multiply-by-seven'で見てみよう。 関数定義はつぎのとおりであった。

     (defun multiply-by-seven (number)       ; 対話的版
       "Multiply NUMBER by seven."
       (interactive "p")
       (message "The result is %d" (* 7 number)))

   この関数では、式`(interactive "p")'は、要素2個のリストである。
`"p"'は、前置引数を関数に渡すことをEmacsに指示するもので、
その値を関数への引数として使う。

   引数は数である。 つまり、つぎの行のシンボル`number'には数が束縛される。

     (message "The result is %d" (* 7 number))

たとえば、前置引数が5であったとすると、 Lispインタープリタはつぎのような行であるとして評価する
（GNU Emacsで読んでいる場合には、読者自身がこの式を評価してほしい）。

     (message "The result is %d" (* 7 5))

まず、インタープリタは内側のリスト`(* 7 5)'を評価する。 値35が返される。
つぎに、インタープリタは外側のリストを評価するが、それには、
リストの第2要素以降の値を関数`message'に渡す。

   すでに説明したように、`message'はユーザーに1行のメッセージを
表示するために考えられたEmacs Lispの関数である （*Note message::）。
すなわち、関数`message'は、`%d'や`%s'や`%c'を除いて、
第1引数を字面のとおりにエコー領域に表示する。 `%d'や`%s'や`%c'の制御文字列があると、
2番目以降の引数を調べてその値を対応する制御文字列の位置に表示する。

   対話的関数`multiply-by-seven'では、
制御文字列としては`%d'を使っており、これは数を必要とする。 `(* 7
5)'を評価した結果は数35である。 したがって、`%d'の位置に数35が表示されるので、
メッセージは`The result is 35'となる。

   （関数`multiply-by-seven'を呼んだときは、
メッセージには二重引用符が付かないが、`message'を呼んだときには、
二重引用符のあいだにテキストが表示されることに注意してほしい。
`message'を先頭要素とする式を評価したときには、
`message'が返した値がエコー領域に表示されるが、
関数内で用いた場合には、副作用として`message'が二重引用符なしでテキストを
表示するからである。）


File: emacs-lisp-intro-ja.info,  Node: Interactive Options,  Next: Permanent Installation,  Prev: Interactive,  Up: Writing Defuns

3.4 `interactive'の他のオプション
=================================

上の例の`multiply-by-seven'では、 `interactive'の引数として`"p"'を用いた。
この引数は、ユーザーがタイプした`C-u'や<META>に続く数を、
関数への引数として渡すコマンドとして解釈するようにEmacsに指示する。
Emacsでは、あらかじめ定義された20個以上の文字を`interactive'に指定できる。
ほとんどの場合、これらのオプションを指定すれば、 必要な情報を関数へ対話的に渡せる
（*Note Code Characters for `interactive': (elisp)Interactive Codes）。

   たとえば、文字`r'を指定すると、Emacsは、リージョンの開始位置と終了位置
（ポイントとマークの現在値）を2つの引数として関数へ渡す。 つぎのように使う。

     (interactive "r")

   一方、`B'を指定すると、Emacsは関数にバッファ名を渡す。
`B'をみると、Emacsは、`"BAppend to buffer: "'のような`B'に
続く文字列をプロンプトとしてミニバッファに表示して、 ユーザーに名前を問い合わせる。
Emacsはプロンプトを表示するだけでなく、<TAB>が押されると名前を補完する。

   2つ以上の引数を取る関数では、
`interactive'に続く文字列に要素を追加すれば各引数に情報を渡せる。
このとき、各引数に情報を渡す順番は、 リスト`interactive'に指定した順番と同じである。
文字列の各部分は、改行`\n'で区切る。 たとえば、`"BAppend to buffer:
"'に続けて、`\n'と`r'を 指定する。
こうすると、Emacsはバッファ名を問い合わせることに加えて、 ポイントとマークの値を関数に渡す。
つまり、引数は全部で3つである。

   この場合、関数定義はつぎのようになり、 `buffer'、`start'、`end'の各シンボルには、
バッファ、リージョンの開始位置、 終了位置の現在値を`interactive'が束縛する。

     (defun 関尽名 (buffer start end)
       "逝明文..."
       (interactive "BAppend to buffer: \nr")
       関尽の本体...)

（プロンプトのコロンのうしろの空白は、
プロンプトを表示したときに見やすくするためのものである。
関数`append-to-buffer'でもこのようにしている。 *Note append-to-bufferm::。）

   引数がない関数の場合には、`interactive'には何も指定しなくてよい。
そのような関数では、単に式`(interactive)'を指定する。
関数`mark-whole-buffer'は、このようになっている。

   読者のアプリケーションにおいて、あらかじめ定義した文字では不十分な場合には、
`interactive'にリストを指定すれば、独自の引数を渡せる。 この技法について詳しくは、*Note
Using `Interactive': (elisp)interactive。


File: emacs-lisp-intro-ja.info,  Node: Permanent Installation,  Next: let,  Prev: Interactive Options,  Up: Writing Defuns

3.5 コードの恒久的インストール
==============================

関数定義を評価して関数定義をインストールすると、 Emacsを終了するまでは関数定義は有効である。
新たにEmacsを起動したときには、
関数定義を再度評価するまでは関数定義はインストールされない。

   新たにEmacsを起動するたびに、自動的にコードをインストールしたくなるであろう。
これにはいくつかの方法がある。

   * 個人用のコードの場合には、
     個人用の初期化ファイル`.emacs'に関数定義のコードを入れておく。
     Emacsを起動すると、個人用の`.emacs'が自動的に評価され、
     その中のすべての関数定義がインストールされる。 *Note Emacs Initialization::。

   * あるいは、インストールしたい関数定義をいくつかのファイルに収めておき、
     関数`load'を用いてEmacsに各ファイルの関数定義を評価させインストールする。 *Note
     Loading Files::。

   * 読者のサイト全体で使用するコードの場合には、
     Emacsを構築する際にロードするファイル`site-init.el'にコードを収める。
     こうすると、サイトのユーザーなら誰でもコードを使えるようになる
     （Emacsのディストリビューションに含まれるファイル`INSTALL'を参照のこと）。

   最後に、Emacsのすべてのユーザーが使いそうなコードがあれば、
ネットワークに投稿するかFree Software Foundationに送付することができる
（こうする場合には、投稿するまえに他の人が実行・コピー・学習・修正・再配布できる
ように許可したライセンスを入れてほしい．）。 Free Software
Foundationにコードを送付すると，適切なライセンスで保護されていれば，
Emacsの次期リリースにコードが含まれるかもしれない。
このような「寄贈行為」によりEmacsが成長してきたのである。


File: emacs-lisp-intro-ja.info,  Node: let,  Next: if,  Prev: Permanent Installation,  Up: Writing Defuns

3.6 `let' _(2004/03/28)_
========================

`let'式はLispのスペシャルフォームであり、 ほとんどの関数定義で使う必要がある。

   `let'はシンボルに値を結び付ける、すなわち、束縛するのであるが、
関数の内部と外部で同じ名前の変数を使ってもLispインタープリタが混乱しない
ような方法でこれを行う。

   このスペシャルフォームが必要な理由を理解するために、
「家を塗装し直す必要がある」などのように一般的に「家」と呼ぶような 家屋を所有している状況を仮定してみよう。
読者が友人宅を訪問したときに、友人が「家」といったときには、
_友人の_家を意味しているのであって、読者の家ではないだろう。

   友人は彼の家を意味しているのに、読者が読者の家を意味していると考えると、 混乱が生じる。
ある関数の内部で使う変数と別の関数の内部で使う変数が同じ名前でも、
同じ値を参照する意図がないのであれば、Lispでも同じことが起こる。`let' はこ の種の混乱を防ぐ．

* Menu:

* Prevent confusion::
* Parts of let Expression::
* Sample let Expression::
* Uninitialized let Variables::


File: emacs-lisp-intro-ja.info,  Node: Prevent confusion,  Next: Parts of let Expression,  Prev: let,  Up: let

`let' で混乱を避ける
--------------------

   スペシャルフォーム`let'はこの種の混乱を防ぐ。
`let'は、`let'式の外側にある同じ名前を隠すような "ローカル変数（local
variable）"としての名前を作り出す。
これは、友人が「家」といった場合、彼は読者のではなく彼の家を意味していると 理解することに似ている
（引数リストに使われるシンボルも同じように働く。 *Note defun::）。

   `let'式が作るローカル変数は、`let'式の内側
（と`let'式から呼ばれた式の内側）でのみそれらの値を保持する。
ローカル変数は、`let'式の外側にはまったく影響しない。

   `let' は 一次的なローカルの `setq' のようなものとも理解できるだろう． `let'
により定義された値は `let' が終わると自動的に解除されます． `let'
はその境界の中でだけ有効になるのです．コンピュータ科学用語辞典では 「`let'
でよばれた関数でだけシンボル割り当てを見ることができます．Emacs Lisp
ではスコープは動的で静的ではないのです．」となっています．

   `let'では一度に複数個の変数を作れる。 また、`let'で各変数を作るときには、
指定した値か`nil'を初期値として設定できる （専門用語では、「変数に値を束縛する」という）。
`let'で変数を作って束縛すると、`let'の本体のコードを実行し、
`let'式全体の値として本体の最後の式の値を返す
（「実行（execute）」とは、リストを評価することを意味する専門用語である。
これは、「実質的な効果を与える」という単語の用法 （`Oxford English
Dictionary'）からきている。 ある動作を行わせるために式を評価するので、
「実行（execute）」は「評価（evaluate）」の同義語である）。


File: emacs-lisp-intro-ja.info,  Node: Parts of let Expression,  Next: Sample let Expression,  Prev: let,  Up: let

3.6.1 `let'式の構造 _(2004/03/28)_
----------------------------------

`let'式は、3つの要素からなるリストである。 第一の部分は、シンボル`let'である。
第二の部分は、"変数リスト（varlist）"と呼ばれるリストであり、
その個々の要素は、単独のシンボルであるか、第1要素がシンボルであるような 2要素リストである。
`let'式の第3の部分は、`let'の本体である。 通常、本体は複数個のリストである。

     (let VARLIST BODY...)

変数リストの各シンボルは、 スペシャルフォーム`let'で初期値を設定された変数である。
単独のシンボルの場合、初期値は`nil'である。
第1要素がシンボルであるような2要素リストである場合、
そのシンボルには、Lispインタープリタが第2要素を評価した結果を束縛する。

   したがって、変数リストは`(thread (needles 3))'のようになる。
この`let'式では、Emacsは、シンボル`thread'には初期値`nil'を、
シンボル`needles'には初期値3を束縛する。

   `let'式を書くときには、 `let'式の雛型の適当な項目に必要な式を書き込めばよい。

   変数リストが2要素リストだけから成る場合には、 `let'式の雛型はつぎのようになる。

     (let ((VARIABLE VALUE)
           (VARIABLE VALUE)
           ...)
       BODY...)


File: emacs-lisp-intro-ja.info,  Node: Sample let Expression,  Next: Uninitialized let Variables,  Prev: Parts of let Expression,  Up: let

3.6.2 `let'式の例 _(2004/03/28)_
--------------------------------

つぎの式では、2つの変数`zebra'と`tiger'を作り、 それぞれに初期値を与える。
`let'式の本体は、関数`message'を呼ぶリストである。

     (let ((zebra 'stripes)
           (tiger 'fierce))
       (message "One kind of animal has %s and another is %s."
                zebra tiger))

   変数リストは`((zebra 'stripes) (tiger 'fierce))'である。

   2つの変数は、`zebra'と`tiger'である。
各変数は2要素リストの先頭要素であり、個々の値は2要素リストの第2要素である。
変数リストでは、Emacsは、変数`zebra'には値`stripes'を、
変数`tiger'には値`fierce'を束縛する。
この例では、どちらの値も引用符を直前に付けたシンボルである。
これらの値は、リストであっても文字列であってもよい。
変数を保持するリストのあとには、`let'式の本体が続く。
この例では、エコー領域に文字列を表示する関数`message'を使ったリストが 本体である。

   これまでのように、例の最後の括弧の直後にカーソルを置いて`C-x C-e'と
タイプすれば例を評価できる。
そうすると、エコー領域にはつぎのように表示されるはずである。

     "One kind of animal has stripes and another is fierce."

   これまでに見てきたように、関数`message'は `%s'を除いて第1引数を表示する。
この例では、変数`zebra'の値が最初の`%s'の位置に、
変数`tiger'の値が2番目の`%s'の位置に表示される。


File: emacs-lisp-intro-ja.info,  Node: Uninitialized let Variables,  Prev: Sample let Expression,  Up: let

3.6.3 `let'式の非初期化変数 _(2004/03/28)_
------------------------------------------

`let'式において特に初期値を束縛していない変数には、 自動的に初期値として`nil'を束縛する。
つぎの例を見てほしい。

     (let ((birch 3)
           pine
           fir
           (oak 'some))
       (message
        "Here are %d variables with %s, %s, and %s value."
        birch pine fir oak))

変数リストは`((birch 3) pine fir (oak 'some))'である。

   いつものようにこの式を評価すると、エコー領域にはつぎのように表示される。

     "Here are 3 variables with nil, nil, and some value."

この例では、Emacsは、シンボル`birch'に数3を、 シンボル`pine'と`fir'に`nil'を、
シンボル`oak'に`some'を束縛する。

   `let'の最初の部分では、変数`pine'と`fir'は括弧で囲んでない 単独のアトムである。
そのため、これらの変数は空リスト`nil'に束縛される。 一方、`oak'は、リスト`(oak
'some)'の一部なので、 `some'に束縛される。
同様に、`birch'もリストの一部なので数3に束縛される
（数はそれ自身に評価されるので、数をクオートする必要はない。
また、メッセージに数を表示するには`%s'のかわりに`%d'を使う）。
4つの変数をまとめてリストにすることで、`let'の本体と区別できるようにする。


File: emacs-lisp-intro-ja.info,  Node: if,  Next: else,  Prev: let,  Up: Writing Defuns

3.7 スペシャルフォーム`if' _(2004/03/28)_
=========================================

`defun'や`let'に続く3番目のスペシャルフォームは、 条件分岐`if'である。
このフォームは、コンピュータに判定を指示する。
`if'を使わずに関数定義を書くことも可能であろうが、
多くの場面で使用する重要なものなので、ここで説明しておこう。
たとえば、関数`beginning-of-buffer'のコードで使っている。

   `if'の基本的な考え方は、
「_もし（if）_条件が_真ならば（then）_式を評価する」である。
条件が真でなければ、式を評価しない。
たとえば、「もし（if）暑くて夏ならば（then）海へ行く！」のような判定に使う。

* Menu:

* if in more detail::
* type-of-animal in detail::    An example of an `if' expression.


File: emacs-lisp-intro-ja.info,  Node: if in more detail,  Next: type-of-animal in detail,  Prev: if,  Up: if

`if' の詳細
-----------

   Lispで`if'式を書く場合には、「then」を書かない。
第1要素が`if'であるリストの第2要素と第3要素のそれぞれに、
判定条件と真の場合の動作を指定する。
`if'式の条件を調べる部分を"判定条件（if-part）"、
2番目の引数を"真の場合の動作（then-part）"と呼ぶ。

   また、`if'式を書くとき、判定条件はシンボル`if'と同じ行に書くが、
真の場合の動作は2行目以降に書く。 このようにすると`if'式が読みやすくなる。

     (if 判鎚紹系
         真の礁糠の動採)

判定条件は、Lispインタープリタが評価できればどんな式でもよい。

   いつものようにして評価できる例をつぎにあげよう。
判定条件は、「数5は数4よりも大きいか」である。 これは真なので、メッセージ`5 is
greater than 4!'が表示される。

     (if (> 5 4)                             ; 判定条件
         (message "5 is greater than 4!"))   ; 真の場合の動作

（関数`>'は、第1引数が第2引数よりも大きいかどうかを調べ、 そうならば真を返す。）

   実際のコードでは、`if'式の判定条件は、式`(> 5 4)'のように 固定されていない。
判定条件に使われる少なくとも1つの変数に束縛された値は、 あらかじめわかっていないはずである
（あらかじめ値がわかっていれば、テストする必要はない）。

   たとえば、関数定義の引数に束縛された値を使う。
つぎの関数定義では、関数に渡される値は動物の性質である。
`characteristic'に束縛された値が`fierce'（獰猛な）の場合には、 メッセージ`It's a
tiger!'を表示する。 そうでなければ、`nil'を返す。

     (defun type-of-animal (characteristic)
       "Print message in echo area depending on CHARACTERISTIC.
     If the CHARACTERISTIC is the symbol `fierce',
     then warn of a tiger."
       (if (equal characteristic 'fierce)
           (message "It's a tiger!")))

GNU Emacsで読んでいる場合には、これまでのように関数定義を評価して
定義をEmacsにインストールし、つぎの2つの式を評価して結果を確認できる。

     (type-of-animal 'fierce)

     (type-of-animal 'zebra)

`(type-of-animal 'fierce)'を評価すると、 エコー領域にはメッセージ`"It's a
tiger!"'が表示される。 `(type-of-animal 'zebra)'を評価すると、
エコー領域には`nil'と表示される。


File: emacs-lisp-intro-ja.info,  Node: type-of-animal in detail,  Prev: if in more detail,  Up: if

3.7.1 関数`type-of-animal'の詳細 _(2004/03/28)_
-----------------------------------------------

関数`type-of-animal'を詳しく見てみよう。

   `type-of-animal'の関数定義は、 関数定義の雛型と`if'式の雛型を埋めて書いたものである。

   これらは対話的関数の雛型ではない。

     (defun 関尽名 (畏尽ナスト)
       "逝明文..."
       本体...)

   この雛型に対応する関数の部分はつぎのとおりである。

     (defun type-of-animal (characteristic)
       "Print message in echo area depending on CHARACTERISTIC.
     If the CHARACTERISTIC is the symbol `fierce',
     then warn of a tiger."
       本体( `if'式))

   関数名は`type-of-animal'であり、渡される引数は1つである。
引数リストのあとには複数行の説明文字列が続いている。
各関数定義に説明文を付加しておくのはよい習慣なので、 この例でも説明文を付けておいた。
関数定義の本体は`if'式から成る。

   `if'式の雛型はつぎのとおりである。

     (if 判鎚紹系
         真の礁糠の動採)

   関数`type-of-animal'の`if'のコードはつぎのとおりである。

     (if (equal characteristic 'fierce)
         (message "It's a tiger!")))

   ここで、判定条件はつぎのとおり。

     (equal characteristic 'fierce)

Lispでは、`equal'は、第1引数が第2引数に等しいかどうかを調べる関数である。
第2引数はクオートしたシンボル`'fierce'であり、
第1引数はシンボル`characteristic'の値、 つまり、この関数に渡された引数である。

   `type-of-animal'の最初の使用例では、
引数`fierce'を`type-of-animal'に渡した。 `fierce'は`fierce'に等しいので、
式`(equal characteristic 'fierce)'は真を返す。 すると、`if'は第2引数、つまり、
真の場合の動作`(message "It's a tiger!")'を評価する。

   一方、`type-of-animal'の2番目の使用例では、
引数`zebra'を`type-of-animal'に渡した。
`zebra'は`fierce'に等しくないので、真の場合の動作は評価されず、 `if'式は`nil'を返す。


File: emacs-lisp-intro-ja.info,  Node: else,  Next: Truth & Falsehood,  Prev: if,  Up: Writing Defuns

3.8 If-then-else式 _(2004/03/28)_
=================================

`if'式には第3引数を指定することもでき、判定条件が
"偽の場合の動作（else-part）"である。
判定条件が偽であると、`if'式の第2引数、つまり、真の場合の動作は
いっさい評価_されず_、第3引数、つまり、偽の場合の動作が評価_される_。 曇の場合を考慮して
「もし（if）暑くて夏ならば（then）海へ行く、そうでなければ（else）読書する！」
のような判定である。

   Lispのコードには「else」を書かない。
偽の場合の動作は、`if'式の真の場合の動作のうしろに書く。
偽の場合の動作は新しい行で始め、真の場合の動作よりも字下げを少なくする。

     (if TRUE-OR-FALSE-TEST
         ACTION-TO-CARRY-OUT-IF-THE-TEST-RETURNS-TRUE
       ACTION-TO-CARRY-OUT-IF-THE-TEST-RETURNS-FALSE)

   たとえば、つぎの`if'式では、いつものように評価するとメッセージ `4 is not
greater than 5!'を表示する。

     (if (> 4 5)                             ; 判定条件
         (message "5 is greater than 4!")    ; 真の場合の動作
       (message "4 is not greater than 5!")) ; 偽の場合の動作

適当に字下げすると真の場合の動作と偽の場合の動作を 区別しやすくなることに注意してほしい （GNU
Emacsには、`if'式を自動的に正しく字下げするコマンドがある。 *Note Typing Lists::）。

   `if'式に偽の場合の動作を追加するだけで、 関数`type-of-animal'の機能を拡張できる。

   関数`type-of-animal'のつぎの版を評価して定義をインストールしてから、
続く2つの式を評価するとこの拡張を理解できるであろう。

      (defun type-of-animal (characteristic)  ; 第2版.
       "Print message in echo area depending on CHARACTERISTIC.
     If the CHARACTERISTIC is the symbol `fierce',
     then warn of a tiger;
     else say it's not fierce."
       (if (equal characteristic 'fierce)
           (message "It's a tiger!")
         (message "It's not fierce!")))


     (type-of-animal 'fierce)

     (type-of-animal 'zebra)

`(type-of-animal 'fierce)'を評価すると、 エコー領域にメッセージ`"It's a
tiger!"'が表示される。 ところが、`(type-of-animal 'zebra)'を評価すると `"It's
not fierce!"'と表示される。

   （CHARACTERISTICが`ferocious'（凶暴な）であれば、 メッセージ`"It's not
fierce!"'が表示されるが、これは誤解を招く。
コードを書く際には、`if'で調べる値の可能な組み合わせを十分に考慮し、
そのようにプログラムを書く必要がある。）


File: emacs-lisp-intro-ja.info,  Node: Truth & Falsehood,  Next: save-excursion,  Prev: else,  Up: Writing Defuns

3.9 Emacs Lispの真偽値 _(2004/03/28)_
=====================================

`if'式での判定条件が真かどうかの検査には重要な側面がある。
これまで、述語の値としての「真（true）」と「偽（false）」を、 新たなEmacs
Lispオブジェクトであるかのように使ってきた。
実際には、「偽（false）」とは、すでに馴染みのある`nil'のことである。
これ以外は、たとえ何であれ、「真（true）」である。

   判定条件の式では、評価結果が`nil'以外の値であれば、 "真（true）"と解釈する。
いいかえれば、47などの数、`"hello"'のような文字列、
（`nil'ではない）`flowers'などのシンボルやリスト、 バッファでさえも、真と解釈する。

* Menu:

* nil explained::               `nil' has two meanings.


File: emacs-lisp-intro-ja.info,  Node: nil explained,  Prev: Truth & Falsehood,  Up: Truth & Falsehood

`nil' について
--------------

   これらの例を示すまえに、`nil'について説明しておこう。

   Emacs Lispでは、シンボル`nil'には2つの意味がある。 第一に、空リストを意味する。
第二に、偽を意味し、判定条件が偽の場合に返される値でもある。
`nil'は、空リスト`()'とも`nil'とも書ける。
Lispインタープリタにとっては、`()'も`nil'も同じである。
一方、人間向きには、偽は`nil'と、空リストは`()'と書く傾向がある。

   Emacs Lispでは、`nil'でない、つまり、空リストでない値は真と解釈する。
つまり、評価結果が空リスト以外であれば、`if'式の判定条件は真になる。
たとえば、判定条件に数を書いた場合、数を評価するとその数そのものである。
したがって、`if'式の判定条件は真になる。
式の評価結果が`nil'つまり空リストの場合に限り、判定条件は偽になる。

   つぎの2つの式を評価すると理解できるだろう。

   最初の例では、`if'式の判定条件として数4を評価するが、 その結果は数4である。
したがって、式の真の場合の動作が評価され、その結果が返される。
つまり、エコー領域には`true'と表示される。 2番目の例では、`nil'は偽を意味するので、
偽の場合の動作が評価されその結果が返される。 エコー領域には`false'と表示される。

     (if 4
         'true
       'false)

     (if nil
         'true
       'false)

   判定結果として真を表す有用な値がない場合には、 Lispインタープリタは真としてシンボル`t'を返す。
たとえば、つぎの例でわかるように、式`(> 5 4)'を評価すると`t'を返す。

     (> 5 4)

一方、偽の判定結果としては、この関数は`nil'を返す。

     (> 4 5)


File: emacs-lisp-intro-ja.info,  Node: save-excursion,  Next: Review,  Prev: Truth & Falsehood,  Up: Writing Defuns

3.10 `save-excursion' _(2004/03/28)_
====================================

関数`save-excursion'は、 本章で説明する4番目で最後のスペシャルフォームである。

   エディタとしてのEmacs Lispプログラムでは、 関数`save-excursion'を多用している。
この関数は、ポイントとマークの位置を記録してから、関数の本体を実行し、
ポイントやマークの位置が移動していれば実行前の状態に復元する。
この関数の主要な目的は、ポイントやマークの予期しない移動によって
ユーザーが混乱したり煩わされないようにすることである。

* Menu:

* Point and mark::              A review of various locations.
* Template for save-excursion::


File: emacs-lisp-intro-ja.info,  Node: Point and mark,  Next: Template for save-excursion,  Prev: save-excursion,  Up: save-excursion

ポイントとマーク
----------------

   `save-excursion'を説明するまえに、 GNU
Emacsのポイントとマークについて復習しておこう。
"ポイント（point）"とは、カーソルの現在位置である。
カーソルがどこにあろうとも、それがポイントである。
端末画面上では、カーソルは文字に重なって表示されるが、 ポインタはその文字の直前にある。
Emacs Lispでは、ポイントは整数である。 バッファの最初の文字は1、つぎの文字は2と数える。
関数`point'はカーソルの現在位置を数で返す。 各バッファごとに、個別のポイントがある。

   "マーク（mark）"も、バッファ内の位置を表す。
`C-<SPC>'（`set-mark-command'）などのコマンドで、値を設定する。 マークを設定してあれば、
コマンド`C-x C-x'（`exchange-point-and-mark'）を用いて
カーソルをマークに移動するとともに、 カーソル移動前のポイント位置にマークを設定する。
さらに、別のマークが設定してあった場合には、 交換前のマークの位置をマークリングに保存する。
このようにして複数個のマーク位置を保存できる。 `C-u
C-<SPC>'と数回タイプすると保存したマーク位置に移動できる。

   バッファのポイントとマークのあいだの部分を"リージョン（region）"と呼ぶ。
`center-region'、`count-lines-region'、`kill-region'、
`print-region'などのさまざまなコマンドはリージョンに作用する。

   スペシャルフォーム`save-excursion'は、ポイントとマークの位置を記録し、
Lispインタープリタがスペシャルフォームの本体のコードを評価し終えると、
それらの位置を復元する。 したがって、テキストの始めの部分にポイントがあったときに、
コードでポイントをバッファの最後に移動したとすると、
`save-excursion'は、関数の本体の式を評価し終えると ポイントをもとの場所に戻す。

   Emacsでは、ユーザーが意図しなくても、関数の内部動作の過程でポイントを
移動することが多い。 たとえば、`count-lines-region'はポイントを移動する。
（ユーザーの視点からは）予期しないような不必要なポイントの移動で
ユーザーが混乱しないように、ポイントやマークがユーザーの期待どおりの位置に
あるように`save-excursion'を多用する。
`save-excursion'を使うと、正しく管理できる。

   正しく管理できるように、`save-excursion'の内側のコードで
何か不都合なことが起こった場合（専門用語でいえば、「異常終了した場合」）でも、
`save-excursion'はポイントとマークの値を復元する。 この機能はとても役に立つ。

   ポイントとマークの値を記録することに加えて、
`save-excursion'は、カレントバッファも記録しておいて復元する。
つまり、バッファを切り替えるようなコードを書いた場合でも、
`save-excursion'によりもとのバッファに戻れる。
`append-to-buffer'では、このために`save-excursion'を使っている （*Note
append-to-buffer::）。


File: emacs-lisp-intro-ja.info,  Node: Template for save-excursion,  Prev: Point and mark,  Up: save-excursion

3.10.1 `save-excursion'式の雛型 _(2004/03/28)_
----------------------------------------------

`save-excursion'を使うコードの雛型は簡単である。

     (save-excursion
       本体...)

関数の本体は、複数個の式であり、Lispインタープリタはそれらを順に評価する。
本体に複数個の式がある場合、 最後の式の値が関数`save-excursion'の値として返される。
本体のそれ以外の式は、副作用を得るためだけに評価される。
`save-excursion'自体も（ポイントとマークの位置を復元するという）
副作用を得るためだけに使われる。

   `save-excursion'式の雛型をより詳しく書くと、つぎのようになる。

     (save-excursion
       本体の最宿の式
       本体の2番目の式
       本体の3番目の式
        ...
       本体の最古の式)

ここで、式は単一のシンボルやリストである。

   Emacs Lispのコードでは、`save-excursion'式は`let'式の 本体に現れることが多い。
つぎのようになる。

     (let 変尽ナスト
       (save-excursion
         本体...))


File: emacs-lisp-intro-ja.info,  Node: Review,  Next: defun Exercises,  Prev: save-excursion,  Up: Writing Defuns

3.11 復　習 _(2004/08/04)_
==========================

これまでの章では、多数の関数やスペシャルフォームを紹介してきた。
以下には、説明しなかった同種の関数も含めて概要を記しておく。

`eval-last-sexp'
     ポイントの現在位置の直前にあるシンボリック式を評価する。
     引数を指定せずにこの関数を起動した場合には、エコー領域に値を表示する。
     引数を指定した場合には、カレントバッファに結果を表示する。
     このコマンドは慣習的に`C-x C-e'にバインドされる。

`defun'
     関数を定義する。 このスペシャルフォームは、多くても5つの部分から成る。
     つまり、名前、関数に渡される引数の雛型、
     説明文、省略してもよい対話的使用の宣言、定義の本体である。

     例：

          (defun back-to-indentation ()
            "Move point to first visible character on line."
            (interactive)
            (beginning-of-line 1)
            (skip-chars-forward " \t"))

`interactive'
     対話的に使える関数であることをインタープリタに対して宣言する。
     このスペシャルフォームには、関数の引数に渡すべき情報を指定する
     文字列を続けてもよい。
     これらの文字列には、インタープリタが使用するプロンプトも指定できる。
     文字列の各要素は改行`\n'で区切る。

     よく使うコード文字はつぎのとおりである。

    `b'
          既存バッファの名前。

    `f'
          既存ファイルの名前。

    `p'
          数値の前置引数（「p」は小文字）。

    `r'
          2つの数値引数でポイントとマークを渡す。 値が小さいほうを先に渡す。
          これは、1つではなく2つの引数を渡す唯一のコード文字である。

     コード文字の完全な一覧に ついては、*Note Code Characters for
     `interactive': (elisp)Interactive Codes。

`let'
     `let'の本体で使用する変数のリストを宣言し、
     それらに`nil'や指定した値を初期値として設定する。
     続いて、`let'の本体の式を評価し、その最後の値を返す。
     `let'の本体の内側では、Lispインタープリタは`let'の外側で
     同じ名前の変数に束縛された値を使うことはない。

     例：

          (let ((foo (buffer-name))
                (bar (buffer-size)))
            (message
             "This buffer is %s and has %d characters."
             foo bar))

`save-excursion'
     このスペシャルフォームの本体を評価するまえに、
     ポイントとマークの値、カレントバッファを記録する。
     そのあとで、ポイントとマークの値、バッファを復元する。

     例：

          (message "We are %d characters into this buffer."
                   (- (point)
                      (save-excursion
                        (goto-char (point-min)) (point))))

`if'
     関数の第1引数を評価する。 それが真ならば、第2引数を評価する。
     そうでない場合、第3引数があればそれを評価する。

     スペシャルフォーム`if'は、"条件判定（conditional）"である。
     Emacsには別の条件判定もあるが、もっともよく使うのは`if'であろう。

     例：

          (if (string-equal
               (number-to-string 21)
               (substring (emacs-version) 10 12))
              (message "This is version 21 Emacs")
            (message "This is not version 21 Emacs"))

`equal'
`eq'
     2つのオブジェクトが同じであるかどうかを調べる。`equal' は「同じ」という意味 で使うが
     `eq' はそうではない．
     `equal'は、2つのオブジェクトが同じ本のコピーのように，同じ内容で同じ構造ならば真を返す。
     一方、`eq'は、2つの引数が同一のオブジェクトならば真を返す。 

`<'
`>'
`<='
`>='
     関数`<'は、第1引数が第2引数より小さいかどうかを検査する。
     対応する関数`>'は、第1引数が第2引数より大きいかどうかを検査する。
     同様に、`<='は、第1引数が第2引数より小さいか等しいかどうかを検査し、
     `>='は、第1引数が第2引数より大きいか等しいかどうかを検査する。
     いずれの場合でも、2つの引数は数かマーカー(バッファの位置を示すマーカー)である必要がある。

`string<'
`string-lessp'
`string='
`string-equal'
     関数 `string-lessp' は最初の引数が二番目の引数よりも小さいかどうかを確認し
     ます．同じ機能を持つ(`defalias' による)別の名は `string<' です．

     `string-lessp' の引数は文字列かシンボルでなければなりません．順序は辞書的に
     付けられますので，大文字小文字は区別されます．シンボルの名前はシンボル自身の代わ
     りとして使われます．

     `""' のような空文字は文字のない文字列ですので，どんな文字よりも小さくなりま す．

     `string-equal' は一致するかの確認を行います．別の名は `string=' です．
     >，`>='，`<=' に相当する文字列用の関数はありません．

`message'
     エコー領域にメッセージを表示する。
     第1引数は文字列であり、文字列に続く引数の値を表示するために
     `%s'や`%d'や`%c'を含んでもよい。 `%s'で使う引数は文字列かシンボルであること。
     `%d'で使う引数は数であること。 `%c'で使う引数も数(アスキーコード)であるが、
     その値のASCIIコードの文字として表示される。

`setq'
`set'
     関数`setq'は、第2引数の値を第1引数の値として設定する。
     第1引数は自動的にクオートされる。 連続する2つの引数ごとに同じことを行う。
     もう一方の関数`set'は、2つの引数のみを取り、
     両者を評価してから、第2引数の値を第1引数の値として設定する。

`buffer-name'
     引数はなく、バッファ名を文字列として返す。

`buffer-file-name'
     引数はなく、バッファが訪問しているファイル名を返す。

`current-buffer'
     Emacsが操作対象としているバッファを返す。
     このバッファが画面に表示されているとは限らない。

`other-buffer'
     （`other-buffer'に引数として渡したバッファやカレントバッファ以外の）
     もっとも最近に選択していたバッファを返す。

`switch-to-buffer'
     Emacsが操作対象とするバッファを指定し、同時に、
     カレントウィンドウに表示してユーザーが見られるようにする。 通常、`C-x
     b'にバインドされる。

`set-buffer'
     Emacsが操作対象とするバッファを切り替える。 ウィンドウの表示は変更しない。

`buffer-size'
     カレントバッファ内にある文字数を返す。

`point'
     バッファの先頭から現在のカーソル位置までの文字の個数を表す整数を返す。

`point-min'
     カレントバッファで取りえるポイントの最小値を返す。 ナロイングしていない場合には、1である。

`point-max'
     カレントバッファで取りえるポイントの最大値を返す。
     ナロイングしていない場合には、バッファの最後である。


File: emacs-lisp-intro-ja.info,  Node: defun Exercises,  Prev: Review,  Up: Writing Defuns

3.12 演習問題
=============

   * 数である引数の値を2倍する非対話的な関数を書いてみよ。 さらにこの関数を対話的にしてみよ。

   * `fill-column'の現在の値が関数に渡した引数より大きいかどうか調べ、
     そうならば適切なメッセージを表示するような関数を書いてみよ。


File: emacs-lisp-intro-ja.info,  Node: Buffer Walk Through,  Next: More Complex,  Prev: Writing Defuns,  Up: Top

4 バッファ関連の関数 _(2004/08/05)_
***********************************

本章では、GNU Emacsで使われている数個の関数を詳しく調べよう。
つまり「ウォークスルー」をしてみよう。
これらの関数はLispコードの例題として取り上げたが、仮想的な例題ではない。
最初の簡略した関数定義を除いて、GNU Emacsで実際に使っているコードである。
これらの定義から多くのことを学べるはずである。
ここで説明する関数は、すべて、バッファに関連するものである。
それ以外の関数についてはのちほど説明する。

* Menu:

* Finding More::                How to find more information.
* simplified-beginning-of-buffer::  Shows `goto-char',
                                `point-min', and `push-mark'.
* mark-whole-buffer::           Almost the same as `beginning-of-buffer'.
* append-to-buffer::            Uses `save-excursion' and
                                `insert-buffer-substring'.
* Buffer Related Review::       Review.
* Buffer Exercises::


File: emacs-lisp-intro-ja.info,  Node: Finding More,  Next: simplified-beginning-of-buffer,  Prev: Buffer Walk Through,  Up: Buffer Walk Through

4.1 詳しい情報を得る _(2004/08/04)_
===================================

このウォークスルーでは、個々の新しい関数を、あるときは詳しく、
あるときはその概要を説明する。 Emacs Lisp関数に興味を持ったときには、 `C-h
f'に続けて関数名（と<RET>）を入力すれば、 いつでもその関数の説明文を得られる。
同様に、変数の説明文が必要な場合には、`C-h v'に続けて 変数名（と<RET>）を入力すればよい。

   バージョン20以上では， Emacs Lisp で書かれた関数は `describe-function' で定
義箇所を探すことができます．ファイル名の上にカーソルを置き，<RET> を入力する
と，`help-follow' が実行され，Emacs で直接定義箇所へ移動することができます．

   もっと一般的に、関数のソースファイルを見るには、関数`find-tags'を使います。
`find-tags' はCやLisp だけでなく，プログラミング言語ではないテキスト(TeXな
ど)まで，非常に多くの言語で利用できます．例えば，`find-tags'はTexinfoのソー
スファイルでさまざまなノードに簡単に移動することができます．

   関数 `find-tags' の動作は`find-tags' で移動するための関数や変数，他の
アイテムを記録した「タグテーブル」に依存します．

   `find-tags' を使うためには，`M-.'（つまり、<META>と同時にピリオドキーを押すか、
<ESC>キーに続けてピリオドキー）をタイプし、
`mark-whole-buffer'のようなソースコードを見たい関数の名前を
プロンプトに対して入力し、<RET>をタイプする。
Emacsはソースコードのバッファに切り替えて画面に表示する。 もとのバッファに戻るには`C-x b
<RET>'とタイプする(キーボードによっては <META> キーが <ALT>
と表示されているかもしれません)．

   読者のEmacsの初期設定状態に依存して、 `TAGS'と呼ばれる「タグテーブル（tags
table）」のパスを指定する必要もあろう。 例えば，Emacs
のソースファイルに興味があるなら，最も必要となるタグファイルは既に
`/usr/local/share/emacs/' のサブディレクトリに作成されている．
読者が使用するのはディレクトリ`emacs/src'であろうから、 コマンド`M-x
visit-tags-table'を使って、 `/usr/local/share/emacs/21.0.100/lisp/TAGS' や
`/usr/local/src/emacs/lisp/TAGS' のようなパス名を指定する。タグテーブル作成
されていなければ，自身で作成する必要がある．

   特定のディレクトリに `TAGS' ファイルを作成するためには，`M-x cd' コマン
ドを使ってそのディレクトリに切り替えるか，`C-x d' (`dired') でそのディ
レクトリを表示させます．それから，`etags *.el' のようなコマンドをコンパ
イルコマンドで実行します．

     M-x compile RET etags *.el RET

   詳細については *note Create Your Own `TAGS' File: etags. を参照のこと．

   Emacs Lispに慣れてくると、ソースコードを読む際には`find-tags'を多用する
ようになり、独自のタグテーブルを作成するようになるであろう。

   Lispコードを収めたファイルのことを"ライブラリ（libraries）"と呼ぶ。
この用法は、法律図書や技術図書のような特化した図書（ライブラリ）からきている。
各ライブラリ、つまり、ファイルには、 ある特定の目的や動作に関連する関数群を収める。
たとえば、`abbrev.el'は省略入力を、 `help.el'はオンラインヘルプを扱うものである
（ある1つの目的のために複数のライブラリがある場合もある。
たとえば、`rmail...'のファイル群には、 電子メールを読むためのコードが収めてある）。 `GNU
Emacsマニュアル'には、「コマンド`C-h p'により、 キーワードでEmacs
Lispの標準ライブラリを検索できる」のような記述がある。


File: emacs-lisp-intro-ja.info,  Node: simplified-beginning-of-buffer,  Next: mark-whole-buffer,  Prev: Finding More,  Up: Buffer Walk Through

4.2 `beginning-of-buffer'の簡略した定義 _(2004/08/04)_
======================================================

コマンド`beginning-of-buffer'には十分慣れていて理解しやすいであろうから、
この関数から始めよう。 対話的関数として使うと、`beginning-of-buffer'は、
バッファの先頭にカーソルを移動し、それまでカーソルがあった位置にマークを 設定する。
一般には`M-<'にバインドしてある。

   本節では、もっとも多く使われる形式に簡略した関数を説明する。
簡略版の関数は正しく動作するが、複雑なオプションを処理するコードは含まない。
別の節で、完全な関数を説明する （*Note beginning-of-buffer::）。

   コードを調べるまえに、関数定義には何が含まれるかを考えてみよう。 `M-x
beginning-of-buffer'や`M-<'のようなキー列で関数を呼べるように、
関数を対話的にする式を含んでいる必要がある。
バッファのもとの位置にマークを設定するコードが必要である。
バッファの先頭にカーソルを移動するコードも必要である。

   では、簡略版の関数のコード全体を示そう。

     (defun simplified-beginning-of-buffer ()
       "Move point to the beginning of the buffer;
     leave mark at previous position."
       (interactive)
       (push-mark)
       (goto-char (point-min)))

   すべての関数定義と同様に、この定義でもスペシャルフォーム`defun'に
続けて5つの部分がある。

  1. 名前。 ここでは、`simplified-beginning-of-buffer'である。

  2. 引数のリスト。 ここでは、空リスト`()'である。

  3. 説明文の文字列。

  4. 対話的にするための式。

  5. 本体。

この関数定義では、引数リストは空である。 つまり、この関数は引数を必要としない
（関数の完全な定義では、省略可能な引数を取る）。

   `interactive'式は、関数が対話的に使われることをEmacsに伝える。
`simplified-beginning-of-buffer'は引数を必要としないので、
`interactive'に引数はない。

   関数の本体はつぎの2行である。

     (push-mark)
     (goto-char (point-min))

   最初の式は`(push-mark)'である。 Lispインタープリタがこの式を評価すると、
カーソルがどこにあってもその現在位置にマークを設定する。
また、このマークの位置はマークリングに保存される。

   つぎの行は`(goto-char (point-min))'である。
この式はバッファで取りえるポイントの最小位置にカーソルを移動する。
つまり、カーソルの先頭（あるいは、ナロイングしている場合には、 バッファの参照可能な範囲の先頭。
*Note Narrowing & Widening::）に移動する。

   式`(goto-char (point-min))'でカーソルをバッファの先頭に移動するまえに、
コマンド`push-mark'でカーソルの位置にマークを設定する。 そのため、必要ならば、`C-x
C-x'とタイプすればもとの位置に戻れる。

   以上が関数定義のすべてである。

   `goto-char'のような知らない関数に出会ったときには、
コマンド`describe-function'を使えば、何をする関数かを調べることができる。
このコマンドを使うには、`C-h f'に続けて関数名を入力してから <RET>を押す。
コマンド`describe-function'は、関数の説明文字列を
ウィンドウ`*Help*'に表示する。 たとえば、`goto-char'の説明文はつぎのとおりである。

     One arg, a number.  Set point to that number.
     Beginning of buffer is position (point-min),
     end is (point-max).

（`describe-function'のプロンプトには、
カーソル下かそのまえにあるシンボルが取り込まれる。
したがって、関数の上かその直後にカーソルを置いて`C-h f <RET>'とタイプすれば、
入力量を減らせる。）

   `end-of-buffer'の関数定義は、`beginning-of-buffer'と同じように
書けるが、関数の本体には`(goto-char (point-min))'のかわりに `(goto-char
(point-max))'を使う。


File: emacs-lisp-intro-ja.info,  Node: mark-whole-buffer,  Next: append-to-buffer,  Prev: simplified-beginning-of-buffer,  Up: Buffer Walk Through

4.3 `mark-whole-buffer'の定義 _(2004/08/05)_
============================================

関数`mark-whole-buffer'を理解するのは、
関数`simplified-beginning-of-buffer'を理解するのと同じくらい容易である。
ここでは、簡略版ではなく完全な関数を見てみよう。

   関数`beginning-of-buffer'ほどは多用されないが、
関数`mark-whole-buffer'も有用である。 関数`mark-whole-buffer'は、
バッファの先頭にポイントを、バッファの最後にマークを置いて バッファ全体をリージョンとする。
一般には`C-x h'にバインドされる。

* Menu:

* mark-whole-buffer overview::
* Body of mark-whole-buffer::   Only three lines of code.


File: emacs-lisp-intro-ja.info,  Node: mark-whole-buffer overview,  Next: Body of mark-whole-buffer,  Prev: mark-whole-buffer,  Up: mark-whole-buffer

`mark-whole-buffer' の概略
--------------------------

   Emacs 20 では，関数の完全なコードはつぎのとおりである。

     (defun mark-whole-buffer ()
       "Put point at beginning and mark at end of buffer."
       (interactive)
       (push-mark (point))
       (push-mark (point-max))
       (goto-char (point-min)))

   他のすべての関数定義と同様に、関数`mark-whole-buffer'は 関数定義の雛型にあてはまる。
雛型はつぎのとおりである。

     (defun 関尽名 (畏尽ナスト)
       "逝明文..."
       (INTERACTIVE-EXPRESSION...)
       本体...)

   この関数はつぎのように動作する。 関数名は`mark-whole-buffer'である。
空の引数リスト`()'がこれに続き、関数には引数を必要としないことを意味する。
さらに、説明文が続く。

   つぎの行の式`(interactive)'は、関数が対話的に使われることをEmacsに 指示する。
これらの詳細は、前節で述べた関数`simplified-beginning-of-buffer'と 同様である。


File: emacs-lisp-intro-ja.info,  Node: Body of mark-whole-buffer,  Prev: mark-whole-buffer,  Up: mark-whole-buffer

4.3.1 `mark-whole-buffer'の本体 _(2004/08/05)_
----------------------------------------------

関数`mark-whole-buffer'の本体は、つぎの3行である。

     (push-mark (point))
     (push-mark (point-max))
     (goto-char (point-min))

   最初の行は、式`(push-mark (point))'である。

   この行は、関数`simplified-beginning-of-buffer'の本体では
`(push-mark)'と書かれた行とまったく同じことを行う。
いずれの場合も、Lispインタープリタはカーソルの現在位置にマークを設定する。

   なぜ、`mark-whole-buffer'では`(push-mark (point))'と書き、
`beginning-of-buffer'では`(push-mark)'と書いたのかはわからない。
たぶん、コードを書いた人が、`push-mark'の引数を省略でき、
引数がない場合には`push-mark'はポイント位置に自動的にマークを
設定することを知らなかったのではないかと想像する。
あるいは、つぎの行と同じような構造にしたかったのであろう。
いずれにしても、この行により、Emacsはポイントの位置を調べて、 そこにマークを設定する。

   `mark-whole-buffer'のつぎの行は`(push-mark (point-max))'である。
この式は、バッファで取り得るポイントの最大値の位置にマークを設定する。
これはバッファの最後である（バッファをナロイングしている場合には、
バッファの参照可能な部分の最後である。 ナロイングについてより詳しくは *Note Narrowing &
Widening::）。 このマークを設定すると、ポイントに設定されていた直前のマークはなくなるが、
Emacsはその位置を最近の他のマークと同様に記録しておく。 つまり、必要ならば`C-u
C-<SPC>'を2回タイプすれば その位置に戻れるのである。

   Emacs 21 では `(push-mark (point-max)' が以下よりも少し複雑になりました．

     (push-mark (point-max) nil t)

(この式は以前とほとんど同じように動作します．これはバッファ上につけられたマークのう
ちでできる限り高い番号の位置にマークをセットします．しかし，このバージョンでは `push-mark'
には2つの追加の引数があります．`push-mark' の2番目の引数は `nil'
になっています．このことは，マークをセットした際に「Mark set」という
メッセージを表示_すべきである_ということを意味しています．3番目の引数は `t'
になっています．このことは，暫定マークモードがオンであれば， `push-mark'
がマークを有効にすることを意味しています．暫定マークモードは現
在有効になっているリージョンを可視化します．この動作は通常オフになっています)

   関数の最後の行は、`(goto-char (point-min)))'である。
これは`beginning-of-buffer'のときとまったく同じに書いてある。
この式では、カーソルをバッファの最小ポイント
つまり、バッファの先頭（あるいは、バッファの参照可能な部分の先頭）に移動する。
この結果、バッファの先頭にポイントがあり、バッファの最後にマークが設定される。
したがって、バッファ全体がリージョンとなる。


File: emacs-lisp-intro-ja.info,  Node: append-to-buffer,  Next: Buffer Related Review,  Prev: mark-whole-buffer,  Up: Buffer Walk Through

4.4 `append-to-buffer'の定義 _(2004/08/05)_
===========================================

コマンド`append-to-buffer'は、コマンド`mark-whole-buffer'と 同様に単純である。
このコマンドは、カレントバッファのリージョン（つまり、バッファのポイントと
マークのあいだの部分）を指定したバッファにコピーする。

* Menu:

* append-to-buffer overview::
* append interactive::          A two part interactive expression.
* append-to-buffer body::       Incorporates a `let' expression.
* append save-excursion::       How the `save-excursion' works.


File: emacs-lisp-intro-ja.info,  Node: append-to-buffer overview,  Next: append interactive,  Prev: append-to-buffer,  Up: append-to-buffer

`append-to-buffer' の概略
-------------------------

   コマンド`append-to-buffer'は、関数`insert-buffer-substring'を
用いてリージョンをコピーする。 `insert-buffer-substring'の名前からわかるように、
バッファのある部分を構成する文字列、つまり、「部分文字列」を 別のバッファに挿入する。
`append-to-buffer'の大部分は、`insert-buffer-substring'が動作する
ように条件を設定することである。 つまり、テキストを受け取るバッファとコピーすべきリージョンを
設定することである。 つぎは、関数の完全なテキストである。

     (defun append-to-buffer (buffer start end)
       "Append to specified buffer the text of the region.
     It is inserted into that buffer before its point.

     When calling from a program, give three arguments:
     a buffer or the name of one, and two character numbers
     specifying the portion of the current buffer to be copied."
       (interactive "BAppend to buffer: \nr")
       (let ((oldbuf (current-buffer)))
         (save-excursion
           (set-buffer (get-buffer-create buffer))
           (insert-buffer-substring oldbuf start end))))

   この関数は、雛型を埋めたものと考えれば理解できるであろう。

   もっとも外側の雛型は関数定義である。
ここでは、（いくつかの部分を埋めると）つぎのとおりである。

     (defun append-to-buffer (buffer start end)
       "逝明文..."
       (interactive "BAppend to buffer: \nr")
       本体...)

   関数の最初の行には、関数名と3つの引数がある。
引数は、テキストのコピーを受け取るバッファ`buffer'、
カレントバッファのコピーすべきリージョンの 始め`start'と最後`end'である。

   関数のつぎの部分は説明文であるが、これは明白であろう。


File: emacs-lisp-intro-ja.info,  Node: append interactive,  Next: append-to-buffer body,  Prev: append-to-buffer overview,  Up: append-to-buffer

4.4.1 `append-to-buffer'の`interactive'式 _(2004/08/05)_
--------------------------------------------------------

関数`append-to-buffer'は対話的に使われるので、 関数には`interactive'式が必要である
（`interactive'の復習は、 *note Interactive::を参照）。 この式はつぎのように読める。

     (interactive "BAppend to buffer: \nr")

この式では、二重引用符のあいだに引数が、`\n'で区切られて2つある。

   最初の部分は`BAppend to buffer: 'である。
この`B'は、関数にバッファ名を渡すことをEmacsに指示する。
Emacsは、`B'に続く文字列`Append to buffer: 'をミニバッファに
表示してユーザーに名前を問い合わせる。 そして、Emacsは、指定されたバッファを
関数の引数リストの変数`buffer'に束縛する。

   改行`\n'は引数の最初の部分と2番目の部分を区切る。
`\n'に続く`r'は、関数の引数リストのシンボル
`buffer'に続く2つの引数（つまり、`start'と`end'）に
ポイントとマークの値を束縛するようにEmacsに指示する。


File: emacs-lisp-intro-ja.info,  Node: append-to-buffer body,  Next: append save-excursion,  Prev: append interactive,  Up: append-to-buffer

4.4.2 `append-to-buffer'の本体 _(2004/08/05)_
---------------------------------------------

関数`append-to-buffer'の本体は`let'で始まる。

   すでに説明したように（*note let::）、`let'式の目的は、
`let'の本体の内側のみで使う変数を作り初期値を設定することである。
つまり、`let'式の外側で同じ名前の変数があっても、 それらとは混乱しないようにする。

   `let'式の概略を含んだ`append-to-buffer'の雛型を示せば、
関数定義全体にどのように`let'式をあてはめるかがわかるであろう。

     (defun append-to-buffer (buffer start end)
       "逝明文..."
       (interactive "BAppend to buffer: \nr")
       (let ((変尽 値))
             本体...)

   `let'式には3つの要素がある。

  1. シンボル`let'。

  2. 変数リスト。 ここでは、1つの2要素リスト`(VARIABLE VALUE)'。

  3. `let'式の本体。

   関数`append-to-buffer'では、変数リストはつぎのとおりである。

     (oldbuf (current-buffer))

`let'式のこの部分では、式`(current-buffer)'が 返す値を変数`oldbuf'に束縛する。
変数`oldbuf'には、どのバッファを使用していたかやどのバッファからコピーする かを記録する。

   Lispインタープリタが変数リストと`let'式の本体とを区別できるように、
変数リストの要素を括弧で囲む。 そのため、変数リストの2要素リストを括弧で囲むのである。
したがって、つぎのようになる。

     (let ((oldbuf (current-buffer)))
       ... )

`oldbuf'のまえにある2つの括弧のうち、 最初の括弧は変数リストの区切りを表し、
2番目の括弧は2要素リスト`(oldbuf (current-buffer))'の始まりを表す ことに注意してほしい。


File: emacs-lisp-intro-ja.info,  Node: append save-excursion,  Prev: append-to-buffer body,  Up: append-to-buffer

4.4.3 `append-to-buffer'の`save-excursion' _(2004/08/05)_
---------------------------------------------------------

`append-to-buffer'の`let'式の本体は、 `save-excursion'式から成っている。

   関数`save-excursion'は、ポイントとマークの位置を記録し、
`save-excursion'の本体の式の実行を完了すると これらの位置を復元する。
さらに、`save-excursion'はもとのバッファも記録しておき復元する。
`append-to-buffer'ではこのように`save-excursion'を使う。

   複数行にまたがるリストは、最初のシンボル以外は最初のシンボルよりも
字下げして書き、Lisp関数もこのように書く。
この関数定義では、つぎに示すように、`let'は`defun'よりも字下げし、
`save-excursion'は`let'よりも字下げする。

     (defun ...
       ...
       ...
       (let...
         (save-excursion
           ...

このような書き方をすると、`save-excursion'の本体の2行が
`save-excursion'の括弧に囲まれていること、
また、`save-excursion'自体も`let'の括弧に囲まれていること がわかりやすくなる。

     (let ((oldbuf (current-buffer)))
       (save-excursion
         (set-buffer (get-buffer-create buffer))
         (insert-buffer-substring oldbuf start end))))

   関数`save-excursion'の使い方は、雛型の項目を埋めていくと考えればよい。

     (save-excursion
       本体の最宿の式
       本体の2番目の式
        ...
       本体の最古の式)

この関数では、`save-excursion'の本体には2つの式があるだけである。
本体はつぎのとおりである。

     (set-buffer (get-buffer-create buffer))
     (insert-buffer-substring oldbuf start end)

   関数`append-to-buffer'を評価すると、
`save-excursion'の本体の2つの式が順番に評価される。
最後の式の値が関数`save-excursion'の値として返される。
これ以外の式は、副作用を起こすためだけに評価される。

   `save-excursion'の本体の最初の行では、
関数`set-buffer'を用いてカレントバッファを`append-to-buffer'の
第1引数で指定したものに切り替える （バッファを切り替えることは副作用である。
まえにも述べたように、Lispでは副作用が主要な目的である）。
2番目の行で、関数の主要な処理を行う。

   関数`set-buffer'は、Emacsの注意をテキストをコピーする先のバッファに向け、
`save-excursion'でもとに戻す。

   この行はつぎのとおりである。

     (set-buffer (get-buffer-create buffer))

   このリストのもっとも内側の式は`(get-buffer-create buffer)'である。
この式では関数`get-buffer-create'を使うが、
この関数は指定した名前のバッファを取得するか、
そのようなバッファが存在しなければその名前でバッファを作成する。
つまり、`append-to-buffer'を使えば、 既存でないバッファにもテキストをコピーできる。

   `get-buffer-create'により、`set-buffer'で不必要なエラーが 発生することを避けている。
`set-buffer'には、切り替え先のバッファが必要である。
存在しないバッファを指定すると、Emacsは失敗する。
`get-buffer-create'は、バッファが存在しなければバッファを作成するので、
`set-buffer'にはつねにバッファが与えられる。

   `append-to-buffer'の最後の行が、テキストの追加操作を行う。

     (insert-buffer-substring oldbuf start end)

関数`insert-buffer-substring'は、第1引数で指定したバッファ_から_
カレントバッファに文字列をコピーする。 ここでは、`insert-buffer-substring'への引数は、
`let'で作成し束縛した変数`oldbuf'の値であり、 その値は、コマンド`append-to-buffer'を
実行したときのカレントバッファである。

   `insert-buffer-substring'の処理が終了すると、
`save-excursion'はもとのバッファに戻し、 `append-to-buffer'が終了する。

   本体の動作の概要はつぎのとおりである。

     (let (`oldbuf'に`current-buffer'の値を束縛する)
       (save-excursion                       ; バッファを記録する
         バッファひ切な替えに
         `oldbuf'の文孜林ひバッファへコピーすに)

       ぢとのバッファへ盟す
     終了すにときに名前`oldbuf'ひ消す

   まとめると、`append-to-buffer'はつぎのように動作する。
変数`oldbuf'にカレントバッファを記録する。
必要ならば作成して新しいバッファを取得し、そのバッファへ切り替える。
`oldbuf'の値を用いて、もとのバッファのリージョンのテキストを 新しいバッファに挿入する。
`save-excursion'を使っているので、もとのバッファに戻る。

   `append-to-buffer'を調べることで、ある程度複雑な関数について 知ることができた。
`let'と`save-excursion'の使い方や、
バッファを切り替えたあとで、もとのバッファに戻す方法がわかったと思う。
多くの関数で、`let'、`save-excursion'、`set-buffer' をこのように使う。


File: emacs-lisp-intro-ja.info,  Node: Buffer Related Review,  Next: Buffer Exercises,  Prev: append-to-buffer,  Up: Buffer Walk Through

4.5 復　習 _(2004/08/05)_
=========================

本章で説明したさまざまな関数の概要をまとめておく。

`describe-function'
`describe-variable'
     関数や変数の説明文を表示する。 慣習的に、`C-h f'と`C-h v'にバインドされる。

`find-tag'
     関数や変数を含むソースファイルを探し、そのファイルのバッファに切り替え、
     その関数や変数の先頭にポイントを移動する。
     慣習的に、`M-.'（つまり、<META>キーに続けてピリオド） にバインドされる。

`save-excursion'
     ポイントとマークの位置を記録し、`save-excursion'の引数を評価し終えたら、
     もとの値に戻す。 カレントバッファも記録しておき、終了後にもとに戻す。

`push-mark'
     指定位置にマークを設定し、設定前のマークの値をマークリングに保存する。
     マークはバッファ内の位置であり、バッファにテキストが追加されても
     削除されても、その相対的な位置を保持する。

`goto-char'
     引数で指定した位置にポイントを移動する。
     引数は、数、マーク、`(point-min)'のような位置を返す式のいずれかである。

`insert-buffer-substring'
     引数として関数に渡されたバッファのリージョンのテキストのコピーを
     カレントバッファに挿入する。

`mark-whole-buffer'
     バッファ全体をリージョンとする。 通常、`C-x h'にバインドされる。

`set-buffer'
     Emacsの注意を別のバッファに向けるが、ウィンドウへの表示は変えない。
     プログラムで別のバッファを操作するときに使う。

`get-buffer-create'
`get-buffer'
     指定した名前のバッファを探し、存在しなければその名前のバッファを作成する。
     関数`get-buffer'は、指定した名前のバッファが 存在しなければ`nil'を返す。


File: emacs-lisp-intro-ja.info,  Node: Buffer Exercises,  Prev: Buffer Related Review,  Up: Buffer Walk Through

4.6 演習問題
============

   * 読者独自の`simplified-end-of-buffer'の関数定義を書き、動作を確認せよ。

   * バッファが既存かどうかのメッセージを表示する関数を
     `if'と`get-buffer'を用いて書け。

   * `find-tag'を用いて、関数`copy-to-buffer'のソースを探してみよ。


File: emacs-lisp-intro-ja.info,  Node: More Complex,  Next: Narrowing & Widening,  Prev: Buffer Walk Through,  Up: Top

5 多少複雑な関数 _(2004/08/05)_
*******************************

本章では、前章で学んだことをもとに、多少複雑な関数を見てみよう。
関数`copy-to-buffer'では、1つの定義内で式`save-excursion'を
2つ使う方法を、関数`insert-buffer'では、
`interactive'式でのアスタリスクの使い方と`or'の使い方を、
名前と名前が参照するオブジェクトとの重要な違いを示す。

* Menu:

* copy-to-buffer::              With `set-buffer', `get-buffer-create'.
* insert-buffer::               Read-only, and with `or'.
* beginning-of-buffer::         Shows `goto-char',
                                `point-min', and `push-mark'.
* Second Buffer Related Review::
* optional Exercise::


File: emacs-lisp-intro-ja.info,  Node: copy-to-buffer,  Next: insert-buffer,  Prev: More Complex,  Up: More Complex

5.1 `copy-to-buffer'の定義 _(2004/08/05)_
=========================================

`append-to-buffer'の動作を理解していれば、 `copy-to-buffer'を理解するのは容易である。
この関数はテキストをバッファにコピーするが、
指定したバッファに追加するのではなく、指定バッファの内容を書き換える。
関数`copy-to-buffer'のコードは、`append-to-buffer'のコードと
ほぼ同じであるが、`erase-buffer'ともう1つ`save-excursion'を使う
（`append-to-buffer'の説明は、 *Note append-to-buffer::）。

   `copy-to-buffer'の本体はつぎのとおりである。

     ...
     (interactive "BCopy to buffer: \nr")
       (let ((oldbuf (current-buffer)))
         (save-excursion
           (set-buffer (get-buffer-create buffer))
           (erase-buffer)
           (save-excursion
             (insert-buffer-substring oldbuf start end)))))

   このコードは、`append-to-buffer'のコードとほぼ同じである。
`append-to-buffer'の定義と違いがでるのは、 コピー先のバッファに切り替えたあとである。
関数`copy-to-buffer'では、バッファの既存の内容を削除する （つまり、書き換えるのである。
Emacsでは、テキストを書き換えるには、既存のテキストを削除してから、
新たなテキストを挿入する）。 バッファの既存の内容を削除したあと、
2つめの`save-excursion'を使い、新たなテキストを挿入する。

   なぜ`save-excursion'を2つ使うのだろうか？　 関数の動作を見直してみよう。

   `copy-to-buffer'の本体の概略はつぎのとおりである。

     (let (`oldbuf'に`current-buffer'の値ひ束配すに)
       (save-excursion         ; 最初の`save-excursion'
         バッファひ切な替えに
           (erase-buffer)
           (save-excursion     ; 2つめの`save-excursion'
             `oldbuf'かど不分文孜林ひバッファへ挿曇すに)))

   最初の`save-excursion'で、Emacsは、テキストのコピーもとのバッファに
戻ることができる。 これは`append-to-buffer'での用法と同じであり、明らかであろう。
では、2つめは何のためであろう？　 `insert-buffer-substring'は、つねに、
挿入したリージョンの_最後_にポイントを置く。 2番目の`save-excursion'により、
Emacsは挿入したテキストの先頭にポイントを置くことになる。
多くの場合、ユーザーは、挿入したテキストの先頭にポイントがあることを好む
（もちろん、関数`copy-to-buffer'が完了するともとのバッファに戻る。
しかし、ユーザーがコピー先のバッファに切り替えると、 ポイントはテキストの先頭にある。
つまり、このために2番目の`save-excursion'がある）。


File: emacs-lisp-intro-ja.info,  Node: insert-buffer,  Next: beginning-of-buffer,  Prev: copy-to-buffer,  Up: More Complex

5.2 `insert-buffer'の定義 _(2004/08/05)_
========================================

`insert-buffer'もバッファに関連した関数である。
このコマンドは、別のバッファからカレントバッファへコピーする。
カレントバッファのテキストのリージョンを別のバッファへコピーする
`append-to-buffer'や`copy-to-buffer'とは逆向きである。

   また、このコードでは、"読み出し専用（read-only）"のバッファでの
`interactive'の使い方と、オブジェクトの名前と名前が参照する オブジェクトとの重要な違いを示す。

* Menu:

* insert-buffer code::
* insert-buffer interactive::   When you can read, but not write.
* insert-buffer body::          The body has an `or' and a `let'.
* if & or::                     Using an `if' instead of an `or'.
* Insert or::                   How the `or' expression works.
* Insert let::                  Two `save-excursion' expressions.


File: emacs-lisp-intro-ja.info,  Node: insert-buffer code,  Next: insert-buffer interactive,  Prev: insert-buffer,  Up: insert-buffer

`insert-buffer' のソースコード
------------------------------

   コードはつぎのとおりである。

     (defun insert-buffer (buffer)
       "Insert after point the contents of BUFFER.
     Puts mark after the inserted text.
     BUFFER may be a buffer or a buffer name."
       (interactive "*bInsert buffer: ")
       (or (bufferp buffer)
           (setq buffer (get-buffer buffer)))
       (let (start end newmark)
         (save-excursion
           (save-excursion
             (set-buffer buffer)
             (setq start (point-min) end (point-max)))
           (insert-buffer-substring buffer start end)
           (setq newmark (point)))
         (push-mark newmark)))

   他の関数と同様に、雛型を使って関数の概略を見ることができる。

     (defun insert-buffer (buffer)
       "逝明文..."
       (interactive "*bInsert buffer: ")
       本体...)


File: emacs-lisp-intro-ja.info,  Node: insert-buffer interactive,  Next: insert-buffer body,  Prev: insert-buffer code,  Up: insert-buffer

5.2.1 `insert-buffer'の`interactive'式
--------------------------------------

`insert-buffer'では、`interactive'の引数には、 アスタリスク`*'と`bInsert
buffer: 'の2つの部分がある。

* Menu:

* Read-only buffer::            When a buffer cannot be modified.
* b for interactive::           An existing buffer or else its name.


File: emacs-lisp-intro-ja.info,  Node: Read-only buffer,  Next: b for interactive,  Prev: insert-buffer interactive,  Up: insert-buffer interactive

読み出し専用バッファ
....................

アスタリスクは、読み出し専用バッファ、つまり、 変更できないバッファに対処するためである。
読み出し専用のバッファに`insert-buffer'を使うと、
読み出し専用である旨のメッセージがエコー領域に表示され、 端末のベルが鳴るか点滅する。
カレントバッファには挿入できないのである。
アスタリスクのあとにはつぎの部分との区切りに改行は必要ない。


File: emacs-lisp-intro-ja.info,  Node: b for interactive,  Prev: Read-only buffer,  Up: insert-buffer interactive

`interactive'式の`b'
....................

`interactive'式の引数の2番目の部分は、小文字の`b'で始まっている
（大文字の`B'で始まる`append-to-buffer'のコードと異なる *Note
append-to-buffer::）。 小文字の`b'は、`insert-buffer'の引数は既存のバッファであるか
バッファ名であることをLispインタープリタに指示する
（大文字の`B'では、バッファが存在しない場合も許す）。
Emacsは、デフォルトのバッファを提示してバッファ名を問い合わせ、 名前の補完も行う。
バッファが存在しないと、メッセージ「No match（一致するものがない）」を表示して
端末のベルを鳴らす。


File: emacs-lisp-intro-ja.info,  Node: insert-buffer body,  Next: if & or,  Prev: insert-buffer interactive,  Up: insert-buffer

5.2.2 関数`insert-buffer'の本体 _(2004/08/05)_
----------------------------------------------

関数`insert-buffer'の本体には、2つの主要な部分、 `or'式と`let'式がある。
`or'式の目的は、引数`buffer'がバッファの名前ではなく、
バッファに束縛されていることを保証することである。 `let'式の本体は、
別のバッファからカレントバッファにコピーするコードである。

   関数`insert-buffer'の2つの式の概略はつぎのとおりである。

     (defun insert-buffer (buffer)
       "逝明文..."
       (interactive "*bInsert buffer: ")
       (or ...
           ...
       (let (変尽ナスト)
           `let'の本体... )

   `or'式により、どのようにして引数`buffer'にバッファ名ではなく
バッファが束縛されることが保証されるのかを理解するには、 まず、関数`or'を理解する必要がある。

   そのまえに、関数の最初の部分を`if'で書き換えて、 すでによく知っている方法で考えてみよう。


File: emacs-lisp-intro-ja.info,  Node: if & or,  Next: Insert or,  Prev: insert-buffer body,  Up: insert-buffer

5.2.3 `or'のかわりに`if'を使った`insert-buffer' _(2004/08/05)_
--------------------------------------------------------------

必要なことは、`buffer'の値をバッファ名ではなく バッファそのものとすることである。
値が名前の場合には、対応するバッファそのものを取得する必要がある。

   読者の名前が記された名簿を持って、会議場で受け付け係が読者を探している
場面を想像してほしい。 このとき受け付け係には、読者自身ではなく読者の名前が「束縛」されている。
受け付け係が読者を探しあてて読者の腕をとると、 受け付け係には読者が「束縛」される。

   Lispでは、このような状況をつぎのように書ける。

     (if (not (招待客の腕をとっている))
         (招待客を探し、腕をとる))

   バッファについても同じことをしたいのである。
バッファそのものを取得していなければ、それを取得したいのである。

   （名前ではなく）バッファそのものを持っているかどうかを調べる
述語`bufferp'を用いれば、つぎのようなコードが書ける。

     (if (not (bufferp buffer))              ; 判定条件
         (setq buffer (get-buffer buffer)))  ; 真の場合の動作

ここで、`if'式の判定条件は`(not (bufferp buffer))'であり、
真の場合の動作は、式`(setq buffer (get-buffer buffer))'である。

   判定条件では、引数がバッファならば関数`bufferp'は真を返すが、 引数がバッファ名の場合には偽を返す
（関数名`bufferp'の最後の文字は`p'である。 すでに説明したように、`p'をそのように使うのは、
関数が述語（predicate）であることを意味する慣習である。
また、述語とは、ある性質が真であるか偽であるかを調べる関数であった。 *Note Wrong
Type of Argument::）。

   式`(bufferp buffer)'のまえには関数`not'があり、 判定条件はつぎのとおりである。

     (not (bufferp buffer))

`not'は、引数が偽の場合には真を、真の場合には偽を返す関数である。 したがって、`(bufferp
buffer)'が真ならば`not'式は偽を返し、 偽ならば真を返す。 「not 真」は偽であり、「not
偽」は真である。

   この判定条件を使うと、`if'式はつぎのように動作する。
変数`buffer'の値がバッファ名ではなく実際のバッファであれば、
判定条件は偽となり、`if'式の真の場合の動作は評価されない。
変数`buffer'が実際のバッファであれば何もする必要はないので、 これでよい。

   一方、`buffer'の値がバッファそのものではなくバッファ名の場合には、
判定条件は真を返し、真の場合の動作が評価される。 ここでは、真の場合の動作は`(setq
buffer (get-buffer buffer))'である。
この式では、バッファ名を与えると実際のバッファそのものを 返す関数`get-buffer'を使う。
`setq'により、変数`buffer'にバッファそのものを設定し、 （バッファ名であった）まえの値を置き換える。


File: emacs-lisp-intro-ja.info,  Node: Insert or,  Next: Insert let,  Prev: if & or,  Up: insert-buffer

5.2.4 `or'の本体 _(2004/08/05)_
-------------------------------

関数`insert-buffer'での`or'式の目的は、
引数`buffer'にバッファ名ではなくバッファが束縛されていることを 保証することである。
上の節では、`if'式を用いてこれを行う方法を示したが、
関数`insert-buffer'では実際には`or'を使っている。
これを理解するには、`or'の動作を理解する必要がある。

   関数`or'は、任意個数の引数を取る。
各引数を順番に評価し、`nil'以外の値を返した最初の引数の値を返す。
さらに、`nil'以外の値が初めて返されると、
それよりうしろの引数をいっさい評価しないのも、`or'の重要な機能である。

   `or'式はつぎのようになる。

     (or (bufferp buffer)
         (setq buffer (get-buffer buffer)))

`or'の最初の引数は、式`(bufferp buffer)'である。
この式は、バッファが名前ではなく実際のバッファであるときには 真（`nil'以外の値）を返す。
`or'式では、この場合には`or'式は真の値を返し、 そのつぎの式は評価しない。
`buffer'の値が実際のバッファであれば何もする必要はないので、 これでよい。

   一方、`buffer'の値がバッファ名であると、 `(bufferp buffer)'の値は`nil'であり、
Lispインタープリタは`or'式のつぎの要素を評価する。 つまり、式`(setq buffer (get-buffer
buffer))'を評価する。 この式は、`nil'以外の値、つまり、変数`buffer'に設定した値であり、
バッファ名ではなくバッファそのものである。

   以上の効果をまとめると、シンボル`buffer'には、つねに、
バッファ名ではなくバッファそのものが束縛されるのである。
後続行の関数`set-buffer'はバッファ名ではなくバッファそのものしか
扱えないので、以上の処理が必要なのである。

   なお、`or'を使えば、受け付け係の例はつぎのように書ける。

     (or (招待客の腕をとっている) (招待客を探し腕をとる))


File: emacs-lisp-intro-ja.info,  Node: Insert let,  Prev: Insert or,  Up: insert-buffer

5.2.5 `insert-buffer'の`let'式 _(2004/08/05)_
---------------------------------------------

変数`buffer'がバッファ名ではなくバッファそのものを参照することを
保証したあと、関数`insert-buffer'は`let'式に進む。
ここには、3つのローカル変数、`start'、`end'、`newmark'があり、
それぞれを初期値`nil'に束縛する。 これらの変数は`let'内部の残りの部分で使われ、
`let'が終わるまでEmacsの同じ名前の変数の出現を一時的に隠す。

   `let'の本体には2つの`save-excursion'がある。
まず、内側の`save-excursion'を詳しく見てみよう。 その式はつぎのとおりである。

     (save-excursion
       (set-buffer buffer)
       (setq start (point-min) end (point-max)))

式`(set-buffer buffer)'は、Emacsの注意をカレントバッファから
テキストのコピーもとのバッファに向ける。
そのバッファにて、コマンド`point-min'と`point-max'を用いて
バッファの先頭と最後を変数`start'と`end'に設定する。
ここでは、`setq'により、1つの式で2つの変数に値を設定する方法も 示している。
`setq'の最初の引数には第2引数の値が、第3引数には第4引数の値が設定される。

   内側の`save-excursion'の本体を終了すると、
`save-excursion'はもとのバッファに戻すが、 `start'と`end'には、
テキストのコピーもとのバッファの先頭と最後の値が設定されたままである。

   外側の`save-excursion'式の概要はつぎのとおりである。

     (save-excursion
       (涜側の式`save-excursion'
          (新しいバッファに切な替え`start'と`end'ひ設鎚)
       (insert-buffer-substring buffer start end)
       (setq newmark (point)))

関数`insert-buffer-substring'は、
バッファ`buffer'の始め`start'から終わり`end'までのリージョンの
テキストをカレントバッファにコピーする。
`start'と`end'のあいだは2番目のバッファ全体であるので、
2番目のバッファ全体が読者が編集しているバッファにコピーされる。
続いて、挿入したテキストの最後にあるポイントを変数`newmark'に記録する。

   外側の`save-excursion'の本体を評価し終えると、
ポイントとマークはもとの位置に戻される。

   しかし、新たに挿入したテキストの最後にマークを、先頭にポイントを設定
しておくと便利である。 変数`newmark'は挿入したテキストの最後を記録している。
`let'式の最後の行の式`(push-mark newmark)'で、 このようにマークを設定する
（そのまえのマークの位置も参照できる。 つまりマークリングに記録されているので、`C-u
C-<SPC>'で戻れる）。 一方、ポイントは挿入したテキストの先頭にあり、
挿入する関数を呼ぶまえの位置のままである。

   `let'式全体はつぎのとおりである。

     (let (start end newmark)
       (save-excursion
         (save-excursion
           (set-buffer buffer)
           (setq start (point-min) end (point-max)))
         (insert-buffer-substring buffer start end)
         (setq newmark (point)))
       (push-mark newmark))

   関数`append-to-buffer'と同様に、関数`insert-buffer'は、
`let'と`save-excursion'と`set-buffer'を使っている。
さらに、この関数では`or'の1つの使い方を示した。
これらのすべての関数は、何度も何度も使う構成部品である。


File: emacs-lisp-intro-ja.info,  Node: beginning-of-buffer,  Next: Second Buffer Related Review,  Prev: insert-buffer,  Up: More Complex

5.3 `beginning-of-buffer'の完全な定義 _(2004/08/05)_
====================================================

関数`beginning-of-buffer'の基本的な構造はすでに説明した （*Note
simplified-beginning-of-buffer::）。

   まえに説明したように、引数なしで`beginning-of-buffer'を起動すると、
カーソルをバッファの先頭に移動し、マークを移動前の位置に設定する。
ところが、1〜10までの数nを指定して起動すると、 関数はその数をバッファ長を単位としたn/10と解釈し、
Emacsはバッファの先頭からn/10の位置にカーソルを移動する。
したがって、この関数を`M-<'で呼べばバッファの先頭にカーソルを移動するし、 `C-u
7M-<'で呼べばバッファの70%のところにカーソルを移動する。
引数に10より大きな数を使うと、バッファの最後にカーソルを移動する。

   関数`beginning-of-buffer'は、引数を指定しても、しなくても呼べる。
つまり、引数は省略できる。

* Menu:

* Optional Arguments::
* beginning-of-buffer opt arg::  Example with optional argument.
* beginning-of-buffer complete::


File: emacs-lisp-intro-ja.info,  Node: Optional Arguments,  Next: beginning-of-buffer opt arg,  Prev: beginning-of-buffer,  Up: beginning-of-buffer

5.3.1 オプションの引数 _(2004/08/05)_
-------------------------------------

特に指定しない限り、Lispは、関数定義で引数を指定した関数は、
引数に渡す値とともに呼ばれることを期待する。 そうでないと、`Wrong number of
arguments'のエラーメッセージを得る。

   しかし、オプション引数の機能がLispにはある。
引数を省略できることを"キーワード（keyword）"で Lispインタープリタに指示する。
そのキーワードは`&optional'である （`optional'の直前の`&'もキーワードの一部である）。
関数定義において、キーワード`&optional'のあとに続く引数には、
関数を呼び出すときにその引数に値が渡されなくてもよい。

   したがって、`beginning-of-buffer'の関数定義の最初の行はつぎのようになる。

     (defun beginning-of-buffer (&optional arg)

   関数全体の概略はつぎのとおりである。

     (defun beginning-of-buffer (&optional arg)
       "逝明文..."
       (interactive "P")
       (push-mark)
         (畏尽があぬば
             移動脆の位置ひ計算すに
           ぢなけぬば、
           (point-min))))

   この関数は、`simplified-beginning-of-buffer'に似ているが、
`interactive'式には引数として`"P"'があり、
関数`goto-char'に続けて、引数が指定された場合に
移動先を計算する`if'式がある点が異なる。

   `interactive'式の`"P"'は、前置引数がある場合にはそれを
関数に渡すことをEmacsに指示する。 前置引数は、<META>キーに続けて数をタイプするか、
`C-u'をタイプしてから数をタイプする （数をタイプしないと、`C-u'のデフォルトは4である）。

   `if'式の判定条件は単純で、単に引数`arg'である。 `arg'に`nil'以外の値があるのは、
引数を指定して`beginning-of-buffer'が呼ばれた場合であり、
`if'式の真の場合の動作を評価する。 一方、引数なしで`beginning-of-buffer'を呼ぶと、
`arg'の値は`nil'となり`if'式の偽の場合の動作が評価される。
偽の場合の動作は単純であり、`point-min'である。
このように評価される場合は、`goto-char'式全体は `(goto-char (point-min))'となり、
関数`beginning-of-buffer'の簡略な場合と同じである。


File: emacs-lisp-intro-ja.info,  Node: beginning-of-buffer opt arg,  Next: beginning-of-buffer complete,  Prev: Optional Arguments,  Up: beginning-of-buffer

5.3.2 引数を指定した`beginning-of-buffer' _(2004/08/05)_
--------------------------------------------------------

引数を指定して`beginning-of-buffer'を呼ぶと、
`goto-char'に渡す値を計算する式が評価される。 この式は、一見、複雑なように見える。
これには、内側に`if'式や多くの算術演算がある。 つぎのとおりである。

     (if (> (buffer-size) 10000)
         ;; バッファサイズが大きな場合の桁溢れを防ぐ!
         (* (prefix-numeric-value arg) (/ (buffer-size) 10))
       (/
        (+ 10
           (*
            (buffer-size) (prefix-numeric-value arg))) 10))

* Menu:

* Disentangle beginning-of-buffer::
* Large buffer case::
* Small buffer case::


File: emacs-lisp-intro-ja.info,  Node: Disentangle beginning-of-buffer,  Next: Large buffer case,  Prev: beginning-of-buffer opt arg,  Up: beginning-of-buffer opt arg

Disentangle `beginning-of-buffer'
.................................

   複雑に見える他の式や`beginning-of-buffer'内の条件式などと同様に、この式も雛
型に当てはめてみると分かりやすくなる。 ここでは`if'式の雛型を使う。
この式の骨格はつぎのようになる。

     (if (バッファが打きい
         バッファイズひ10で劃ってかど、畏尽ひ掛けに
       ぢなけぬば、別の計算保法

   内側の`if'式の判定条件では、バッファサイズを調べる。 古いEmacs
Lispの第18版では、（大きな数は必要ないので）8百万を超える数は扱えず、
バッファが大きな場合にEmacsがこの制限を超えるような数を
計算する可能性があるので、このような検査をしていた。
注釈中の「桁溢れ（overflow）」は、数が大きすぎることを意味する。Emacs 21 では大
きな数を使えるが，このコードは変更されていない．以前よりもずっと大きなバッファを
見るようになってきたためだ．

   バッファが大きい場合とそうでない場合の2つの場合がある。


File: emacs-lisp-intro-ja.info,  Node: Large buffer case,  Next: Small buffer case,  Prev: Disentangle beginning-of-buffer,  Up: beginning-of-buffer opt arg

大きなバッファでの動作
......................

`beginning-of-buffer'では、内側の`if'式で
バッファサイズが10000文字より大きいかどうかを検査する。
これには関数`>'と関数`buffer-size'を使う。

   つぎのとおりである。

     (if (> (buffer-size) 10000)

バッファが大きな場合、`if'式の真の場合の動作が評価される。
（読みやすいように整形すると）その行はつぎのようになる。

     (*
       (prefix-numeric-value arg)
       (/ (buffer-size) 10))

この式は乗算であり、関数`*'には2つの引数を渡す。

   第1引数は`(prefix-numeric-value arg)'である。
`interactive'の引数に`"P"'を使うと、
関数に引数として渡される値は数ではなく、「生の前置引数（raw prefix argument）」
である（数のリスト）。 数値演算を施すには、変換する必要があり、
それには`prefix-numeric-value'を使えばよい。

   第2引数は`(/ (buffer-size) 10)'である。
この式は、バッファの大きさの数を10で割る。
これにより、バッファサイズの1/10に相当する文字数が得られる
（Lispでは、`*'を乗算に使うように、`/'を除算に使う）。

   乗算の式全体では、この値に引数の値を掛ける。 乗算はつぎのようになる。

     (* 前置畏尽の値
        バッファの文孜尽の1/10)

たとえば、前置引数が`7'ならば、1/10に相当する値に7を掛け、 バッファの70%の位置になる。

   つまり、バッファが大きな場合には、以上の結果から、 `goto-char'式はつぎのようになる。

     (goto-char (* (prefix-numeric-value arg)
                   (/ (buffer-size) 10)))

   これにより、望みの位置にカーソルが移動する。


File: emacs-lisp-intro-ja.info,  Node: Small buffer case,  Prev: Large buffer case,  Up: beginning-of-buffer opt arg

小さなバッファでの動作
......................

バッファが10000文字未満の場合には、少々異なる計算を行う。
最初の計算方法で十分であり、このようなことは不要と考える読者もいよう。
しかし、小さなバッファでは、最初の計算方法では、目的の行に正しく
カーソルを移動できず、2番目の計算方法のほうがよい。

   コードはつぎのとおりである。

     (/ (+ 10 (* (buffer-size) (prefix-numeric-value arg))) 10))

このコードでは、関数がどのように括弧の中に入れ子になっているかがわかれば、
何が起こるかを理解できる。 入れ子になった式をより深く字下げして整形すると読みやすくなる。

       (/
        (+ 10
           (*
            (buffer-size)
            (prefix-numeric-value arg)))
        10))

括弧をよく見ると、もっとも内側の演算は`(prefix-numeric-value arg)'であり、
生の引数を数に変換する。 つぎの式で、この数にバッファサイズを掛ける。

     (* (buffer-size) (prefix-numeric-value arg)

この乗算により、バッファのサイズよりも大きな数を得る。
たとえば、引数が7ならば、7倍大きい。
この数に10を加えてから10で割り、バッファの目的の位置より1だけ大きな数を得る。

   この計算結果を`goto-char'に渡してカーソルを移動する。


File: emacs-lisp-intro-ja.info,  Node: beginning-of-buffer complete,  Prev: beginning-of-buffer opt arg,  Up: beginning-of-buffer

5.3.3 `beginning-of-buffer'の完全なコード _(2004/08/05)_
--------------------------------------------------------

関数`beginning-of-buffer'の完全なテキストをつぎに示す。

     (defun beginning-of-buffer (&optional arg)
       "Move point to the beginning of the buffer;
     leave mark at previous position.
     With arg N, put point N/10 of the way
     from the true beginning.
     Don't use this in Lisp programs!
     \(goto-char (point-min)) is faster
     and does not set the mark."
       (interactive "P")
       (push-mark)
       (goto-char
        (if arg
            (if (> (buffer-size) 10000)
                ;; Avoid overflow for large buffer sizes!
                (* (prefix-numeric-value arg)
                   (/ (buffer-size) 10))
              (/ (+ 10 (* (buffer-size)
                          (prefix-numeric-value arg)))
                 10))
          (point-min)))
       (if arg (forward-line 1)))

2つの小さな点を除いて、この関数はまえに述べたような動作をする。
最初の点は、説明文字列に関する部分であり、 第2の点は関数の最後の行である。

   説明文字列では、つぎの式を参照している。

     \(goto-char (point-min))

この式の最初の括弧のまえには`\'がある。 この`\'は、シンボリック式として評価するのではなく
説明文として式を表示するようにLispインタープリタに指示する。

   コマンド`beginning-of-buffer'の最後の行は、
引数を指定してコマンドを起動した場合に、ポイントを次行の先頭に移動する。

     (if arg (forward-line 1)))

これにより、バッファの適切なn/10の位置の直後の行の先頭にカーソルを置く。
これは、すくなくともバッファの指定されたn/10の位置にカーソルを位置決めして
見栄えをよくするためのもので、必要ないことかもしれないが、 こうしないと不満のもとになる。


File: emacs-lisp-intro-ja.info,  Node: Second Buffer Related Review,  Next: optional Exercise,  Prev: beginning-of-buffer,  Up: More Complex

5.4 復　習 _(2004/08/05)_
=========================

本章で説明したことがらをまとめておく。

`or'
     各引数を順番に評価し、`nil'以外の値を返した最初の値を返す。
     `nil'以外の値を返すものがなければ、`nil'を返す。 つまり、引数の最初の真の値を返す。
     1つでも真のものがあれば、真の値を返す。

`and'
     各引数を順番に評価し、すべてが`nil'ならば`nil'を返す。
     `nil'でないものがなければ、最後の引数の値を返す。 つまり、すべての引数が真ならば真の値を返す。

`&optional'
     関数定義に引数を省略できることを表すキーワード。
     つまり、必要ならば、引数を与えなくても関数を評価できる。

`prefix-numeric-value'
     `(interactive "P")'で得た「生の前置引数」を数値に変換する。

`forward-line'
     ポイントをつぎの行の先頭に移動する。
     1より大きな引数を与えた場合には、その行数だけポイントを進める。
     ポイントを指定量だけ進められない場合には、
     `forward-line'は可能なだけ進めて、指定量に満たない行数を返す。

`erase-buffer'
     カレントバッファの全内容を削除する。

`bufferp'
     引数がバッファなら`t'を、さもなければ`nil'を返す。


File: emacs-lisp-intro-ja.info,  Node: optional Exercise,  Prev: Second Buffer Related Review,  Up: More Complex

5.5 `optional'引数の演習問題
============================

省略できる引数に指定した数が`fill-column'の値に比べて
大きいか小さいかをメッセージに表示する対話的関数を書いてみよ。
ただし、関数に引数を渡されなかった場合のデフォルトは56とする。


File: emacs-lisp-intro-ja.info,  Node: Narrowing & Widening,  Next: car cdr & cons,  Prev: More Complex,  Up: Top

6 ナロイングとワイドニング _(2004/08/07)_
*****************************************

ナロイングとは、バッファの特定部分に集中して残りの部分を
不用意に変更しないようにするEmacsの機能である。
初心者に混乱を与えないように、ナロイングは、通常、無効にしてある。

* Menu:

* Narrowing advantages::        The advantages of narrowing
* save-restriction::            The `save-restriction' special form.
* what-line::                   The number of the line that point is on.
* narrow Exercise::


File: emacs-lisp-intro-ja.info,  Node: Narrowing advantages,  Next: save-restriction,  Prev: Narrowing & Widening,  Up: Narrowing & Widening

ナローイングの利点
==================

   ナロイングすると、バッファの残りの部分は存在しないかのように見えなくなる。
たとえば、バッファのある部分のみで単語を置き換えるような場合には、 利点となる。
望みの範囲にナロイングすれば、その部分だけで置き換えを行える。
文字列検索もその範囲内のみで行えるので、
たとえば、文書のある部分を編集する場合、編集範囲にナロイングしておけば
それ以外の範囲の文字列を拾うことがない。 (`narrow-to-region' のキーバインドは `C-x
n n' である)

   しかし、ナロイングするとバッファの残りの部分が見えなくなるため、
偶然にナロイングしてしまうとファイルのその部分を削除してしまったと思うような 読者を怯えさせる。
さらに、（通常`C-x u'にバインドされる）コマンド`undo'でも、
ナロイングを無効にしない（また、そうすべきでもない）ので、
コマンド`widen'によりバッファの残りの部分が見えるようになることを
知らない人は絶望することになる （`widen'は`C-x w'にバインドしてある）。

   ナロイングは人間にとってと同様にLispインタープリタにとっても有用である。 Emacs
Lisp関数は、しばしば、バッファの一部分に働くように設計されている。
逆に、ナロイングしてあるバッファの全体に働く必要があるEmacs Lisp関数もある。
たとえば、関数`what-line'は、ナロイングが有効な場合にはそれを無効にし、
処理を終了するともとのようにナロイングする。
一方で、`what-line'からも呼ばれる関数`count-lines'では、
ナロイングを用いてバッファの操作範囲を限定し、終了するときにもとに戻す。


File: emacs-lisp-intro-ja.info,  Node: save-restriction,  Next: what-line,  Prev: Narrowing advantages,  Up: Narrowing & Widening

6.1 スペシャルフォーム`save-restriction' _(2004/08/07)_
=======================================================

Emacs Lispでは、スペシャルフォーム`save-restriction'を用いて、
設定されているナロイングの範囲を記録できる。 Lispインタープリタが`save-restriction'式に出会うと、
`save-restriction'の本体を実行し、それらがナロイング範囲を 変更した場合にはもとに戻す。
たとえば、バッファをナロイングしてあるときに、`save-restriction'に続く
コードでナロイングを取り除いた場合には、完了後に`save-restriction'は
バッファのナロイングをもとに戻す。 コマンド`what-line'では、
コマンド`save-restriction'の直後にあるコマンド`widen'で
バッファに設定されたナロイングを取り除く。 関数が終了する直前にもとのナロイングが復元される。

   `save-restriction'式の雛型は単純である。

     (save-restriction
       本体... )

`save-restriction'の本体は、1つ以上の式であり、 Lispインタープリタが順番に評価する。

   `save-excursion'と`save-restriction'を続けて使う場合には、
`save-excursion'は外側で使うべきである。
逆順に使うと、`save-excursion'を呼んでEmacsが切り替えたバッファの
ナロイングを記録し損なうことがある。
つまり、`save-excursion'と`save-restriction'とを一緒に使う場合には、 つぎのように書く。

     (save-excursion
       (save-restriction
         本体...))

   状況によっては，`save-excursion' と `save-restriction' のスペ
シャルフォームを一緒に書かずに，適切な順番で書かなければなりません．

   例を示します．

       (save-restriction
         (widen)
         (save-excursion
         BODY...))


File: emacs-lisp-intro-ja.info,  Node: what-line,  Next: narrow Exercise,  Prev: save-restriction,  Up: Narrowing & Widening

6.2 `what-line' _(2004/08/07)_
==============================

コマンド`what-line'は、カーソルが位置する行の行数を調べる。
この関数では、コマンド`save-restriction'と`save-excursion'の 使用例を示す。
関数の完全なテキストはつぎのとおりである。

     (defun what-line ()
       "Print the current line number (in the buffer) of point."
       (interactive)
       (save-restriction
         (widen)
         (save-excursion
           (beginning-of-line)
           (message "Line %d"
                    (1+ (count-lines 1 (point)))))))

   関数には、予想どおり、説明文と`interactive'式がある。
続く2つの行では関数`save-restriction'と`widen'を使っている。

   スペシャルフォーム`save-restriction'は、
カレントバッファに設定されているナロイングを記録し、
`save-restriction'の本体のコードを評価したあと、 記録したナロイングを復元する。

   スペシャルフォーム`save-restriction'に続いて、`widen'がある。
この関数は、`what-line'が呼ばれたときにカレントバッファに設定されている ナロイングを無効にする
（このナロイングは`save-restriction'が記録している）。
このワイドニングにより、バッファの先頭から行数を数えられるようになる。
さもないと、参照可能なリージョン内に制限されてしまう。 設定されていたもとのナロイングは、
スペシャルフォーム`save-restriction'を終了する直前に復元される。

   `widen'の呼び出しに続いて、`save-excursion'があり、
カーソル（つまり、ポイント）とマークの位置を記録し、
`save-excursion'の本体のコードでポイントを移動する
関数`beginning-of-line'を呼んだあとにそれらを復元する。

   （式`(widen)'は、`save-restriction'と`save-excursion'のあいだに ある。
2つの`save- ...'式を続けて順に書く場合には、 `save-excursion'を外側にすること。）

   関数`what-line'の最後の2行で、バッファの行数を数えて、 エコー領域にその数を表示する。

     (message "Line %d"
              (1+ (count-lines 1 (point)))))))

   関数`message'はEmacsの画面の最下行に1行のメッセージを表示する。
第1引数は二重引用符のあいだにあり、文字列として表示される。
ただし、この文字列には、これに続く引数を表示するための
`%d'や`%s'や`%c'が含まれてもよい。 `%d'は、引数を10進数で表示するので、
メッセージは`Line 243'のようになる。

   `%d'のかわりに表示される数は、関数のつぎの行で計算される。

     (1+ (count-lines 1 (point)))

このコードは、`1'で示されるバッファの先頭から`(point)'までの
行数を数え、それに1を加える （関数`1+'は、引数に1を加える）。
1を加えるのは、たとえば、2番目の行のまえには1行しかないからであり、
`count-lines'は現在行の直前までの行数を数える。

   `count-lines'が処理を終了するとエコー領域にメッセージが表示され、
`save-excursion'がポイントとマークの位置をもとに戻す。
さらに、`save-restriction'はもとのナロイングの設定を復元する。


File: emacs-lisp-intro-ja.info,  Node: narrow Exercise,  Prev: what-line,  Up: Narrowing & Widening

6.3 ナロイングの演習問題
========================

バッファの後半にナロイングしていて最初の行を参照できないような場合であっても、
カレントバッファの最初の60文字を表示する関数を書いてみよ。
これには、`save-restriction'、`widen'、`goto-char'、
`point-min'、`buffer-substring'、`message'を始め、
さまざまな関数をポプリのように混ぜ合わせて使う必要がある。


File: emacs-lisp-intro-ja.info,  Node: car cdr & cons,  Next: Cutting & Storing Text,  Prev: Narrowing & Widening,  Up: Top

7 基本関数 `car'、`cdr'、`cons' _(2004/08/07)_
**********************************************

Lispでは、`car'、`cdr'、`cons'は基本関数である。 関数`cons'はリストの作成、
関数`car'と`cdr'はリストの分解に使う。

   関数`copy-region-as-kill'のウォークスルーでは、
`cons'に加えて`cdr'の変形である`setcdr'と`nthcdr'を 見ることになる （*Note
copy-region-as-kill::）。

* Menu:

* Strange Names::               An historical aside: why the strange names?
* car & cdr::                   Functions for extracting part of a list.
* cons::                        Constructing a list.
* nthcdr::                      Calling `cdr' repeatedly.
* nth::
* setcar::                      Changing the first element of a list.
* setcdr::                      Changing the rest of a list.
* cons Exercise::


File: emacs-lisp-intro-ja.info,  Node: Strange Names,  Next: car & cdr,  Prev: car cdr & cons,  Up: car cdr & cons

Strange Names
=============

   関数`cons'の名前は不合理ではなく、 単語「construct（作り上げる）」の省略である。
一方、`car'と`cdr'の名前の由来は、難解である。 `car'は「Contents of the
Address part of the Register」の頭文字であり、 `cdr'（「クダー」と読む）は
「Contents of the Decrement part of the Register」の頭文字である。
これらの語句は、最初のLispが開発された初期のコンピュータの
ハードウェアの一部を指す。 この語句は古くて意味がないばかりでなく、
Lispに関していえば、25年間以上にもわたってこれらの語句は無意味であった。
研究者の一部には、これらの関数に対する合理的な名称を使う人もいるが、
それにもかかわらず、これらの名称は使われ続けている。 特に、これらはEmacs
Lispのソースコードでも使われているので、 本書でもこれにならう。


File: emacs-lisp-intro-ja.info,  Node: car & cdr,  Next: cons,  Prev: Strange Names,  Up: car cdr & cons

7.1 `car'と`cdr' _(2004/08/07)_
===============================

The CAR of a list is, quite simply, the first item in the list.  Thus
the CAR of the list `(rose violet daisy buttercup)' is `rose'.
リストのCARは、簡単にいえば、リストの先頭要素である。 したがって、リスト`(rose violet
daisy buttercup)'のCARは、 `rose'である。

   GNU EmacsのInfoで読んでいる場合には、つぎを評価するとわかる。

     (car '(rose violet daisy buttercup))

式を評価すると、エコー領域に`rose'と表示される。

   明らかに、関数`car'のもっと合理的な名称は`first'であり、
しばしばそのように提案されている。

   `car'は、リストからその先頭要素を取り除くのではない。
先頭要素が何であるかを返すだけである。
リストに`car'を適用したあとでも、リストはそれ以前と同じである。
専門用語では、`car'は「非破壊的（non-destructive）」であるという。
この機能は重要なことがあとでわかる。

   リストのCDRは、リストの残りである。
つまり、関数`cdr'は、リストの最初の要素のあとに続く部分を返す。 したがって、リスト`'(rose
violet daisy buttercup)'のCDRは、 `rose'であるが、`cdr'が返すリストの残りは
`(violet daisy buttercup)'である。

   いつものようにつぎの式を評価すればわかる。

     (cdr '(rose violet daisy buttercup))

これを評価すると、エコー領域には`(violet daisy buttercup)'と表示される。

   `car'と同様に、`cdr'もリストから要素を取り除くことはない。
リストの第2要素以降が何であるかを返すだけである。

   上の例では、花のリストをクオートしていた。
クオートしないと、Lispインタープリタは、関数として`rose'を呼び リストを評価しようとする。
この例では、そのようにはしたくないのである。

   明らかに、関数`cdr'のより合理的な名称は`rest'であろう。

   （つぎのことに注意してほしい：
新しい関数に名前を付けるときには、何をしているかを注意深く考えてほしい。
というのは、予想以上に長期間にわたって使われることもあるからである。
本書で、（`car'や`cdr'のような）これらの名称を使い続けるのは、 Emacs
Lispのソースコードでこれらを使っているからである。
同じ名称を使わないと、読者がコードを読む際に苦労するであろう。
合理的な名称を使えば、あとに続く人々に感謝されるはずである。）

   When `car' and `cdr' are applied to a list made up of symbols, such
as the list `(pine fir oak maple)', the element of the list returned by
the function `car' is the symbol `pine' without any parentheses around
it.  `pine' is the first element in the list.  However, the CDR of the
list is a list itself, `(fir oak maple)', as you can see by evaluating
the following expressions in the usual way: `(pine fir oak
maple)'のようなシンボルだけから成るリストに `car'や`cdr'を適用すると、関数`car'が返す
リストの要素は周りに括弧のないシンボル`pine'である。 `pine'は、リストの先頭要素である。
一方、つぎの式を評価してみるとわかるように、 リストのCDRはリストであり、`(fir oak
maple)'である。

     (car '(pine fir oak maple))

     (cdr '(pine fir oak maple))

   ところが、リストのリストでは、先頭要素は、それ自体、リストである。
`car'はリストの先頭要素をリストとして返す。
たとえば、3つのリスト、肉食獣のリスト、草食獣のリスト、海棲哺乳類のリスト から成るリストを考える。

     (car '((lion tiger cheetah)
            (gazelle antelope zebra)
            (whale dolphin seal)))

この場合、第1要素、つまり、リストのCARは、 肉食獣のリスト`(lion tiger
cheetah)'であり、リストの残りの部分は `((gazelle antelope zebra) (whale dolphin
seal))'である。

     (cdr '((lion tiger cheetah)
            (gazelle antelope zebra)
            (whale dolphin seal)))

   再度指摘するが、`car'と`cdr'は、非破壊的である。
つまり、これらをリストに適用したあとでも、 リストは変更されていないことに注意してほしい。
これらの使い方において、この性質はとても重要である。

   第1章のアトムに関する説明で、Lispにおいては、
「配列などのある種のアトムは分解できるが、 その機構はリストを分解する機構とは異なる。
Lispでは、リストのアトムを分解することはできない」と述べた （*Note Lisp Atoms::）。
関数`car'と`cdr'は、リストを分解するために使い、 Lispにとって基本的であると考えられている。
これらの関数では、 配列を分解したりその一部を参照できないので、配列はアトムと考えられる。
逆に、別の基本関数`cons'はリストを作り上げるが、配列を作ることはできない
（配列は、配列専用の関数で処理する。 *Note Arrays::）。


File: emacs-lisp-intro-ja.info,  Node: cons,  Next: nthcdr,  Prev: car & cdr,  Up: car cdr & cons

7.2 `cons' _(2004/08/07)_
=========================

関数`cons'はリストを作り、`car'と`cdr'の逆操作である。 たとえば、3要素リスト`(fir oak
maple)'から4要素リストを作るのに `cons'を使う。

     (cons 'pine '(fir oak maple))

このリストを評価すると、つぎのリスト

     (pine fir oak maple)

がエコー領域に表示される。
`cons'は、リストの先頭に新たな要素を置く、あるいは、要素をリストに繋ぐ。

* Menu:

* Build a list::
* length::                      How to find the length of a list.


File: emacs-lisp-intro-ja.info,  Node: Build a list,  Next: length,  Prev: cons,  Up: cons

Build a list
------------

   `cons'には繋ぐべきリストが必要である。 (1) 何もないところから始めることはできない。
リストを作るときには、最初は少なくとも空リストを与える必要がある。
花のリストを作る一連の`cons'をつぎに示す。 GNU
EmacsのInfoで読んでいる場合には、いつものように各式を評価できる。
値は「の評価結果は」と読める`=>'のうしろに記しておく。

     (cons 'buttercup ())
          => (buttercup)

     (cons 'daisy '(buttercup))
          => (daisy buttercup)

     (cons 'violet '(daisy buttercup))
          => (violet daisy buttercup)

     (cons 'rose '(violet daisy buttercup))
          => (rose violet daisy buttercup)

最初の例では、空リストを`()'で表し、`buttercup'に空リストが続く リストを作成している。
見ればわかるように、作成したリスト内の空リストは表示されない。
`(buttercup)'とだけ表示される。
空リストには何も含まれないので、空リストをリストの要素としては数えない。 一般に、空リストは見えない。

   2番目の例では、`(cons 'daisy '(buttercup))'により、
`buttercup'のまえに`daisy'を置いて新たに2要素リストを作る。
3番目の例では、`daisy'と`buttercup'のまえに`violet'を置いて 3要素リストを作っている。

   ---------- Footnotes ----------

   (1) ドットペアーを作成するためにアトムと要素を`cons'することも できる。
ここでは、ドットペアーについては 説明しないので、*note Dotted Pair Notation:
(elisp)Dotted Pair Notation.を参照。


File: emacs-lisp-intro-ja.info,  Node: length,  Prev: Build a list,  Up: cons

7.2.1 リストの長さ：`length'
----------------------------

Lisp関数`length'を使うとリスト内の要素の個数を調べることができる。 たとえば、つぎの式、

     (length '(buttercup))
          => 1

     (length '(daisy buttercup))
          => 2

     (length (cons 'violet '(daisy buttercup)))
          => 3

3番目の例では、関数`cons'を用いて3要素リストを作り、
それを関数`length'の引数として渡している。

   空リストの要素数を数える場合にも`length'を使える。

     (length ())
          => 0

予想どおりに、空リストの要素数は0である。

   リスト以外の長さを調べようとするとどうなるであろうか？　
`length'に空リストさえも与えずに引数なしで呼んでみよう。

     (length )

これを評価すると、つぎのエラーメッセージを得る。

     Wrong number of arguments: #<subr length>, 0

これは、関数が予想する引数の個数とは異なる、 0個の引数を受け取ったことを意味する。
この場合は、関数`length'が長さを調べる引数として1個必要である
（リストの要素数がいくつであろうが、 _1つ_のリストは_1つ_の引数である）。

   エラーメッセージの`#<subr length>'の部分は、関数名を表す。
これは特別な記法`#<subr'で書かれており、 関数`length'はEmacs
LispではなくCで書かれた基本操作関数であることを 意味する
（`subr'は、「subroutine（サブルーティン）」の略）。 サブルーティンについてより
詳しくは、*Note What Is a Function?: (elisp)What Is a Function。


File: emacs-lisp-intro-ja.info,  Node: nthcdr,  Next: nth,  Prev: cons,  Up: car cdr & cons

7.3 `nthcdr'
============

関数`nthcdr'は、関数`cdr'に関連しており、 リストのCDRを繰り返し取る。

   リスト`(pine fir oak maple)'のCDRを取ると、 リスト`(fir oak maple)'を得る。
同じことを返された値に適用するとリスト`(oak maple)'を得る
（もちろん、もとのリストにCDRを繰り返し適用しても、
関数はリストを変更しないので、同じ結果を得るだけである。
CDRのCDRのように評価する必要がある）。
これを続けると、最終的には空リストを得ることになるが、 `()'のかわりに`nil'と表示される。

   一連のCDRを繰り返して適用してみよう。 それぞれの結果は、`=>'のうしろに記しておく。

     (cdr '(pine fir oak maple))
          =>(fir oak maple)

     (cdr '(fir oak maple))
          => (oak maple)

     (cdr '(oak maple))
          =>(maple)

     (cdr '(maple))
          => nil

     (cdr 'nil)
          => nil

     (cdr ())
          => nil

   一連のCDRのあいだで値を表示しない場合には、つぎのようにする。

     (cdr (cdr '(pine fir oak maple)))
          => (oak maple)

この例では、Lispインタープリタはもっとも内側のリストを最初に評価する。
もっとも内側のリストはクオートしてあるので、そのままもっとも内側の`cdr'に 渡される。
この`cdr'はリストの2番目以降の要素で構成されたリストを
もっとも外側の`cdr'に渡し、それはもとのリストの3番目以降の要素で 構成されたリストを返す。
この例では、関数`cdr'を繰り返し、もとのリストの先頭と2番目の要素を
除いた要素で構成されたリストを返す。

   関数`nthcdr'は、`cdr'を繰り返し呼んで同じことを行う。
つぎの例では、引数2とリストを関数`nthcdr'に渡し、 先頭と第2要素を除いたリストを得る。
つまり、リストに対して`cdr'を2回繰り返したのと同じである。

     (nthcdr 2 '(pine fir oak maple))
          => (oak maple)

   もとの4要素リストを使って、0、1、5などの数値引数を `nthcdr'に渡すとどうなるかを見てみよう。

     ;; リストはそのまま
     (nthcdr 0 '(pine fir oak maple))
          => (pine fir oak maple)

     ;; 第1要素を除いたコピーを返す
     (nthcdr 1 '(pine fir oak maple))
          => (fir oak maple)

     ;; 最初の3つの要素を除いたリストのコピーを返す
     (nthcdr 3 '(pine fir oak maple))
          => (maple)

     ;; 4つの要素すべてを除いたものを返す
     (nthcdr 4 '(pine fir oak maple))
          => nil

     ;; すべての要素を除いたものを返す
     (nthcdr 5 '(pine fir oak maple))
          => nil


File: emacs-lisp-intro-ja.info,  Node: nth,  Next: setcar,  Prev: nthcdr,  Up: car cdr & cons

7.4 `nth'
=========

`nthcdr' はリストの CDR を繰り返し取ります．`nth' は `nthcdr' により得られた結果の
CAR を取ります．結果として，リ ストの N 番目の要素を返します．

   そういうわけで，速度のことを考えずに C で定義しなければ，`nth' の
定義は下記のようになるだろう．

     (defun nth (n list)
       "Returns the Nth element of LIST.
     N counts from zero.  If LIST is not that long, nil is returned."
       (car (nthcdr n list)))

(もともと，`nth' は `subr.el' で Emacs Lisp により定義されて
いました．しかし，1980年代に C で再定義されました．)

   `nth' はリストの要素を1つ返します．これはとても便利な機能です．

   要素は1からではなく，0から始まります．つまり，リストの最初の要素， CAR
で取り出せるものは 0 番目の要素なのです．これは"0基準"の数え
方であり，しばしば"1基準"であるリストの最初の要素が1番目から始まる数え
方に慣れていると戸惑うことでしょう．

   例を示します．

     (nth 0 '("one" "two" "three"))
         => "one"

     (nth 1 '("one" "two" "three"))
         => "two"

   重要なことは，`nth' は `nthcdr' や `cdr' のようにもとの
リストを変更しないことである．つまり，この関数は非破壊的なのである．こ れは，`setcar' や
`setcdr' とは大きく異なる．


File: emacs-lisp-intro-ja.info,  Node: setcar,  Next: setcdr,  Prev: nth,  Up: car cdr & cons

7.5 `setcar'
============

名前から予想できるように、関数`setcar'や`setcdr'は、
リストの`car'や`cdr'に新しい値を設定する。 もとのリストを変更しない`car'や`cdr'と異なり、
これらはもとのリストを変更する。 実際にその動作を試してみよう。
まず、関数`setcar'から始めよう。

   最初に、リストを作り、関数`setq'を使って変数の値 としてそのリストを設定する。
ここでは動物のリストを作ろう。

     (setq animals '(antelope giraffe lion tiger))

GNU EmacsのInfoで読んでいる場合には、いつものように 式の直後にカーソルを置いて`C-x
C-e'とタイプすれば、この式を評価できる （筆者もこのようにして執筆している。
これは、計算環境にインタープリタがあることの1つの利点である）。

   変数`animals'を評価すると、リスト`(giraffe antelope tiger lion)'に
束縛されていることがわかる。

     animals
          => (antelope giraffe lion tiger)

いいかえれば、変数`animals'はリスト `(antelope giraffe lion tiger)'
を指しているのである。

   つぎに、変数`animals'とクオートしたシンボル`hippopotamus'を
2つの引数として関数`setcar'を評価する。 それには、3要素リスト`(setcar animals
'hippopotamus)'を書いて、 いつものようにそれを評価する。

     (setcar animals 'hippopotamus)

この式を評価してから、変数`animals'を再度評価する。
動物のリストが変化したことがわかるはずである。

     animals
          => (hippopotamus giraffe lion tiger)

The first element on the list, `antelope' is replaced by `hippopotamus'.
リストの先頭要素が`antelope'から`hippopotamus'に変更された。

   つまり、`setcar'は、`cons'のようにはリストに新たな要素を 追加しないことがわかる。
`setcar'は、`giraffe'を`hippopotamus'で置き換え、 リストを_変更_したのである。


File: emacs-lisp-intro-ja.info,  Node: setcdr,  Next: cons Exercise,  Prev: setcar,  Up: car cdr & cons

7.6 `setcdr'
============

関数`setcdr'は関数`setcar'に似ているが、 リストの先頭要素ではなく2番目以降の要素を変更する。

   この動作をみるために、つぎの式を評価して変数に 家畜動物のリストを設定する。

     (setq domesticated-animals '(horse cow sheep goat))

このリストを評価すると、リスト`(horse cow sheep goat)'を得る。

     domesticated-animals
          => (horse cow sheep goat)

   つぎに、リストを値として持つ変数の名前とリストの`cdr'に設定する
リストの2つの引数でSETCDRを評価する。

     (setcdr domesticated-animals '(cat dog))

この式を評価すると、エコー領域にリスト`(cat dog)'と表示される。
これは関数が返した値である。
ここで興味があるのは「副作用」であり、変数`domesticated-animals'を 評価するとわかる。

     domesticated-animals
          => (horse cat dog)

つまり、リストは`(horse cow sheep goat)'から`(horse cat dog)'へと 変更された。
リストのCDRが、`(cow sheep goat)'から `(cat dog)'に変わったのである。


File: emacs-lisp-intro-ja.info,  Node: cons Exercise,  Prev: setcdr,  Up: car cdr & cons

7.7 演習問題
============

`cons'を使った数個の式を評価して、鳥のリストを作ってみよ。
リストにそのリスト自身を`cons'するとどうなるかを調べてみよ。
鳥の4要素リストの先頭要素を魚に置き換えてみよ。
さらに、そのリストの残りの部分を他の魚で置き換えてみよ。


File: emacs-lisp-intro-ja.info,  Node: Cutting & Storing Text,  Next: List Implementation,  Prev: car cdr & cons,  Up: Top

8 テキストのカットと保存 _(2004/08/08)_
***************************************

GNU Emacsで「キル（kill）」コマンドでバッファからテキストをカットする
（切り取る）と、それらはリストに保存され、 「ヤンク（yank）」コマンドで取り出せる。

   （Emacsにおける単語「kill」は、実体の値を破壊_しない_処理を意味するが、
その用法は、歴史的な不運な偶然による。 もっと適切な用語は、キルコマンドの動作からすれば、
「clip（切り取る）」であろう。
バッファからテキストを切り取り、復元可能なように保存するからである。
Emacsのソースのすべての「kill」を「clip」に、
すべての「killed」を「clipped」に置き換えたくなる誘惑にしばしば駆られる。）

* Menu:

* Storing Text::                Text is stored in a list.
* zap-to-char::                 Cutting out text up to a character.
* kill-region::                 Cutting text out of a region.
* Digression into C::           Minor note on C programming language macros.
* defvar::                      How to give a variable an initial value.
* copy-region-as-kill::         A definition for copying text.
* cons & search-fwd Review::
* search Exercises::


File: emacs-lisp-intro-ja.info,  Node: Storing Text,  Next: zap-to-char,  Prev: Cutting & Storing Text,  Up: Cutting & Storing Text

Storing Text in a List
======================

   バッファからテキストを切る取ると、それはリストに保存される。
順に切り取ったテキストは順にリストに保存されるので、 リストはつぎのようになる。

     ("a piece of text" "previous piece")

リストにテキストを追加するには、つぎのように関数`cons'を使う。

     (cons "another piece"
           '("a piece of text" "previous piece"))

この式を評価すると、エコー領域に3要素リストが表示される。

     ("another piece" "a piece of text" "previous piece")

   関数`car'と`nthcdr'を使えば、テキストの望みの断片を取り出せる。
たとえば、つぎのコードでは、 `nthcdr 1 ...'は先頭要素を除いたリストを返し、
`car'はその先頭要素を返す。 つまり、もとのリストの第2要素である。

     (car (nthcdr 1 '("another piece"
                      "a piece of text"
                      "previous piece")))
          => "a piece of text"

   もちろん、Emacsの実際の関数はこれより複雑である。
テキストを切り取り復元するコードは、何番目の要素を指定しようとも、
Emacsがリストの望みの要素を取り出すように書く必要がある。
さらに、リストの最後に達した場合には、何も返さないのではなく、
リストの先頭要素を返すようにすべきである。

   テキストの断片を保持するリストを"キルリング（kill ring）"と呼ぶ。
本章では、キルリングについて説明し、まず、関数`zap-to-char'の動作と
その使い方を説明する。
この関数は、キルリングを操作する関数を起動する関数を使う（呼び出す）。
まずは、裾野を登ることにしよう。

   本章以降では、バッファから切り取ったテキストをどのように取り出すかを説明する。 *Note
Yanking::。


File: emacs-lisp-intro-ja.info,  Node: zap-to-char,  Next: kill-region,  Prev: Storing Text,  Up: Cutting & Storing Text

8.1 `zap-to-char'
=================

関数`zap-to-char'は、GNU Emacsの第19版と第21版ではわずかに変更さ
れた．しかし，`zap-to-char' は他の関数 `kill-region' を呼び
出す．この関数は第21版では大幅に書き換えられた．

   Emacs 19 の `kill-region' は複雑だが，ここでは重要ではないので省 略する．

   Emacs 21 の `kill-region' は Emacs 19 よりも読みやすくなっている．
そして，とても重要なエラーハンドリングという考え方が含まれているので，
ざっと紹介することになるだろう．

   しかし，まずは `zap-to-char' を紹介しよう．

   以下は、第19版での関数の実装の完全なテキストである。

     (defun zap-to-char (arg char)  ; version 19 implementation
       "Kill up to and including ARG'th occurrence of CHAR.
     Goes backward if ARG is negative; error if CHAR not found."
       (interactive "*p\ncZap to char: ")
       (kill-region (point)
                    (progn
                      (search-forward
                       (char-to-string char) nil nil arg)
                      (point))))


File: emacs-lisp-intro-ja.info,  Node: zap-to-char interactive,  Next: zap-to-char body,  Prev: Complete zap-to-char,  Up: zap-to-char

8.1.1 `interactive'式
---------------------

コマンド`zap-to-char'の`interactive'式はつぎのとおりである。

     (interactive "*p\ncZap to char: ")

   `"*p\ncZap to char: "'のように二重引用符に囲まれた引数があり、 3つの部分から成る。
最初の部分はもっとも簡単でアスタリスク`*'であり、
バッファが読み出し専用だった場合にエラーを発生させる。
つまり、読み出し専用バッファで`zap-to-char'を使うと、 テキストを削除できずに、「Buffer
is read-only（バッファは読み出し専用）」という エラーメッセージを受け取り、端末のベルも鳴る。

   第21版ではアスタリスク `*' を持たないように改良されました．第19版
でもこの関数は同じように動作すいます．しかし，読み出し専用バッファから
テキストを削除するのではなく，キルリングに削除されるはずだったテキスト
をコピーするのです．両版で，エラーメッセージが表示されます．

   しかし，第19版の改良では `interactive' の改良の誤りのために読み出
し専用バンファからテキストをコピーします．`interactive' のドキュ
メントによるとアスタリスク `*' は `zap-to-char' がバッファが
読み出し専用の時，何かをしないようにすべきなのです．つまり，関数はテキ
ストをキルリングにコピーすべきではないのです．コピーするのはバグなので す．

   第21版では `interactive' が適切に改良されました．だから，アスタリ スク `*'
は interactive の仕様から削除されなければなりませんでし た．`*'
を挿入し関数定義を評価すると，`zap-to-char' を読み出
し専用バッファで実行することになります．しかし，テキストはコピーできま せん．

   その変更とドキュメントの変更を除くと2つのバージョンにおける `zap-to-char'
の機能は同じです．

   さて，interactive の仕様の説明を続けよう．

   `"*p\ncZap to char: "' の2番目の部分は
`p'である．この部分は改行`\n'で終わる。
`p'は、関数の第1引数には「処理した前置引数（processed prefix）」の
値を渡すことを意味する。 前置引数は、`C-u'に続けて数、あるいは、`M-'と数をタイプして渡す。
引数なしで対話的に関数を呼び出した場合には、この引数には1が渡される。

   `"*p\ncZap to char: "'の3番目の部分は `cZap to char:'である。
この部分では、小文字の`c'により、`interactive'はプロンプトがあり、
引数は文字であることを期待する。 プロンプトは`c'のあとに続く文字列`Zap to char:
'である （コロンのうしろの空白は、見やすくするためである）。

   これらにより、ユーザーに問い合わせて`zap-to-char'へ渡す正しい型の引数を
準備する。


File: emacs-lisp-intro-ja.info,  Node: zap-to-char body,  Next: search-forward,  Prev: zap-to-char interactive,  Up: zap-to-char

8.1.2 `zap-to-char'の本体
-------------------------

関数`zap-to-char'の本体には、
カーソルの現在位置から指定文字を含んだテキストをキル（つまり、削除）する コードがある。
コードの最初の部分はつぎのとおりである。

     (kill-region (point) ...

`(point)'はカーソルの現在位置である。

   コードのつぎの部分は、`progn'を使った式である。
`progn'の本体は、`search-forward'と`point'の呼び出しから成る。

   `search-forward'を説明してからのほうが `progn'の動作を理解しやすいので、
`search-forward'を説明してから`progn'を説明する。


File: emacs-lisp-intro-ja.info,  Node: search-forward,  Next: progn,  Prev: zap-to-char body,  Up: zap-to-char

8.1.3 関数`search-forward'
--------------------------

関数`search-forward'は、`zap-to-char'にて削除する指定文字を 探すために使われる。
この探索に成功すると、`search-forward'は、探索文字列の最後の文字の
直後にポイントを置く （`zap-to-char'では、探索文字列は1文字である）。
逆向きに探索した場合には、探索文字列の最初の文字の直前にポイントを置く。
さらに、`search-forward'は、真として`t'を返す
（したがって、ポイントの移動は「副作用」である）。

   `zap-to-char'では、関数`search-forward'をつぎのように使う。

     (search-forward (char-to-string char) nil nil arg)

   関数`search-forward'は4つの引数を取る。

  1. 第1引数は探す対象となるものであり、 `"z"'のような文字列である必要がある。

     `zap-to-char'に渡される引数は単独の文字である。
     コンピュータの構成方法のために、Lispインタープリタは単独の文字と
     文字列を区別するかもしれない。
     コンピュータ内部では、単独の文字は、1文字の文字列とは異なる電気的な形式となる
     （単独の文字は、コンピュータ内部では、しばしば、ちょうど1バイトで記録される。
     一方、文字列は長かったりするので、コンピュータはそれに対応できる 必要がある）。
     関数`search-forward'は文字列を探すので、
     関数`zap-to-char'が引数として受け取った文字は、
     コンピュータ内部では、ある形式から別の形式に変換する必要がある。
     さもないと、関数`search-forward'は失敗する。
     関数`char-to-string'を使って、この変換を行う。

  2. 第2引数は探索範囲を限定し、バッファ内の位置を指定する。
     この場合、バッファの最後まで探索してよいので、 探索範囲を限定せず、第2引数は`nil'である。

  3. 第3引数は、探索に失敗した場合にどうするかを指定する。
     エラーを通知する（かつ、メッセージを表示する）か、`nil'を返す。
     第3引数に`nil'を指定すると、探索に失敗すると関数はエラーを通知する。

  4. `search-forward'の第4引数は、繰り返し回数、
     つまり、文字列の出現を何回探すかを指定する。
     この引数は省略でき、繰り返し回数を指定しないと1である。
     この引数が負の場合には、逆向きに探索する。

   `search-forward'式の概略はつぎのとおりである。

     (search-forward "索文孜林"
                     索範囲
                     索失敗枝の動採
                     繰な返し禾尽)

   では、`progn'を説明しよう。


File: emacs-lisp-intro-ja.info,  Node: progn,  Next: Summing up zap-to-char,  Prev: search-forward,  Up: zap-to-char

8.1.4 The `progn' Special Form
------------------------------

8.1.5 スペシャルフォーム `progn'
--------------------------------

`progn'は、個々の引数を順番に評価して最後のものの値を返すスペシャ ルフォームである。
最後以外の式は、それらの副作用のためだけに評価される。 それらが返す値は捨てられる。

   `progn'式の雛型はとても簡単である。

     (progn
       本体...)

   `zap-to-char'では、`progn'式は2つのことを行う。 正しい位置にポイントを置くことと、
`kill-region'がどこまでを削除するかがわかるようにポイントの位置を 返すことである。

   `progn'の第1引数は`search-forward'である。
`search-forward'は、文字列を探しあてると 検索文字列の最後の文字の直後にポイントを置く
（ここでは、検索文字列は1文字長である）。
逆向きに検索した場合は、`search-forward'は検索文字列の最初の文字の 直前にポイントを置く。
ポイントの移動は副作用である。

   `progn'の2番目で最後の引数は、式`(point)'である。 この式はポイントの値を返し、
ここでは、`search-forward'が移動した位置である。
`progn'式がこの値を返し、`kill-region'の第2引数として `kill-region'に渡される。


File: emacs-lisp-intro-ja.info,  Node: Summing up zap-to-char,  Prev: progn,  Up: zap-to-char

8.1.6 `zap-to-char'のまとめ
---------------------------

`search-forward'と`progn'の動作がわかったので、
関数`zap-to-char'全体としての動作を理解しよう。

   `kill-region'の第1引数は、コマンド`zap-to-char'を与えたときの
カーソルの位置、つまり、そのときのポイントの値である。
`progn'の中で、探索関数が削除する文字の直後にポイントを移動し、
`point'がその位置の値を返す。 関数`kill-region'は、ポイントの2つの値を組み合わせて、
最初のものをリージョンの始まり、 あとのものをリージョンの終わりと解釈してリージョンを削除する。

   式`search-forward'と`point'を2つ続けて余分な2つの引数として書くと、
2つの引数を取るコマンド`kill-region'は失敗するので、
スペシャルフォーム`progn'が必要なのである。
`progn'式は、`kill-region'に対しては1つの引数となり、
`kill-region'が第2引数に必要とする1つの値を返す。


File: emacs-lisp-intro-ja.info,  Node: kill-region,  Next: Digression into C,  Prev: zap-to-char,  Up: Cutting & Storing Text

8.2 `kill-region' _(2004/08/08)_
================================

関数 `zap-to-char' は関数 `kill-region' を使います．この関数
はリージョンからテキストを切取り，テキストを後で利用できるようにキルリングへコピーします．

   Emacs 21 ではこの関数は `condition-case' と `copy-region-as-kill'
を仕様しています．`condition-case' は 重要なスペシャルフォームです．

   要するに，関数 `kill-region' は `condition-case' を呼び出し
ます．この関数は3つの引数を取ります．この関数では，最初の引数は何もし
ません．2番目の引数は正常に終了した時の処理を含みます．3番目の引数はエ
ラーが生じた時に呼ばれるコードを含みます．

* Menu:

* Complete kill-region::        The function definition.
* condition-case::              Dealing with a problem.
* delete-and-extract-region::   Doing the work.


File: emacs-lisp-intro-ja.info,  Node: Complete kill-region,  Next: condition-case,  Prev: kill-region,  Up: kill-region

`kill-region' の定義
--------------------

   すぐに `condition-case' を知ることになるでしょう．最初に，コメン トを加えた
`kill-region' の完全な定義を見ていきます．

     (defun kill-region (beg end)
       "Kill between point and mark.
     The text is deleted but saved in the kill ring."
       (interactive "r")

       ;; 1. `condition-case' は3つの引数を取ります．
       ;;    最初に引数がここにあるように nil であれば
       ;;    エラーシグナルに関する情報は
       ;;    他の関数で使用されるように保存することをしません．
       (condition-case nil

           ;; 2. 'condition-case' の2番目の引数は
           ;;    正常に終了した時に何をするべきかを知らせます．

           ;;    関数 `delete-and-extract-region' は大抵正常に機能します．
           ;;    もしリージョンの最初と終わりが両方とも同じであれば，
           ;;    変数 `string' は空か nil になるでしょう．
           (let ((string (delete-and-extract-region beg end)))

             ;; `when' は `else-part' を取らない `if' です．
             ;; Emacs は通常 `last-command' の値を
             ;; 前のコマンドの値にします．
             ;; `kill-append' は新しいテキストを古いものに連結します．
             ;; `kill-new' はテキストをキルリングの新しい要素として挿入します．
             (when string
               (if (eq last-command 'kill-region)
                   ;; if true, prepend string
                   (kill-append string (< end beg))
                 (kill-new string)))
             (setq this-command 'kill-region))

         ;; 3. `condition-case' の3番目の引数はエラー時に
         ;;    何をすべきかを指定します．
         ;;    3番目の引数は条件部分と本体部分を含みます．
         ;;    もし条件が合えば (この例では
         ;;    テキストかバッファが読み出し専用であれば)
         ;;    本体部分が実行されます．
         ((buffer-read-only text-read-only) ;; 条件部分
          ;; 一致すれば
          (copy-region-as-kill beg end)
          (if kill-read-only-ok            ;; 大抵この変数は nil である．
              (message "Read only text copied to kill ring")
            ;; そうでなければ，バッファが読み出し専用であるというエラーを
            ;; 表示する
            (barf-if-buffer-read-only)
             ;; そして，どんな場合でもテキストが読み出し専用であることを知
             ;; らせる．
            (signal 'text-read-only (list (current-buffer)))))))


File: emacs-lisp-intro-ja.info,  Node: condition-case,  Next: delete-and-extract-region,  Prev: Complete kill-region,  Up: kill-region

8.2.1 `condition-case' _(2004/08/08)_
-------------------------------------

以前見た (*note Generate an Error Message: Making Errors.) ように， Emacs
Lisp は式を評価して問題が生じた時に，ヘルプを与えます．専門的に
言うと"エラーを知らせる"のです．大抵はコンピュータはプログラムを停止さ
せメッセージを表示します．

   しかし，いくつかのプログラムでは複雑な動作を保証します．単にエラーで停
止すべきではないのです．関数 `kill-region' で，最もありそうなエラ
ーは読み出し専用のテキストをキルしようとして削除できないことです．だか ら，関数
`kill-region' ではこの状況を処理するためのコードを含みま す．このコードは関数
`kill-region' の本体を構成し， `condition-case' の内部にあるのです．

   `condition-case' のテンプレートは以下のようになります．

     (condition-case
       VAR
       BODYFORM
       ERROR-HANDLER...)

   2番目の引数 BODYFORM は簡単です．スペシャルフォームである `condition-case'
は BODYFORM のコードを評価させます．もしエ
ラーが起これば，スペシャルフォームはコードの値を返し，もし何かあれば副
作用を生じさせます．

   簡単に言うと，`condition-case' の BODYFORM 部分はすべてが正
常に機能した時に何が起きるかを決定するのです．

   しかし，もしエラーが起これば，その他の部分の途中で，1つかそれ以上のエ
ラーシグナルを決定し，返します．

   `condition case' の3番目の引数はエラーを処理する部分です．エラー
を処理する部分はCONDITION-NAME と BODY という2つの部分を持
ちます．もし，エラーハンドラーの CONDITION-NAME 部分がエラーによっ
て生じた名前と一致すれば，エラーを処理する BODY 部分が実行されま す．

   予期していると思いますが，エラーハンドラーの CONDITION-NAME 部分
は1つか条件名のリストのどちらかになります．

   `condition-case' 式は1つ以上のエラーハンドラーを含むかもしれませ
ん．エラーが起こった時，最初に適用できるものが実行されます．

   最後に，`condition-case' の最初の引数，VAR は時々，エラーに
関する情報を含む変数になっています．しかし，その引数が nil であれば，
`kill-region' の場合のようにその情報は破棄されます．

   要するに関数 `kill-region' の `condition-case'部分は以下のよ うに動作するのです．

     ぢしエドーがけぬば, このコードが実行ぬに
         しかし, エドーなど, このコードが実行ぬに.


File: emacs-lisp-intro-ja.info,  Node: delete-and-extract-region,  Prev: condition-case,  Up: kill-region

8.2.2 `delete-and-extract-region' _(2004/08/08)_
------------------------------------------------

`condition-case' 式は2つの部分を持ちます．1つ目は正常に動作
すると期待されている部分です．しかし，エラーが生じると，もう一つの部分
が評価されます．

   最初に，`kill-region' のコードを正常に動作するものとして見てみよ
う．これは関数の核心である．このコードは下記のようになる．

     (let ((string (delete-and-extract-region beg end)))
       (when string
         (if (eq last-command 'kill-region)
             (kill-append string (< end beg))
           (kill-new string)))
       (setq this-command 'kill-region))

   新しい関数 `delete-and-extract-region'， `kill-append'，
`kill-new'と新しい変数 `last-command' と `this-command'
があるために複雑に思えます．

   関数 `delete-and-extract-region' は簡単です．これは組込み関数であ
り，リージョンのテキストを削除し，そのテキストを返します．これは実際に
テキストを削除する関数なのです．(そして，不可能であれば，エラーを返し ます)

   この `let' 式で `delete-and-extract-region' が返すテキストは ローカル変数
`string' に保存されます．これはバッファから削除され
たテキストです．(具体的には，変数はポイント位置から切り出されたテキス
トになります．要は変数とは単にテキストの略称なのです．)

   もし変数 `string' がテキストを含むのであれば，そのテキストはキル
リングに追加されます．削除されたテキストが無ければ変数の値は `nil' になります．

   このコードでは変数 `string' がテキストを含むかどうかを `when'
を用いて確認しています．`when' は単にプログラマの利便 性のためだけにあります．`when'
は else 部分のない `if' です． 頭の中で，`when' を
`if'に置き換えるとどうなるか理解できるで しょう．それは Lisp
のインタープリタがしていることです．

   技術的に言うと，`when' は Lisp マクロです．Lisp "macro" は新
しい制御や他の言語機能を実現できる．インタープリタに順に変数を処理する 他の Lisp
式をどのように処理するかを伝えます．この例では，"他の式"とは `if' 式です．Lisp
マクロに関する詳細は *note Macros: (elisp)Macros. を
参照ください．C言語でもマクロがあります．違いはありますが，両者とも便
利なものです．*note `delete-and-extract-region': Digressing into C:
Digression into C. でCマクロを簡単に 見ることができます．

   文字列が内容を含んでいれば，他の条件式が実行されます．これは，then と else
部分を持つ `if' である．

     (if (eq last-command 'kill-region)
         (kill-append string (< end beg))
       (kill-new string)))

   もし前のコマンドが `kill-region' であれば，then 部分が評価されま
す．もしそうでなければ，else 部分が評価されます．

   `last-command' はまだ紹介していないEmacsに標準の変数です．通常は，
関数が実行されると，Emacsは変数 `last-command' に前のコマンドを設 定します．

   この部分の定義では，`if' 式は前のコマンドが `kill-region' だっ
たかどうかを確認しています．もしそうだったら，

     (kill-append string (< end beg))

すぐ前にキルリングに切り出されたテキストに新しく切り出されたテキストの
コピーを連結します．(もし `(< end beg))' 式が真であれば， `kill-append'
は文字列をすぐ前に切り出したテキストの先頭に追加し ます．詳細については*note The
`kill-append' function: kill-append function.を参照ください．)

   もしテキストをヤンクすれば，つまり貼り付けると，一度に両方を得る．こう
して，2つの単語を連続して削除し，ヤンクすると，1度のヤンクを実行するこ
とで，適当な順番で両方の単語を得ることができる．(`(< end beg))'
式は順序が正しくなるようにしているのです．)

   一方で，前のコマンドが `kill-region' でなければ，関数 `kill-new'
が呼ばれ，テキストをキルリングの最新の位置に追加します． そして，変数
`kill-ring-yank-pointer' にその位置を保存します．


File: emacs-lisp-intro-ja.info,  Node: Digression into C,  Next: defvar,  Prev: kill-region,  Up: Cutting & Storing Text

8.3 `delete-and-extract-region': Cへ回り道 _(2004/08/08)_
=========================================================

コマンド`zap-to-char'は関数`kill-region'を使い、
それはさらに`copy-region-as-kill'と`delete-region'と いう2つの関数を使っている。
関数`copy-region-as-kill'はつぎの節で説明するが、
リージョンのコピーをキルリングに保存して取り出せるようにする （*Note
copy-region-as-kill::）。

   関数`delete-region'はリージョンの内容を削除するが、 その内容を戻すことはできない。

   これまでに説明したコードと異なり、`delete-region'はEmacs Lispで 書かかれていない。
Cで書かかれており、GNU Emacsシステムの基本操作関数の1つである。
とても簡単なので、Lispから回り道して、ここで説明することにする。

   Emacsのほとんどの基本操作関数と同様に、`delete-region'は、
Cのマクロ、コードの雛型となるマクロを用いて書かれている。 マクロの最初の部分はつぎのとおりである。

     DEFUN ("delete-and-extract-region", Fdelete_and_extract_region,
            Sdelete_and_extract_region, 2, 2, 0,
       "Delete the text between START and END and return it.")
       (start, end)
          Lisp_Object start, end;
     {
       validate_region (&start, &end);
       return del_range_1 (XINT (start), XINT (end), 1, 1);
     }

   マクロを詳細に踏み込むようなことはしないが，このマクロは単語 `DEFUN'
で開始することが指摘しておこう．この単語 `DEFUN' は Lisp の `defun'
と同じ目的で作られているため，選ばれたものです． `DEFUN'
は括弧の中に7つの部分を取っています．

   * 最初の部分はLispでの関数名であり、ここでは、`delete-and-extract-region'である。

   * The second part is the name of the function in C,
     `Fdelete_and_extract_region'.  By convention, it starts with `F'.
     Since C does not use hyphens in names, underscores are used
     instead.  2番目の部分はCでの関数名であり、`Fdelete_and_extract_region'である。
     慣習的に`F'で始める。 Cでは名前としてハイフンを使えないので、かわりに下線を使う。

   * 3番目の部分は、この関数を内部で使用するための情報を記録した
     Cの構造体の定数の名前である。 これはCでの関数名であるが、`F'のかわりに`S'で始める。

   * 4番目と5番目の部分は、関数が取りえる引数の最小個数と最大個数である。
     この関数は必ず2つの引数を必要とする。

   * 6番目の部分は、Lispで書いた関数の`interactive'の引数とほとんど同じであり、
     文字に続けてプロンプトがあってもよい。Lisp との唯一の違いはマクロが引
     数無しで呼ばれた時である．つまり，このマクロで `0' (null 文字) を 書くような時だ．

     もし引数を指定していたなら，それを引用符の間に置いたことだろう． `goto-char' の C
     マクロはこの位置に関数が無引数の時のために，
     バッファの位置を指定できるようプロンプトを表示するように `"NGoto char: "'
     を置いてある．

   * 7番目の部分は説明文字列であり、Emacs Lispで書いた関数と同じものであるが、
     各改行は、`\n'に続けてバックスラッシュと改行で書く必要がある。
     そうして，`goto-char' のドキュメントの最初の2行は下記のようになる．

            "Set point to POSITION, a number or marker.\n\
          Beginning of buffer is position (point-min), end is (point-max).

   Cのマクロでは、オブジェクトの種類を指定する文とともに仮引数があり、
さらに、マクロの「本体」とも呼ぶべきものが続く。
`delete-and-extract-region'の本体はつぎの2行から成る。

     validate_region (&start, &end);
     return del_range_1 (XINT (start), XINT (end), 1, 1);

   最初の関数 `validate_region' はリージョンの開始と先頭を示す値が適
当な値で範囲内にあるかどうかを確認しています．2番目の関数 `del_range_1'
は実際にテキストを削除する．

   `del_range_1' は複雑な関数であり，詳細は述べない．この関数はバッ
ファを更新し，他のことはしない．

   しかし，`del_range' へ渡る2つの引数は見ておく価値がある．引数には
`XINT (start)' と `XINT (end)' がある．

   C 言語に関する限り，`start' と `end' は削除される (1)
リージョンの最初と最後の位置を示す2つの整数である．

   Emacs の初期バージョンでは，これら2つの数は32ビット長でした．しかし，
コードはゆっくりと他の長さを扱えるように書き直されてきました．利用でき
るビットの3番目は情報のタイプを特定できるように遣われます．そして，4ビッ
ト目はコンピュータのメモリを扱うために使われます．残ったビットは"内容"
を示すために使われます．

   `XINT' は C マクロであり，ビットの長い部分から適当な部分を切り出
すのです．つまり，4つ以外のビットは破棄される．

   `delete-and-extract-region' のコマンドは下記のようになります．

     del_range_1 (XINT (start), XINT (end), 1, 1);

これは リージョンの開始位置 `start' と終了位置 `end' の間を 削除します．

   Lisp を書く人の視点だと，Emacs はとても単純です．しかし，正常に動作さ
せるために，たくさんの複雑な部分が隠れているのです．

   ---------- Footnotes ----------

   (1) より正確に，より深く理解できるように述べておくと，2つの引数 は`Lisp_Object'
タイプである．これは，Cの整数タイプの代わりとなること ができる


File: emacs-lisp-intro-ja.info,  Node: defvar,  Next: copy-region-as-kill,  Prev: Digression into C,  Up: Cutting & Storing Text

8.4 `defvar'による変数の初期化 _(2004/08/08)_
=============================================

関数 `delete-and-extract-region' と異なり、関数`copy-region-as-kill'は Emacs
Lispで書かれている。内部に含まれる2つの関数 `kill-append' と `kill-new'
はバッファのリージョンのコピーを変数 `kill-ring'にコピーする。 本節では、変数
`kill-ring' の作成とスペシャルフォーム `defvar' を使った初期化の方法を説明する。

   （`kill-ring'はふさわしくない名称であることを再度指摘しておく。
バッファから切り取ったテキストは戻すことができる。
キルリングは死体のリングではなく、復活できるテキストのリングである。）

   Emacs Lispでは、`kill-ring'のような変数は、
スペシャルフォーム`defvar'を用いて作成し初期化する。 この名称は「define
variable（変数を定義する）」からきている。

   スペシャルフォーム`defvar'は、変数の値を設定するという意味では `setq'に似ている。
しかし、`setq'とは2つの点で異なる。 まず、値を持っていない変数にのみ値を設定することである。
変数にすでに値があれば、`defvar'は既存の値を書き換えない。
第二に、`defvar'は説明文字列を有することである。

   他のスペシャルフォーム `defcustom' はカスタマイズできる変数のため
にある．`defvar' よりも多くの機能を持つ． (*Note Setting Variables with
`defcustom': defcustom.)

* Menu:

* See variable current value::
* defvar and asterisk::         An old-time convention.


File: emacs-lisp-intro-ja.info,  Node: See variable current value,  Next: defvar and asterisk,  Prev: defvar,  Up: defvar

変数の現在値を知る
------------------

   任意の変数の現在の値は、関数`describe-variable'を使って調べることができ、 普通、`C-h
v'とタイプすれば起動できる。 `C-h
v'とタイプして問い合わせに`kill-ring'（に続けて<RET>）と
タイプすれば、今のキルリングに何が入っているかがわかるが、とても多量であろう。
一方、本書を読む以外の操作をEmacsで行っていなければ、キルリングには 何もないであろう。
`kill-ring' のドキュメントを見てみよう．

     Documentation:
     List of killed text sequences.
     Since the kill ring is supposed to interact nicely with cut-and-paste
     facilities offered by window systems, use of this variable should
     interact nicely with `interprogram-cut-function' and
     `interprogram-paste-function'.  The functions `kill-new',
     `kill-append', and `current-kill' are supposed to implement this
     interaction; you may want to use them instead of manipulating the kill
     ring directly.

   キルリングはつぎのように`defvar'で定義してある。

     (defvar kill-ring nil
       "List of killed text sequences.
     ...")

この変数定義では、変数に初期値`nil'を設定している。
何も保存していないときには、コマンド`yank'で何も戻ってほしくないので、 この値には意味がある。
説明文字列は、`defun'の説明文字列と同じである。
`apropos'のようなある種のコマンドは説明文の最初の1行しか表示しないので、
`defun'の説明文字列と同様に説明文の最初の行は完全な文にしておく。 また、`C-h
v'（`describe-variable'）で表示したときに 変にならないように、続く行は字下げしない。


File: emacs-lisp-intro-ja.info,  Node: defvar and asterisk,  Prev: See variable current value,  Up: defvar

8.4.1 `defvar' とアスタリスク _(2004/08/08)_
--------------------------------------------

過去に Emacs はスペシャルフォーム `defvar' をユーザが変更しないよ
うな内部変数とユーザが変更する変数の両方を定義するために使っていました． 今でも
`defvar' をユーザがカスタマイズできる変数として利用できま すが，代わりに
`defcustom' を使うようにしてください．このスペシャ
ルフォームはカスタマイズで利用できるするためのスペシャルフォームです． (*Note
Setting Variables with `defcustom': defcustom)．

   スペシャルフォーム `defvar' を使って変数を定義するとき，アスタリ スク `*'
をドキュメントの最初に入力しておくことで，すぐに設定でき
る変数であると区別できる．例えば，

     (defvar shell-command-default-error-buffer nil
       "*Buffer name for `shell-command' ... error output.
     ... ")

`shell-command-default-error-buffer' の値は、コマンド
`edit-options'を使って一時的に変更できる(そして，今でもできる)ことを意味する。

   しかし，`edit-options' を使って設定した値は編集期間しか有効ではな
い．セッション間で新しい値は保存されない．そのため，`.emacs' ファ
イルで変更したり，`customize' を使って設定していなければ，Emacs を開始するた
びに，元の値が読み込まれる．

   私にとって，コマンド `edit-options' の主な用法は `.emacs' ファ
イルで設定したい値を試してみることだ．私はそのリストを見てみることを強 く勧める．(*Note
Editing Variable Values: (emacs)Edit Options.)


File: emacs-lisp-intro-ja.info,  Node: copy-region-as-kill,  Next: cons & search-fwd Review,  Prev: defvar,  Up: Cutting & Storing Text

8.5 `copy-region-as-kill' _(2004/08/08)_
========================================

関数`copy-region-as-kill'は、バッファからリージョンのテキストをコ
ピーし(`kill-append' か `kill-new' を介して) 変数`kill-ring'に保存する。

   コマンド`kill-region'の直後に`copy-region-as-kill'を呼ぶと、
Emacsは、新たにコピーしたテキストを直前にコピーしたテキストに追加する。
つまり、そのテキストを復元すると、そのテキストと直前のテキストを まとめて得ることになる。
一方で、`copy-region-as-kill'のまえに別のコマンドを実行した場合には、
この関数はテキストを独立した項目としてキルリングに保存する。

* Menu:

* Complete copy-region-as-kill::  The complete function definition.
* copy-region-as-kill body::    The body of `copy-region-as-kill'.


File: emacs-lisp-intro-ja.info,  Node: Complete copy-region-as-kill,  Next: copy-region-as-kill body,  Prev: copy-region-as-kill,  Up: copy-region-as-kill

関数 `copy-region-as-kill' の定義
---------------------------------

   ここに第21版での関数 `copy-region-as-kill'の完全なテキストを示す．

     (defun copy-region-as-kill (beg end)
       "Save the region as if killed, but don't kill it.
     In Transient Mark mode, deactivate the mark.
     If `interprogram-cut-function' is non-nil, also save
     the text for a window system cut and paste."
       (interactive "r")
       (if (eq last-command 'kill-region)
           (kill-append (buffer-substring beg end) (< end beg))
         (kill-new (buffer-substring beg end)))
       (if transient-mark-mode
           (setq deactivate-mark t))
       nil)

   この関数も部分部分に分解できる。

     (defun copy-region-as-kill (畏尽ナスト)
       "逝明文..."
       (interactive "r")
       本体...)

   引数は`beg'と`end'であり、 `"r"'が指定された対話的関数であるので、
2つの引数はリージョンの始まりと終わりを参照する必要がある。
本書を始めから読んでいる読者ならば、関数のこの部分を理解するのは簡単であろう。

   単語「kill」が通常の意味と異なることを思い出せば、
説明文の内容に混乱することもないであろう。暫定マークと コメント
`interprogram-cut-function' はある副作用を説明している．

   一度マークをセットすると，バッファにはいつもリージョンがあることになる．
もし希望すれば，一時的にリージョンをハイライトするために暫定マークモー
ドを利用できる．(いつでもリージョンをハイライトしたい人なんていないだ
ろう．だから，暫定モードマークは適当な時だけハイライトする．多くの人は
暫定マークモードをオフにしているので，リージョンは決してハイライトされ ない．)

   ウィンドウシステムでは，異なるプログラム間でコピーやカット，ペーストで きる．例えば
Xウィンドウシステムでは関数 `interprogram-cut-function' は `x-select-text'
である．これ は，Emacs のキルリングと同等ものである．

   関数 `copy-region-as-kill' の本体は `if' で始まる．ここでは，
2つの異なる状況，コマンドが以前の `kill-region' の直後に実行され
たかどうか，を区別するためにある．最初の例では，新しいリージョンは以前
コピーされたテキストに追加される．そうでなければ，キルリングの先頭に前
回のものとは別のテキストとして追加される．

   この関数の最後の2行は暫定マークモードがオンの時，リージョンがハイライ
トされないようにしている．

   `copy-region-as-kill'の本体は詳しく説明する価値がある。


File: emacs-lisp-intro-ja.info,  Node: copy-region-as-kill body,  Prev: Complete copy-region-as-kill,  Up: copy-region-as-kill

8.5.1 `copy-region-as-kill'の本体 _(2004/08/08)_
------------------------------------------------

関数`copy-region-as-kill'は、関数 `kill-region' (*note `kill-region':
kill-region.)とほとんど同じように動作する． 両者とも
連続してキルしたテキストは1つの断片にまとめるように書かれている。
キルリングからテキストを取り出すと、1つの断片として得ることになる。
さらに、カーソルの現在位置から終わりに向けたキルでは 直前にコピーしたテキストの末尾に追加し、
先頭向けのコピーでは直前にコピーしたテキストの先頭に追加する。
このようにして、テキスト内の語順は正しく保たれる。

   `kill-region'と同様に，関数 `copy-region-as-kill' は変数 `last-command'
をEmacsが以前実行したコマンドを確認するために使う．

* Menu:

* last-command & this-command::
* kill-append function::
* kill-new function::


File: emacs-lisp-intro-ja.info,  Node: last-command & this-command,  Next: kill-append function,  Prev: copy-region-as-kill body,  Up: copy-region-as-kill body

`last-command' and `this-command'
.................................

   通常、関数が実行されると、Emacsは、`this-command'の値に
実行する関数（ここでは、`copy-region-as-kill'）を設定する。
同時に、`this-command'の直前の値を`last-command'に設定する。

   関数`copy-region-as-kill'の本体の始めの部分では、
`last-command'の値が`kill-region'かどうかを `if'式で調べている。
そうならば、`if'式の真の場合の動作が評価される。 そこでは、関数`kill-append'を使って、
この呼び出しでコピーするテキストをキルリングの先頭要素（CAR）に連結する。
一方、`last-command'の値が`kill-region'でなければ、
関数`copy-region-as-kill'は新たな要素を関数 `kill-new' を使っ
てキルリングに追加する。

   まだ説明していない関数`eq'を用いているが、 `if'式はつぎのように読める。

       (if (eq last-command 'kill-region)
           ;; 真の場合の動作
           (kill-append (buffer-substring beg end) (< end beg))
         ;; 偽の場合の動作
         (kill-new (buffer-substring beg end)))

関数`eq'は、第1引数が第2引数と同じLispオブジェクトかどうかを検査する。
関数`eq'は、等しいかどうかを検査する関数`equal'に似ているが、
2つの表現がコンピュータ内部で実際に同じオブジェクトかどうかを検査する。
`equal'は、2つの式の構造と内容が同じかどうかを検査する。

   以前のコマンドが `kill-region' だったら Emacs Lisp インタープリタ は関数
`kill-append' を呼び出します．


File: emacs-lisp-intro-ja.info,  Node: kill-append function,  Next: kill-new function,  Prev: last-command & this-command,  Up: copy-region-as-kill body

関数`kill-append'
.................

関数`kill-append'はつぎのとおりである。

     (defun kill-append (string before-p)
       "Append STRING to the end of the latest kill in the kill ring.
     If BEFORE-P is non-nil, prepend STRING to the kill.
     If `interprogram-cut-function' is set, pass the resulting kill to
     it."
       (kill-new (if before-p
                     (concat string (car kill-ring))
                   (concat (car kill-ring) string))
                 t))

関数 `kill-append' はかなり単純である．この関数は関数 `kill-new'
を使用し，すぐに詳細が分かるだろう．

   最初に `kill-new' の2つの引数の1つである条件部分を見てみよう．
関数`setcar'は、キルリングのCARに新たなテキストを連結するために `concat'を使っている。
テキストを先頭に挿入するのか末尾に追加するのかは、 `if'式の結果に依存する。

     (if before-p                            ; 判定条件
         (concat string (car kill-ring))     ; 真の場合の動作
       (concat (car kill-ring) string))      ; 偽の場合の動作

直前のコマンドでキルしたリージョンの直前のリージョンをキルしたときには、
直前のキルで保存したテキストの先頭に挿入するべきである。
逆に、直前にキルしたリージョンの直後に続くテキストをキルした場合には、
直前のテキストの末尾に追加するべきである。
`if'式では、新たに保存するテキストを直前に保存したテキストの先頭に
挿入するか末尾に追加するかを述語`before-p'を用いて決めている。

   シンボル`before-p'は、`kill-append'の引数の名前の1つである。
関数`kill-append'が評価されると、実引数を評価した結果の値に束縛される。
ここでは、式`(< end beg)'である。
この式では、このコマンドでキルしたテキストが直前のコマンドでキルしたテキストの
まえにあるか、うしろにあるかを直接には決定しない。
変数`end'の値が変数`beg'の値より小さいかどうかのみを決定する。
そうであった場合には、バッファの先頭に向けてである可能性が高い。 すると、述語式`(< end
beg)'の評価結果は真となり、 テキストは直前のテキストの先頭に挿入される。
一方、変数`end'の値が変数`beg'の値より大きければ、
テキストは直前のテキストの末尾に追加される。

   新たに保存するテキストを先頭に挿入するときには、
既存のテキストのまえに新たなテキストを連結する。

     (concat string (car kill-ring))

テキストを追加する場合には、既存のテキストのうしろに連結する。

     (concat (car kill-ring) string))

   この動作を理解するには、まず、関数`concat'を復習しておく必要がある。
関数`concat'は、2つの文字列を繋げる。 結果も文字列である。 たとえば、

     (concat "abc" "def")
          => "abcdef"

     (concat "new "
             (car '("first element" "second element")))
          => "new first element"

     (concat (car
             '("first element" "second element")) " modified")
          => "first element modified"

   これで`kill-append'の動作を理解でき、キルリングの内容を変更することが わかる。
キルリングはリストであり、各要素は保存したテキストである。関数 `kill-append' は関数
`setcar' を使う代わりに， `kill-new' を使っている．


File: emacs-lisp-intro-ja.info,  Node: kill-new function,  Prev: kill-append function,  Up: copy-region-as-kill body

関数 `kill-new'
...............

関数 `kill-new' は以下のようになる．

     (defun kill-new (string &optional replace)
       "Make STRING the latest kill in the kill ring.
     Set the kill-ring-yank pointer to point to it.
     If `interprogram-cut-function' is non-nil, apply it to STRING.
     Optional second argument REPLACE non-nil means that STRING will replace
     the front of the kill ring, rather than being added to the list."
       (and (fboundp 'menu-bar-update-yank-menu)
            (menu-bar-update-yank-menu string (and replace (car kill-ring))))
       (if (and replace kill-ring)
           (setcar kill-ring string)
         (setq kill-ring (cons string kill-ring))
         (if (> (length kill-ring) kill-ring-max)
             (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
       (setq kill-ring-yank-pointer kill-ring)
       (if interprogram-cut-function
           (funcall interprogram-cut-function string (not replace))))

   いつものようにこの関数を部分に分けてみていこう．

   ドキュメントの最初の行には意味がある．

     Make STRING the latest kill in the kill ring.

しばらくドキュメントの残りは飛ばしていこう．

   コードの `menu-bar-update-yank-menu' を呼び出している最初の2行も
飛ばそう．そうすると，下記のように説明できる．

   重要な行は下記である：

       (if (and replace kill-ring)
           ;; 真の場合には
           (setcar kill-ring string)
         ;; 偽の場合には
         (setq kill-ring (cons string kill-ring))
         (if (> (length kill-ring) kill-ring-max)
             ;; キルリングが溢れるのを避ける
             (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
       (setq kill-ring-yank-pointer kill-ring)
       (if interprogram-cut-function
           (funcall interprogram-cut-function string (not replace))))

   条件部分は `(and replace kill-ring)' である．これは，2つの条
件が合致すれば真となる．つまり，キルリングが何かを含んでいて，変数 `replace'
が真の時，この条件は真となる．

   関数 `kill-append' は `replace' を真に設定する．そうして，キ
ルリングが少なくとも1要素を含んでいれば `setcar' 式が実行される．

     (setcar kill-ring string)

   関数 `setcar' は実際に `kill-ring' の最初の要素を
`string'の値に変更する．この関数は最初の要素を置き換える．

   一方，キルリングが空であるか置換に失敗したなら，条件の偽の部分が実行さ れる：

     (setq kill-ring (cons string kill-ring))
     (if (> (length kill-ring) kill-ring-max)
         (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil))

この式はまずキルリングに `string' を新しい要素として先頭に追加す
ることで新しいキルリングを構成する．そうして，2番目の `if' 文が実
行される．この2番目の `if' 文はキルリングが長くなりすぎるのを防い でいる．

   これらの2つの式を順番に見ていこう．

   偽の場合の動作の`setq'の行では、キルした文字列をもとのキルリングに
追加した結果をキルリングの新たな値に設定する。

   つぎの例からこの動作を理解できる。

     (setq example-list '("here is a clause" "another clause"))

`C-x C-e'でこの式を評価してから、`example-list'を評価すると つぎのような結果になる。

     example-list
          => ("here is a clause" "another clause")

このリストに新たな要素を追加するには、つぎの式を評価すればよい。 

     (setq example-list (cons "a third clause" example-list))

`example-list'を評価すると、その値はつぎのとおりである。

     example-list
          => ("a third clause" "here is a clause" "another clause")

つまり、`cons'で「the third clause」をリストに追加したのである。

   以上は、関数内で`setq'と`cons'とが行うことと同じである．
その行を改めてつぎに記しておく。

     (setq kill-ring (cons string kill-ring))

   `if' 文の2番目へ進もう．この式はキルリングが長くなりすぎるのを防
いでいる．この部分は下記のようになっている．

     (if (> (length kill-ring) kill-ring-max)
         (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil))

   このコードでは、キルリングの長さが許された最大長よりも 大きいかどうかを検査する。
最大長は`kill-ring-max'の値である（デフォルトは60）。
キルリングの長さが長すぎる場合には、キルリングの最後の要素を`nil'に 設定する。
これには、2つの関数`nthcdr'と`setcdr'を使う。

   `setcdr'についてはすでに説明した（*note setcdr::）。
`setcar'がリストのCARを設定するように、 `setcdr'はリストのCDRを設定する。
しかし、ここでは`setcdr'はキルリング全体のCDRを設定するのではない。
関数`nthcdr'が使われていて、キルリングの最後の要素の直前のCDRを 設定するのである。
つまり、最後の要素の直前のCDRはキルリングの最後の要素であるから、
キルリングの最後の要素を設定することになる。

   関数`nthcdr'は、リストのCDRを繰り返し取るように動作する。
つまり、CDRのCDRのCDRの...のCDRを取る。 N回繰り返した結果を返す。

   したがって、たとえば、4要素リストを3要素リストにするには、
最後の要素の直前のCDRを`nil'にしてリストを短くすればよい。

   つぎの3つの式を順に評価すれば、これを理解できるであろう。
まず、`trees'の値として`(maple oak pine birch)'を設定する。
つぎに、2つめのCDRのCDRを`nil'にしてから、 `trees'の値を見てみる。

     (setq trees '(maple oak pine birch))
          => (maple oak pine birch)

     (setcdr (nthcdr 2 trees) nil)
          => nil

     trees
          => (maple oak pine)

（`setcdr'式が返す値は、CDRを`nil'に設定したので、 `nil'である。）

   `kill-new'では、関数`nthcdr'は、 キルリングの許された最大長引く1回だけCDRを取り、
その要素（キルリングの残りの要素）のCDRに`nil'を設定する。
これにより、キルリングが長くなり過ぎるのを防ぐ。

   関数`copy-region-as-kill'の最後の行の直前はつぎのとおりである。

     (setq kill-ring-yank-pointer kill-ring)

   `kill-ring-yank-pointer' は `kill-ring' が設定されるグローバ ル変数である．

   `kill-ring-yank-pointer' は `pointer' と呼ばれるが，キルリン
グのような変数である．しかし，変数がどのように使われるか理解しやすいよ
うに変数名は選ばれた．この変数は `yank'や`yank-pop' (*note Yanking Text Back:
Yanking.) のような関数で使われる．

   関数の本体である最初の2行に話を戻そう．

       (and (fboundp 'menu-bar-update-yank-menu)
            (menu-bar-update-yank-menu string (and replace (car kill-ring))))

これは最初の要素が関数 `and' である式である．

   スペシャルフォーム `and' は 1つの引数が `nil' を返し， `and' 式が `nil'
を返すまで順番に引数を評価する．しかし，ど の引数も `nil'
を返さなければ，最後の引数を評価した時の値が返るこ とになる．(そのような値は `nil'
ではないので，Emacs Lisp では真と
考える)．言い換えると，`and'式はその引数が真であれば1つの真値だけ を返すのである．．

   この例では，最初に `menu-bar-update-yank-menu' が関数として存在す
るかを確認する．もし存在すれば，それを呼ぶ．関数 `fboundp' はシン
ボルの関数定義が"ボイド(無)で無ければ"真を返す．もしシンボルの関数定義
が無であったなら，わざとエラーを作成したように (*note Generate an Error Message:
Making Errors.)，エラーメッセージが表示される．

   要するに，`and' は以下のような `if' 式なのである．

     if THE-MENU-BAR-FUNCTION-EXISTS
       then EXECUTE-IT

   `menu-bar-update-yank-menu' はメニューの Edit にある `Select and Paste'
を実現している関数の一つである．このメニューでは，マウスを使い，
以前にコピーしたさまざまなテキストを見て，貼り付けるものを選択できる．

   最後に，関数 `kill-new' の最後の式はウィンドウシステム上の別のプ
ログラムでコピーやペーストができるように，新しくコピーした文字を保存し
ます．例えば，Xウィンドウシステムでは関数 `x-select-text' が文字 列を取り，X
で扱われるメモリに保存します．これで，Xtermのような他のプ ログラムでペーストできる．

   この式は以下のようである．

       (if interprogram-cut-function
           (funcall interprogram-cut-function string (not replace))))

   `interprogram-cut-function' が存在すると，Emacs は `funcall'
をある関数を第1引数，残りの引数を渡して実行します．(ついでに，私が見る 限りでは，この `if'
式はこの関数の最初の部分と同様に `and' 式で置き換えることができる．)

   ここで，ウィンドウシステムや他のプログラムについて説明するつもりはない．
ここでは単に，GNU Emacs が他のプログラムと簡単にうまく機能できるような
仕組みであるとだけ覚えておいて欲しい．

   This code for placing text in the kill ring, either concatenated with
an existing element or as a new element, leads us to the code for
bringing back text that has been cut out of the buffer--the yank
commands.  However, before discussing the yank commands, it is better
to learn how lists are implemented in a computer.  This will make clear
such mysteries as the use of the term `pointer'.
テキストをキルリングに，既存の要素に連結するか，新しい要素として，追加
し、バッファから切り取ったテキストを復元する ヤンクコマンドのコードの説明に進める。
しかし、ヤンクコマンドを説明するまえに、コンピュータでのリストの実装方法を
学んでおくのがよいであろう。 そうすれば、「ポインタ」などの用語の不可解さが明らかになる。


File: emacs-lisp-intro-ja.info,  Node: cons & search-fwd Review,  Next: search Exercises,  Prev: copy-region-as-kill,  Up: Cutting & Storing Text

8.6 復　習 _(2004/08/08)_
=========================

これまでに説明した関数のいくつかを以下にまとめておく。

`car'
`cdr'
     `car'はリストの先頭要素を返す。 `cdr'はリストの2番目以降の要素を返す。

     たとえば、

          (car '(1 2 3 4 5 6 7))
               => 1
          (cdr '(1 2 3 4 5 6 7))
               => (2 3 4 5 6 7)

`cons'
     `cons'は、第1引数を第2引数のまえに置いたリストを作る。

     たとえば、

          (cons 1 '(2 3 4))
               => (1 2 3 4)

`nthcdr'
     リストに`cdr'を「n」回適用した結果を返す。

     たとえば、

          (nthcdr 3 '(1 2 3 4 5 6 7))
               => (4 5 6 7)

`setcar'
`setcdr'
     `setcar'はリストの先頭要素を変更する。 `setcdr'はリストの2番目以降の要素を変更する。

     たとえば、

          (setq triple '(1 2 3))

          (setcar triple '37)

          triple
               => (37 2 3)

          (setcdr triple '("foo" "bar"))

          triple
               => (37 "foo" "bar")

`progn'
     引数を順番に評価し、最後のものの値を返す。

     たとえば、

          (progn 1 2 3 4)
               => 4

`save-restriction'
     カレントバッファで有効になっているナロイングを記録し、
     引数を評価し終えたら、もとのナロイングに戻す。

`search-forward'
     文字列を探し、それがみつかればポイントを移動する。

     4つの引数を取る。

       1. 探すべき文字列。

       2. 探索範囲の制限。 省略できる。

       3. 探索に失敗した場合に`nil'を返すかエラーメッセージを返すか指定する。
          省略できる。

       4. 探索を何回行うかを指定する。 省略できる。
          負の場合には、逆向きに（先頭へ向けて）探索する。

`kill-region'
`delete-region'
`copy-region-as-kill'
     `kill-region'は、ポイントとマークのあいだのテキストを
     バッファから切り取り、ヤンクで復元できるように、 キルリングにそのテキストを保存する。

     `delete-and-extract-region' は、ポイントとマークのあいだのテキストを
     バッファから取りさり、破棄する。 復元することはできない。

     `copy-region-as-kill'はポイントとマークのあいだのテキストを
     キルリングにコピーし、キルリングからそのテキストを復元できるようにする。
     この関数は、バッファからテキストを取りさったりしない。


File: emacs-lisp-intro-ja.info,  Node: search Exercises,  Prev: cons & search-fwd Review,  Up: Cutting & Storing Text

8.7 探索の演習問題 _(2004/08/08)_
=================================

   * 文字列を探す対話的関数を書いてみよ。
     文字列を探しあてた場合には、その直後にポイントを移動してメッセージ「Found!」を
     表示する （この関数の名前には`search-forward'を使わないこと。
     さもないと、Emacsの既存の`search-forward'を書き換えてしまう。
     かわりに、`test-search'のような名前を使う）。

   * キルリングに第3要素があれば、それをエコー領域に表示する関数を書いてみよ。
     キルリングに第3要素がなければ、適切なメッセージを表示せよ。


File: emacs-lisp-intro-ja.info,  Node: List Implementation,  Next: Yanking,  Prev: Cutting & Storing Text,  Up: Top

9 リストの実装方法 _(2004/08/08)_
*********************************

Lispでは、アトムは単純な方法で記録されている。
現実の実装が単純ではないとしても、理論的には単純である。
たとえば、アトム`rose'は、`r'、`o'、`s'、
`e'の4つの連続した文字として記録されている。 一方で、リストは異なった方法で記録されている。
その機構は同様に単純であるが、その考え方に慣れるには時間がかかる。
リストは一連のポインタ対を用いて記録されている。 ポインタ対の最初のポインタはアトムやリストを指し、
ポインタ対の2番目のポインタはつぎの対やシンボル、 あるいは、リストの終わりを表す`nil'を指す。

   ポインタ自身は、とても単純で、それが指すもののアドレスである。
したがって、リストは一連のアドレス対として記録される。

* Menu:

* Lists diagrammed::
* Symbols as Chest::            Exploring a powerful metaphor.
* List Exercise::


File: emacs-lisp-intro-ja.info,  Node: Lists diagrammed,  Next: Symbols as Chest,  Prev: List Implementation,  Up: List Implementation

リストの図解
============

   たとえば、リスト`(rose violet buttercup)'には3つの要素、
`rose'、`violet'、`buttercup'がある。 コンピュータ内部では、`rose'のアドレスは、
アトム`violet'の場所を示すアドレスを与えるアドレスとともに メモリに記録されている。
（`violet'の場所を示す）アドレスは、
アトム`buttercup'の場所を示すアドレスを与えるアドレスとともに 記録されている。

   複雑に聞こえるであろうが、図で表せば簡単である。

         ___ ___      ___ ___      ___ ___
        |___|___|--> |___|___|--> |___|___|--> nil
          |            |            |
          |            |            |
           --> rose     --> violet   --> buttercup



図では、各箱は、メモリアドレス形式のLispオブジェクトを保持する
コンピュータのメモリを表す。 箱、つまり、アドレスは対になっている。
各矢印は、アトムや他のアドレスの対のアドレスで表されるものを指す。
最初の箱は`rose'のアドレスであり、矢印は`rose'を指す。
2番目の箱は、つぎの箱の対のアドレスであり、 その先頭部分は`violet'のアドレスであり、
2番目の部分はつぎの対のアドレスである。
最後の箱はシンボル`nil'を指し、リストの終わりを表す。

   `setq'などの関数で変数にリストを設定すると、 変数には最初の箱のアドレスを設定する。 つぎの式

     (setq bouquet '(rose violet buttercup))

を評価するとつぎのような状況になる。

     bouquet
          |
          |     ___ ___      ___ ___      ___ ___
           --> |___|___|--> |___|___|--> |___|___|--> nil
                 |            |            |
                 |            |            |
                  --> rose     --> violet   --> buttercup



この例では、シンボル`bouquet'は、最初の箱の対のアドレスを保持する。

   同じリストを異なる箱表記方法で示すこともできる。

     bouquet
      |
      |    --------------       ---------------       ----------------
      |   | car   | cdr  |     | car    | cdr  |     | car     | cdr  |
       -->| rose  |   o------->| violet |   o------->| butter- |  nil |
          |       |      |     |        |      |     | cup     |      |
           --------------       ---------------       ----------------



   (リストであるようなシンボルは多くのアドレスのペアからなる．しかし，個々
のシンボルの構造はアドレスである．シンボル `bouquet' はアドレスを
入れた箱のグループからなり，1つは `bouquet' のアドレス，2つ目はシ
ンボルに割り当てられた関数定義のアドレス，3番目はリスト `(rose violet buttercup)'
の最初のペアのアドレスを入れた箱のアドレスなどとなっ
ている．ここで，シンボルの3番目のアドレスはリストのアドレス箱の最初の ペアを指している)

   シンボルにリストのCDRを設定しても、リスト自体は変わらない。
シンボルはリストを辿ったアドレスを持つだけである
（専門用語では、CARやCDRは「非破壊的」である）。 したがって、つぎの式を評価すると

     (setq flowers (cdr bouquet))

つぎのようになる。


     bouquet        flowers
       |              |
       |     ___ ___  |     ___ ___      ___ ___
        --> |   |   |  --> |   |   |    |   |   |
            |___|___|----> |___|___|--> |___|___|--> nil
              |              |            |
              |              |            |
               --> rose       --> violet   --> buttercup




`flowers'の値は`(violet buttercup)'であり、
つまり、シンボル`flowers'は、`violet'のアドレスを最初の箱に、
`buttercup'のアドレスを2番目の箱に持つような箱の対のアドレスを保持する。

   アドレスを収めた箱の対を"コンスセル（cons cell）"とか "ドットペアー（dotted
pair）"と呼ぶ。 コンスセルやドットペアーについて 詳しくは、*note Dotted Pair Notation:
(elisp)Dotted Pair Notation.や *Note List Type: (elisp)List Type。

   関数`cons'は、上に示した一連のアドレスのまえにアドレスの新たな対を加える。
たとえば、つぎの式

     (setq bouquet (cons 'lily bouquet))

を評価すると、つぎのようになる。


     bouquet                       flowers
       |                             |
       |     ___ ___        ___ ___  |     ___ ___       ___ ___
        --> |   |   |      |   |   |  --> |   |   |     |   |   |
            |___|___|----> |___|___|----> |___|___|---->|___|___|--> nil
              |              |              |             |
              |              |              |             |
               --> lily      --> rose       --> violet    --> buttercup




しかし、つぎの式を評価するとわかるように、
これによりシンボル`flowers'の値が変更されることはない。

     (eq (cdr (cdr bouquet)) flowers)

は、真を表す`t'を返す。

   再設定しない限り、`flowers'の値は`(violet buttercup)'である。
つまり、`flowers'は、最初の部分に`violet'のアドレスを 収めたコンスセルのアドレスを持つ。
さらに、すでに存在するいかなるコンスセルも変更しない。 それらはそのまま存続する。

   したがって、LispでリストのCDRを取り出すと、
一連のコンスセルの中のつぎのコンスセルのアドレスを得るのである。
リストのCARを取り出すと、リストの先頭要素のアドレスを得る。
新たな要素をリストに`cons'すると、 リストのまえに新たなコンスセルを置くのである。
以上がすべてである。 Lispの根底にある構造は、とても単純なのである。

   一連のコンスセルの最後のアドレスは何を指すのであろう？　
それは空リスト、つまり、`nil'のアドレスである。

   まとめると、Lispの変数に値を設定すると、 変数が参照するリストのアドレスが設定される。


File: emacs-lisp-intro-ja.info,  Node: Symbols as Chest,  Next: List Exercise,  Prev: Lists diagrammed,  Up: List Implementation

9.1 箪笥の引き出しに見立てたシンボル _(2004/08/08)_
===================================================

始めの節では、シンボルを箪笥と考えればよいと述べた。
関数定義はある引き出しに入れてあり、値は別の引き出しに入れてあるのである。
関数定義を収めた引き出しの中身を変えることなく、
値を収めた引き出しの中身を変更でき、その逆もそうである。

   実際、各引き出しに収められているのは、値や関数定義のアドレスである。
屋根裏部屋でみつけた古い箪笥の引き出しから、宝物を埋めた場所を記した
地図をみつけるようなものである。

   （シンボルには、名前、関数定義、値に加えて、その他の情報を記録するための
"属性リスト（property list）"を収める引き出しもある。 ここでは属性リストについては
説明しないので、*note Property Lists: (elisp)Property Lists.を参照。）

   Here is a fanciful representation: 仮想的な表現をつぎに示す。


                  箪笥の引き出し                 引き出しの中身

                 __   o0O0o   __
               /                 \
              ---------------------
             |    シンボル名の     |            [map to]
             |       場所          |             bouquet
             |                     |
             +---------------------+
             |     関数定義の      |
             |       場所          |             なし
             |                     |
             +---------------------+
             |      変数の値の     |            [map to]
             |         場所        |             (rose violet buttercup)
             |                     |
             +---------------------+
             |    属性リストの     |
             |        場所         |             [本書では説明しない]
             |                     |
             +---------------------+
             |/                   \|




   詳しくは、*Note Autoload: (elisp)Autoload。


File: emacs-lisp-intro-ja.info,  Node: Simple Extension,  Next: X11 Colors,  Prev: Autoload,  Up: Emacs Initialization

9.2 簡単な拡張：`line-to-top-of-window' _(2004/08/10)_
======================================================

ウィンドウの先頭行にポイントを移動するEmacsへの簡単な拡張を説明する。
筆者は、テキストを読みやすくするためこれをよく使っている。

   以下のコードを別のファイルに収めて、そのファイルを`.emacs'ファイルで
ロードしてもよいし、コードを`.emacs'ファイルに収めてもよい。

   定義はつぎのとおりである。

     ;;; Line to top of window;
     ;;; replace three keystroke sequence  C-u 0 C-l
     (defun line-to-top-of-window ()
       "Move the line point is on to top of window."
       (interactive)
       (recenter 0))

   つぎは、キーバインドである。

   最近ではマウス操作や非ASCII 文字と同様にファンクションキーも引用
符なしで角括弧に入れて書かれる(Emacs 18 以前では端末ごとに異なるファン
クションキー割り当てを書かなければならなかった)．

   著者は `line-to-top-of-window' を以下のようにしてファンクションキー `F6'
に割り当てている．

     (global-set-key [f6] 'line-to-top-of-window)

   詳細については *note Rebinding Keys in Your Init File: (emacs)Init
Rebinding. を参照のこと．

   もしバージョン20と21のように2つのバージョンのEmacsを1つの `.emacs'
ファイルで使うのであれば，以下のような条件式を使うことで 評価する部分を変えることができる．

     (cond
      ((string-equal (number-to-string 20) (substring (emacs-version) 10 12))
       ;; バージョン 20 が評価するコード
       ( ... ))
      ((string-equal (number-to-string 21) (substring (emacs-version) 10 12))
       ;; バージョン 21 が評価するコード
       ( ... )))

   例えば，バージョン20とは違い21ではデフォルトでカーソルを点滅させる．著
者はバージョン21の他の機能と同様に，そのような点滅は嫌いなので，以下の コードを `.emacs'
ファイルに書いている(1):

     (if (string-equal "21" (substring (emacs-version) 10 12))
         (progn
           (blink-cursor-mode 0)
           ;; Insert newline when you press `C-n' (next-line)
           ;; at the end of the buffer
           (setq next-line-add-newlines t)
           ;; Turn on image viewing
           (auto-image-file-mode t)
           ;; Turn on menu bar (this bar has text)
           ;; (Use numeric argument to turn on)
           (menu-bar-mode 1)
           ;; Turn off tool bar (this bar has icons)
           ;; (Use numeric argument to turn on)
           (tool-bar-mode nil)
           ;; Turn off tooltip mode for tool bar
           ;; (This mode causes icon explanations to pop up)
           ;; (Use numeric argument to turn on)
           (tooltip-mode nil)
           ;; If tooltips turned on, make tips appear promptly
           (setq tooltip-delay 0.1)  ; default is one second
            ))

(`(number-to-string 21)' と入力する代わりに，数字を文字列へ変換さ
せるよりもむしろ，入力を省略して，`21'を文字列  `"21"'と書くこと
に著者は決めた．この例では，この式は長いが一般的な `(number-to-string 21)'
よりもいい．しかし，もし返ってくる値につ いて前もって知らなければ，関数
`number-to-string' が必要となる)

   ---------- Footnotes ----------

   (1) `.emacs' ファ イルやサイトファイルを読み込まないような Emacs のインスタンスを開始し
た時でも，点滅はさせないようにしている:

     emacs -q --no-site-file -eval '(blink-cursor-mode nil)'


File: emacs-lisp-intro-ja.info,  Node: X11 Colors,  Next: Miscellaneous,  Prev: Simple Extension,  Up: Emacs Initialization

9.3 X11の色指定 _(2004/08/10)_
==============================

Emacs第19版をMITのXウィンドウシステムのもとで使用している場合には、 色を指定できる
（これまでの例は、Emacs第18版でも第19版でも動作するはずであるが、
この例は第19版でのみ動作する）。

   デフォルトの色は好みに合わないので、自前の指定をする。

   筆者の`.emacs'ファイルの値を設定する式はつぎのとおりである。

     ;; カーソル色を設定
     (set-cursor-color "white")

     ;; マウス色を設定
     (set-mouse-color "white")

     ;; 前景色と背景色を設定
     (set-foreground-color "white")
     (set-background-color "darkblue")

     ;;; isearch やドラッグ時のハイライトを設定
     (set-face-foreground 'highlight "white")
     (set-face-background 'highlight "blue")

     (set-face-foreground 'region "cyan")
     (set-face-background 'region "blue")

     (set-face-foreground 'secondary-selection "skyblue")
     (set-face-background 'secondary-selection "darkblue")

     ;; Set calendar highlighting colors
     (setq calendar-load-hook
           '(lambda ()
              (set-face-foreground 'diary-face   "skyblue")
              (set-face-background 'holiday-face "slate blue")
              (set-face-foreground 'holiday-face "white")))

   青のさまざまな濃淡は目にやさしく、画面のチラツキを目立たせない。

   代わりに，さまざまな X の初期化ファイルで設定できる．例えば，前景色や
背景色，カーソル，ポインター(つまりマウス)色を `~/.Xresources' ファ
イルで以下のように設定できる．

     Emacs*foreground:   white
     Emacs*background:   darkblue
     Emacs*cursorColor:  white
     Emacs*pointerColor: white

   ともかく，これは Emacs の部分ではない．`~/.xinitrc'ファイルにある X
ウィンドウの色を設定している．(1)

     # I use TWM for window manager.
     xsetroot -solid Navy -fg white &

   ---------- Footnotes ----------

   (1) 時おり，GNOME, Enlightenment, SCWM, KDE
のような最新のウィンドウマネージャを使う．そ の場合，しばしば単色よりも画像が設定される


File: emacs-lisp-intro-ja.info,  Node: Miscellaneous,  Next: Mode Line,  Prev: X11 Colors,  Up: Emacs Initialization

9.4 `.emacs' ファイルのその他の設定 _(2004/08/10)_
==================================================

その他の雑多な設定の一部を説明しておく。

   - マウスカーソルの色と形を設定する。
          ; Cursor shapes are defined in
          ; `/usr/include/X11/cursorfont.h';
          ; for example, the `target' cursor is number 128;
          ; the `top_left_arrow' cursor is number 132.

          (let ((mpointer (x-get-resource "*mpointer"
                                          "*emacs*mpointer")))
            ;; If you have not set your mouse pointer
            ;;     then set it, otherwise leave as is:
            (if (eq mpointer nil)
                (setq mpointer "132")) ; top_left_arrow
            (setq x-pointer-shape (string-to-int mpointer))
            (set-mouse-color "white"))


File: emacs-lisp-intro-ja.info,  Node: Mode Line,  Prev: Miscellaneous,  Up: Emacs Initialization

9.5 モード行の変更 _(2004/08/10)_
=================================

最後に、筆者のお気に入りの機能を説明する。 モード行の変更である。

   著者はネットワークを介して作業をする時，使用しているマシンを忘れてしま
うことがある．また，今どのディレクトリにいて，どの行にいるかも忘れがち である．

   だから，著者のモードラインはこのようになっている．

     -:-- foo.texi   rattlesnake:/home/bob/  Line 1  (Texinfo Fill) Top

   マシン `rattlesnake'上で `foo.texi' というファイルを `/home/bob'
というバッファで訪問している．Texinfo モードで1行目の バッファの先頭にいる．

   `.emacs' ファイルには以下のような部分がある．

     ;; モードラインにどのマシン，どのディレクトリ，どの行にあるかを
     ;; 追加の情報に加えて設定する．
     (setq default-mode-line-format
      (quote
       (#("-" 0 1
          (help-echo
           "mouse-1: select window, mouse-2: delete others ..."))
        mode-line-mule-info
        mode-line-modified
        mode-line-frame-identification
        "    "
        mode-line-buffer-identification
        "    "
        (:eval (substring
                (system-name) 0 (string-match "\\..+" (system-name))))
        ":"
        default-directory
        #(" " 0 1
          (help-echo
           "mouse-1: select window, mouse-2: delete others ..."))
        (line-number-mode " Line %l ")
        global-mode-string
        #("   %[(" 0 6
          (help-echo
           "mouse-1: select window, mouse-2: delete others ..."))
        (:eval (mode-line-mode-name))
        mode-line-process
        minor-mode-alist
        #("%n" 0 2 (help-echo "mouse-2: widen" local-map (keymap ...)))
        ")%] "
        (-3 . "%P")
        ;;   "-%-"
        )))

ここで，デフォルトのモードラインを再定義している．ほとんどの部分はデフォ
ルトのものを使っているが，少し変えてある．Info のように上書きするさま
ざまなモードを許すように_デフォルトの_モードライン書式を設定して いる．

   リストの多くの要素は説明である．`mode-line-modified' はバッファが
変更されているか，`mode-name' はモード名を教えてくれる変数である．
しかし，まだ議論していない2つの機能のために，この書式は複雑なように思える．

   モードラインの最初の文字はダッシュかハイフン `-'である．以前は， 単に `"-"'
のように定義されていた．しかし，今ではEmacsは文字列に
ハイライトしたりヘルプ機能を利用できるように属性を追加できる．もしマウ
スカーソルをハイフンの上に起くと，いくらかのヘルプが表示される．(デフォ
ルトでは，情報が表示されるまで数秒待たなければなりません．表示されるま での遅延は
`tooltip-delay' の値で変更できる．)

   新しい文字列の書式は特別な構文を持つ．

     #("-" 0 1 (help-echo "mouse-1: select window, ..."))

`#('はリストを始める．リストの最初の要素は文字列自身であり，ここ では1個の `-'
である．2番目と3番目の要素は4番目の要素が適用される
範囲を規定する．範囲は文字の_後から_始まる．だから，0は範囲が最初
の文字の前から始まって，1は最初の文字の後で終わることを意味する．4番目
の要素は範囲に適用される属性である．これは属性のリストから成り，属性名
(ここでは，`help-echo')，値(ここでは文字列)を含む．この新しい文字
列に対する書式である2番目，3番目，4番目の要素は繰り返すことができる．

   詳細は *Note Text Properties in String: (elisp)Text Props and Strings
と *note Mode Line Format: (elisp)Mode Line Format. を参照のこと．

   `mode-line-buffer-identification' はカレントバッファ名を表示する．
これは`(#("%12b" 0 4 ...' で始まるリストである．`#(' は リストの開始を意味する．

   `"%12b"' はカレントバッファ名を関数馴染みの深い `buffer-name'
を使って表示する．"12" は表示される最大の文字数を規
定する．名前が短い時には，長さを調節するために空白が挿入される．(バッ
ファ名はしばしば12文字よりも長くなる．この12という長さは典型的な80文字
幅のウィンドウでうまく動作してくれる．)

   `:eval' はEmacs 21の新しい機能である．この書式は続くフォームを評
価し，結果を表示する文字列として使う．この例では，完全なシステム名の最
初の要素を表示する．最初の要素の終わりの方にあるのは `.'(ピリオド)
であり，`string-match' を使って要素の長さを調べている．0からその 長さまでを substring
で切り出すと，マシン名となる．

   ここは以下のような式である．

     (:eval (substring
             (system-name) 0 (string-match "\\..+" (system-name))))

   `%['と`%]'は、各再帰編集レベルに応じて鈎括弧の対を表示する。
`%n'は、ナロイングしている場合に「Narrow」を表示する。
`%P'は、ウィンドウの最下行より上に表示されているバッファの割合や
「Top」、「Bottom」、「All」を表示する
（小文字の`p'は、ウィンドウの先頭行より上に表示されているバッファの割合 を表示する）。
`%-'は、モード行が適当な長さになるように`-'を詰め込む。

   「Emacsを好きになるにはEmacsが好きである必要はない」を覚えておいてほしい。
読者のEmacsは、デフォルトのEmacsとは、 色表示が異なり、コマンドも異なり、キーも異なるであろう。

   一方、「箱から取り出した」ままのカスタマイズしていないEmacsを起動するには
つぎのようにタイプする。

     emacs -q

初期化ファイル`~/.emacs'をロードせずにEmacsを起動する。
デフォルトのままのEmacsである。 何も変わっていない。


File: emacs-lisp-intro-ja.info,  Node: Debugging,  Next: Conclusion,  Prev: Emacs Initialization,  Up: Top

10 デバッグ _(2006/04/06)_
**************************

GNU Emacsには2つのデバッガ、`debug'と`edebug'がある。
最初のものは、Emacs内部に組み込まれていていつでも使える。
2番目のものは使う前に関数を指示する必要がある．

   どちらのデバッガも*note Debugging Lisp Programs:
(elisp)Debugging.に詳しく記載されている。 本章では、それぞれの短い例を示すことにする。

* Menu:

* debug::                       How to use the built-in debugger.
* debug-on-entry::              Start debugging when you call a function.
* debug-on-quit::               Start debugging when you quit with C-g.
* edebug::                      How to use Edebug, a source level debugger.
* Debugging Exercises::


File: emacs-lisp-intro-ja.info,  Node: debug,  Next: debug-on-entry,  Prev: Debugging,  Up: Debugging

10.1 `debug' _(2004/08/10)_
===========================

1から指定した数までの総和を求める関数定義を書いたとしよう
（まえに説明した関数`triangle'である。 説明は、*Note Decrementing Example::）。

   しかし、関数定義にはバグがある。 `1-'を`1='とタイプミスした。
まちがった定義はつぎのとおりである。

     (defun triangle-bugged (number)
       "Return sum of numbers 1 through NUMBER inclusive."
       (let ((total 0))
         (while (> number 0)
           (setq total (+ total number))
           (setq number (1= number)))      ; ここがエラー
         total))

   Infoで読んでいる場合には、いつものようにこの定義を評価できる。
エコー領域に`triangle-bugged'と表示される。

   引数4で関数`triangle-bugged'を評価してみる。

     (triangle-bugged 4)

Emacs 21では以下のような `*Backtrace*'バッファを作成し，そのバッ ファに移動する


     ---------- Buffer: *Backtrace* ----------
     Debugger entered--Lisp error: (void-function 1=)
       (1= number)
       (setq number (1= number))
       (while (> number 0) (setq total (+ total number))
             (setq number (1= number)))
       (let ((total 0)) (while (> number 0) (setq total ...)
         (setq number ...)) total)
       triangle-bugged(4)
       eval((triangle-bugged 4))
       eval-last-sexp-1(nil)
       eval-last-sexp(nil)
       call-interactively(eval-last-sexp)
     ---------- Buffer: *Backtrace* ----------

(この例は少々整形してある。デバッガは長い行を折り畳まない。大抵，デバッ ガは
`*Backtrace*' バッファで `q'と入力することで終了できる．)

   実際、このような単純なバグならば、"Lisp error"の行で定義を修正する必要
があることが分かるだろう．`1=' は"void"である．

   Emacs 20以前では以下のように表示される．

     Symbol's function definition is void: 1=

意味はEmacs 21の`*Backtrace*'バッファと同じ意味である．

   しかし，もし何をすべきか確信が無い時には，バックトレースをすべて読むこ とになる．

   この場合は，自動的にデバッガを開始して，`*Backtrace*' バッファに 移動する Emacs 21
を実行する必要がある．さもなければ，手動 でデバッガを開始する必要がある．

   バッファ`*Backtrace*'は、下から上へ向けて読む。
Emacsが何を行ってエラーに至ったかを教えてくれる。Emacsは`C-x C-e'
（`eval-last-sexp'）を対話的に呼び出し、これは
`triangle-bugged'式の評価につながった。各行はLispインタープリタが、
つぎに何を評価したのかを教えてくれる．

   バッファの先頭から3行目はつぎのとおりである。

     (setq number (1= number))

Emacsはこの式を評価しようとした。
そのために、先頭から2行目に示されたもっとも内側の式を評価しようとした。

     (1= number)

これがエラーを起こした場所であり、 先頭の行にはつぎのように表示されている。

     Debugger entered--Lisp error: (void-function 1=)

この誤りを修正して、関数定義を再評価し、再度試せばよい。


File: emacs-lisp-intro-ja.info,  Node: debug-on-entry,  Next: debug-on-quit,  Prev: debug,  Up: Debugging

10.2 `debug-on-entry' _(2004/08/10)_
====================================

関数にエラーがある時，Emacs 21は自動的にデバッガを開始する．Emacs 20以
前では開始せずにエラーメッセージのみを表示する．デバッガは手動で起動し なければなりません．

   すべてのバージョンのEmacs で手動でデバッファを開始できる．自分のコード
にバグがなくてもデバッガを実行しておくと利点がある．いつか，あなたのコー
ドからバグがなくなることだろう．

   `debug-on-entry' を呼んで関数を呼ぶことで，デバッガに入ることができます．

つぎのようにタイプする。

     M-x debug-on-entry RET triangle-bugged RET

続いて、つぎの式を評価する。

     (triangle-bugged 5)

すべてのバージョンのEmacsはバッファ`*Backtrace*'を作成し、
関数`triangle-bugged'を評価し始めたことを伝える。

     ---------- Buffer: *Backtrace* ----------
     Debugger entered--entering a function:
     * triangle-bugged(5)
       eval((triangle-bugged 5))
       eval-last-sexp-1(nil)
       eval-last-sexp(nil)
       call-interactively(eval-last-sexp)
     ---------- Buffer: *Backtrace* ----------

   バッファ`*Backtrace*'の中で、`d'とタイプする。
Emacsは`triangle-bugged'の最初の式を評価し、 バッファはつぎのようになる。

     ---------- Buffer: *Backtrace* ----------
     Debugger entered--beginning evaluation of function call form:
     * (let ((total 0)) (while (> number 0) (setq total ...)
             (setq number ...)) total)
     * triangle-bugged(5)
       eval((triangle-bugged 5))
       eval-last-sexp-1(nil)
       eval-last-sexp(nil)
       call-interactively(eval-last-sexp)
     ---------- Buffer: *Backtrace* ----------

さらに`d'をゆっくりと8回タイプする。
`d'をタイプするたびに、Emacsは関数定義内の別の式を評価する。

   最終的に、バッファはつぎのようになる。

     ---------- Buffer: *Backtrace* ----------
     Debugger entered--beginning evaluation of function call form:
     * (setq number (1= number))
     * (while (> number 0) (setq total (+ total number))
             (setq number (1= number)))
     * (let ((total 0)) (while (> number 0) (setq total ...)
             (setq number ...)) total)
     * triangle-bugged(5)
       eval((triangle-bugged 5))
       eval-last-sexp-1(nil)
       eval-last-sexp(nil)
       call-interactively(eval-last-sexp)
     ---------- Buffer: *Backtrace* ----------

最後にさらに`d'を2回タイプすると、
Emacsはエラーに到達し、バッファ`*Backtrace*'の先頭の2行には つぎのように表示される。

     ---------- Buffer: *Backtrace* ----------
     Debugger entered--Lisp error: (void-function 1=)
     * (1= number)
     ...
     ---------- Buffer: *Backtrace* ----------

   `d'をタイプすることで、関数を順を追って実行することができるのである。

   バッファ`*Backtrace*'を終えるには、`q'とタイプする。
これは、関数の追跡を止めるが、`debug-on-entry'を取り消さない。

   `debug-on-entry'の効果を無効にするには、
つぎのように、`cancel-debug-on-entry'を呼んで関数名を与える。

     M-x cancel-debug-on-entry RET triangle-bugged RET

（Infoで読んでいる場合には、ここで`debug-on-entry'を取り消す。）


File: emacs-lisp-intro-ja.info,  Node: debug-on-quit,  Next: edebug,  Prev: debug-on-entry,  Up: Debugging

10.3 `debug-on-quit'と`(debug)' _(2004/08/10)_
==============================================

`debug-on-error'を設定したり`debug-on-entry'を呼んだりすることに
加えて、`debug'を起動するには別に2つの方法がある。

   変数`debug-on-quit'を`t'に設定すると、
`C-g'（`keyboard-quit'）とタイプすると いつでも`debug'を起動できる。
これは、無限ループのデバッグに役立つ。

   あるいは、つぎのように、コード内のデバッガを起動したい場所に`(debug)'を
入れておくことである。

     (defun triangle-bugged (number)
       "Return sum of numbers 1 through NUMBER inclusive."
       (let ((total 0))
         (while (> number 0)
           (setq total (+ total number))
           (debug)                         ; デバッガを起動
           (setq number (1= number)))      ; ここがエラー
         total))

   関数`debug'は、*note The Lisp Debugger:
(elisp)Debugger.に詳しく記載されている。


File: emacs-lisp-intro-ja.info,  Node: edebug,  Next: Debugging Exercises,  Prev: debug-on-quit,  Up: Debugging

10.4 ソースレベルのデバッガ`edebug' _(2006/04/06)_
==================================================

Edebug はソースレベルのデバッガである．Edebugはデバッグ中のソースコードを表示して、
現在評価中の行の左端に矢印を表示する。

   関数の実行を行ごとに制御したり、実行を停止する
"ブレークポイント（breakpoint）"まで素早く実行させたりできる。

   Edebugは、*note Edebug: (elisp)edebug.  に記載されている。

   バグのある`triangle-recursively'の関数定義をつぎに示す。 復習するには、*Note
Recursive triangle function::。

     (defun triangle-recursively-bugged (number)
       "Return sum of numbers 1 through NUMBER inclusive.
     Uses recursion."
       (if (= number 1)
           1
         (+ number
            (triangle-recursively-bugged
             (1= number)))))               ; ここがエラー

この定義をインストールするには、普通は、関数の閉じ括弧の直後にカーソルを 置いて`C-x
C-e'（`eval-last-sexp'）とタイプするか、
あるいは、定義の途中にカーソルを置いて`C-M-x'（`eval-defun'） とタイプする
（デフォルトでは、コマンド`eval-defun'は、Emacs Lispモードか Lisp
Interactiveモードのみで使える）。

   しかし、この関数定義をEdebugで使うには準備する必要があり、
別のコマンドを使ってコードを処置する必要がある。
定義の途中にカーソルを置いてつぎのようにタイプする。

     M-x edebug-defun RET

これにより、Emacsは必要ならばEdebugを自動的にロードし、 関数を正しく処置する

   関数を処置したら、つぎの式の直後にカーソルを置いて `C-x
C-e'（`eval-last-sexp'）とタイプする。

     (triangle-recursively-bugged 3)

`triangle-recursively-bugged'のソースに戻り、
カーソルが関数の`if'の行の先頭に位置付けされる。
矢印は、関数のどの行を実行中かを示す。(後の例では，矢印を `=>'と
書く．ウィンドウシステムではフリンジに三角形として表示される．)

     =>-!-(if (= number 1)

In the example, the location of point is displayed as `-!-' (in a
printed book, it is displayed with a five pointed star).

   <SPC>を押すと、ポイントはつぎに実行すべき式へ移動し、 つぎのようになる。

     =>(if -!-(= number 1)

<SPC>を押し続けると、ポイントは式のあいだを移動する。
同時に、式が値を返すと、その値がエコー領域に表示される。
たとえば、`number'のあとにポイントが移動したときには、 つぎのように表示される。

     Result: 3 = C-c

これは、`number'の値は3であり、ASCIIコードでは"control-c"
（アルファベットの3番目の文字）であることを意味する。

   エラーに達するまで、コードの中を移動できる。 評価するまえには、その行はつぎのようである。

     =>        -!-(1= number)))))               ; ここがエラー

もう一度<SPC>を押すと、つぎのようなエラーメッセージが表示される。

     Symbol's function definition is void: 1=

これがバグである。

   `q'を押してEdebugを終了する。

   処置した関数定義を削除するには、
単に処置しない普通のコマンドで関数定義を再評価すればよい。
たとえば、関数定義の閉じ括弧の直後にカーソルを 移動して`C-x C-e'とタイプする。

   Edebugでは、関数の中を動き廻るよりも多くのことができる。
エラーを検出したり指定した停止位置に達した場合だけ停止するとか、
さまざまな式の値の変化を表示したり、 関数が何回呼ばれたかを調べたりなどである。

   Edebugは*note Edebug: (elisp)edebug.に記載されている。


File: emacs-lisp-intro-ja.info,  Node: Debugging Exercises,  Prev: edebug,  Up: Debugging

10.5 デバッグの演習問題
=======================

   * 関数`count-words-region'をインストールし、
     これを呼び出すと組み込みのデバッガを起動するようにせよ。
     2つの単語を含んだリージョンに対してこのコマンドを実行せよ。
     `d'を何度も押す必要がある。
     読者のシステムでは、コマンドが終了したあとに「フック」が呼ばれるか？
     （フックについて詳しくは、*note Command Loop Overview: (elisp)Command
     Overview.を参照）

   * `count-words-region'をバッファ`*scratch*'にコピーし、
     `defun'の行のまえの空白を取り去ってから、 Edebug用に関数を処置し、実行を追ってみよ。
     この関数にはバグはないはずであるが、必要ならばバグを入れてみよ。
     関数にバグがなければ、何の問題にも出会わずに実行を完了する。

   * Edebugを実行中に、`?'とタイプしてEdebugのすべてのコマンドを表示してみよ
     （`global-edebug-prefix'は、普通、`C-x X'である。
     つまり、`<CTL>-x'に続けて大文字の`X'である。
     Edebugのバッファ以外でこのキー列を試してみよ）。

   * Edebugバッファにて、`count-words-region'がバッファのどのリージョンで
     動作しているかをコマンド`p'（`edebug-bounce-point'）を 使って調べてみよ。

   * 関数のうしろのほうにポイントを移動して`h'（`edebug-goto-here'）と
     タイプしてその場所へジャンプしてみよ。

   * Edebugに自身の関数をウォークスルーするように
     `t'（`edebug-trace-mode'）コマンドを使ってみよ。
     `edebug-Trace-fast-mode'を使うには大文字の`T'を使う。

   * ブレークポイントを設定し、停止位置に達するまで TraceモードでEdebugを実行してみよ。


File: emacs-lisp-intro-ja.info,  Node: Conclusion,  Next: the-the,  Prev: Debugging,  Up: Top

11 結　論 _(2004/08/10)_
************************

これで、本書の終わりまできた。 値を設定する、自分のために簡単な`.emacs'ファイルを書く、
Emacsの簡単なカスタマイズや拡張を書くなどのEmacs Lispでのプログラミングに
ついて十分に学べたものと思う。

   これで終わりかもしれない。 あるいは、さらに進んで、自習することもあろう。

   プログラミングの基本を少しは学べたはずである。 しかし、ほんの少しである。
ここでは説明しなかった多くのことがらがまだまだある。

   読者が進むべき道は、GNU Emacsのソースや、 *note The GNU Emacs Lisp Reference
Manual: (elisp)Top.

   Emacs Lispのソースは冒険である。
ソースを読み進めているときに、不慣れな関数や式に出会った場合には、
それが何をするものか突き止める必要がある。

   リファレンスマニュアルに進んだとする。 これは、とおしで完全な比較的読みやすいEmacs
Lispの解説である。 経験者向けだけでなく、一般向けでもある （`リファレンスマニュアル'は、
GNU Emacsの標準ディストリビューションに含まれる。
本書のように、Texinfoのソースファイルが付属しているので、
オンラインでも印刷しても読める）。

   GNU Emacsの一部でもあるオンラインヘルプに進むこともできる。
すべての関数にはオンラインヘルプがあり、
`find-tags'はソースファイルへ導くプログラムである。

   筆者はつぎのようにしてソースを探検した。
だいぶまえに、その名前からまず`simple.el'を最初に見てみた。
`simple.el'の関数のいくつかは複雑だったり、少なくとも一見しただけでは 複雑に見えた。
たとえば、関数`open-line' は複雑に見えた．

   関数`forward-sentence'でやったように、読者は、この関数をゆっくりと
ウォークスルーするかもしれない (*Note forward-sentence::.)
あるいは、この関数を飛ばして、`split-line'などの別の関数を 読むかもしれない。
全部の関数を読む必要はない。 `count-words-in-defun'によれば、関数`split-line'には
27個の単語やシンボルが含まれている。

   これは短いが、`split-line'には、説明していない4つの式、
`skip-chars-forward'、`indent-to'、`current-column'、`?\n'が 含まれている。

   関数`skip-chars-forward'を考えてみよう（これは、 *note Review:
Review.で見た`back-to-indentation' の関数定義の一 部である)．

   Emacsでは、`C-h f'（`describe-function'）に
続けて関数名をタイプすれば、`skip-chars-forward'についてさらに調べることができる。
関数の説明文を表示してくれる。

   `indent-to' のように適切な名前の関数は動作を予想することもできるし、
探すこともできる．関数`describe-function'自身は`help.el'にある。
長い関数の1つであるが、読みこなせる関数である。`C-h f'を使って `describe-function'
を実行することで調べることもできる!

   この場合，コードが Lisp で書かれているので，`*Help*' バッファには
関数定義を含むライブラリ名が表示される．ライブラリ名にカーソルを起き， RET キーを入力する
(RET が `help-follow' に割り当てられている時に は)と`M-.'
(`find-tag')と同じように，関数定義へ直接移動できる．

   `describe-function' の定義を見ると，標準的な文字を使わないで `interactive'
式をカスタマイズする方法を見ることができる．そして， 一時的なバッファの作成方法も分かる．

   (関数 `indent-to' はEmacs Lisp ではなく Cで書かれた"組み込み"関数
である．`help-follow' は組み込み関数のドキュメントだけを表示し，
定義箇所へは移動できない．しかし，適切に設定されていれば， `find-tag'
で定義箇所へ移動できる．)

   `M-.'に割り当てられた `find-tag' を使うことで，関数定義を見る
ことができる．最後に、リファレンスマニュアルにあるように、
`i'（`Info-index'）に続けて関数名をタイプして
Infoのマニュアルを見るか、印刷したマニュアルの索引から`skip-chars-forward'を探す。

   `?\n'の意味も同様にして調べられる。 `Info-index'に`?\n'を指定してみる。
これは役立たないことがわかるであろうが、諦めないでほしい。
`?'を付けずに`\n'だけで探すと、マニュアルの関連する節に辿りつける （*Note
Character Type: (elisp)Character Type。 `?\n'は改行を意味する）。

   その他の興味深いファイルは、`paragraphs.el'、`loaddefs.el'、
`loadup.el'である。 ファイル`paragraphs.el'には、長いものもあるが、
短くて理解しやすい関数がある。 ファイル`loaddefs.el'には、標準的な多数のオートロードや
多数のキーマップがある。 筆者もその一部を見ただけで、すべてを見たことはない。
`loadup.el'は、Emacsの標準的なものをロードするためのファイルである。
Emacsの構築方法に関してとても詳しく教えてくれる （構築に関して詳しくは、*Note Building
Emacs: (elisp)Building Emacs）。

   初歩は学べたはずである。 しかし、プログラミングの重要な側面にはふれなかった。
既知の関数`sort'を使う以外には、 情報をソートする方法については説明しなかった。
変数やリストを使うことを除いて、情報の保存方法については説明しなかった。
プログラムを作成するプログラムの書き方については説明しなかった。
これらは、別の話題である。

   GNU Emacsを実用的に使うに十分なことは学べたと思う。 やっと、始めたばかりである。
これで入門を終える。


File: emacs-lisp-intro-ja.info,  Node: the-the,  Next: Kill Ring,  Prev: Conclusion,  Up: Top

Appendix A 関数`the-the' _(2004/08/10)_
***************************************

文書を書いているときに、「you you」などと単語をだぶらせることがある。
筆者は、しばしば「the」をだぶって書いていることに気づいた。
そこで、重複した単語を検出する関数を`the-the'と命名する。

   第1段階としては、重複の検出にはつぎの正規表現が使える。

     \\(\\w+[ \t\n]+\\)\\1

この正規表現は、単語構成文字の1個以上の繰り返しに続いて
空白文字やタブや改行が1個以上続くものに一致する。
しかし、最初の単語の終わりである改行は、2番目の単語の終わりである空白文字とは
異なるので、2行にわたる単語の重複は検出できない （正規表現についてより詳しくは、 *note
Regexp Search::や*note Syntax of Regular Expressions:
(emacs)Regexps.や*note Regular Expressions: (elisp)Regular
Expressions.を参照）。

   パターンは「with the」の「th」のような重複を検出できないので、
単語構成文字の重複の探索を試しても失敗する。

   別の正規表現では、単語構成文字に続けて単語を構成しない文字があり重複部分
が続くようなものを探す。 ここで、`\\w+'は、単語構成文字の1個以上の繰り返しに一致し、
`\\W*'は、単語を構成しない文字の0個以上の繰り返しに一致する。

     \\(\\(\\w+\\)\\W*\\)\\1

これも、役に立たない。

   つぎに、筆者が用いているパターンを示す。 完全ではないが十分である。
`\\b'は、単語の始めや終わりにある空の文字列に一致する。
`[^@ \n\t]+'は、@-記号、空白文字、改行、タブ以外の
任意の文字の1個以上の繰り返しに一致する。

     \\b\\([^@ \n\t]+\\)[ \n\t]+\\1\\b

   より完全な表現を書くことも可能であろうが、 この表現でも十分なのでこれを使っている。

   グローバルキーバインドとともに`.emacs'ファイルに収めた 関数`the-the'をつぎに示す。

     (defun the-the ()
       "Search forward for for a duplicated word."
       (interactive)
       (message "Searching for for duplicated words ...")
       (push-mark)
       ;; This regexp is not perfect
       ;; but is fairly good over all:
       (if (re-search-forward
            "\\b\\([^@ \n\t]+\\)[ \n\t]+\\1\\b" nil 'move)
           (message "Found duplicated word.")
         (message "End of buffer")))

     ;; Bind `the-the' to  C-c \
     (global-set-key "\C-c\\" 'the-the)


   テスト用のテキストを示しておく。

     one two two three four five
     five six seven

   上の関数定義の正規表現を別の正規表現に置き換えることもでき、
それぞれをこのテキストで試すとよい。


File: emacs-lisp-intro-ja.info,  Node: Kill Ring,  Next: Full Graph,  Prev: the-the,  Up: Top

Appendix B キルリングの扱い方
*****************************

キルリングはリストであるが、 関数`rotate-yank-pointer'の働きでリングに変換されている。
コマンド`yank'と`yank-pop'は、 関数`rotate-yank-pointer'を使っている。
本付録では、関数`rotate-yank-pointer'とともに、
コマンド`yank'と`yank-pop'を説明する。

* Menu:

* rotate-yank-pointer::         Move a pointer along a list and around.
* yank::                        Paste a copy of a clipped element.
* yank-pop::                    Insert first element pointed to.


File: emacs-lisp-intro-ja.info,  Node: rotate-yank-pointer,  Next: yank,  Prev: Kill Ring,  Up: Kill Ring

B.1 関数`rotate-yank-pointer' _(2004/08/10)_
============================================

関数`rotate-yank-pointer'は、`kill-ring-yank-pointer'が指す
キルリングの要素を変更する。
たとえば、`kill-ring-yank-pointer'が第2要素を指していたら
第3要素を指すように変更する。

   `rotate-yank-pointer'のコードをつぎに示す。

     (defun rotate-yank-pointer (arg)
       "Rotate the yanking point in the kill ring."
       (interactive "p")
       (let ((length (length kill-ring)))
         (if (zerop length)

             ;; 真の場合の動作
             (error "Kill ring is empty")

           ;; 偽の場合の動作
           (setq kill-ring-yank-pointer
                 (nthcdr (% (+ arg
                               (- length
                                  (length
                                   kill-ring-yank-pointer)))
                            length)
                         kill-ring)))))

* Menu:

* Understanding rotate-yk-ptr::
* rotate-yk-ptr body::          The body of `rotate-yank-pointer'.


File: emacs-lisp-intro-ja.info,  Node: Understanding rotate-yk-ptr,  Next: rotate-yk-ptr body,  Prev: rotate-yank-pointer,  Up: rotate-yank-pointer

`rotate-yank-pointer' の概略
----------------------------

   関数 `rotate-yank-pointer'
は複雑に見えるが、いつものように、部分部分に分解すれば理解できる。 まず、骨格から見てみよう。

     (defun rotate-yank-pointer (arg)
       "Rotate the yanking point in the kill ring."
       (interactive "p")
       (let 変尽ナスト
         本体...)

   この関数は、1つの引数、`arg'を取る。
短い説明文字列があり、小文字の`p'を指定した`interactive'がある。
これは、前置引数を処理した数を引数として関数に渡すことを意味する。

   関数定義の本体は`let'式であり、これには変尽ナストと本体がある。

   `let'式は、この関数内部でのみ使える変数を宣言する。
この変数は、`length'であり、キルリング中の要素数に束縛される。
関数`length'を呼び出してこれを行う （この関数は変数`length'と同じ名前である。
しかし、一方は関数の名称としての使い方であり、 他方は変数の名称としての使い方である。
この2つはまったく異なる。 同様に、英語の話者は、 『I must ship this package
immediately.』と 『I must get aboard the ship immediately.』との`ship'の意味を
区別できる）。

   関数`length'は、リスト内の要素の個数を返すので、 `(length
kill-ring)'は、キルリングにある要素の個数を返す。


File: emacs-lisp-intro-ja.info,  Node: rotate-yk-ptr body,  Prev: Understanding rotate-yk-ptr,  Up: rotate-yank-pointer

B.1.1 `rotate-yank-pointer'の本体 _(2004/08/10)_
------------------------------------------------

`rotate-yank-pointer'の本体は`let'式であり、 `let'式の本体は`if'式である。

   `if'式の目的は、キルリングに何かがあるかどうかを調べることである。
キルリングが空ならば、関数`error'が関数の評価を停止し、
エコー領域にメッセージを表示する。 一方、キルリングに何かがあれば、関数の処理を実施する。

   `if'式の判定条件と真の場合の動作をつぎに示す。

     (if (zerop length)                      ; 判定条件
         (error "Kill ring is empty")        ; 真の場合の動作
       ...

キルリングに何もなければ、その長さは0であるはずなので、 ユーザーにエラーメッセージ`Kill
ring is empty'を表示する。
`if'式では関数`zerop'を用いるが、これは値が0ならば真を返す。
`zerop'が真を返したならば、`if'の真の場合の動作が評価される。
真の場合の動作は、関数`error'で始まるリストである。 これは関数`message'（*note
message::）に似ており、 1行のメッセージをエコー領域に表示する。
しかし、メッセージの表示に加えて、 `error'はこれを含んだ関数の評価を停止させる。
キルリングの長さが0ならば、 関数の残りの部分は評価されないことを意味する。

* Menu:

* Digression concerning error::  How to mislead humans, but not computers.
* rotate-yk-ptr else-part::     The else-part of the `if' expression.
* Remainder Function::          The remainder, `%', function.
* rotate-yk-ptr remainder::     Using `%' in `rotate-yank-pointer'.
* kill-rng-yk-ptr last elt::    Pointing to the last element.


File: emacs-lisp-intro-ja.info,  Node: Digression concerning error,  Next: rotate-yk-ptr else-part,  Prev: rotate-yk-ptr body,  Up: rotate-yk-ptr body

"エラー"という単語へ脱線
........................

   (In my opinion, it is slightly misleading, at least to humans, to use
the term `error' as the name of the `error' function.  A better term
would be `cancel'.  Strictly speaking, of course, you cannot point to,
much less rotate a pointer to a list that has no length, so from the
point of view of the computer, the word `error' is correct.  But a
human expects to attempt this sort of thing, if only to find out
whether the kill ring is full or empty.  This is an act of exploration.
（筆者の意見では、関数 `error' の名前に「error」を使うことは、
少なくとも人間にとっては、少々誤解を招く。 よりよい名前は「cancel」であろう。
厳密にいえば、長さが0のリストを指すポインタをつぎの要素を
指すように巡回できないので、コンピュータの視点からは 「error」は正しい用語である。
しかし、キルリングが満杯か空かを調べるだけでも、 人間はこの種のことを試せるものと考える。
これは、探査行為である。）

   （人間の視点からは、探査行為や発見行為は、必ずしもエラーではなく、
したがって、たとえコンピュータ内部であっても、「error」と呼ぶべきではない。
Emacsのコードでは、高潔に振舞っている人間がその環境を探査していて
エラーを引き起こしたということになる。 これは残念である。
エラーがあった場合にはコンピュータは同じ手順を踏むのであるが、
「cancel」のような用語のほうが、はっきりと意味を表す。）


File: emacs-lisp-intro-ja.info,  Node: rotate-yk-ptr else-part,  Next: Remainder Function,  Prev: Digression concerning error,  Up: rotate-yk-ptr body

`if'式の偽の場合の動作
......................

`if'式の偽の場合の動作は、キルリングに何かがあるときに
`kill-ring-yank-pointer'の値を設定することに費される。 コードはつぎのとおりである。

     (setq kill-ring-yank-pointer
           (nthcdr (% (+ arg
                         (- length
                            (length kill-ring-yank-pointer)))
                      length)
                   kill-ring)))))

   これには説明が必要であろう。 明らかに、`kill-ring-yank-pointer'には、
前節で説明した関数`nthcdr'を使って キルリングのどこかのCDRを設定する（*Note
copy-region-as-kill::）。 これをどうやって行っているのであろう？

   コードの詳細を見るまえに、関数`rotate-yank-pointer'の目的を考えてみよう。

   関数`rotate-yank-pointer'は、
`kill-ring-yank-pointer'が指すものを変更する。
`kill-ring-yank-pointer'がリストの先頭要素を指している場合に
`rotate-yank-pointer'を呼び出すと、2番目の要素を指すように変わる。
`kill-ring-yank-pointer'が2番目の要素を指している場合に
`rotate-yank-pointer'を呼び出すと、3番目の要素を指すように変わる
（また、`rotate-yank-pointer'に1より大きな引数を与えると、
その数だけポインタを進める）。

   関数`rotate-yank-pointer'は、
`kill-ring-yank-pointer'が指すものを再設定するために`setq'を使う。
`kill-ring-yank-pointer'がキルリングの第1要素を指している場合、
もっとも簡単な場合であるが、関数`rotate-yank-pointer'は、
`kill-ring-yank-pointer'が2番目の要素を指すようにする。
いいかえれば、`kill-ring-yank-pointer'には、キルリングのCDRと
同じ値が設定される必要がある。

   つまり、つぎのような場合、

     (setq kill-ring-yank-pointer
        ("some text" "a different piece of text" "yet more text"))

     (setq kill-ring
        ("some text" "a different piece of text" "yet more text"))

コードはつぎのようにする必要がある。

     (setq kill-ring-yank-pointer (cdr kill-ring))

その結果、`kill-ring-yank-pointer'はつぎのようになる。

     kill-ring-yank-pointer
          => ("a different piece of text" "yet more text"))

   実際の`setq'式では関数`nthcdr'を使ってこれを行う。

   すでに見たように（*note nthcdr::）、 関数`nthcdr'は、リストのCDRを繰り返し取る。
CDRのCDRのCDR ...を取る。

   つぎの2つの式は同じ結果になる。

     (setq kill-ring-yank-pointer (cdr kill-ring))

     (setq kill-ring-yank-pointer (nthcdr 1 kill-ring))

   しかし、関数`rotate-yank-pointer'では、`nthcdr'の第1引数は、
多くの算術を含んだ複雑に見える式である。

     (% (+ arg
           (- length
              (length kill-ring-yank-pointer)))
        length)

   いつものように、もっとも内側の式から始めて、外側に向かって調べる必要がある。

   もっとも内側の式は、`(length kill-ring-yank-pointer)'である。
これは、`kill-ring-yank-pointer'の現在の長さを調べる
（`kill-ring-yank-pointer'は、その値がリストである変数の名前である）。

   この長さは、つぎの式の内側にある。

     (- length (length kill-ring-yank-pointer))

この式では、`length'は、関数の始めにある`let'文にて キルリングの長さを設定した変数である
（変数の名前を`length'ではなく`length-of-kill-ring'とすれば、
この関数がより明確になると考える読者がいるかもしれない。
しかし、関数のテキスト全体を見れば短いので、
ここでやっているように関数を小さな部分部分に分解しなければ、
変数を`length'と命名しても邪魔ではない）。

   したがって、`(- length (length kill-ring-yank-pointer))'は、
キルリングの長さと`kill-ring-yank-pointer'のリストの長さの差を取る。

   これが関数`rotate-yank-pointer'にどのように適合するのかを、 つぎの状況で分析してみよう。
`kill-ring'と同じで`kill-ring-yank-pointer'は キルリングの第1要素を指し、
`rotate-yank-pointer'を引数1で呼び出したとする。

   変数`length'はキルリングの長さであり、
`kill-ring-yank-pointer'はキルリング全体を指しているので、
変数`length'と式`(length kill-ring-yank-pointer)'の値は同じである。 そのため、

     (- length (length kill-ring-yank-pointer))

の値は0になる。 `arg'は1なので、式全体では

     (+ arg (- length (length kill-ring-yank-pointer)))

の値は1になる。

   したがって、`nthcdr'の引数は、つぎの式の結果である。

     (% 1 length)


File: emacs-lisp-intro-ja.info,  Node: Remainder Function,  Next: rotate-yk-ptr remainder,  Prev: rotate-yk-ptr else-part,  Up: rotate-yk-ptr body

剰余関数`%'
...........

`(% 1 length)'を理解するには`%'を理解する必要がある。 （`C-h f %
<RET>'とタイプして探した）その説明文によれば、
関数`%'は、第1引数を第2引数で割ったときの余りを返す。
たとえば、5を2で割った余りは1である （2を2倍して余り1を加えると5になる）。

   算術をほとんどしない人には、
小さな数を大きな数で割ることができて余りがあることに驚くかもしれない。 例では、5を2で割った。
逆に、2を5で割った結果はどうなるであろう？　 小数を使えば、答えは、2/5、つまり、0.4である。
しかし、整数しか使えない場合には、結果は異なったものになる。
明らかに、5を0倍すればよいだろうが、余りはいくつだろう？　
答えを探すには、子どものころから馴染み深い場合分けを考える。

   * 5割る5は1で、余りは0；

   * 6割る5は1で、余りは1；

   * 7割る5は1で、余りは2；

   * 同様に、10割る5は2で、余りは0；

   * 11割る5は2で、余りは1；

   * 12割る5は2で、余りは2；

これに対比させると、

   * 0割る5は0で、余りは0であるはず；

   * 1割る5は0で、余りは1であるはず；

   * 2割る5は0で、余りは2であるはず；

などなどである。

   したがって、このコードでは、`length'の値は5なので、

     (% 1 5)

を評価した結果は1である （式の直後にカーソルを置いて`C-x C-e'とタイプして確認した。
もちろん、エコー領域には1と表示される）。


File: emacs-lisp-intro-ja.info,  Node: rotate-yk-ptr remainder,  Next: kill-rng-yk-ptr last elt,  Prev: Remainder Function,  Up: rotate-yk-ptr body

`rotate-yank-pointer'における`%'の利用
......................................

`kill-ring-yank-pointer'がキルリングの先頭を指し、
`rotate-yank-pointer'に渡した引数が1の場合には、 `%'式は1を返す。

     (- length (length kill-ring-yank-pointer))
          => 0

したがって、

     (+ arg (- length (length kill-ring-yank-pointer)))
          => 1

であり、`length'の値に関係なく、

     (% (+ arg (- length (length kill-ring-yank-pointer)))
        length)
          => 1

となる。

   この結果、式`setq kill-ring-yank-pointer'はつぎのように簡約できる。

     (setq kill-ring-yank-pointer (nthcdr 1 kill-ring))

この動作を理解するのは簡単である。
キルリングの第1要素を指していたものが、`kill-ring-yank-pointer'は
第2要素を指すように設定される。

   明らかに、`rotate-yank-pointer'に渡す引数が2の場合、
`kill-ring-yank-pointer'には`(nthcdr 2 kill-ring)'が設定される。
引数に他の値を指定すると変わる。

   同様に、`kill-ring-yank-pointer'がキルリングの第2要素を
指している状態では、その長さはキルリングの長さより1小さいので、 余りの計算は式`(% (+ arg
1) length)'をもとに行われる。 つまり、`rotate-yank-pointer'へ渡す引数が1ならば、
`kill-ring-yank-pointer'は、キルリングの第2要素から第3要素に移動する。


File: emacs-lisp-intro-ja.info,  Node: kill-rng-yk-ptr last elt,  Prev: rotate-yk-ptr remainder,  Up: rotate-yk-ptr body

最後の要素を指す
................

最後の疑問は、`kill-ring-yank-pointer'がキルリングの_最後_の
要素を指しているとどうなるかである。 `rotate-yank-pointer'を呼び出すと、
キルリングからは何も取り出せないのであろうか？　 答えは否である。
これとは異なる有用なことが起こる。
`kill-ring-yank-pointer'は、キルリングの先頭を指すように設定される。

   これがどのように行われるかを、キルリングの長さを5、
`rotate-yank-pointer'に渡す引数を1と仮定して、コードを見てみよう。
`kill-ring-yank-pointer'がキルリングの最後の要素を指していると、 その長さは1である。
コードはつぎのとおりであった。

     (% (+ arg (- length (length kill-ring-yank-pointer))) length)

   変数に数値を入れると、式はつぎのようになる。

     (% (+ 1 (- 5 1)) 5)

もっとも内側の式から外側に向かって評価する。 `(- 5 1)'の値は4、`(+ 1 4)'の合計は5、
5を5で割った余りは0である。 したがって、`rotate-yank-pointer'が実行することは

     (setq kill-ring-yank-pointer (nthcdr 0 kill-ring))

であり、`kill-ring-yank-pointer'はキルリングの先頭を指すように設定される。

   `rotate-yank-pointer'を連続して呼び出すと、 キルリングの最後に達するまでは、
`kill-ring-yank-pointer'はキルリングの要素を順番に指し、先頭に戻る。
リストには終わりがないかのように先頭に戻るので、 キルリングをリングとよぶのである
（リングとは、終わりがないもの？）。


File: emacs-lisp-intro-ja.info,  Node: yank,  Next: yank-pop,  Prev: rotate-yank-pointer,  Up: Kill Ring

B.2 `yank' _(2004/08/10)_
=========================

`rotate-yank-pointer'を理解していれば、関数`yank'は簡単である。
唯一の巧妙な部分は、`rotate-yank-pointer'に渡す引数を計算する部分である。

   コードはつぎのとおりである。

     (defun yank (&optional arg)
       "Reinsert the last stretch of killed text.
     More precisely, reinsert the stretch of killed text most
     recently killed OR yanked.
     With just C-U as argument, same but put point in front
     (and mark at end).  With argument n, reinsert the nth
     most recently killed stretch of killed text.
     See also the command \\[yank-pop]."

       (interactive "*P")
       (rotate-yank-pointer (if (listp arg) 0
                              (if (eq arg '-) -1
                                (1- arg))))
       (push-mark (point))
       (insert (car kill-ring-yank-pointer))
       (if (consp arg)
           (exchange-point-and-mark)))

   このコードをざっと見ると、最後の数行はすぐにわかりそうである。
マークをプッシュする、つまり、記録する。
`kill-ring-yank-pointer'が指す最初の要素（CAR）は挿入するものである。
関数に渡された引数が`cons'ならば、ポイントとマークを交換して、
挿入したテキストの最後ではなく先頭にポイントを移動する。 このオプションは説明文で解説してある。
関数自体は、`"*P"'を指定した対話的なものである。 これは、読み出し専用のバッファでは動作せず、
未処理の前置引数を関数に渡すことを意味する。

* Menu:

* rotate-yk-ptr arg::           Pass the argument to `rotate-yank-pointer'.
* rotate-yk-ptr negative arg::  Pass a negative argument.


File: emacs-lisp-intro-ja.info,  Node: rotate-yk-ptr arg,  Next: rotate-yk-ptr negative arg,  Prev: yank,  Up: yank

引数の渡し方
............

`yank'の難しい部分は、`rotate-yank-pointer'に渡す引数を決定する
ための計算を理解することである。 幸い、一見したほど難しくはない。

   一方あるいは両方の`if'式を評価すると数になり、
その数が`rotate-yank-pointer'に渡される引数となる。

   注釈を付けると、コードはつぎのようになる。

     (if (listp arg)                         ; 判定条件
         0                                   ; 真の場合の動作
       (if (eq arg '-)                       ; 偽の場合の動作、内側のif
           -1                                ; 内側のifの真の場合の動作
         (1- arg))))                         ; 内側のifの偽の場合の動作

このコードは2つの`if'式から成り、 一方の偽の場合の動作に他方が含まれている。

   最初の、つまり、外側の`if'式では、`yank'に渡された引数が リストかどうかを調べる。
奇妙であるが、引数なしで`yank'が呼ばれると、これは真になる。
省略できる引数に渡される値は`nil'であり、 `(listp
nil)'を評価すると真を返すからである。
そこで、`yank'に引数を渡さないと、`yank'の中の
`rotate-yank-pointer'に渡す引数は0である。
つまり、予想どおりに、ポインタは移動されずに、`kill-ring-yank-pointer'が
指す先頭要素が挿入される。 同様に、`yank'への引数が`C-u'であると、これはリストとして読まれ、
この場合も`rotate-yank-pointer'には0が渡される
（`C-u'は、未処理の前置引数である`(4)'となり、 これは1要素のリストである）。
同時に、関数のうしろの部分で、この引数は`cons'であることがわかるので、
ポイントを挿入したテキストの始まりに、 マークを挿入したテキストの終わりに移動する
（`interactive'の引数`P'は、省略可能な引数が略されていたり、
`C-u'だったりした場合にこれらの値を提供するためのものである）。

   外側の`if'式の真の場合の動作では、引数がなかったり`C-u'であった 時，処理を行う。
偽の場合の動作では、それ以外の状況を処理する。 偽の場合の動作自身は、別の`if'式である。

   内側の`if'式では、引数が負かどうかを調べる
（<META>と<->キーを同時に押し下げるか、
<ESC>キーに続けて<->キーを押すとこのようになる）。
この場合には、関数`rotate-yank-pointer'には、 引数として`-1'が渡される。
そうすると`kill-ring-yank-pointer'は逆向きに移動し、望んだ動作となる。

   内側の`if'の判定条件が偽（つまり、引数はマイナス記号ではない）であると、
式の偽の場合の動作が評価される。 これは式`(1- arg)'である。
2つの`if'式のために、引数が正の数か（マイナス記号だけではない）負の数の
場合にこの式が評価される。 `(1- arg)'は、引数から1を引いた値を返す
（`1-'関数は、引数から1を引く）。 つまり、`yank'への引数が1ならば、0に減らされ、
予想どおりに、 `kill-ring-yank-pointer'が指す先頭要素が挿入される。


File: emacs-lisp-intro-ja.info,  Node: rotate-yk-ptr negative arg,  Prev: rotate-yk-ptr arg,  Up: yank

負の引数を渡す
..............

最後に、剰余関数`%'や関数`nthcdr'に負の引数を与えると どうなるのであろうか？

   試してみればわかる。 `(% -1 5)'を評価すると、負の数が返される。
負の数で`nthcdr'を呼び出すと、第1引数が0の場合と同じ値を返す。
つぎのコードを評価するとこのことがわかる。

   `=>'のまえの式を評価すると`=>'のあとに 示した結果になる。
いつものように、コードの直後にカーソルを置いて`C-x C-e'
（`eval-last-sexp'）とタイプして行った。 GNU
EmacsのInfoで読んでいる場合には、読者自身で試してほしい。

     (% -1 5)
          => -1

     (setq animals '(cats dogs elephants))
          => (cats dogs elephants)

     (nthcdr 1 animals)
          => (dogs elephants)

     (nthcdr 0 animals)
          => (cats dogs elephants)

     (nthcdr -1 animals)
          => (cats dogs elephants)

   したがって、`yank'にマイナス記号や負の数を渡すと、
`kill-ring-yank-pointer'は先頭に達するまで逆向きに巡回される。 そして、先頭で止まる。
リストの最後に達するとリストの先頭へ戻ってリングを形成するのとは異なり、 先頭で止まる。
これには意味がある。 なるべく最近に切り取ったテキストの断片を戻したいとしばしば思うだろうが、
30回もまえのキルコマンドからテキストを挿入したくはないであろう。
そこで、終わりに向かってはリングである必要があるが、 逆向きで先頭に戻った場合には巡回しない。

   マイナス記号付きのどんな数を`yank'に渡しても、-1と解釈される。
これはプログラムの記述を明らかに簡単にする。
キルリングの先頭へ向けて一度に1よりも大きく戻る必要はないので、
マイナス記号に続く数の大きさを調べるように関数を書くよりもよほど簡単である。


File: emacs-lisp-intro-ja.info,  Node: yank-pop,  Prev: yank,  Up: Kill Ring

B.3 `yank-pop' _(2004/08/10)_
=============================

`yank'を理解していれば、関数`yank-pop'は簡単である。
場所を節約するために説明文を省くと、つぎのようになる。

     (defun yank-pop (arg)
       (interactive "*p")
       (if (not (eq last-command 'yank))
           (error "Previous command was not a yank"))
       (setq this-command 'yank)
       (let ((before (< (point) (mark))))
         (delete-region (point) (mark))
         (rotate-yank-pointer arg)
         (set-mark (point))
         (insert (car kill-ring-yank-pointer))
         (if before (exchange-point-and-mark))))

   この関数には小文字の`p'を指定した`interactive'があるので、
前置引数は処理してから関数に渡される。
コマンドはyankの直後でのみ使え、それ以外の場合にはエラーメッセージが送られる。
この検査には、すでに説明した変数`last-command'を使っている （*Note
copy-region-as-kill::）。

   `let'節では、ポイントがマークのまえにあるかうしろにあるかに依存して
変数`before'に真か偽を設定し、 ポイントとマークのあいだのリージョンを削除する。
これは直前のyankで挿入したリージョンであり、 この部分のテキストを置き換えるのである。
つぎに、`kill-ring-yank-pointer'を巡回して、
直前に挿入したテキストを再度挿入しないようにする。
新たに挿入するテキストの先頭にマークを設定し、
`kill-ring-yank-pointer'が指す先頭要素をポイントに挿入する。
これにより、テキストの終わりにポイントが置かれる。
直前のyankで挿入したテキストの先頭にポイントを置いてあった場合には、
ポイントとマークを入れ換えて、新たに挿入したテキストの先頭に 再度ポイントを置く。 以上である。


File: emacs-lisp-intro-ja.info,  Node: Full Graph,  Next: GNU Free Documentation License,  Prev: Kill Ring,  Up: Top

Appendix C ラベル付きグラフ _(2004/08/10)_
******************************************

座標軸が表示されていると、グラフの理解に役立つ。 これらは尺度を与えてくれる。
前節（*note Readying a Graph::）では、 グラフの本体を表示するコードを書いた。
ここでは、本体自身に加えて、ラベルを付けた垂直軸と水平軸も 表示するコードを書く。

* Menu:

* Labelled Example::
* print-graph Varlist::         `let' expression in `print-graph'.
* print-Y-axis::                Print a label for the vertical axis.
* print-X-axis::                Print a horizontal label.
* Print Whole Graph::           The function to print a complete graph.


File: emacs-lisp-intro-ja.info,  Node: Labelled Example,  Next: print-graph Varlist,  Prev: Full Graph,  Up: Full Graph

グラフにレベルをつける例
========================

   バッファへの挿入はポイントの右下へ向かって行われるので、
グラフを描く新しい関数では、まず、Y軸、つまり、垂直軸を描いてから、
グラフの本体を描き、最後に、X軸、つまり、水平軸を描く。
この描く順序から、関数の内容が決まる。

  1. コードの初期設定。

  2. Y軸を描く。

  3. グラフの本体を描く。

  4. X軸を描く。

   最終的なグラフはつぎのようになる。

         10 -
                       *
                       *  *
                       *  **
                       *  ***
          5 -      *   *******
                 * *** *******
                 *************
               ***************
          1 - ****************
              |   |    |    |
              1   5   10   15

このグラフでは、垂直と水平の両者の軸に、数字のラベルを付けてある。
しかし、ある種のグラフでは、水平軸は時間であり、つぎのように、
月名のラベルのほうが適することもある。

          5 -      *
                 * ** *
                 *******
               ********** **
          1 - **************
              |    ^      |
              Jan  June   Jan

   もちろん、少々考えれば、垂直／水平軸のさまざまなラベリング方法を考えつく。
われわれの仕事も複雑になる。 複雑さは混乱を招く。
したがって、まずは単純なラベリング方法を選び、 そのあとで修正なり置き換えを行う。

   以上の考察から、関数`print-graph'の概略はつぎのようになる。

     (defun print-graph (numbers-list)
       "逝明文..."
       (let ((height  ...
             ...))
         (print-Y-axis height ... )
         (graph-body-print numbers-list)
         (print-X-axis ... )))

   `print-graph'の関数定義の各部分を順番に扱おう。


File: emacs-lisp-intro-ja.info,  Node: print-graph Varlist,  Next: print-Y-axis,  Prev: Labelled Example,  Up: Full Graph

C.1 `print-graph'の変数リスト _(2004/08/10)_
============================================

関数`print-graph'を書く場合、最初の仕事は、 `let'式の変数リストを書くことである
（関数を対話的にしたり、説明文字列の内容については、 しばらく手をつけないでおく）。

   変数リストでは、数個の変数を設定する。
明らかに、垂直軸のラベルの先頭は少なくともグラフの高さである必要があるので、
この情報をここで得ておく必要がある。
関数`print-graph-body'もこの情報を必要とすることに注意してほしい。
異なる2つの場所でグラフの高さを計算する理由はないので、
ここでの計算を利用するように`print-graph-body'の以前の定義を変更する。

   同様に、X軸を描く関数と関数`print-graph-body'の両者は、
各シンボルの幅を知る必要がある。
この計算もここで行い、`print-graph-body'の以前の定義を変更する。

   水平軸のラベルの長さは少なくともグラフの幅である必要がある。
しかし、この情報は水平軸を描く関数でのみ使われるので、 ここで計算する必要はない。

   以上の考察から、`print-graph'の`let'の変数リストはつぎのようになる。

     (let ((height (apply 'max numbers-list)) ; 第1版
           (symbol-width (length graph-blank)))

あとでわかるように、この式は実は正確ではない。


File: emacs-lisp-intro-ja.info,  Node: print-Y-axis,  Next: print-X-axis,  Prev: print-graph Varlist,  Up: Full Graph

C.2 関数`print-Y-axis' _(2004/08/10)_
=====================================

関数`print-Y-axis'の仕事は、つぎのような垂直軸のラベルを描くことである。

         10 -




          5 -



          1 -

関数にはグラフの高さが渡され、適切な数字や目盛を作成して挿入する。

   Y軸のラベルをどのようにすべきかは図からは簡単にわかるが、
言葉で書き表したり、そのようにする関数定義を書くことはまた別である。
5行ごとに数字や目盛が必要なのではない。
`1'と`5'のあいだには3行（2行目、3行目、4行目）あるが、
`5'と`10'のあいだには4行（6行目、7行目、8行目、9行目）ある。
基準行（数1）には数字と目盛が必要であり、最下行から5行目および5の倍数の行に
数字と目盛が必要であるといい直したほうがよい。

* Menu:

* Height of label::             What height for the Y axis?
* Compute a Remainder::         How to compute the remainder of a division.
* Y Axis Element::              Construct a line for the Y axis.
* Y-axis-column::               Generate a list of Y axis labels.
* print-Y-axis Penultimate::    A not quite final version.


File: emacs-lisp-intro-ja.info,  Node: Height of label,  Next: Compute a Remainder,  Prev: print-Y-axis,  Up: print-Y-axis

ラベルの高さは？
----------------

   つぎの問題は、ラベルの高さをどうすべきかである。
グラフのもっとも大きな高さが7であったとしよう。 Y軸のもっとも大きなラベルを`5 -'にして、
グラフの棒がラベルより高くなってもよいのだろうか？　 あるいは、もっとも大きなラベルを`7
-'にして、 グラフの最大値の目印にするのだろうか？　
あるいは、もっとも大きなラベルを5の倍数の`10 -'にして、
グラフの最大値よりも高くするのだろうか？

   後者が望ましい。 ほとんどのグラフは、刻み幅の倍数の長さの辺の四角形の中に書かれる。
刻み幅が5であれば、辺の長さは、5、10、15、などなどである。
垂直軸の高さを刻み幅の倍数にしようとすると、
変数リストの高さを計算する単純な式はまちがっていることに気づく。 式は`(apply 'max
numbers-list)'であった。 これは、正確に最大の高さを返し、
5の倍数となるような最大数に繰り上げた値を返さない。 より複雑な式が必要である。

   このような場合の常として、小さな複数の問題に分解できれば、 複雑な問題は簡単になる。

   まず、グラフの最大の高さが5の倍数、つまり5、10、15、などの場合を考える。
この値をY軸の高さとして使える。

   数が5の倍数であるかを調べる比較的簡単な方法は、 数を5で割って余りを調べることである。
余りがなければ、数は5の倍数である。 つまり、7を5で割ると余りは2となり、7は5の倍数ではない。
いい方を変えて教室でのことを思い出すと、5を1倍して余り2を足すと7になる。
しかし、5を2倍して余り0を足すと10になり、10は5の倍数である。


File: emacs-lisp-intro-ja.info,  Node: Compute a Remainder,  Next: Y Axis Element,  Prev: Height of label,  Up: print-Y-axis

C.2.1 余りの計算 _(2004/08/10)_
-------------------------------

Lispでは、余りを計算する関数は`%'である。
この関数は、第1引数を第2引数で割った余りを返す。
`%'は、`apropos'を使って探せないEmacs Lispの関数である。 `M-x apropos <RET>
remainder <RET>'とタイプしても何も得られない。
`%'の存在を知る唯一の方法は、本書のような書籍を読むか、 Emacs Lispのソースを読むことである。
関数`%'は、付録で説明している`rotate-yank-pointer'のコードで
使われている（*Note rotate-yk-ptr body::）。

   つぎの2つの式を評価すれば関数`%'を試せる。

     (% 7 5)

     (% 10 5)

最初の式は2を返し、2番目は0を返す。

   返された値が0かどうかを調べるには、関数`zerop'を使う。
この関数は、数である引数が0ならば`t'を返す。

     (zerop (% 7 5))
          => nil

     (zerop (% 10 5))
          => t

   したがって、つぎの式はグラフの高さが5の倍数ならば`t'を返す。

     (zerop (% height 5))

（もちろん、`height'の値は、`(apply 'max numbers-list)'の値である。）

   一方、`height'の値が5の倍数でなかったら、
それより大きなつぎの5の倍数に直したいのである。
これは、すでに馴染みのある関数を使った単純な算術でできる。
まず、`height'の値を5で割って、5の何倍かを調べる。 したがって、12は、5の2倍はある。
この商に1を加えて5を掛けると、高さより大きなつぎの5の倍数の値を得られる。
12は、5の2倍はある。 2に1を加えて、5を掛ける。
結果は15であり、これは12より大きなつぎの5の倍数である。
これに対応するLispの式はつぎのとおりである。

     (* (1+ (/ height 5)) 5)

たとえば、つぎの式を評価すると結果は15である。

     (* (1+ (/ 12 5)) 5)

   これまでの説明では、Y軸の刻み幅として5を使ってきたが、
これ以外の値を使いたい場合もあろう。
一般的には、5のかわりに、値を設定できる変数を使うべきである。
この変数の名前としては`Y-axis-label-spacing'が最適であると思う。

   これを使うと、`if'式はつぎのようになる。

     (if (zerop (% height Y-axis-label-spacing))
         height
       ;; そうでなければ
       (* (1+ (/ height Y-axis-label-spacing))
          Y-axis-label-spacing))

この式は、高さが`Y-axis-label-spacing'の値の倍数ならば`height'の
値を返し、そうでなければ、
`Y-axis-label-spacing'のつぎに大きな倍数を計算してその値を返す。

   （`Y-axis-label-spacing'の値を設定してから）
この式を関数`print-graph'の`let'式に埋め込む。 

     (defvar Y-axis-label-spacing 5
       "Number of lines from one Y axis label to next.")

     ...
     (let* ((height (apply 'max numbers-list))
            (height-of-top-line
             (if (zerop (% height Y-axis-label-spacing))
                 height
               ;; そうでなければ
               (* (1+ (/ height Y-axis-label-spacing))
                  Y-axis-label-spacing)))
            (symbol-width (length graph-blank))))
     ...

（関数`let*'を使っていることに注意してほしい。 高さの初期値を、いったん、式`(apply 'max
numbers-list)'で計算し、 最終的な値を計算するために`height'の値を使っている。
`let*'について詳しくは、*Note fwd-para let::。）


File: emacs-lisp-intro-ja.info,  Node: Y Axis Element,  Next: Y-axis-column,  Prev: Compute a Remainder,  Up: print-Y-axis

C.2.2 Y軸の要素の作成 _(2004/08/10)_
------------------------------------

垂直軸を書くときには、`5 -'や`10 - 'などの文字列を 5行ごとに書きたい。
さらに、数字と目盛をきちんとそろえたいので、 短い数字には空白をまえに埋める必要がある。
数字を2桁で表す文字列がある場合には、
数字が1桁になる文字列では、数字の直前に空白文字を埋める必要がある。

   数の桁数を調べるには、関数`length'を使う。
しかし、関数`length'は文字列のみを扱い、数を扱えない。
そのため、数を文字列に変換する必要がある。 これは関数`number-to-string'で行う。
たとえば、

     (length (number-to-string 35))
          => 2

     (length (number-to-string 100))
          => 3

(`number-to-string' は `int-to-string' とも呼ばれる．さまざ
まなソースで代わりの名前としてみることだろう)

   さらに、各ラベルの数字のあとには` - 'などの文字列が続く。
これを`Y-axis-tic'と呼ぶことにする。 この変数をつぎのように`defvar'で定義する。

     (defvar Y-axis-tic " - "
        "String that follows number in a Y axis label.")

   Y軸のラベルの長さは、Y軸の目盛の長さとグラフの先頭の数字の桁数の総和である。

     (length (concat (number-to-string height) Y-axis-tic)))

   この値は、関数`print-graph'の変数リストで`full-Y-label-width'として 計算する
（始めは、これを変数リストに含めるとは思っていなかった）。

   垂直軸の完全なラベルを作るには、数字に目盛を繋げ、数字の桁数に応じて
それらのまえに空白文字を繋げる。
ラベルは3つの部分、（省略されるかもしれない）空白、数字、目盛から成る。
関数には、特定の行の数の値と、`print-graph'で（一度だけ）計算された 先頭行の幅が渡される。

     (defun Y-axis-element (number full-Y-label-width)
       "Construct a NUMBERed label element.
     A numbered element looks like this `  5 - ',
     and is padded as needed so all line up with
     the element for the largest number."
       (let* ((leading-spaces
              (- full-Y-label-width
                 (length
                  (concat (number-to-string number)
                          Y-axis-tic)))))
         (concat
          (make-string leading-spaces ? )
          (number-to-string number)
          Y-axis-tic)))

   関数`Y-axis-element'は、必要ならばまえに置く空白、
文字列にした数字、目盛を繋げる。

   ラベルに何個の空白が必要かを調べるために、目的とするラベルの幅から、
数字の桁数と目盛の長さを足した実際の目盛の長さを引く。

   関数`make-string'を使って、空白文字を挿入する。 この関数は2つの引数を取る。
第1引数で文字列の長さを指定し、 第2引数には挿入する文字を特別な形式で指定する。 `?
'のように疑問符のあとに空白文字を続ける。 文字の書き方に関する記述は、 *Note Character
Type: (elisp)Character Type。

   関数 `number-to-string'は、文字列を繋げる式で使われており、 数を文字列に変換する。
この文字列には、まえに置く空白文字や目盛が繋げられる。


File: emacs-lisp-intro-ja.info,  Node: Y-axis-column,  Next: print-Y-axis Penultimate,  Prev: Y Axis Element,  Up: print-Y-axis

C.2.3 Y軸のコラムの作成 _(2004/08/10)_
--------------------------------------

これまでの関数は、 垂直軸のラベルとして挿入する数字や空白から成る文字列のリストを
生成する関数を作るために必要なすべての道具を提供する。

     (defun Y-axis-column (height width-of-label)
       "Construct list of Y axis labels and blank strings.
     For HEIGHT of line above base and WIDTH-OF-LABEL."
       (let (Y-axis)
         (while (> height 1)
           (if (zerop (% height Y-axis-label-spacing))
               ;; ラベルを挿入する
               (setq Y-axis
                     (cons
                      (Y-axis-element height width-of-label)
                      Y-axis))
             ;; そうでなければ、空白を挿入する
             (setq Y-axis
                   (cons
                    (make-string width-of-label ? )
                    Y-axis)))
           (setq height (1- height)))
         ;; 基準行を挿入する
         (setq Y-axis
               (cons (Y-axis-element 1 width-of-label) Y-axis))
         (nreverse Y-axis)))

   この関数では、`height'の値から始めて1ずつ減らす。
引き算をするたびに、値が`Y-axis-label-spacing'の倍数かどうかを調べる。
倍数ならば、関数`Y-axis-element'を使って数字を書いたラベルを作る。
そうでなければ、関数`make-string'を使って空白ラベルを作る。
基準行では、数字1のあとに目盛を付ける。


File: emacs-lisp-intro-ja.info,  Node: print-Y-axis Penultimate,  Prev: Y-axis-column,  Up: print-Y-axis

C.2.4 `print-Y-axis'の最終直前版 _(2004/08/10)_
-----------------------------------------------

関数`Y-axis-column'が作成したリストは関数`print-Y-axis'に渡され、
リストをコラムとして挿入する。

     (defun print-Y-axis (height full-Y-label-width)
       "Insert Y axis using HEIGHT and FULL-Y-LABEL-WIDTH.
     Height must be the maximum height of the graph.
     Full width is the width of the highest label element."
     ;; Value of height and full-Y-label-width
     ;; are passed by `print-graph'.
       (let ((start (point)))
         (insert-rectangle
          (Y-axis-column height full-Y-label-width))
         ;; グラフを挿入できるようにポイントを移動
         (goto-char start)
         ;; ポイントを full-Y-label-width だけ進める
         (forward-char full-Y-label-width)))

   `print-Y-axis'は、関数`insert-rectangle'を使って
関数`Y-axis-column'が作成したY軸のラベルを挿入する。
さらに、グラフ本体を書けるようにポイントを正しい位置に移動する。

   つぎのようにして`print-Y-axis'を試せる。

  1. インストールする。

          Y-axis-label-spacing
          Y-axis-tic
          Y-axis-element
          Y-axis-column
          print-Y-axis

  2. つぎの式をコピーする。

          (print-Y-axis 12 5)

  3. バッファ`*scratch*'に切り替え、 軸のラベルを書き始めたい場所にカーソルを移動する。

  4. `M-<ESC>'（`eval-expression'）とタイプする。

  5. `C-y'（`yank'）で、`graph-body-print'式を ミニバッファにヤンクする。

  6. <RET>を押して、式を評価する。

   Emacsは、先頭が`10 - 'であるようなラベルを垂直に表示する
（関数`print-graph'は`height-of-top-line'の値を渡し、 その値は15になる）。


File: emacs-lisp-intro-ja.info,  Node: print-X-axis,  Next: Print Whole Graph,  Prev: print-Y-axis,  Up: Full Graph

C.3 関数`print-X-axis' _(2004/08/10)_
=====================================

X軸のラベルはY軸のラベルに似ているが、目盛は数字の行の上にある。 ラベルはつぎのようである。

         |   |    |    |
         1   5   10   15

   最初の目盛は、グラフの最初のコラムの下にあり、 そのまえには複数の空白文字がある。
これらの空白は、その上にあるY軸のラベルの幅に相当する。
2番目、3番目、4番目、それ以降の目盛はすべて等間隔で、
`X-axis-label-spacing'の値で決まる。

   X軸の第2行目は、空白をまえに置いた数字で、
変数`X-axis-label-spacing'の値で決まる間隔だけ離れている。

   グラフ本体の表示に使うシンボルの幅を変更してもラベルの付き方が
変わらないように、変数`X-axis-label-spacing'の値は、
`symbol-width'を単位とすべきである。

* Menu:

* Similarities differences::    Much like `print-Y-axis', but not exactly.
* X Axis Tic Marks::            Create tic marks for the horizontal axis.


File: emacs-lisp-intro-ja.info,  Node: Similarities differences,  Next: X Axis Tic Marks,  Prev: print-X-axis,  Up: print-X-axis

類似点と相違点
--------------

   関数`print-X-axis'は、関数`print-Y-axis'とほぼ同様に作れるが、
X軸は目盛の行と数字の行の2行であることが異なる。 それぞれを表示する別々の関数を書いて、
それらを関数`print-X-axis'で組み合わせる。

   これは、3段階の処理になる。

  1. X軸の目盛を描く関数`print-X-axis-tic-line'を書く。

  2. X軸の数字を描く関数`print-X-axis-numbered-line'を書く。

  3. `print-X-axis-tic-line'と`print-X-axis-numbered-line'を使って、
     軸の2つの行を描く関数`print-X-axis'を書く。


File: emacs-lisp-intro-ja.info,  Node: X Axis Tic Marks,  Prev: Similarities differences,  Up: print-X-axis

C.3.1 X軸の目盛 _(2004/08/10)_
------------------------------

最初の関数は、X軸の目盛を描く。 目盛自体とその間隔を指定する必要がある。

     (defvar X-axis-label-spacing
       (if (boundp 'graph-blank)
           (* 5 (length graph-blank)) 5)
       "Number of units from one X axis label to next.")

（`graph-blank'の値は、別の`defvar'で設定される。
述語`boundp'は、`graph-blank'に値が設定されたかどうかを調べる。
設定されていない場合には、`boundp'は`nil'を返す。
`graph-blank'が束縛されていない場合に、この条件式を使わないと、 Emacs 21
ではデバッファに入り，エラーメッセージ `Debugger entered--Lisp error:
(void-variable graph-blank)' を得る。）

   以下は `X-axis-tic-symbol' の `defvar' である．

     (defvar X-axis-tic-symbol "|"
       "String to insert to point to a column in X axis.")

   目標はつぎのような行を作ることである。

            |   |    |    |

   最初の目盛は、最初のコラムの下にくるように字下げされるが、
これは、Y軸のラベル幅と同じである。

   目盛の要素は、目盛からつぎの目盛までのあいだの空白文字と、 目盛のシンボルである。
空白の個数は、目盛のシンボルの幅と`X-axis-label-spacing'で決まる。

   コードはつぎのようになる。

     ;;; X-axis-tic-element
     ...
     (concat
      (make-string
       ;; 空白文字の文字列を作る
       (-  (* symbol-width X-axis-label-spacing)
           (length X-axis-tic-symbol))
       ? )
      ;; 空白文字列に目盛のシンボルを繋ぐ
      X-axis-tic-symbol)
     ...

   つぎは、最初の目盛をグラフの最初のコラムに字下げするために必要な空白文字の
個数を決めることである。
関数`print-graph'が`full-Y-label-width'として渡した値を使う。

   `X-axis-leading-spaces'を計算するコードはつぎのとおりである。

     ;; X-axis-leading-spaces
     ...
     (make-string full-Y-label-width ? )
     ...

   水平軸の長さを決める必要もある。
この長さは、数のリストの長さと水平軸の目盛の個数で決まる。

     ;; X-length
     ...
     (length numbers-list)

     ;; tic-width
     ...
     (* symbol-width X-axis-label-spacing)

     ;; number-of-X-tics
     (if (zerop (% (X-length tic-width)))
         (/ (X-length tic-width))
       (1+ (/ (X-length tic-width))))

   以上のことから、X軸の目盛の行を描く関数を書ける。

     (defun print-X-axis-tic-line
       (number-of-X-tics X-axis-leading-spaces X-axis-tic-element)
       "Print tics for X axis."
         (insert X-axis-leading-spaces)
         (insert X-axis-tic-symbol)  ; 最初のコラムの真下
         ;; 2番目の目盛を正しい位置に挿入する
         (insert (concat
                  (make-string
                   (-  (* symbol-width X-axis-label-spacing)
                       ;; Insert white space up to second tic symbol.
                       (* 2 (length X-axis-tic-symbol)))
                   ? )
                  X-axis-tic-symbol))
         ;; 残りの目盛を挿入する
         (while (> number-of-X-tics 1)
           (insert X-axis-tic-element)
           (setq number-of-X-tics (1- number-of-X-tics))))

   数字の行も同じように簡単である。

   まず、空白をまえに置いた数字を作る。

     (defun X-axis-element (number)
       "Construct a numbered X axis element."
       (let ((leading-spaces
              (-  (* symbol-width X-axis-label-spacing)
                  (length (number-to-string number)))))
         (concat (make-string leading-spaces ? )
                 (number-to-string number))))

   つぎに、最初のコラムの直下に描く「1」から始まる数字の行を書く関数を作る。

     (defun print-X-axis-numbered-line
       (number-of-X-tics X-axis-leading-spaces)
       "Print line of X-axis numbers"
       (let ((number X-axis-label-spacing))
         (insert X-axis-leading-spaces)
         (insert "1")
         (insert (concat
                  (make-string
                   ;; つぎの数字までの空白文字を挿入する
                   (-  (* symbol-width X-axis-label-spacing) 2)
                   ? )
                  (number-to-string number)))
         ;; 残りの数字を挿入する
         (setq number (+ number X-axis-label-spacing))
         (while (> number-of-X-tics 1)
           (insert (X-axis-element number))
           (setq number (+ number X-axis-label-spacing))
           (setq number-of-X-tics (1- number-of-X-tics)))))

   最後に、`print-X-axis-tic-line'と`print-X-axis-numbered-line'を
使う`print-X-axis'を書く必要がある。

   関数では、`print-X-axis-tic-line'と`print-X-axis-numbered-line'が
使うローカル変数の値を決定する必要があり、 そのあと、これらの関数を呼び出す。
さらに、2つの行を分ける復帰を書く必要もある。

   関数は、5つのローカル変数を指定する変数リストと、
2つの行のおのおのを描く関数の呼び出しから成る。

     (defun print-X-axis (numbers-list)
       "Print X axis labels to length of NUMBERS-LIST."
       (let* ((leading-spaces
               (make-string full-Y-label-width ? ))
            ;; symbol-width は graph-body-print が与える
            (tic-width (* symbol-width X-axis-label-spacing))
            (X-length (length numbers-list))
            (X-tic
             (concat
              (make-string
               ;; 空白の文字列を作る
               (-  (* symbol-width X-axis-label-spacing)
                   (length X-axis-tic-symbol))
               ? )
              ;; 空白を目盛のシンボルに繋ぐ
              X-axis-tic-symbol))
            (tic-number
             (if (zerop (% X-length tic-width))
                 (/ X-length tic-width)
               (1+ (/ X-length tic-width)))))
         (print-X-axis-tic-line tic-number leading-spaces X-tic)
         (insert "\n")
         (print-X-axis-numbered-line tic-number leading-spaces)))

   `print-X-axis'を試してみよう。

  1. `X-axis-tic-symbol'、`X-axis-label-spacing'、
     `print-X-axis-tic-line'とともに
     `X-axis-element'、`print-X-axis-numbered-line'、
     `print-X-axis'をインストールする。

  2. つぎの式をコピーする。

          (progn
           (let ((full-Y-label-width 5)
                 (symbol-width 1))
             (print-X-axis
              '(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16))))

  3. バッファ`*scratch*'に切り替え、 軸のラベルを描き始める場所にカーソルを置く。

  4. `M-<ESC>'（`eval-expression'）とタイプする。

  5. `C-y'（`yank'）でテスト用の式をミニバッファにヤンクする。

  6. <RET>を押して式を評価する。

   Emacsはつぎのように水平軸を表示する。

          |   |    |    |    |
          1   5   10   15   20


File: emacs-lisp-intro-ja.info,  Node: Print Whole Graph,  Prev: print-X-axis,  Up: Full Graph

C.4 グラフ全体の表示 _(2004/08/11)_
===================================

グラフ全体を表示する準備ができた。

   正しいラベルを付けたグラフを描く関数は、 まえに作った概略（*note Full
Graph::） とほぼ同じであるが多少追加点もある。

   つぎに概略を示す。

     (defun print-graph (numbers-list)
       "逝明文..."
       (let ((height  ...
             ...))
         (print-Y-axis height ... )
         (graph-body-print numbers-list)
         (print-X-axis ... )))

* Menu:

* The final version::           A few changes.
* Test print-graph::            Run a short test.
* Graphing words in defuns::    Executing the final code.
* lambda::                      How to write an anonymous function.
* mapcar::                      Apply a function to elements of a list.
* Another Bug::                 Yet another bug ... most insidious.
* Final printed graph::         The graph itself!


File: emacs-lisp-intro-ja.info,  Node: The final version,  Next: Test print-graph,  Prev: Print Whole Graph,  Up: Print Whole Graph

最終版での変更
--------------

   最終版は、計画したものと2つの点で異なる。
第一に、変数リストには一度だけ計算する値が追加してある。
第二に、ラベルの行間隔を指定するオプションを持つことである。
後者の機能は本質的であり、これがないと、1画面や1ページに収まらない グラフができてしまう。

   この新しい機能のためには、`vertical-step'を追加するように
関数`Y-axis-column'を変更する必要がある。 関数はつぎのようになる。

     ;;; 最終版
     (defun Y-axis-column
       (height width-of-label &optional vertical-step)
       "Construct list of labels for Y axis.
     HEIGHT is maximum height of graph.
     WIDTH-OF-LABEL is maximum width of label.
     VERTICAL-STEP, an option, is a positive integer
     that specifies how much a Y axis label increments
     for each line.  For example, a step of 5 means
     that each line is five units of the graph."
       (let (Y-axis
             (number-per-line (or vertical-step 1)))
         (while (> height 1)
           (if (zerop (% height Y-axis-label-spacing))
               ;; ラベルを挿入する
               (setq Y-axis
                     (cons
                      (Y-axis-element
                       (* height number-per-line)
                       width-of-label)
                      Y-axis))
             ;; そうでなければ、空白を挿入する
             (setq Y-axis
                   (cons
                    (make-string width-of-label ? )
                    Y-axis)))
           (setq height (1- height)))
         ;; 基準行を挿入する
         (setq Y-axis (cons (Y-axis-element
                             (or vertical-step 1)
                             width-of-label)
                            Y-axis))
         (nreverse Y-axis)))

   グラフの最大の高さとシンボルの幅は、`print-graph'の`let'式で 計算される。
そこで、`graph-body-print'がこれらの値を受け取るように変更する必要がある。

     ;;; 最終版
     (defun graph-body-print (numbers-list height symbol-width)
       "Print a bar graph of the NUMBERS-LIST.
     The numbers-list consists of the Y-axis values.
     HEIGHT is maximum height of graph.
     SYMBOL-WIDTH is number of each column."
       (let (from-position)
         (while numbers-list
           (setq from-position (point))
           (insert-rectangle
            (column-of-graph height (car numbers-list)))
           (goto-char from-position)
           (forward-char symbol-width)
           ;; コラムごとにグラフを描く
           (sit-for 0)
           (setq numbers-list (cdr numbers-list)))
         ;; X軸のラベル用に、ポイントを移動する
         (forward-line height)
         (insert "\n")))

   最後に、関数`print-graph'のコードを示す。

     ;;; 最終版
     (defun print-graph
       (numbers-list &optional vertical-step)
       "Print labelled bar graph of the NUMBERS-LIST.
     The numbers-list consists of the Y-axis values.

     Optionally, VERTICAL-STEP, a positive integer,
     specifies how much a Y axis label increments for
     each line.  For example, a step of 5 means that
     each row is five units."
       (let* ((symbol-width (length graph-blank))
              ;; `height' は、最大の数であり
              ;; 表示幅がもっとも大きくなる
              (height (apply 'max numbers-list))
              (height-of-top-line
               (if (zerop (% height Y-axis-label-spacing))
                   height
                 ;; そうでなければ
                 (* (1+ (/ height Y-axis-label-spacing))
                    Y-axis-label-spacing)))
              (vertical-step (or vertical-step 1))
              (full-Y-label-width
               (length
                (concat
                 (number-to-string
                  (* height-of-top-line vertical-step))
                 Y-axis-tic))))

         (print-Y-axis
          height-of-top-line full-Y-label-width vertical-step)
         (graph-body-print
          numbers-list height-of-top-line symbol-width)
         (print-X-axis numbers-list)))


File: emacs-lisp-intro-ja.info,  Node: Test print-graph,  Next: Graphing words in defuns,  Prev: The final version,  Up: Print Whole Graph

C.4.1 `print-graph'のテスト _(2004/08/10)_
------------------------------------------

関数`print-graph'を数の短いリストで試してみよう。

  1. `Y-axis-column'、`graph-body-print'、`print-graph'
     （および、残りのコード）をインストールする。

  2. つぎの式をコピーする。

          (print-graph '(3 2 5 6 7 5 3 4 6 4 3 2 1))

  3. バッファ`*scratch*'に切り替え、 軸のラベルを描き始めたい場所にカーソルを置く。

  4. `M-<ESC>'（`eval-expression'）とタイプする。

  5. `C-y'（`yank'）で、ミニバッファにテスト用の式をヤンクする。

  6. <RET>を押し、式を評価する。

   Emacsはつぎのようなグラフを表示する。

     10 -


              *
             **   *
      5 -   ****  *
            **** ***
          * *********
          ************
      1 - *************

          |   |    |    |
          1   5   10   15

   一方、`vertical-step'の値として2を`print-graph'に渡す つぎの式を評価すると、

     (print-graph '(3 2 5 6 7 5 3 4 6 4 3 2 1) 2)

グラフはつぎのようになる。

     20 -


              *
             **   *
     10 -   ****  *
            **** ***
          * *********
          ************
      2 - *************

          |   |    |    |
          1   5   10   15

（垂直軸の最後が「2」であるのは、バグであろうか機能であろうか？　
バグと考えるのであれば、かわりに「1」（あるいは、「0」）を表示するように
ソースを直せばよい。）


File: emacs-lisp-intro-ja.info,  Node: Graphing words in defuns,  Next: lambda,  Prev: Test print-graph,  Up: Print Whole Graph

C.4.2 単語やシンボルの個数のグラフ _(2004/08/11)_
-------------------------------------------------

グラフ作成に必要なコードはすべて書いた。 単語やシンボルの個数が10個未満の関数定義はいくつ、
10から19個のものはいくつ、20から29個のものはいくつ、 などなどを示すグラフである。

   これは、多段の処理である。 まず、必要なコードをすべてロードしてあることを確認する。

   `top-of-ranges'の値を変えてしまった場合に備えて、
`top-of-ranges'の値を再設定しておこう。 つぎの式を評価する。

     (setq top-of-ranges
      '(10  20  30  40  50
        60  70  80  90 100
       110 120 130 140 150
       160 170 180 190 200
       210 220 230 240 250
       260 270 280 290 300)

つぎは、各範囲に属する単語やシンボルの個数のリストを作る。

   つぎの式を評価する。

     (setq list-for-graph
            (defuns-per-range
              (sort
               (recursive-lengths-list-many-files
                (directory-files "/usr/local/emacs/lisp"
                                 t ".+el$"))
               '<)
              top-of-ranges))

筆者のマシンでは、1時間ほど掛かる。 Emacs第19.23版の303個のLispのファイルを調べる。
処理が完了すると、`list-for-graph'にはつぎのような値が入る。

     (537 1027 955 785 594 483 349 292 224 199 166 120 116 99
     90 80 67 48 52 45 41 33 28 26 25 20 12 28 11 13 220)

つまり、筆者の場合、単語やシンボルの個数が10個未満の関数定義は537、
10から19個のものは1027、20から29個のものは955、などなどである。

   明らかに、このリストを見るだけで、
ほとんどの関数定義では10から30個の単語やシンボルが含まれことがわかる。

   ではグラフを描こう。 しかし、1030行もの高さのグラフを描きたいわけではない。
高さが25行よりも低いグラフを描きたい。
画面や1ページの紙に簡単に収まるような高さのグラフである。

   これには、`list-for-graph'の各値を1/50に減らす必要がある。

   まだ説明していない2つの関数`mapcar'と`lambda'を使うと、 つぎの小さな関数でできる。

     (defun one-fiftieth (full-range)
       "Return list, each number one-fiftieth of previous."
      (mapcar '(lambda (arg) (/ arg 50)) full-range))


File: emacs-lisp-intro-ja.info,  Node: lambda,  Next: mapcar,  Prev: Graphing words in defuns,  Up: Print Whole Graph

C.4.3 `lambda'式：便利な無名性 _(2004/08/11)_
---------------------------------------------

`lambda'は、関数名を持たない無名関数を表すシンボルである。
無名関数を使う場合には、その本体を含める必要がある。

つまり、

     (lambda (arg) (/ arg 50))

は、「`arg'として渡されたものを50で割った商を返す」ような関数定義である。

   たとえば、まえに、関数`multiply-by-seven'があった。 それは、引数を7倍した。
引数を50で割ることと、名前がないことを除けば、この関数も似ている。
`multiply-by-seven'に等価な無名関数は、つぎのようになる。

     (lambda (number) (* 7 number))

（*Note defun::。）

3を7倍したければ、つぎのように書ける。

     (multiply-by-seven 3)
      \_______________/ ^
              |         |
            関数      引数



この式は、21を返す。

   同様に、つぎのようにも書ける。

     ((lambda (number) (* 7 number)) 3)
      \____________________________/ ^
                    |                |
                無名関数           引数



100を50で割りたければ、つぎのように書ける。

     ((lambda (arg) (/ arg 50)) 100)
      \______________________/  \_/
                  |              |
              無名関数         引数



この式は、2を返す。 関数には100が渡され、50で割られるのである。

   `lambda'について詳しくは、*Note Lambda Expressions: (elisp)Lambda
Expressions。 Lispとlambda式は、λ計算（Lambda Calculus）から導かれたのである。


File: emacs-lisp-intro-ja.info,  Node: mapcar,  Next: Another Bug,  Prev: lambda,  Up: Print Whole Graph

C.4.4 関数`mapcar' _(2004/08/11)_
---------------------------------

`mapcar'は、順番に、第2引数の各要素で第1引数を呼び出す。 第2引数は並びであること。

   この名前の`map'部分は数学的用語 "mapping over a domain" (ある機能
をある範囲に属する各要素に適用すること)に由来する．数学的用語は征服者
が一度に一箇所ずつ征服している領域を巡回することの隠喩である．そして， もちろん
`car'はリストの最初を意味する Lisp の概念に由来する．

たとえば、

     (mapcar '1+ '(2 4 6))
          => (3 5 7)

引数に1を加える関数`1+'が、リストの各要素に対して実行され、 新たなリストが返される。

   これと、第1引数を残りのものに適用する`apply'とを対比してほしい
（`apply'の説明は、 *Note Readying a Graph::）。

   `one-fiftieth'の定義では、第1引数はつぎの無名関数である。

     (lambda (arg) (/ arg 50))

そして、第2引数は`full-range'であり、 `list-for-graph'に束縛される。

   式全体はつぎのようになる。

     (mapcar '(lambda (arg) (/ arg 50)) full-range))

   `mapcar'について 詳しくは、*Note Mapping Functions: (elisp)Mapping
Functions。

   関数`one-fiftieth'を使って、
`list-for-graph'の各要素を1/50にした要素からなるリストを作れる。

     (setq fiftieth-list-for-graph
           (one-fiftieth list-for-graph))

   結果はつぎのようになる。

     (10 20 19 15 11 9 6 5 4 3 3 2 2
     1 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 4)

書くための準備は、これでほとんど整った （情報の欠落があることに注意してほしい。
上位の範囲の多くは0であるが、それらの範囲にある単語やシンボルの個数の
`defun'の数が50より小さいことを意味し、 必ずしも`defun'の数が0ではない）。


File: emacs-lisp-intro-ja.info,  Node: Another Bug,  Next: Final printed graph,  Prev: mapcar,  Up: Print Whole Graph

C.4.5 別のバグ ... もっとも潜在的 _(2004/08/11)_
------------------------------------------------

「ほとんど整った」といったのは、関数`print-graph'にはバグがあるのである。
`vertical-step'のオプションはあるが、 `horizontal-step'のオプションはない。
`top-of-range'は、10間隔で10から300まである。
しかし、関数`print-graph'は、1ずつ描く。

   これは、もっとも潜在的なバグの典型的なものであり、 無視したことによるバグである。
機能としては存在しないので、コードに書かれておらず、 コードを調べてもこの種のバグは発見できない。
最良の行動は、プログラムを初期の段階で何回もテストすることであり、
コードを可能な限り理解しやすく変更しやすくしておくことである。
たとえすぐにではなくても、最終的には、書いたコードは書き直すことになることを 理解しておいてほしい。
実行するのは難しい格言である。

   関数`print-X-axis-numbered-line'を直す必要がある。
そして、関数`print-X-axis'と`print-graph'も、 対応するように直す必要がある。
多くを直す必要はない。 ちょっとしたことが1つである。 目盛に数字を合わせるだけである。
これには少々考える必要がある。

   つぎに修正した`print-X-axis-numbered-line'を示す。

     (defun print-X-axis-numbered-line
       (number-of-X-tics X-axis-leading-spaces
        &optional horizontal-step)
       "Print line of X-axis numbers"
       (let ((number X-axis-label-spacing)
             (horizontal-step (or horizontal-step 1)))
         (insert X-axis-leading-spaces)
         ;; まえにある余分な空白を削除する
         (delete-char
          (- (1-
              (length (number-to-string horizontal-step)))))
         (insert (concat
                  (make-string
                   ;; 空白を挿入する
                   (-  (* symbol-width
                          X-axis-label-spacing)
                       (1-
                        (length
                         (number-to-string horizontal-step)))
                       2)
                   ? )
                  (number-to-string
                   (* number horizontal-step))))
         ;; 残りの数を挿入する
         (setq number (+ number X-axis-label-spacing))
         (while (> number-of-X-tics 1)
           (insert (X-axis-element
                    (* number horizontal-step)))
           (setq number (+ number X-axis-label-spacing))
           (setq number-of-X-tics (1- number-of-X-tics)))))

   Infoで読んでいる場合には、
新しい版の`print-X-axis'や`print-graph'もあるので、これらを評価する。
印刷物で読んでいる場合には、変更した行をつぎに示してある （コードを全体は多すぎる）。

     (defun print-X-axis (numbers-list horizontal-step)
       "Print X axis labels to length of NUMBERS-LIST.
     Optionally, HORIZONTAL-STEP, a positive integer,
     specifies how much an X  axis label increments for
     each column."
     ;; Value of symbol-width and full-Y-label-width
     ;; are passed by `print-graph'.
       (let* ((leading-spaces
               (make-string full-Y-label-width ? ))
             ;; symbol-width は graph-body-print が与える
            (tic-width (* symbol-width X-axis-label-spacing))
            (X-length (length numbers-list))
            (X-tic
             (concat
              (make-string
               ;; 空白文字の文字列を作る
               (-  (* symbol-width X-axis-label-spacing)
                   (length X-axis-tic-symbol))
               ? )
              ;; 空白を目盛のシンボルに繋げる
              X-axis-tic-symbol))
            (tic-number
             (if (zerop (% X-length tic-width))
                 (/ X-length tic-width)
               (1+ (/ X-length tic-width)))))

         (print-X-axis-tic-line
          tic-number leading-spaces X-tic)
         (insert "\n")
         (print-X-axis-numbered-line
          tic-number leading-spaces horizontal-step)))

     (defun print-graph
       (numbers-list &optional vertical-step horizontal-step)
       "Print labelled bar graph of the NUMBERS-LIST.
     The numbers-list consists of the Y-axis values.

     Optionally, VERTICAL-STEP, a positive integer,
     specifies how much a Y axis label increments for
     each line.  For example, a step of 5 means that
     each row is five units.

     Optionally, HORIZONTAL-STEP, a positive integer,
     specifies how much an X  axis label increments for
     each column."
       (let* ((symbol-width (length graph-blank))
              ;; `height' は最大の数であり
              ;; 表示幅がもっとも大きい
              (height (apply 'max numbers-list))
              (height-of-top-line
               (if (zerop (% height Y-axis-label-spacing))
                   height
                 ;; そうでなければ
                 (* (1+ (/ height Y-axis-label-spacing))
                    Y-axis-label-spacing)))
              (vertical-step (or vertical-step 1))
              (full-Y-label-width
               (length
                (concat
                 (number-to-string
                  (* height-of-top-line vertical-step))
                 Y-axis-tic))))
         (print-Y-axis
          height-of-top-line full-Y-label-width vertical-step)
         (graph-body-print
             numbers-list height-of-top-line symbol-width)
         (print-X-axis numbers-list horizontal-step)))


File: emacs-lisp-intro-ja.info,  Node: Final printed graph,  Prev: Another Bug,  Up: Print Whole Graph

C.4.6 グラフ _(2004/08/10)_
---------------------------

インストールしたら、コマンド`print-graph'をつぎのようにして呼ぶ。

     (print-graph fiftieth-list-for-graph 50 10)

   グラフはつぎのとおりである。



     1000 -  *
             **
             **
             **
             **
      750 -  ***
             ***
             ***
             ***
             ****
      500 - *****
            ******
            ******
            ******
            *******
      250 - ********
            *********                     *
            ***********                   *
            *************                 *
       50 - ***************** *           *
            |   |    |    |    |    |    |    |
           10  50  100  150  200  250  300  350



   関数のもっとも大きなグループは、10から19個の単語やシンボルを含むものである。


File: emacs-lisp-intro-ja.info,  Node: GNU Free Documentation License,  Next: Index,  Prev: Full Graph,  Up: Top

Appendix D GNU Free Documentation License _(2004/08/11)_
********************************************************

                        Version 1.1, March 2000

     Copyright (C) 2000 Free Software Foundation, Inc.
     59 Temple Place, Suite 330, Boston, MA  02111-1307, USA

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

  0. PREAMBLE

     The purpose of this License is to make a manual, textbook, or other
     written document "free" in the sense of freedom: to assure everyone
     the effective freedom to copy and redistribute it, with or without
     modifying it, either commercially or noncommercially.  Secondarily,
     this License preserves for the author and publisher a way to get
     credit for their work, while not being considered responsible for
     modifications made by others.

     This License is a kind of "copyleft", which means that derivative
     works of the document must themselves be free in the same sense.
     It complements the GNU General Public License, which is a copyleft
     license designed for free software.

     We have designed this License in order to use it for manuals for
     free software, because free software needs free documentation: a
     free program should come with manuals providing the same freedoms
     that the software does.  But this License is not limited to
     software manuals; it can be used for any textual work, regardless
     of subject matter or whether it is published as a printed book.
     We recommend this License principally for works whose purpose is
     instruction or reference.

  1. APPLICABILITY AND DEFINITIONS

     This License applies to any manual or other work that contains a
     notice placed by the copyright holder saying it can be distributed
     under the terms of this License.  The "Document", below, refers to
     any such manual or work.  Any member of the public is a licensee,
     and is addressed as "you".

     A "Modified Version" of the Document means any work containing the
     Document or a portion of it, either copied verbatim, or with
     modifications and/or translated into another language.

     A "Secondary Section" is a named appendix or a front-matter
     section of the Document that deals exclusively with the
     relationship of the publishers or authors of the Document to the
     Document's overall subject (or to related matters) and contains
     nothing that could fall directly within that overall subject.
     (For example, if the Document is in part a textbook of
     mathematics, a Secondary Section may not explain any mathematics.)
     The relationship could be a matter of historical connection with
     the subject or with related matters, or of legal, commercial,
     philosophical, ethical or political position regarding them.

     The "Invariant Sections" are certain Secondary Sections whose
     titles are designated, as being those of Invariant Sections, in
     the notice that says that the Document is released under this
     License.

     The "Cover Texts" are certain short passages of text that are
     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
     that says that the Document is released under this License.

     A "Transparent" copy of the Document means a machine-readable copy,
     represented in a format whose specification is available to the
     general public, whose contents can be viewed and edited directly
     and straightforwardly with generic text editors or (for images
     composed of pixels) generic paint programs or (for drawings) some
     widely available drawing editor, and that is suitable for input to
     text formatters or for automatic translation to a variety of
     formats suitable for input to text formatters.  A copy made in an
     otherwise Transparent file format whose markup has been designed
     to thwart or discourage subsequent modification by readers is not
     Transparent.  A copy that is not "Transparent" is called "Opaque".

     Examples of suitable formats for Transparent copies include plain
     ASCII without markup, Texinfo input format, LaTeX input format,
     SGML or XML using a publicly available DTD, and
     standard-conforming simple HTML designed for human modification.
     Opaque formats include PostScript, PDF, proprietary formats that
     can be read and edited only by proprietary word processors, SGML
     or XML for which the DTD and/or processing tools are not generally
     available, and the machine-generated HTML produced by some word
     processors for output purposes only.

     The "Title Page" means, for a printed book, the title page itself,
     plus such following pages as are needed to hold, legibly, the
     material this License requires to appear in the title page.  For
     works in formats which do not have any title page as such, "Title
     Page" means the text near the most prominent appearance of the
     work's title, preceding the beginning of the body of the text.

  2. VERBATIM COPYING

     You may copy and distribute the Document in any medium, either
     commercially or noncommercially, provided that this License, the
     copyright notices, and the license notice saying this License
     applies to the Document are reproduced in all copies, and that you
     add no other conditions whatsoever to those of this License.  You
     may not use technical measures to obstruct or control the reading
     or further copying of the copies you make or distribute.  However,
     you may accept compensation in exchange for copies.  If you
     distribute a large enough number of copies you must also follow
     the conditions in section 3.

     You may also lend copies, under the same conditions stated above,
     and you may publicly display copies.

  3. COPYING IN QUANTITY

     If you publish printed copies of the Document numbering more than
     100, and the Document's license notice requires Cover Texts, you
     must enclose the copies in covers that carry, clearly and legibly,
     all these Cover Texts: Front-Cover Texts on the front cover, and
     Back-Cover Texts on the back cover.  Both covers must also clearly
     and legibly identify you as the publisher of these copies.  The
     front cover must present the full title with all words of the
     title equally prominent and visible.  You may add other material
     on the covers in addition.  Copying with changes limited to the
     covers, as long as they preserve the title of the Document and
     satisfy these conditions, can be treated as verbatim copying in
     other respects.

     If the required texts for either cover are too voluminous to fit
     legibly, you should put the first ones listed (as many as fit
     reasonably) on the actual cover, and continue the rest onto
     adjacent pages.

     If you publish or distribute Opaque copies of the Document
     numbering more than 100, you must either include a
     machine-readable Transparent copy along with each Opaque copy, or
     state in or with each Opaque copy a publicly-accessible
     computer-network location containing a complete Transparent copy
     of the Document, free of added material, which the general
     network-using public has access to download anonymously at no
     charge using public-standard network protocols.  If you use the
     latter option, you must take reasonably prudent steps, when you
     begin distribution of Opaque copies in quantity, to ensure that
     this Transparent copy will remain thus accessible at the stated
     location until at least one year after the last time you
     distribute an Opaque copy (directly or through your agents or
     retailers) of that edition to the public.

     It is requested, but not required, that you contact the authors of
     the Document well before redistributing any large number of
     copies, to give them a chance to provide you with an updated
     version of the Document.

  4. MODIFICATIONS

     You may copy and distribute a Modified Version of the Document
     under the conditions of sections 2 and 3 above, provided that you
     release the Modified Version under precisely this License, with
     the Modified Version filling the role of the Document, thus
     licensing distribution and modification of the Modified Version to
     whoever possesses a copy of it.  In addition, you must do these
     things in the Modified Version:

       A. Use in the Title Page (and on the covers, if any) a title
          distinct from that of the Document, and from those of
          previous versions (which should, if there were any, be listed
          in the History section of the Document).  You may use the
          same title as a previous version if the original publisher of
          that version gives permission.

       B. List on the Title Page, as authors, one or more persons or
          entities responsible for authorship of the modifications in
          the Modified Version, together with at least five of the
          principal authors of the Document (all of its principal
          authors, if it has less than five).

       C. State on the Title page the name of the publisher of the
          Modified Version, as the publisher.

       D. Preserve all the copyright notices of the Document.

       E. Add an appropriate copyright notice for your modifications
          adjacent to the other copyright notices.

       F. Include, immediately after the copyright notices, a license
          notice giving the public permission to use the Modified
          Version under the terms of this License, in the form shown in
          the Addendum below.

       G. Preserve in that license notice the full lists of Invariant
          Sections and required Cover Texts given in the Document's
          license notice.

       H. Include an unaltered copy of this License.

       I. Preserve the section entitled "History", and its title, and
          add to it an item stating at least the title, year, new
          authors, and publisher of the Modified Version as given on
          the Title Page.  If there is no section entitled "History" in
          the Document, create one stating the title, year, authors,
          and publisher of the Document as given on its Title Page,
          then add an item describing the Modified Version as stated in
          the previous sentence.

       J. Preserve the network location, if any, given in the Document
          for public access to a Transparent copy of the Document, and
          likewise the network locations given in the Document for
          previous versions it was based on.  These may be placed in
          the "History" section.  You may omit a network location for a
          work that was published at least four years before the
          Document itself, or if the original publisher of the version
          it refers to gives permission.

       K. In any section entitled "Acknowledgments" or "Dedications",
          preserve the section's title, and preserve in the section all
          the substance and tone of each of the contributor
          acknowledgments and/or dedications given therein.

       L. Preserve all the Invariant Sections of the Document,
          unaltered in their text and in their titles.  Section numbers
          or the equivalent are not considered part of the section
          titles.

       M. Delete any section entitled "Endorsements".  Such a section
          may not be included in the Modified Version.

       N. Do not retitle any existing section as "Endorsements" or to
          conflict in title with any Invariant Section.

     If the Modified Version includes new front-matter sections or
     appendices that qualify as Secondary Sections and contain no
     material copied from the Document, you may at your option
     designate some or all of these sections as invariant.  To do this,
     add their titles to the list of Invariant Sections in the Modified
     Version's license notice.  These titles must be distinct from any
     other section titles.

     You may add a section entitled "Endorsements", provided it contains
     nothing but endorsements of your Modified Version by various
     parties--for example, statements of peer review or that the text
     has been approved by an organization as the authoritative
     definition of a standard.

     You may add a passage of up to five words as a Front-Cover Text,
     and a passage of up to 25 words as a Back-Cover Text, to the end
     of the list of Cover Texts in the Modified Version.  Only one
     passage of Front-Cover Text and one of Back-Cover Text may be
     added by (or through arrangements made by) any one entity.  If the
     Document already includes a cover text for the same cover,
     previously added by you or by arrangement made by the same entity
     you are acting on behalf of, you may not add another; but you may
     replace the old one, on explicit permission from the previous
     publisher that added the old one.

     The author(s) and publisher(s) of the Document do not by this
     License give permission to use their names for publicity for or to
     assert or imply endorsement of any Modified Version.

  5. COMBINING DOCUMENTS

     You may combine the Document with other documents released under
     this License, under the terms defined in section 4 above for
     modified versions, provided that you include in the combination
     all of the Invariant Sections of all of the original documents,
     unmodified, and list them all as Invariant Sections of your
     combined work in its license notice.

     The combined work need only contain one copy of this License, and
     multiple identical Invariant Sections may be replaced with a single
     copy.  If there are multiple Invariant Sections with the same name
     but different contents, make the title of each such section unique
     by adding at the end of it, in parentheses, the name of the
     original author or publisher of that section if known, or else a
     unique number.  Make the same adjustment to the section titles in
     the list of Invariant Sections in the license notice of the
     combined work.

     In the combination, you must combine any sections entitled
     "History" in the various original documents, forming one section
     entitled "History"; likewise combine any sections entitled
     "Acknowledgments", and any sections entitled "Dedications".  You
     must delete all sections entitled "Endorsements."

  6. COLLECTIONS OF DOCUMENTS

     You may make a collection consisting of the Document and other
     documents released under this License, and replace the individual
     copies of this License in the various documents with a single copy
     that is included in the collection, provided that you follow the
     rules of this License for verbatim copying of each of the
     documents in all other respects.

     You may extract a single document from such a collection, and
     distribute it individually under this License, provided you insert
     a copy of this License into the extracted document, and follow
     this License in all other respects regarding verbatim copying of
     that document.

  7. AGGREGATION WITH INDEPENDENT WORKS

     A compilation of the Document or its derivatives with other
     separate and independent documents or works, in or on a volume of
     a storage or distribution medium, does not as a whole count as a
     Modified Version of the Document, provided no compilation
     copyright is claimed for the compilation.  Such a compilation is
     called an "aggregate", and this License does not apply to the
     other self-contained works thus compiled with the Document, on
     account of their being thus compiled, if they are not themselves
     derivative works of the Document.

     If the Cover Text requirement of section 3 is applicable to these
     copies of the Document, then if the Document is less than one
     quarter of the entire aggregate, the Document's Cover Texts may be
     placed on covers that surround only the Document within the
     aggregate.  Otherwise they must appear on covers around the whole
     aggregate.

  8. TRANSLATION

     Translation is considered a kind of modification, so you may
     distribute translations of the Document under the terms of section
     4.  Replacing Invariant Sections with translations requires special
     permission from their copyright holders, but you may include
     translations of some or all Invariant Sections in addition to the
     original versions of these Invariant Sections.  You may include a
     translation of this License provided that you also include the
     original English version of this License.  In case of a
     disagreement between the translation and the original English
     version of this License, the original English version will prevail.

  9. TERMINATION

     You may not copy, modify, sublicense, or distribute the Document
     except as expressly provided for under this License.  Any other
     attempt to copy, modify, sublicense or distribute the Document is
     void, and will automatically terminate your rights under this
     License.  However, parties who have received copies, or rights,
     from you under this License will not have their licenses
     terminated so long as such parties remain in full compliance.

 10. FUTURE REVISIONS OF THIS LICENSE

     The Free Software Foundation may publish new, revised versions of
     the GNU Free Documentation License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.  See
     `http://www.gnu.org/copyleft/'.

     Each version of the License is given a distinguishing version
     number.  If the Document specifies that a particular numbered
     version of this License "or any later version" applies to it, you
     have the option of following the terms and conditions either of
     that specified version or of any later version that has been
     published (not as a draft) by the Free Software Foundation.  If
     the Document does not specify a version number of this License,
     you may choose any version ever published (not as a draft) by the
     Free Software Foundation.


File: emacs-lisp-intro-ja.info,  Node: Index,  Next: About the Author,  Prev: GNU Free Documentation License,  Up: Top

索引
****

 [index ]
* Menu:

* % （剰余関数）:                           Compute a Remainder. (line   6)
* (debug)（コード内）:                    debug-on-quit.       (line  13)
* * （乗算）:                              defun.               (line  79)
* * 読み出し専用バッファ用:                     Read-only buffer.    (line   6)
* .emacsファイル（簡単な拡張）:               Simple Extension.    (line   6)
* / （除算）:                             Large buffer case.   (line  29)
* > (より大きい):                         if in more detail.   (line  27)
* and:                                   kill-new function.   (line 163)
* and, introduced:                       kill-new function.   (line 163)
* Anonymous function:                    lambda.              (line   6)
* append-to-buffer:                      append-to-buffer.    (line   6)
* beginning-of-buffer:                   beginning-of-buffer. (line   6)
* buffer-file-name:                      Buffer Names.        (line   6)
* buffer-name:                           Buffer Names.        (line   6)
* C, a digression into:                  Digression into C.   (line   6)
* cancel-debug-on-entry:                 debug-on-entry.      (line  82)
* car, 紹介:                              car cdr & cons.      (line   6)
* cdr, 紹介:                              car cdr & cons.      (line   6)
* Chest of Drawers, metaphor for a symbol: Symbols as Chest.  (line   6)
* Common Lisp:                           Lisp History.        (line   9)
* concat:                                Data types.          (line   9)
* condition-case:                        condition-case.      (line   6)
* Conditional 'twixt two versions of Emacs: Simple Extension. (line  35)
* cons, example:                         kill-new function.   (line  86)
* cons, 紹介:                             cons.                (line   6)
* copy-region-as-kill:                   copy-region-as-kill. (line   6)
* copy-to-buffer:                        copy-to-buffer.      (line   6)
* current-buffer:                        Getting Buffers.     (line   6)
* Cへ回り道:                               Digression into C.   (line   6)
* debug:                                 debug.               (line   6)
* debug-on-entry:                        debug-on-entry.      (line   6)
* debug-on-quit:                         debug-on-quit.       (line   9)
* default-mode-line-format:              Mode Line.           (line   6)
* defun:                                 defun.               (line   6)
* defunスペシャルフォーム:                 defun.               (line   6)
* defvar:                                defvar.              (line   6)
* defvar for a user customizable variable: defvar and asterisk.
                                                              (line   6)
* defvar with an asterisk:               defvar and asterisk. (line   6)
* delete-and-extract-region <1>:         delete-and-extract-region.
                                                              (line   6)
* delete-and-extract-region:             Digression into C.   (line   6)
* describe-function:                     simplified-beginning-of-buffer.
                                                              (line  70)
* describe-function, 紹介:                Finding More.        (line   6)
* Digression into C:                     Digression into C.   (line   6)
* Drawers, Chest of, metaphor for a symbol: Symbols as Chest. (line   6)
* edebug:                                edebug.              (line   6)
* edit-options:                          defvar and asterisk. (line  24)
* Else:                                  else.                (line   6)
* Emacs Lispの真偽値:                     Truth & Falsehood.   (line   6)
* Emacs version, choosing:               Simple Extension.    (line  35)
* Emacs のバージョンを選択:                Simple Extension.    (line  35)
* empty string defined:                  Review.              (line 125)
* eq:                                    Review.              (line 100)
* eq （使用例）:                          last-command & this-command.
                                                              (line  26)
* equal:                                 Review.              (line 100)
* error:                                 rotate-yk-ptr body.  (line  14)
* Error for symbol without function:     Void Function.       (line   6)
* Example variable, fill-column:         fill-column Example. (line   6)
* FDL, GNU Free Documentation License:   GNU Free Documentation License.
                                                              (line   6)
* fill-column, an example variable:      fill-column Example. (line   6)
* find-tags:                             Finding More.        (line  31)
* Flowers in a field:                    Lisp Lists.          (line  15)
* function defined:                      Making Errors.       (line  46)
* graph-body-print 最終版:                The final version.   (line  51)
* if:                                    if.                  (line   6)
* ifによる判定:                            if.                  (line   6)
* insert-buffer:                         insert-buffer.       (line   6)
* insert-buffer-substring:               append-to-buffer overview.
                                                              (line   6)
* interactive:                           Interactive.         (line   6)
* interactive, 使用例:                   insert-buffer interactive.
                                                              (line   6)
* interactiveのオプション:                 Interactive Options. (line   6)
* kill-append:                           kill-append function.
                                                              (line   6)
* kill-new:                              kill-new function.   (line   6)
* kill-region:                           kill-region.         (line   6)
* lambda:                                lambda.              (line   6)
* length:                                length.              (line   6)
* let:                                   let.                 (line   6)
* let式の構造:                             Parts of let Expression.
                                                              (line   6)
* let式の非初期化変数:                    Uninitialized let Variables.
                                                              (line   6)
* let式の例:                             Sample let Expression.
                                                              (line   6)
* line-to-top-of-window:                 Simple Extension.    (line   6)
* Lisp macro:                            delete-and-extract-region.
                                                              (line  42)
* Lispの歴史:                            Lisp History.        (line   6)
* Lispインタープリタ（説明）:                  Run a Program.       (line  36)
* Lispインタープリタの動作:                     Lisp Interpreter.    (line   6)
* local variable defined:                Prevent confusion.   (line   6)
* Maclisp:                               Lisp History.        (line   9)
* Macro, lisp:                           delete-and-extract-region.
                                                              (line  42)
* make-string:                           Y Axis Element.      (line  64)
* mapcar:                                mapcar.              (line   6)
* mark:                                  save-excursion.      (line   6)
* mark-whole-buffer:                     mark-whole-buffer.   (line   6)
* message:                               message.             (line   6)
* nil:                                   Truth & Falsehood.   (line   6)
* nil、単語の歴史:                        Buffer Names.        (line  64)
* nth:                                   nth.                 (line   6)
* nthcdr <1>:                            nthcdr.              (line   6)
* nthcdr:                                copy-region-as-kill. (line   6)
* nthcdr, example:                       kill-new function.   (line 120)
* number-to-string:                      Y Axis Element.      (line  11)
* optional:                              Optional Arguments.  (line  10)
* or:                                    Insert or.           (line  12)
* other-buffer:                          Getting Buffers.     (line   6)
* point:                                 save-excursion.      (line   6)
* print-graph 最終版:                     The final version.   (line  73)
* print-graphの変数リスト:                  print-graph Varlist. (line   6)
* print-X-axis:                          X Axis Tic Marks.    (line 139)
* print-X-axis-numbered-line:            X Axis Tic Marks.    (line 110)
* print-X-axis-tic-line:                 X Axis Tic Marks.    (line  78)
* print-Y-axis:                          print-Y-axis Penultimate.
                                                              (line   9)
* progn:                                 progn.               (line   9)
* rotate-yank-pointer:                   rotate-yank-pointer. (line   6)
* save-excursion:                        save-excursion.      (line   6)
* save-restriction:                      save-restriction.    (line   6)
* search-forward:                        search-forward.      (line   6)
* set:                                   Using set.           (line   6)
* set-buffer:                            Switching Buffers.   (line   6)
* setcar:                                setcar.              (line   6)
* setcdr:                                setcdr.              (line   6)
* setcdr, example:                       kill-new function.   (line 123)
* setq:                                  Using setq.          (line   6)
* simplified-beginning-of-buffer:        simplified-beginning-of-buffer.
                                                              (line   6)
* switch-to-buffer:                      Switching Buffers.   (line   6)
* Symbol without function error:         Void Function.       (line   6)
* Symbols as a Chest of Drawers:         Symbols as Chest.    (line   6)
* the-the:                               the-the.             (line   6)
* triangle-bugged:                       debug.               (line  12)
* Variable, example of, fill-column:     fill-column Example. (line   6)
* Version of Emacs, choosing:            Simple Extension.    (line  35)
* what-line:                             what-line.           (line   6)
* Words, duplicated:                     the-the.             (line   6)
* X-axis-element:                        X Axis Tic Marks.    (line 100)
* X軸の表示:                              print-X-axis.        (line   6)
* Y-axis-column:                         Y-axis-column.       (line   9)
* Y-axis-column 最終版:                   The final version.   (line  14)
* Y-axis-label-spacing:                  Compute a Remainder. (line  70)
* Y-axis-tic:                            Y Axis Element.      (line  28)
* yank:                                  yank.                (line   6)
* yank-pop:                              yank-pop.            (line   6)
* Y軸の表示:                              print-Y-axis.        (line   6)
* zap-to-char:                           zap-to-char.         (line   6)
* zerop:                                 rotate-yk-ptr body.  (line  14)
* 束縛（bind）（定義）:                     set & setq.          (line   6)
* 単語の重複:                               the-the.             (line   6)
* 判定条件（if-part）（定義）:             if in more detail.   (line   6)
* 表示（グラフ全体）:                       Print Whole Graph.   (line   6)
* 表示（垂直軸）:                           print-Y-axis.        (line   6)
* 表示（水平軸）:                           print-X-axis.        (line   6)
* 評価:                                   Evaluation.          (line   6)
* 評価、内側のリスト:                         Evaluating Inner Lists.
                                                              (line   6)
* 評価（evaluate）（定義）:                Run a Program.       (line   6)
* 評価の練習:                               Practicing Evaluation.
                                                              (line   6)
* 文字列（string）（定義）:                Lisp Atoms.          (line  54)
* 無名関数:                                   lambda.              (line   6)
* テキストの削除:                           Cutting & Storing Text.
                                                              (line   6)
* テキストのカット:                          Cutting & Storing Text.
                                                              (line   6)
* テキストのキル:                           Cutting & Storing Text.
                                                              (line   6)
* テキストの保存:                           Cutting & Storing Text.
                                                              (line   6)
* データ型:                               Data types.          (line   6)
* デバッガ（ソースレベル）:                   edebug.              (line   6)
* デバッグ:                                 Debugging.           (line   6)
* ナロイング（narrowing）（定義）:              Buffer Size & Locations.
                                                              (line  35)
* ナロイング:                                 Narrowing & Widening.
                                                              (line   6)
* バッファ:                                 Buffer Names.        (line  48)
* バッファの取得:                            Getting Buffers.     (line   6)
* バッファの切り替え:                         Switching Buffers.   (line   6)
* バッファサイズ:                           Buffer Size & Locations.
                                                              (line   6)
* バイトコンパイル:                         Byte Compiling.      (line   6)
* フォーム（form）（定義）:                Lisp Atoms.          (line  20)
* プログラムの実行:                           Run a Program.       (line   6)
* ポイント、マーク、バッファの保存:             save-excursion.      (line   6)
* ポイント（point）（定義）:                Buffer Size & Locations.
                                                              (line  18)
* ポイントの位置:                           Buffer Size & Locations.
                                                              (line   6)
* モード行の形式:                             Mode Line.           (line   6)
* ライブラリ:                               Finding More.        (line  52)
* リージョン:                              save-excursion.      (line   6)
* リストの実装方法:                           List Implementation. (line   6)
* リスト:                                  Lisp Lists.          (line   6)
* リスト内の空白:                           Whitespace in Lists. (line   6)
* リスト入力補佐機能:                        Typing Lists.        (line   6)
* ワイドニングの例:                            what-line.           (line   6)
* ワイドニング:                               Narrowing & Widening.
                                                              (line   6)
* アトム:                                 Lisp Atoms.          (line   6)
* アスタリスク（読み出し専用バッファ）:           Read-only buffer.    (line   6)
* インタープリタの動作:                         Lisp Interpreter.    (line   6)
* エラー（値のないシンボル）:                  Void Variable.       (line   6)
* エラーメッセージの生成:                  Making Errors.       (line   6)
* カット（テキスト）:                         Cutting & Storing Text.
                                                              (line   6)
* キーワード:                              Optional Arguments.  (line  10)
* キルリングの扱い方:                        Kill Ring.           (line   6)
* グラフ全体の表示:                        Print Whole Graph.   (line   6)
* コードの恒久的インストール:                   Permanent Installation.
                                                              (line   6)
* コマンド（command）（定義）:              How to Evaluate.     (line  10)
* シンボリック式（紹介）:                    Lisp Atoms.          (line  20)
* シンボル名:                               Names & Definitions. (line   6)
* スペシャルフォーム:                      Complications.       (line  11)
* タグテーブル:                             Finding More.        (line  31)
* 引数:                                  Arguments.           (line   6)
* 引数（可変個数）:                         Variable Number of Arguments.
                                                              (line   6)
* 引数（型の誤り）:                        Wrong Type of Argument.
                                                              (line   6)
* 引数（省略可能）:                         Optional Arguments.  (line  10)
* 引数（argument）（定義）:               Arguments.           (line  14)
* 引数のデータ型:                          Data types.          (line   6)
* 引数リスト（argument list）（定義）:       defun.               (line  48)
* 可変個数の引数:                           Variable Number of Arguments.
                                                              (line   6)
* 関数（function）（定義）:                Making Errors.       (line  94)
* 関数（無名）:                               lambda.              (line   6)
* 関数のソース:                            Finding More.        (line  11)
* 関数の説明:                             Finding More.        (line   6)
* 関数へ渡す情報:                          Arguments.           (line   6)
* 関数定義（function definition）（定義）: defun.               (line   6)
* 関数定義の書き方:                        Writing Defuns.      (line   6)
* 関数定義のインストール:                      Install.             (line   6)
* 関数定義の変更:                          Change a defun.      (line   6)
* 簡単な拡張:                               Simple Extension.    (line   6)
* 基本操作関数:                           Primitive Functions. (line   6)
* 空リスト（定義）:                         Lisp Atoms.          (line  14)
* 呼び出し（call）（定義）:                  Switching Buffers.   (line  56)
* 字下げ <1>:                                append save-excursion.
                                                              (line  13)
* 字下げ:                                    Typing Lists.        (line   6)
* 式（expression）（定義）:               Lisp Atoms.          (line  20)
* 除算:                                    Large buffer case. (line  29)
* 剰余関数%:                               Compute a Remainder. (line   6)
* 数え上げ:                                  Counting.            (line   6)
* 真の場合の動作（then-part）（定義）:      if in more detail.   (line   6)
* 真偽値:                                Truth & Falsehood.   (line   6)
* 垂直軸の表示:                            print-Y-axis.        (line   6)
* 水平軸の表示:                            print-X-axis.        (line   6)
* 潜在的なバグ:                             Another Bug.         (line   6)
* 対話的関数:                              Interactive.         (line   6)
* 対話的関数（interactive function）（定義）: How to Evaluate.   (line  10)
* 注釈:                                  Change a defun.      (line  19)
* 読み出し専用バッファ:                         Read-only buffer.    (line   6)
* 内側のリストの評価:                          Evaluating Inner Lists.
                                                              (line   6)
* 二重引用符のあいだのテキスト:              Lisp Atoms.          (line  50)
* 副作用（side effect）（定義）:           Evaluation.          (line  18)
* 変数:                                   Variables.           (line   6)
* 変数（値の設定）:                         set & setq.          (line   6)
* 変数の初期化:                              defvar.            (line   6)
* 変数への値の設定:                          set & setq.          (line   6)
* 変数リスト（varlist）（定義）:              Parts of let Expression.
                                                              (line   6)
* 本体（body）（定義）:                    defun.               (line  30)


File: emacs-lisp-intro-ja.info,  Node: About the Author,  Prev: Index,  Up: Top

著者について
************

     Robert J. Chassellは、1985年以来GNU Emacsの仕事をしている。
     執筆や編集、EmacsとEmacs Lispを教えており、世界中でソフトウェアの自由
     に関する講演を行っている．Chassellは Free Software Foundation, Inc. の
     理事、幹事／会計でもある。彼は，Texinfo マニュアルの共著者であり，1ダー
     ス以上の本を執筆している．彼はイギリスのケンブリッジ大学を卒業し
     た．社会史や経済史に興味を持っており、自家用飛行機を操縦する。

    



Tag Table:
Node: Top903
Node: PrePreface19530
Ref: PrePreface-Footnote-123555
Node: Preface23613
Node: Why25142
Node: On Reading this Text25649
Node: Who You Are27502
Node: Lisp History29666
Node: Note for Novices30323
Node: Thank You32367
Node: List Processing32838
Node: Lisp Lists34150
Node: Numbers Lists34958
Node: Lisp Atoms36048
Node: Whitespace in Lists39098
Node: Typing Lists40243
Node: Run a Program41189
Node: Making Errors43312
Node: Names & Definitions47789
Node: Lisp Interpreter49252
Node: Complications50295
Node: Byte Compiling51686
Node: Evaluation52654
Node: Evaluating Inner Lists54087
Node: Variables55989
Node: fill-column Example57344
Node: Void Function58612
Node: Void Variable59884
Node: Arguments61540
Ref: Arguments-Footnote-163001
Node: Data types63643
Node: Args as Variable or List65222
Node: Variable Number of Arguments66496
Node: Wrong Type of Argument67224
Node: message70303
Ref: message-Footnote-173350
Node: set & setq73479
Node: Using set74124
Node: Using setq75953
Node: Counting77769
Node: Summary79290
Node: Error Message Exercises80735
Node: Practicing Evaluation81176
Node: How to Evaluate82247
Node: Buffer Names83521
Node: Getting Buffers87738
Ref: Getting Buffers-Footnote-189837
Node: Switching Buffers90036
Ref: Switching Buffers-Footnote-193284
Ref: Switching Buffers-Footnote-293434
Node: Buffer Size & Locations93651
Node: Evaluation Exercise95264
Node: Writing Defuns95536
Node: Primitive Functions96768
Node: defun97782
Node: Install102621
Node: Effect of installation103747
Node: Change a defun104438
Node: Interactive105804
Node: Interactive multiply-by-seven106690
Node: multiply-by-seven in detail108239
Node: Interactive Options110330
Node: Permanent Installation112676
Node: let114323
Node: Prevent confusion115387
Node: Parts of let Expression116925
Node: Sample let Expression118129
Node: Uninitialized let Variables119540
Node: if120795
Node: if in more detail121562
Node: type-of-animal in detail123673
Node: else125529
Node: Truth & Falsehood127852
Node: nil explained128628
Node: save-excursion130149
Node: Point and mark130866
Node: Template for save-excursion133435
Node: Review134449
Node: defun Exercises140464
Node: Buffer Walk Through140820
Node: Finding More141850
Node: simplified-beginning-of-buffer145052
Node: mark-whole-buffer148459
Node: mark-whole-buffer overview149206
Node: Body of mark-whole-buffer150230
Node: append-to-buffer152858
Node: append-to-buffer overview153534
Node: append interactive155274
Node: append-to-buffer body156306
Node: append save-excursion157901
Node: Buffer Related Review162176
Node: Buffer Exercises163826
Node: More Complex164209
Node: copy-to-buffer164984
Node: insert-buffer167388
Node: insert-buffer code168352
Node: insert-buffer interactive169343
Node: Read-only buffer169812
Node: b for interactive170337
Node: insert-buffer body170996
Node: if & or171972
Node: Insert or174504
Node: Insert let176209
Node: beginning-of-buffer179109
Node: Optional Arguments180184
Node: beginning-of-buffer opt arg182202
Node: Disentangle beginning-of-buffer183012
Node: Large buffer case184044
Node: Small buffer case185611
Node: beginning-of-buffer complete186834
Node: Second Buffer Related Review188660
Node: optional Exercise189855
Node: Narrowing & Widening190211
Node: Narrowing advantages190818
Node: save-restriction192327
Node: what-line193948
Node: narrow Exercise196704
Node: car cdr & cons197160
Node: Strange Names198078
Node: car & cdr198930
Node: cons203144
Node: Build a list203728
Ref: Build a list-Footnote-1204977
Node: length205167
Node: nthcdr206561
Node: nth208888
Node: setcar210154
Node: setcdr211854
Node: cons Exercise212886
Node: Cutting & Storing Text213231
Node: Storing Text214442
Node: zap-to-char216085
Node: zap-to-char interactive217195
Node: zap-to-char body219560
Node: search-forward220217
Node: progn222492
Node: Summing up zap-to-char223659
Node: kill-region224549
Node: Complete kill-region225456
Node: condition-case227946
Node: delete-and-extract-region230217
Node: Digression into C233849
Ref: Digression into C-Footnote-1238527
Node: defvar238674
Node: See variable current value240112
Node: defvar and asterisk241714
Node: copy-region-as-kill243185
Node: Complete copy-region-as-kill244050
Node: copy-region-as-kill body246456
Node: last-command & this-command247368
Node: kill-append function248858
Node: kill-new function251892
Node: cons & search-fwd Review260578
Node: search Exercises262855
Node: List Implementation263502
Node: Lists diagrammed264424
Node: Symbols as Chest269643
Node: Simple Extension271584
Ref: Simple Extension-Footnote-1274696
Node: X11 Colors274890
Ref: X11 Colors-Footnote-1276814
Node: Miscellaneous276950
Node: Mode Line277873
Node: Debugging282870
Node: debug283658
Node: debug-on-entry286471
Node: debug-on-quit289571
Node: edebug290554
Node: Debugging Exercises293754
Node: Conclusion295323
Node: the-the299962
Node: Kill Ring302340
Node: rotate-yank-pointer302958
Node: Understanding rotate-yk-ptr304078
Node: rotate-yk-ptr body305376
Node: Digression concerning error306957
Node: rotate-yk-ptr else-part308439
Node: Remainder Function312556
Node: rotate-yk-ptr remainder313912
Node: kill-rng-yk-ptr last elt315264
Node: yank316675
Node: rotate-yk-ptr arg318316
Node: rotate-yk-ptr negative arg320929
Node: yank-pop322560
Node: Full Graph324164
Node: Labelled Example324907
Node: print-graph Varlist326670
Node: print-Y-axis327931
Node: Height of label329067
Node: Compute a Remainder330531
Node: Y Axis Element333521
Node: Y-axis-column336358
Node: print-Y-axis Penultimate337813
Node: print-X-axis339525
Node: Similarities differences340520
Node: X Axis Tic Marks341151
Node: Print Whole Graph347548
Node: The final version348534
Node: Test print-graph352611
Node: Graphing words in defuns354106
Node: lambda356258
Node: mapcar357739
Node: Another Bug359380
Node: Final printed graph364646
Node: GNU Free Documentation License365598
Node: Index384241
Node: About the Author404705

End Tag Table
