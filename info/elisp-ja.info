-*-coding:utf-8-*-
This is elisp-ja, produced by makeinfo version 4.13 from elisp.texi.

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Elisp-ja: (elisp-ja).	The Emacs Lisp Reference Manual.
END-INFO-DIR-ENTRY

   Emacs Lispリファレンスマニュアル2.9版であり、 Emacs
21.3版に対応します。

   Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA  02111-1307  USA

   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,
2000, 2002 Free Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License", with the
Front-Cover texts being "A GNU Manual", and with the Back-Cover Texts
as in (a) below.  A copy of the license is included in the section
entitled "GNU Free Documentation License".

   (a) The FSF's Back-Cover Text is: "You have freedom to copy and
modify this GNU Manual, like GNU software.  Copies published by the Free
Software Foundation raise funds for GNU development."


File: elisp-ja,  Node: Top,  Next: Introduction,  Prev: (dir),  Up: (dir)

   このinfoファイルは、GNU Emacs Lispマニュアル 2.9版であり、 GNU Emacs
21.3版に対応します。

   旧版の翻訳である elisp-manual-20-2.5-jp.tgz
(ftp://ftp.ascii.co.jp/pub/GNU/elisp-manual-20/elisp-manual-20-2.5-jp.tgz)
を参考に最新版の変更点を追加しています。元文書の翻訳をされた方々に深く
感謝いたします。

また、「コメント」と書いてある部分は私が追加した部分です。また、分かり
にく部分などは原文の意味を曲げない範囲で、加筆を行っています。

   分かりにくい、意味不明だ、用語が統一されていないなどありましたら、
akihisa@mail.ne.jpまでメール (mailto:akihisa@mail.ne.jp)にて連
絡をお願いいたします。あるいは、各章の右上にあるコメントからWikiに書き
込みをお願いします。

またこの文書は原文のライセンスを継承しますので、再配布、コピー、変更な
どはすべて自由にしていただいて構いません。

* Menu:

* Introduction::            Introduction and conventions used.
* Standards: Coding Conventions.    Coding conventions for Emacs Lisp.

* Lisp Data Types::         Data types of objects in Emacs Lisp.
* Numbers::                 Numbers and arithmetic functions.
* Strings and Characters::  Strings, and functions that work on them.
* Lists::                   Lists, cons cells, and related functions.
* Sequences Arrays Vectors::  Lists, strings and vectors are called sequences.
                                Certain functions act on any kind of sequence.
                                The description of vectors is here as well.
* Hash Tables::             Very fast lookup-tables.
* Symbols::                 Symbols represent names, uniquely.

* Evaluation::              How Lisp expressions are evaluated.
* Control Structures::      Conditionals, loops, nonlocal exits.
* Variables::               Using symbols in programs to stand for values.
* Functions::               A function is a Lisp program
                              that can be invoked from other functions.
* Macros::                  Macros are a way to extend the Lisp language.
* Customization::           Writing customization declarations.

* Loading::                 Reading files of Lisp code into Lisp.
* Byte Compilation::        Compilation makes programs run faster.
* Advising Functions::      Adding to the definition of a function.
* Debugging::               Tools and tips for debugging Lisp programs.

* Read and Print::          Converting Lisp objects to text and back.
* Minibuffers::             Using the minibuffer to read input.
* Command Loop::            How the editor command loop works,
                              and how you can call its subroutines.
* Keymaps::                 Defining the bindings from keys to commands.
* Modes::                   Defining major and minor modes.
* Documentation::           Writing and using documentation strings.

* Files::                   Accessing files.
* Backups and Auto-Saving:: Controlling how backups and auto-save
                              files are made.
* Buffers::                 Creating and using buffer objects.
* Windows::                 Manipulating windows and displaying buffers.
* Frames::		    Making multiple X windows.
* Positions::               Buffer positions and motion functions.
* Markers::                 Markers represent positions and update
                              automatically when the text is changed.

* Text::                    Examining and changing text in buffers.
* Non-ASCII Characters::    Non-ASCII text in buffers and strings.
* Searching and Matching::  Searching buffers for strings or regexps.
* Syntax Tables::           The syntax table controls word and list parsing.
* Abbrevs::                 How Abbrev mode works, and its data structures.

* Processes::               Running and communicating with subprocesses.
* Display::	            Features for controlling the screen display.
* Calendar::		    Customizing the calendar and diary.
* System Interface::        Getting the user id, system type, environment
                              variables, and other such things.

付録

* Antinews::                Info for users downgrading to Emacs 20.
* GNU Free Documentation License:: The license for this documentation
* GPL::                     Conditions for copying and changing GNU Emacs.
* Tips::                    Advice and coding conventions for Emacs Lisp.
* GNU Emacs Internals::     Building and dumping Emacs;
                              internal data structures.
* Standard Errors::         List of all error symbols.
* Standard Buffer-Local Variables::
                            List of variables buffer-local in all buffers.
* Standard Keymaps::        List of standard keymaps.
* Standard Hooks::          List of standard hook variables.

* Index::                   Index including concepts, functions, variables,
                              and other terms.

* New Symbols::             New functions and variables in Emacs 21.

      −−− 詳細ノード一覧 −−−

以下は、上にあげたノードの下位ノードです。
直接移動できるように掲載しておきます。

導入

* Caveats::                 Flaws and a request for help.
* Lisp History::            Emacs Lisp is descended from Maclisp.
* Conventions::             How the manual is formatted.
* Acknowledgements::        The authors, editors, and sponsors of this manual.

慣習

* Some Terms::              Explanation of terms we use in this manual.
* nil and t::               How the symbols `nil' and `t' are used.
* Evaluation Notation::     The format we use for examples of evaluation.
* Printing Notation::       The format we use for examples that print output.
* Error Messages::          The format we use for examples of errors.
* Buffer Text Notation::    The format we use for buffer contents in examples.
* Format of Descriptions::  Notation for describing functions, variables, etc.

ヒントと慣習

* Coding Conventions::      Conventions for clean and robust programs.
* Compilation Tips::        Making compiled code run fast.
* Documentation Tips::      Writing readable documentation strings.
* Comment Tips::	    Conventions for writing comments.
* Library Headers::         Standard headers for library packages.

記述形式

* A Sample Function Description::
* A Sample Variable Description::

Lispデータ型

* Printed Representation::  How Lisp objects are represented as text.
* Comments::                Comments and their formatting conventions.
* Programming Types::       Types found in all Lisp systems.
* Editing Types::           Types specific to Emacs.
* Type Predicates::         Tests related to types.
* Equality Predicates::     Tests of equality between any two objects.

プログラミング向けの型

* Integer Type::        Numbers without fractional parts.
* Floating Point Type:: Numbers with fractional parts and with a large range.
* Character Type::      The representation of letters, numbers and
                          control characters.
* Sequence Type::       Both lists and arrays are classified as sequences.
* Cons Cell Type::      Cons cells, and lists (which are made from cons cells).
* Array Type::          Arrays include strings and vectors.
* String Type::         An (efficient) array of characters.
* Vector Type::         One-dimensional arrays.
* Symbol Type::         A multi-use object that refers to a function,
                        variable, property list, or itself.
* Function Type::       A piece of executable code you can call from elsewhere.
* Macro Type::          A method of expanding an expression into another
                          expression, more fundamental but less pretty.
* Primitive Function Type::     A function written in C, callable from Lisp.
* Byte-Code Type::      A function written in Lisp, then compiled.
* Autoload Type::       A type used for automatically loading seldom-used
                          functions.

リスト型

* Dotted Pair Notation::    An alternative syntax for lists.
* Association List Type::   A specially constructed list.

編集向けの型

* Buffer Type::             The basic object of editing.
* Window Type::             What makes buffers visible.
* Window Configuration Type::Save what the screen looks like.
* Marker Type::             A position in a buffer.
* Process Type::            A process running on the underlying OS.
* Stream Type::             Receive or send characters.
* Keymap Type::             What function a keystroke invokes.
* Overlay Type::            How an overlay is represented.

数

* Integer Basics::            Representation and range of integers.
* Float Basics::	      Representation and range of floating point.
* Predicates on Numbers::     Testing for numbers.
* Comparison of Numbers::     Equality and inequality predicates.
* Arithmetic Operations::     How to add, subtract, multiply and divide.
* Bitwise Operations::        Logical and, or, not, shifting.
* Numeric Conversions::	      Converting float to integer and vice versa.
* Math Functions::            Trig, exponential and logarithmic functions.
* Random Numbers::            Obtaining random integers, predictable or not.

文字列と文字

* String Basics::           Basic properties of strings and characters.
* Predicates for Strings::  Testing whether an object is a string or char.
* Creating Strings::        Functions to allocate new strings.
* Text Comparison::         Comparing characters or strings.
* String Conversion::       Converting characters or strings and vice versa.
* Formatting Strings::      `format': Emacs's analogue of `printf'.
* Case Conversion::         Case conversion functions.

リスト

* Cons Cells::              How lists are made out of cons cells.
* Lists as Boxes::          Graphical notation to explain lists.
* List-related Predicates:: Is this object a list?  Comparing two lists.
* List Elements::           Extracting the pieces of a list.
* Building Lists::          Creating list structure.
* Modifying Lists::         Storing new pieces into an existing list.
* Sets And Lists::          A list can represent a finite mathematical set.
* Association Lists::       A list can represent a finite relation or mapping.

既存リスト構造の変更

* Setcar::                  Replacing an element in a list.
* Setcdr::                  Replacing part of the list backbone.
                              This can be used to remove or add elements.
* Rearrangement::           Reordering the elements in a list; combining lists.

シーケンス、配列、ベクトル

* Sequence Functions::      Functions that accept any kind of sequence.
* Arrays::                  Characteristics of arrays in Emacs Lisp.
* Array Functions::         Functions specifically for arrays.
* Vectors::                 Functions specifically for vectors.

シンボル

* Symbol Components::       Symbols have names, values, function definitions
                              and property lists.
* Definitions::             A definition says how a symbol will be used.
* Creating Symbols::        How symbols are kept unique.
* Property Lists::          Each symbol has a property list
                              for recording miscellaneous information.

評価

* Intro Eval::              Evaluation in the scheme of things.
* Eval::                    How to invoke the Lisp interpreter explicitly.
* Forms::                   How various sorts of objects are evaluated.
* Quoting::                 Avoiding evaluation (to put constants in
                              the program).

フォームの種類

* Self-Evaluating Forms::   Forms that evaluate to themselves.
* Symbol Forms::            Symbols evaluate as variables.
* Classifying Lists::       How to distinguish various sorts of list forms.
* Function Forms::          Forms that call functions.
* Macro Forms::             Forms that call macros.
* Special Forms::           ``Special forms'' are idiosyncratic primitives,
                              most of them extremely important.
* Autoloading::             Functions set up to load files
                              containing their real definitions.

制御構造

* Sequencing::              Evaluation in textual order.
* Conditionals::            `if', `cond'.
* Combining Conditions::    `and', `or', `not'.
* Iteration::               `while' loops.
* Nonlocal Exits::          Jumping out of a sequence.

非ローカル脱出

* Catch and Throw::         Nonlocal exits for the program's own purposes.
* Examples of Catch::       Showing how such nonlocal exits can be written.
* Errors::                  How errors are signaled and handled.
* Cleanups::                Arranging to run a cleanup form if an
                              error happens.

エラー

* Signaling Errors::        How to report an error.
* Processing of Errors::    What Emacs does when you report an error.
* Handling Errors::         How you can trap errors and continue execution.
* Error Symbols::           How errors are classified for trapping them.

変数

* Global Variables::        Variable values that exist permanently, everywhere.
* Constant Variables::      Certain "variables" have values that never change.
* Local Variables::         Variable values that exist only temporarily.
* Void Variables::          Symbols that lack values.
* Defining Variables::      A definition says a symbol is used as a variable.
* Accessing Variables::     Examining values of variables whose names
                              are known only at run time.
* Setting Variables::       Storing new values in variables.
* Variable Scoping::        How Lisp chooses among local and global values.
* Buffer-Local Variables::  Variable values in effect only in one buffer.

スコープルールと変数束縛

* Scope::                   Scope means where in the program a value
                              is visible.  Comparison with other languages.
* Extent::                  Extent means how long in time a value exists.
* Impl of Scope::           Two ways to implement dynamic scoping.
* Using Scoping::           How to use dynamic scoping carefully and
                              avoid problems.

バッファローカルな変数

* Intro to Buffer-Local::   Introduction and concepts.
* Creating Buffer-Local::   Creating and destroying buffer-local bindings.
* Default Value::           The default value is seen in buffers
                              that don't have their own buffer-local values.

関数

* What Is a Function::      Lisp functions vs primitives; terminology.
* Lambda Expressions::      How functions are expressed as Lisp objects.
* Function Names::          A symbol can serve as the name of a function.
* Defining Functions::      Lisp expressions for defining functions.
* Calling Functions::       How to use an existing function.
* Mapping Functions::       Applying a function to each element of a list, etc.
* Anonymous Functions::     Lambda-expressions are functions with no names.
* Function Cells::          Accessing or setting the function definition
                              of a symbol.
* Related Topics::          Cross-references to specific Lisp primitives
                              that have a special bearing on how
                              functions work.

ラムダ式

* Lambda Components::       The parts of a lambda expression.
* Simple Lambda::           A simple example.
* Argument List::           Details and special features of argument lists.
* Function Documentation::  How to put documentation in a function.

マクロ

* Simple Macro::            A basic example.
* Expansion::               How, when and why macros are expanded.
* Compiling Macros::        How macros are expanded by the compiler.
* Defining Macros::         How to write a macro definition.
* Backquote::               Easier construction of list structure.
* Problems with Macros::    Don't evaluate the macro arguments too many times.
                              Don't hide the user's variables.

ロード

* How Programs Do Loading:: The `load' function and others.
* Autoload::                Setting up a function to autoload.
* Named Features::          Loading a library if it isn't already loaded.
* Repeated Loading::        Precautions about loading a file twice.

バイトコンパイル

* Compilation Functions::   Byte compilation functions.
* Disassembly::             Disassembling byte-code; how to read byte-code.

関数のアドバイス

* Simple Advice::           A simple example to explain the basics of advice.
* Defining Advice::         Detailed description of `defadvice'.
* Computed Advice::         ...is to `defadvice' as `fset' is to `defun'.
* Activation of Advice::    Advice doesn't do anything until you activate it.
* Enabling Advice::         You can enable or disable each piece of advice.
* Preactivation::           Preactivation is a way of speeding up the
                              loading of compiled advice.
* Argument Access in Advice:: How advice can access the function's arguments.
* Subr Arguments::          Accessing arguments when advising a primitive.
* Combined Definition::     How advice is implemented.

Lispプログラムのデバッグ

* Debugger::                How the Emacs Lisp debugger is implemented.
* Syntax Errors::           How to find syntax errors.
* Compilation Errors::      How to find errors that show up in
                              byte compilation.
* Edebug::                  A source-level Emacs Lisp debugger.

Lispデバッガ

* Error Debugging::         Entering the debugger when an error happens.
* Function Debugging::      Entering it when a certain function is called.
* Explicit Debug::          Entering it at a certain point in the program.
* Using Debugger::          What the debugger does; what you see while in it.
* Debugger Commands::       Commands used while in the debugger.
* Invoking the Debugger::   How to call the function `debug'.
* Internals of Debugger::   Subroutines of the debugger, and global variables.

不正なLisp構文のデバッグ

* Excess Open::             How to find a spurious open paren or missing close.
* Excess Close::            How to find a spurious close paren or missing open.

Lispオブジェクトの読み取りと表示

* Streams Intro::           Overview of streams, reading and printing.
* Input Streams::           Various data types that can be used as
                              input streams.
* Input Functions::         Functions to read Lisp objects from text.
* Output Streams::          Various data types that can be used as
                              output streams.
* Output Functions::        Functions to print Lisp objects as text.

ミニバッファ

* Intro to Minibuffers::    Basic information about minibuffers.
* Text from Minibuffer::    How to read a straight text string.
* Object from Minibuffer::  How to read a Lisp object or expression.
* Completion::              How to invoke and customize completion.
* Yes-or-No Queries::       Asking a question with a simple answer.
* Minibuffer Misc::         Various customization hooks and variables.

補完

* Basic Completion::        Low-level functions for completing strings.
                              (These are too low level to use the minibuffer.)
* Minibuffer Completion::   Invoking the minibuffer with completion.
* Completion Commands::     Minibuffer commands that do completion.
* High-Level Completion::   Convenient special cases of completion
                              (reading buffer name, file name, etc.)
* Reading File Names::      Using completion to read file names.
* Programmed Completion::   Finding the completions for a given file name.

コマンドループ

* Command Overview::    How the command loop reads commands.
* Defining Commands::   Specifying how a function should read arguments.
* Interactive Call::    Calling a command, so that it will read arguments.
* Command Loop Info::   Variables set by the command loop for you to examine.
* Input Events::	What input looks like when you read it.
* Reading Input::       How to read input events from the keyboard or mouse.
* Waiting::             Waiting for user input or elapsed time.
* Quitting::            How C-g works.  How to catch or defer quitting.
* Prefix Command Arguments::    How the commands to set prefix args work.
* Recursive Editing::   Entering a recursive edit,
                          and why you usually shouldn't.
* Disabling Commands::  How the command loop handles disabled commands.
* Command History::     How the command history is set up, and how accessed.
* Keyboard Macros::     How keyboard macros are implemented.

コマンドの定義

* Using Interactive::       General rules for `interactive'.
* Interactive Codes::       The standard letter-codes for reading arguments
                              in various ways.
* Interactive Examples::    Examples of how to read interactive arguments.

キーマップ

* Keymap Terminology::        	Definitions of terms pertaining to keymaps.
* Format of Keymaps::		What a keymap looks like as a Lisp object.
* Creating Keymaps:: 		Functions to create and copy keymaps.
* Inheritance and Keymaps::	How one keymap can inherit the bindings
				  of another keymap.
* Prefix Keys::                 Defining a key with a keymap as its definition.
* Menu Keymaps::		A keymap can define a menu for X
				  or for use from the terminal.
* Active Keymaps::	        Each buffer has a local keymap
                                  to override the standard (global) bindings.
				  Each minor mode can also override them.
* Key Lookup::                  How extracting elements from keymaps works.
* Functions for Key Lookup::    How to request key lookup.
* Changing Key Bindings::       Redefining a key in a keymap.
* Remapping Commands::          Bindings that translate one command to another.
* Key Binding Commands::        Interactive interfaces for redefining keys.
* Scanning Keymaps::            Looking through all keymaps, for printing help.

メジャーモードとマイナモード

* Major Modes::             Defining major modes.
* Minor Modes::             Defining minor modes.
* Mode Line Format::        Customizing the text that appears in the mode line.
* Hooks::                   How to use hooks; how to write code that
                              provides hooks.

メジャーモード

* Major Mode Conventions::  Coding conventions for keymaps, etc.
* Example Major Modes::     Text mode and Lisp modes.
* Auto Major Mode::         How Emacs chooses the major mode automatically.
* Mode Help::               Finding out how to use a mode.

マイナモード

* Minor Mode Conventions::  Tips for writing a minor mode.
* Keymaps and Minor Modes:: How a minor mode can have its own keymap.

モード行の書式

* Mode Line Data::          The data structure that controls the mode line.
* Mode Line Variables::     Variables used in that data structure.
* %-Constructs::            Putting information into a mode line.

説明文

* Documentation Basics::    Good style for doc strings.
                              Where to put them.  How Emacs stores them.
* Accessing Documentation:: How Lisp programs can access doc strings.
* Keys in Documentation::   Substituting current key bindings.
* Describing Characters::   Making printable descriptions of
                              non-printing characters and key sequences.
* Help Functions::          Subroutines used by Emacs help facilities.

ファイル

* Visiting Files::          Reading files into Emacs buffers for editing.
* Saving Buffers::          Writing changed buffers back into files.
* Reading from Files::      Reading files into other buffers.
* Writing to Files::        Writing new files from parts of buffers.
* File Locks::              Locking and unlocking files, to prevent
                                simultaneous editing by two people.
* Information about Files::   Testing existence, accessibility, size of files.
* Contents of Directories::   Getting a list of the files in a directory.
* Changing Files::          Renaming files, changing protection, etc.
* File Names::              Decomposing and expanding file names.

ファイルを訪問する

* Visiting Functions::      The usual interface functions for visiting.
* Subroutines of Visiting:: Lower-level subroutines that they use.

ファイルに関する情報

* Testing Accessibility::   Is a given file readable?  Writable?
* Kinds of Files::          Is it a directory?  A link?
* File Attributes::         How large is it?  Any other names?  Etc.

ファイル名

* File Name Components::    The directory part of a file name, and the rest.
* Directory Names::         A directory's name as a directory
                              is different from its name as a file.
* Relative File Names::     Some file names are relative to a
                              current directory.
* File Name Expansion::     Converting relative file names to absolute ones.
* Unique File Names::       Generating names for temporary files.
* File Name Completion::    Finding the completions for a given file name.

バックアップと自動保存

* Backup Files::            How backup files are made; how their names
                              are chosen.
* Auto-Saving::             How auto-save files are made; how their
                              names are chosen.
* Reverting::               `revert-buffer', and how to customize
                              what it does.

バックアップファイル

* Making Backups::          How Emacs makes backup files, and when.
* Rename or Copy::          Two alternatives: renaming the old file
                              or copying it.
* Numbered Backups::        Keeping multiple backups for each source file.
* Backup Names::            How backup file names are computed; customization.

バッファ

* Buffer Basics::           What is a buffer?
* Buffer Names::            Accessing and changing buffer names.
* Buffer File Name::        The buffer file name indicates which file
                              is visited.
* Buffer Modification::     A buffer is "modified" if it needs to be saved.
* Modification Time::       Determining whether the visited file was changed
                              ``behind Emacs's back''.
* Read Only Buffers::       Modifying text is not allowed in a
                              read-only buffer.
* The Buffer List::         How to look at all the existing buffers.
* Creating Buffers::        Functions that create buffers.
* Killing Buffers::         Buffers exist until explicitly killed.
* Current Buffer::          Designating a buffer as current
                              so primitives will access its contents.

ウィンドウ

* Basic Windows::           Basic information on using windows.
* Splitting Windows::       Splitting one window into two windows.
* Deleting Windows::        Deleting a window gives its space to other windows.
* Selecting Windows::       The selected window is the one that you edit in.
* Cyclic Window Ordering::  Moving around the existing windows.
* Buffers and Windows::     Each window displays the contents of a buffer.
* Displaying Buffers::      Higher-lever functions for displaying a buffer
                              and choosing a window for it.
* Window Point::            Each window has its own location of point.
* Window Start::            The display-start position controls which text
                              is on-screen in the window.
* Vertical Scrolling::      Moving text up and down in the window.
* Horizontal Scrolling::    Moving text sideways on the window.
* Size of Window::          Accessing the size of a window.
* Resizing Windows::        Changing the size of a window.
* Window Configurations::   Saving and restoring the state of the screen.

フレーム

* Creating Frames::	    Creating additional frames.
* Multiple Displays::       Creating frames on other X displays.
* Frame Parameters::	    Controlling frame size, position, font, etc.
* Frame Titles::            Automatic updating of frame titles.
* Deleting Frames::	    Frames last until explicitly deleted.
* Finding All Frames::	    How to examine all existing frames.
* Frames and Windows::	    A frame contains windows;
			      display of text always works through windows.
* Minibuffers and Frames::  How a frame finds the minibuffer to use.
* Input Focus::		    Specifying the selected frame.
* Visibility of Frames::    Frames may be visible or invisible, or icons.
* Raising and Lowering::    Raising a frame makes it hide other X windows;
			      lowering it puts it underneath the others.
* Frame Configurations::    Saving the state of all frames.
* Mouse Tracking::	    Getting events that say when the mouse moves.
* Mouse Position::	    Asking where the mouse is, or moving it.
* Pop-Up Menus::	    Displaying a menu for the user to select from.
* Dialog Boxes::            Displaying a box to ask yes or no.
* Pointer Shapes::          Specifying the shape of the mouse pointer.
* Window System Selections::Transferring text to and from other windows.
* Color Names::	            Getting the definitions of color names.
* Resources::		    Getting resource values from the server.
* Display Feature Testing:: Determining the features of a terminal.

バッファ内の位置

* Point::                   The special position where editing takes place.
* Motion::                  Changing point.
* Excursions::              Temporary motion and buffer changes.
* Narrowing::               Restricting editing to a portion of the buffer.

移動

* Character Motion::        Moving in terms of characters.
* Word Motion::             Moving in terms of words.
* Buffer End Motion::       Moving to the beginning or end of the buffer.
* Text Lines::              Moving in terms of lines of text.
* Screen Lines::            Moving in terms of lines as displayed.
* List Motion::             Moving by parsing lists and sexps.
* Skipping Characters::     Skipping characters belonging to a certain set.

マーカ

* Overview of Markers::     The components of a marker, and how it relocates.
* Predicates on Markers::   Testing whether an object is a marker.
* Creating Markers::        Making empty markers or markers at certain places.
* Information from Markers::  Finding the marker's buffer or character
                                position.
* Moving Markers::          Moving the marker to a new buffer or position.
* The Mark::                How ``the mark'' is implemented with a marker.
* The Region::              How to access ``the region''.

テキスト

* Near Point::              Examining text in the vicinity of point.
* Buffer Contents::         Examining text in a general fashion.
* Insertion::               Adding new text to a buffer.
* Commands for Insertion::  User-level commands to insert text.
* Deletion::                Removing text from a buffer.
* User-Level Deletion::     User-level commands to delete text.
* The Kill Ring::           Where removed text sometimes is saved for
                              later use.
* Undo::                    Undoing changes to the text of a buffer.
* Auto Filling::            How auto-fill mode is implemented to break lines.
* Filling::                 Functions for explicit filling.
* Margins::                 How to specify margins for filling commands.
* Sorting::                 Functions for sorting parts of the buffer.
* Indentation::             Functions to insert or adjust indentation.
* Columns::                 Computing horizontal positions, and using them.
* Case Changes::            Case conversion of parts of the buffer.
* Text Properties::         Assigning Lisp property lists to text characters.
* Substitution::            Replacing a given character wherever it appears.
* Transposition::           Swapping two portions of a buffer.
* Registers::               How registers are implemented.  Accessing
                              the text or position stored in a register.
* Atomic Changes::          Installing several buffer changes ``atomically''.
* Base 64::                 Conversion to or from base 64 encoding.
* MD5 Checksum::            Compute the MD5 ``message digest''/``checksum''.
* Change Hooks::            Supplying functions to be run when text is changed.

キルリング

* Kill Ring Concepts::      What text looks like in the kill ring.
* Kill Functions::          Functions that kill text.
* Yanking::                 How yanking is done.
* Yank Commands::           Commands that access the kill ring.
* Low-Level Kill Ring::	    Functions and variables for kill ring access.
* Internals of Kill Ring::  Variables that hold kill-ring data.

字下げ

* Primitive Indent::        Functions used to count and insert indentation.
* Mode-Specific Indent::    Customize indentation for different modes.
* Region Indent::           Indent all the lines in a region.
* Relative Indent::         Indent the current line based on previous lines.
* Indent Tabs::             Adjustable, typewriter-like tab stops.
* Motion by Indent::        Move to first non-blank character.

テキスト属性

* Examining Properties::    Looking at the properties of one character.
* Changing Properties::	    Setting the properties of a range of text.
* Property Search::	    Searching for where a property changes value.
* Special Properties::	    Particular properties with special meanings.
* Format Properties::       Properties for representing formatting of text.
* Sticky Properties::       How inserted text gets properties from
                              neighboring text.
* Saving Properties::       Saving text properties in files, and reading
                              them back.
* Lazy Properties::         Computing text properties in a lazy fashion
                              only when text is examined.
* Clickable Text::          Using text properties to make regions of text
                              do something when you click on them.
* Fields::                  The `field' property defines
                              fields within the buffer.
* Not Intervals::	    Why text properties do not use
			      Lisp-visible text intervals.

非アスキー文字

* Text Representations::    Unibyte and multibyte representations
* Converting Representations::  Converting unibyte to multibyte and vice versa.
* Selecting a Representation::  Treating a byte sequence as unibyte or multi.
* Character Codes::         How unibyte and multibyte relate to
                                codes of individual characters.
* Character Sets::          The space of possible characters codes
                                is divided into various character sets.
* Chars and Bytes::         More information about multibyte encodings.
* Splitting Characters::    Converting a character to its byte sequence.
* Scanning Charsets::       Which character sets are used in a buffer?
* Translation of Characters::   Translation tables are used for conversion.
* Coding Systems::          Coding systems are conversions for saving files.
* Input Methods::           Input methods allow users to enter various
                                non-ASCII characters without special keyboards.
* Locales::                 Interacting with the POSIX locale.

探索と一致

* String Search::           Search for an exact match.
* Regular Expressions::     Describing classes of strings.
* Regexp Search::           Searching for a match for a regexp.
* Match Data::              Finding out which part of the text matched
                              various parts of a regexp, after regexp search.
* Saving Match Data::       Saving and restoring this information.
* Standard Regexps::        Useful regexps for finding sentences, pages,...
* Searching and Case::      Case-independent or case-significant searching.

正規表現

* Syntax of Regexps::       Rules for writing regular expressions.
* Regexp Example::          Illustrates regular expression syntax.

構文テーブル

* Syntax Descriptors::      How characters are classified.
* Syntax Table Functions::  How to create, examine and alter syntax tables.
* Parsing Expressions::     Parsing balanced expressions
                              using the syntax table.
* Standard Syntax Tables::  Syntax tables used by various major modes.
* Syntax Table Internals::  How syntax table information is stored.

構文記述子

* Syntax Class Table::      Table of syntax classes.
* Syntax Flags::            Additional flags each character can have.

略語と略語の展開

* Abbrev Mode::             Setting up Emacs for abbreviation.
* Tables: Abbrev Tables.    Creating and working with abbrev tables.
* Defining Abbrevs::        Specifying abbreviations and their expansions.
* Files: Abbrev Files.      Saving abbrevs in files.
* Expansion: Abbrev Expansion.  Controlling expansion; expansion subroutines.
* Standard Abbrev Tables::  Abbrev tables used by various major modes.

プロセス

* Subprocess Creation::     Functions that start subprocesses.
* Synchronous Processes::   Details of using synchronous subprocesses.
* Asynchronous Processes::  Starting up an asynchronous subprocess.
* Deleting Processes::      Eliminating an asynchronous subprocess.
* Process Information::     Accessing run-status and other attributes.
* Input to Processes::      Sending input to an asynchronous subprocess.
* Signals to Processes::    Stopping, continuing or interrupting
                              an asynchronous subprocess.
* Output from Processes::   Collecting output from an asynchronous subprocess.
* Sentinels::               Sentinels run when process run-status changes.
* Network::                 Opening network connections.

プロセスからの出力を受け取る

* Process Buffers::         If no filter, output is put in a buffer.
* Filter Functions::        Filter functions accept output from the process.
* Decoding Output::         Filters can get unibyte or multibyte strings.
* Accepting Output::        How to wait until process output arrives.

オペレーティングシステムとのインターフェイス

* Starting Up::             Customizing Emacs start-up processing.
* Getting Out::             How exiting works (permanent or temporary).
* System Environment::      Distinguish the name and kind of system.
* Terminal Input::          Recording terminal input for debugging.
* Terminal Output::         Recording terminal output for debugging.
* Flow Control::            How to turn output flow control on or off.
* Batch Mode::              Running Emacs without terminal interaction.

Emacsの始動

* Startup Summary::         Sequence of actions Emacs performs at start-up.
* Init File::               Details on reading the init file (`.emacs').
* Terminal-Specific::       How the terminal-specific Lisp file is read.
* Command-Line Arguments::  How command line arguments are processed,
                              and how you can customize them.

Emacsから抜ける

* Killing Emacs::           Exiting Emacs irreversibly.
* Suspending Emacs::        Exiting Emacs reversibly.

Emacsの画面表示

* Refresh Screen::          Clearing the screen and redrawing everything on it.
* Truncation::              Folding or wrapping long text lines.
* The Echo Area::           Where messages are displayed.
* Warnings::                Displaying warning messages for the user.
* Selective Display::       Hiding part of the buffer text.
* Overlay Arrow::           Display of an arrow to indicate position.
* Temporary Displays::      Displays that go away automatically.
* Overlays::		    Use overlays to highlight parts of the buffer.
* Width::                   How wide a character or string is on the screen.
* Faces::		    A face defines a graphics style
                              for text characters: font, colors, etc.
* Fringes::                 Controlling window fringes.
* Display Property::        Enabling special display features.
* Images::                  Displaying images in Emacs buffers.
* Blinking::                How Emacs shows the matching open parenthesis.
* Inverse Video::	    Specifying how the screen looks.
* Usual Display::	    The usual conventions for displaying nonprinting chars.
* Display Tables::	    How to specify other conventions.
* Beeping::                 Audible signal to the user.
* Window Systems::          Which window system is being used.

GNU Emacsの内部

* Building Emacs::          How to preload Lisp libraries into Emacs.
* Pure Storage::            A kludge to make preloaded Lisp functions sharable.
* Garbage Collection::      Reclaiming space for Lisp objects no longer used.
* Object Internals::        Data formats of buffers, windows, processes.
* Writing Emacs Primitives::  Writing C code for Emacs.

オブジェクトの内部

* Buffer Internals::        Components of a buffer structure.
* Window Internals::        Components of a window structure.
* Process Internals::       Components of a process structure.


File: elisp-ja,  Node: Copying,  Next: Introduction,  Prev: Top,  Up: Top

GNU一般公有使用許諾書
******************************

                        1991年6月 バージョン2.0

     Copyright (C) 1989, 1991 Free Software Foundation, Inc.
     675 Mass Ave, Cambridge, MA 02139, USA (1)
     【注意】 現在、このバージョン2の発行者(FSF)住所は、正式に新しい住所の
     59 Temple Place - Suite 330, Boston, MA 02111-1307, USA に変わっている。

     何人も、以下の内容を変更しないでそのまま複写する場合に限り、
     本使用許諾書を複製したり頒布することができます。

はじめに
============

ほとんどのソフトウェアの使用許諾は、ソフトウェアを共有し、
変更するユーザの自由を奪うことを意図しています。
それに対して、我々のGNU一般公有使用許諾は、
フリー・ソフトウェアを共有したり変更する自由をユーザに保証するためのもの、
即ちフリー・ソフトウェアがそのユーザ全てにとって
フリーであることを保証するためのものです。 本使用許諾は、Free Software
Foundationのほとんど全てのソフトウェアに 適用されるだけでなく、
プログラムの作成者が本使用許諾に依るとした場合のそのプログラムにも
適用することができます。 （その他の Free Software Foundation
のソフトウェアのいくつかは、
本許諾書ではなく、GNUライブラリ一般公有使用許諾で保護されます。）
あなたは自分のプログラムにもこれを適用できます。

   我々がフリー・ソフトウェアについて言う場合は
自由のことに言及しているのであって、価格のことではありません。
我々の一般公有使用許諾の各条項は、次の事柄を確実に実現することを
目的として立案されています。
   * フリー・ソフトウェアの複製物を自由に頒布できること
     （そして、望むならあなたのこのサービスに対して対価を請求できること）。

   * ソース・コードを実際に受け取るか、あるいは、
     希望しさえすればそれを入手することが可能であること。

   * 入手したソフトウェアを変更したり、
     新しいフリー・プログラムの一部として使用できること。

   *
     以上の各内容を行なうことができるということをユーザ自身が知っていること。

   このようなユーザの権利を守るために、我々は、
何人もこれらの権利を否定したり、あるいは放棄するように
ユーザに求めることはできないという制限条項を設ける必要があります。
これらの制限条項は、ユーザが、フリー・ソフトウェアの複製物を
頒布したり変更しようとする場合には、そのユーザ自身が守るべき義務ともなります。

   例えば、あなたがフリー・ソフトウェアの複製物を頒布する場合、
有償か無償かにかかわらず、
あなたは自分の持っている権利を全て相手に与えなければなりません。
あなたは、相手もまたソース・コードを受け取ったり入手できるということを
認めなければなりません。
さらにあなたは、彼らが自分たちの権利を知るように、
これらの条項を知らしめなければなりません。

   　我々は次の２つの方法でユーザの権利を守ります。
（１）ソフトウェアに著作権を主張し、 （２）本使用許諾の条項の下で
ソフトウェアを複製・頒布・変更する権利をユーザに与えます。

   また、各作成者や我々自身を守るために、
本フリー・ソフトウェアが無保証であることを
全ての人々が了解している必要があります。
さらに、他の誰かによって変更されたソフトウェアが頒布された場合、
受領者はそのソフトウェアがオリジナル・バージョンではないということを
知らされる必要があります。
それは、他人の関与によって原開発者に対する評価が
影響されないようにするためです。

最後に、どのフリー・プログラムもソフトウェア特許に絶えず脅かされています。
我々は、フリー・プログラムの再頒布者が個人的に特許権を取得し、
事実上そのプログラムを自分の財産にしてしまうという危険を
避けたいと願っています。 これを防ぐために我々は、いずれの特許も、
誰でも自由に使用できるように使用許諾されるべきか、
あるいは何人に対しても全く使用させないかの、
いずれかにすべきであることを明らかにしてきました。

   複写・頒布・変更に対する正確な条項と条件を次に示します。

     GNU一般公有使用許諾の下での複製、頒布、変更に関する条項と条件
  1. 本使用許諾は、本一般公有使用許諾の各条項に従って頒布されるという
     著作権者からの告知文が表示されているプログラムやその他の作成物に適用されます。
     以下において「プログラム」とは、そのようなプログラムや作成物を指すものとし、
     また、「プログラム生成物」とは、上述した「プログラム」自身、または、
     著作権法下における全ての派生物；すなわち、その「プログラム」の全部又は一部を、
     そのまま又は変更して、且つ／又は他の言語に変換して、
     内部に組み込んだ作成物を意味します。
     （以下、言語変換は「変更」という用語の中に無条件に含まれるものとします。）
     本使用許諾によって許諾を受ける者を「あなた」と呼びます。　

     複製、頒布、変更以外の行為は本使用許諾の対象としません。
     それらは本使用許諾の範囲外です。
     「プログラム」を実行させる行為に関して制約はありません。
     「プログラム」の出力は、
     （「プログラム」を実行させて作成させたかどうかとは無関係に）
     その内容が「プログラム生成物」である場合に限り本使用許諾の対象となります。
     これが当てはまるかどうかは、「プログラム」が何をするものかに依ります。

  2. あなたは、どのような媒体上へ複製しようとする場合であっても、
     入手した「プログラム」のソース・コードを
     そのままの内容で複写した上で適正な著作権表示と保証の放棄を明確、
     且つ適正に付記する場合に限り、複製又は頒布することができます。
     その場合、本使用許諾及び無保証に関する記載部分は、
     全て元のままの形で表示してください。
     また、「プログラム」の頒布先に対しては、
     「プログラム」と共に本使用許諾書の写しを渡してください。

     複製物の引き渡しに要する実費は請求することができます。
     また、あなた独自の保証を行なう場合はそれを有償とすることができます。

  3. 次の各条件を全て満たしている限り、あなたは、
     「プログラム」又はその一部分を変更して「プログラム生成物」とすることができ、
     さらに、変更版や右作成物を上記第２項に従って複製又は頒布することもできます。

       a.
          ファイルを変更した旨とその変更日とを、変更したファイル上に明確に表示すること。

       b. 変更したか否かを問わず、凡そ「プログラム」
          又はその一部分を内部に組み込んでいるか
          又はそれから派生した生成物を頒布する場合には、
          その全体を本使用許諾の条項に従って第三者へ無償で使用許諾すること。

       c. 変更したプログラムが実行時に通常の対話的な方法で
          コマンドを読むようになっているとすれば、
          最も普通の方法で対話的にそのプログラムを実行する時に、
          次の内容を示す文言がプリンタへ印字されるか、或いは画面に表示されること。
             * 適切な著作権表示。

             *
               無保証であること（あなたが独自に保証する場合は、その旨）。

             * 頒布を受ける者も、
               本使用許諾と同一の条項に従って「プログラム」を再頒布できること。

             * 頒布を受ける者が本使用許諾書の写しを参照する方法。
               （例外として、「プログラム」自体は対話的であっても起動時の文言を
               通常は印字しないのならば、
               あなたの「プログラム生成物」はこのような文言を印字する必要はありません。）

     これらの要件は変更された作成物にも全て適用されます。
     その変更版の或る部分が「プログラム」の派生物ではなく、
     しかもそれ自体独立で異なる作成物だと合理的に考えられる場合、
     あなたがそれらを別の作成物として頒布した時は、
     本使用許諾とその条項はそれらの部分には適用されません。
     しかし、それらを「プログラム生成物」の一部として頒布する場合は、
     全体が本使用許諾の条項に従って頒布されなければならず、
     使用許諾を受ける他の全ての者に対する許諾も
     プログラム全体にわたって与えられなければならず、
     結果として、誰が書いたかにかかわらず、
     全ての部分に本使用許諾が適用されなければなりません。

     このように、本条項の意図するところは、
     完全にあなたによって書かれた作成物について、権利を要求したり、
     あなたと権利関係を争うことではありません。
     むしろその目的は、作成物が「プログラム生成物」
     である場合にその派生物や集合物の頒布を規制することにあります。

     さらに、「プログラム」（又は「プログラム生成物」）と
     「プログラム生成物」とはならない他のプログラムとを、
     単に保管や頒布のために同一の媒体上にまとめて記録したとしても、
     本使用許諾は他のプログラムには適用されません。

  4. あなたは、以下のうちいずれか１つを満たす限り、
     上記第２項及び第３項に従って「プログラム」
     （又は、上記第３項で言及している「プログラム生成物」）を
     オブジェクト・コード又は実行可能な形式で複製及び頒布することができます。

       a.
          対応する機械読み取り可能なソース・コード一式を一緒に引き渡すこと。
          その場合、そのソース・コードの引き渡しは上記第２項及び第３項に従って、
          通常ソフトウェアの交換に用いられる媒体で行なわれること。

       b. 少なくとも３年間の有効期間を定め、
          且つその期間内であれば対応する機械読み取り可能なソース・コード一式の複製を、
          ソース頒布に関わる実費以上の対価を要求せずに提供する旨、
          及びその場合には上記第２項及び第３項に従って、
          通常ソフトウェアの交換に用いられる媒体で提供される旨を記載した書面を、
          第三者に一緒に引き渡すこと。

       c. 対応するソース・コード頒布の申し出に際して、
          あなたが得た情報を一緒に引き渡すこと。
          （この選択肢は、営利を目的としない頒布であって、
          且つあなたが上記の（ｂ）項に基づいて、
          オブジェクト・コード或いは実行可能形式の
          プログラムしか入手していない場合に限り適用される選択項目です。）

     なお、ソース・コードとは、変更作業に適した記述形式を指します。
     また、実行可能形式のファイルに対応するソース・コード一式とは、
     それに含まれる全モジュールに対応する全てのソース・コード、
     及びあらゆる関連のインタフェース定義ファイル、
     及び実行を可能にするコンパイルとインストールの制御に関する記述を指します。
     特別な例外として、実行可能なファイルが動作するオペレーティング・システムの
     主要な構成要素（コンパイラ、カーネルなど）と共に
     （ソース・コード又はバイナリのどちらかで）頒布されているものについては、
     その構成要素自体が実行形式に付随していない場合に限り、
     頒布されるソース・コードに含める必要はありません。

     実行可能形式またはオブジェクト・コードの頒布が、
     指示された場所からの複製のためのアクセス権の賦与である場合、
     同じ場所からのソース・コードの複製のための同等なアクセス権を賦与すれば、
     たとえ第三者にオブジェクト・コードと共にソースの複製を強いなくとも、
     ソース・コードを頒布したものとみなします。

  5. 本使用許諾が明示的に許諾している場合を除き、あなたは、
     「プログラム」を複製、変更、サブライセンス、頒布することができません。
     本使用許諾に従わずに「プログラム」を複製、変更、サブライセンス、
     頒布しようとする行為は、それ自体が無効であり、且つ、
     本使用許諾があなたに許諾している「プログラム」の権利を自動的に消滅させます。
     その場合、本使用許諾に従ってあなたから複製物やその権利を得ている第三者は、
     本使用許諾に完全に従っている場合に限り、
     引続き有効な使用権限を持つものとします。

  6. あなたはまだ同意の印として署名していないので、
     本使用許諾を受け入れる必要はありません。
     しかし、あなたに「プログラム」又はその派生物を変更又は再頒布する許可を
     与えるものは本使用許諾以外にはありません。
     これらの行為は、あなたがもし本使用許諾を受け入れないのであれば、
     法律によって禁じられます。
     従って、あなたが「プログラム」（又は「プログラム生成物」）の変更又は頒布を
     行えば、それ自体であなたは本使用許諾を受け入れ、且つ、
     「プログラム」又はその「プログラム生成物」の複製、頒布、変更に
     関するこれらの条項と条件の全てを受け入れたことを示します。

  7.
     あなたが「プログラム」（又はその「プログラム生成物」）を再頒布すると自動的に、
     その受領者は、元の使用許諾者から、本使用許諾の条項に従って「プログラム」を
     複製、頒布、変更することを内容とする使用許諾を受けたものとします。
     あなたは、受領者に許諾された権利の行使について、
     さらに制約を加えることはできません。
     あなたには、第三者に本使用許諾の受け入れを強いる責任はありません。

  8. 裁判所の判決、又は特許侵害の申し立て、又は（特許問題に限らない）
     何らかの理由の結果として、あなたに課せられた条件が本使用許諾と
     相入れないものであったとしても（裁判所の命令、契約、その他によるものであれ）、
     本使用許諾の条件が免除されるものではありません。
     本使用許諾による責務と、その他の何らかの関連責務を同時に満たす態様で
     頒布することができないならば、
     あなたは「プログラム」を全く頒布してはいけません。
     例えば、特許権の内容が、あなたから直接又は間接に複製を受け取った全ての人に
     使用料のないプログラムの再頒布を許さないものであれば、
     あなたがかかる特許上の要請と本使用許諾の両方を満足させる方法は、
     「プログラム」の頒布を完全に断念することだけです。

     本条項の或る部分が何らかの特別な状況下で無効または適用不可能になった場合、
     本条項のその他の残りの部分が適用されるように意図されており、また、
     本条項は全体としてその他の状況に当てはまるように意図されています。

     本条項の目的は、特許やその他の財産権を侵害したり、
     そのような権利に基づく主張の妥当性を争うようにあなたに
     勧めることではありません。
     本条項の唯一の目的は、フリー・ソフトウェアの頒布システムの完全性を守ることで、
     それは公有使用許諾の実践によって履行されます。
     多くの人々が、このシステムの一貫した適用を信頼して、
     このシステムを通じて頒布されている幅広い範囲のソフトウェアに惜しみない貢献を
     してくれました。
     作成者や寄贈者が他の何らかのシステムを通じてソフトウェアを
     頒布したいと決めることは彼らの自由意志であり、
     使用許諾を受ける者はその選択を強いることはできません。

     本条項は、本使用許諾の他の条項の意味内容が何であるかを
     完全に明らかにすることを意図しています。

  9. 「プログラム」の頒布・使用が、ある国において特許又は著作権で
     保護されたインタフェースのどちらかで制限される場合、
     「プログラム」を本使用許諾下においた原著作権保持者は、
     その国を除外する旨の明示的な頒布地域制限を加え、
     それ以外の（除外されない）国に限定して頒布が
     許されるようにすることができます。
     そのような場合、その制限を本使用許諾の本文に
     あたかも書かれているかのように本使用許諾の中に組み入れられるものとします。

 10. Free Software Foundation は随時、本一般公有使用許諾の改訂版、
     又は新版を公表することがあります。 そのような新しいバージョンは、
     現行のバージョンと基本的に変わるところはありませんが、
     新しい問題や懸案事項に対応するために細部では異なるかもしれません。

     各バージョンは、バージョン番号によって区別します。
     「プログラム」中に本使用許諾のバージョン番号の指定がある場合は、
     その指定されたバージョンか、又はその後にFree Software
     Foundationから
     公表されているいずれかのバージョンから１つを選択して、
     その条項と条件に従ってください。
     「プログラム」中に本使用許諾のバージョン番号の指定がない場合は、
     Free Software Foundation
     が公表したどのバージョンでも選択することができます。

 11. 「プログラム」の一部を頒布条件の異なる他のフリー・プログラムに
     組み込みたい場合は、その開発者に書面で許可を求めてください。 Free
     Software Foundation が著作権を持っているソフトウェアについては、
     Free Software Foundation へ書面を提出してください。
     このような場合に対応するために我々は例外的処理をすることもありますが、
     その判断基準となるのは、次の２つの目標の実現に合致するか否かという点です。
     即ち、１つは我々のフリー・ソフトウェアの全ての派生物を
     フリーな状態に保つことであり、もう１つはソフトウェアの共有と再利用とを
     広く促進させることです。

                                   無保証
 12. 「プログラム」は無償で使用許諾されますので、適用法令の範囲内で、
     「プログラム」の保証は一切ありません。
     著作権者やその他の第三者は全く無保証で「そのまま」の状態で、且つ、
     明示か暗黙であるかを問わず一切の保証をつけないで提供するものとします。
     ここでいう保証とは、市場性や特定目的適合性についての暗黙の保証も含まれますが、
     それに限定されるものではありません。
     「プログラム」の品質や性能に関する全てのリスクはあなたが負うものとします。
     「プログラム」に欠陥があるとわかった場合、
     それに伴う一切の派生費用や修理・訂正に要する費用は全てあなたの負担とします。

 13. 適用法令の定め、又は書面による合意がある場合を除き、
     著作権者や上記許諾を受けて「プログラム」の変更・再頒布を為し得る第三者は、
     「プログラム」を使用したこと、
     または使用できないことに起因する一切の損害について何らの責任も負いません。
     著作権者や前記の第三者が、そのような損害の発生する可能性について
     知らされていた場合でも同様です。
     なお、ここでいう損害には通常損害、特別損害、偶発損害、間接損害が含まれます
     （データの消失、又はその正確さの喪失、あなたや第三者が被った損失、
     他のプログラムとのインタフェースの不適合化、等も含まれますが、
     これに限定されるものではありません）。

                                 以上
注意
======

英文文書（GNU General Public License）を正式文書とする。
この和文文書は弁護士の意見を採り入れて、
できるだけ正確に英文文書を翻訳したものであるが、
法律的に有効な契約書ではない。

和文文書自体の再配布に関して
==========================================

いかなる媒体でも次の条件がすべて満たされている場合に限り、
本和文文書をそのまま複写し配布することを許可する。
また、あなたは第三者に対して本許可告知と同一の許可を与える場合に限り、
再配布することが許可されています。
   * 受領、配布されたコピーに著作権表示および本許諾告知が
     前もって載せられていること。　

   * コピーの受領者がさらに再配布する場合、
     その配布者が本告知と同じ許可を与えていること。

   * 和文文書の本文を改変しないこと。

あなたの新しいプログラムにこれらの条項を適用する方法
==============================================================================

あなたが新しくプログラムを作成し、それを公用に供したい場合は、
プログラムをフリー・ソフトウェアにして、
全ての人々が以上の各条項に従ってこれを再頒布や変更をすることが
できるようにするのが最良の方法です。

   そうするためには、プログラムに以下の表示をしてください。
その場合、無保証であるということを最も効果的に伝えるために、
ソース・ファイルの冒頭にその全文を表示すれば最も安全ですが、
その他の方法で表示する場合でも、「著作権表示」と全文を読み出す為の
アドレスへのポインタだけはファイル上に表示しておいてください。

     ÃÃÂÃÃŐÁÁÂÁŋĽÂÁÂÂÁÁÁÁÁÁÁǰōÁȪƘÁȡ
     Ｃｏｐｙｒｉｇｈｔ（Ｃ）　１９○○年、ȑĽƨȀŐ

     本プログラムはフリー・ソフトウェアです。
     あなたは、Free Software Foundationが公表したGNU 一般公有使用許諾の
     「バージョン２」或いはそれ以降の各バージョンの中からいずれかを選択し、
     そのバージョンが定める条項に従って本プログラムを
     再頒布または変更することができます。

     本プログラムは有用とは思いますが、頒布にあたっては、
     市場性及び特定目的適合性についての暗黙の保証を含めて、
     いかなる保証も行ないません。
     詳細についてはGNU 一般公有使用許諾書をお読みください。

     あなたは、本プログラムと一緒にGNU一般公有使用許諾の写しを
     受け取っているはずです。
     そうでない場合は、

     　Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA
     (2)
     【注意】 現在、このバージョン2の発行者(FSF)住所は、正式に新しい住所の
      59 Temple Place - Suite 330, Boston, MA 02111-1307, USA に変わっている。
     へ手紙を書いてください。

また、ユーザが電子メイルや書信であなたと連絡をとる方法についての情報も
書き添えてください。

   プログラムが対話的に動作する場合は、
対話モードで起動した時に次のような短い告知文が表示されるようにしてください。

     Ｇｎｏｍｏｖｉｓｉｏｎ　バージョン６９、Ｃｏｐｙｒｉｇｈｔ（Ｃ）１９○○年 ȑĽƨȀŐ
     Gnomovision は完全に無保証です。詳細は show w とタイプしてください。
     これはフリー・ソフトウェアなので、特定の条件の下でこれを再頒布する
     ことができます。詳細は show c とタイプしてください。

   上記の`show w'や`show c'は各々、
本一般公有使用許諾の関連する部分を表示するコマンドを指します。
もちろん、あなたが使うこれらのコマンドは`show w'や`show c'といった
呼び名でなくても構いません。
さらに、それらのコマンドはあなたのプログラムに合わせる為に、
マウスでクリックしたりメニュー形式にすることもできます。

   また、必要と認めた場合には、あなたの雇い主
（あなたがプログラマとして働いている場合）や在籍する学校から、
そのプログラムに対する「著作権放棄」を認めた署名入りの書面を入手してください。
ここにその文例を載せます。名前は変えてください。

     Yoyodyne, Inc. は、James Hacker が開発したプログラム`Gnomovision'
     （コンパイラにつなげるプログラム）についての著作権法上の全ての権利を放棄する。

     ϼϽÀϼϽϽϽÀÁǽŐ，　１　Ａｐｒｉｌ　１９８９
     Ｔｙ　Ｃｏｏｎ，　副社長

   本一般公有使用許諾は、あなたのプログラムを財産権の対象となっている
他のプログラムに組み込むことは認めていません。
あなたのプログラムがサブルーチン・ライブラリであって、
あなたがそのライブラリを財産権の対象となっている他のアプリケーションと
リンクさせることによって、さらに有用なものにしようとする場合には、
本使用許諾書の代わりに、GNUライブラリ一般公有使用許諾書に従ってください。

   ---------- Footnotes ----------

   (1) 【注意】
現在、このバージョン2の発行者(FSF)住所は、正式に新しい住所の
　59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
に変わっている。

   (2) 【注意】現在、このバージョン2の発行者(FSF)住所は、
正式に新しい住所の 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA に変わっている。


File: elisp-ja,  Node: Introduction,  Next: Lisp Data Types,  Prev: Copying,  Up: Top

1 はじめに
**************

GNU Emacsテキストエディタの大部分は、 Emacs
Lispと呼ばれるプログラム言語で記述してあります。 Emacs
Lispで新たなコードを書いて、
それをエディタの拡張としてインストールできます。 しかし、Emacs
Lispは、単なる『拡張言語』ではありません。
それ自身、れっきとしたプログラム言語です。
他のプログラム言語でできることは、Emacs Lispでできます。

   Emacs Lispは、エディタで使うために設計してあるため、
ファイル、バッファ、ディスプレイ、サブプロセスなどを扱う機能に加えて、
テキストを走査し解析する特別な機能もあります。 Emacs
Lispは編集機構に密に組み込まれています。
このため、編集コマンドはLispプログラムからも呼び出せる関数ですし、
カスタマイズのためのパラメータは普通のLisp変数です。

   本書は、Emacs Lispを完全に記述することを目指しています。
初心者向けの入門には、Free Software Foundation刊、 Bob Chassellの`An
Introduction to  Emacs Lisp Programming' (1) をご覧ください。
本書では、Emacsの操作を熟知しているものと仮定します。
操作に関する基本的な情報は、`The GNU Emacs Manual' (2)
を参照してください。

   おおまかにいえば、始めのほうの章では、
多くのプログラム言語に見られる機能に相当するEmacs Lispの機能を説明し、
あとのほうの章では、 Emacs
Lispに特有の機能や編集に特化した機能を説明します。

   本書は、2.5版です。

* Menu:

* Caveats::             Flaws and a request for help.
* Lisp History::        Emacs Lisp is descended from Maclisp.
* Conventions::         How the manual is formatted.
* Version Info::        Which Emacs version is running?
* Acknowledgements::    The authors, editors, and sponsors of this manual.

   ---------- Footnotes ----------

   (1) 【訳注】日本語訳： 『Emacs
Lispプログラミング入門』、アスキー出版局、ISBN 4-7561-1805-4

   (2) 【訳注】日本語訳： 『GNU Emacsマニュアル』、アスキー出版局、ISBN
4-7561-3002-X


File: elisp-ja,  Node: Caveats,  Next: Lisp History,  Up: Introduction

1.1 警告
==========

本書は、数多くの草稿を重ねてきました。
ほぼ完璧に近いはずですが、誤りは皆無ではありません。
ふれていない話題も少なからずあります。
（大部分の個別のモードのような）副次的と捉えている話題や、
まだ執筆していない話題もあります。
完全にはこれらに対処しきれませんので、
意図的に省いたことがらもあります。
たとえば、VMSにおける利用方法に関する情報です。

   本書で取り上げたことがらに関しては、本書は完璧であるべきですから、
例題や記述内容から章や節の構成順序といったことまで、
広く意見を求めています。
混乱を招くような記述や、本書でふれていないことがらを
学ぶためにソースや実験で調べる必要があるときには、
本書を改訂すべきなのでしょう。 そのときは、ぜひ、教えてください。

本書を読むときには、訂正箇所をみつけたらすぐ送ってくださるようにお願いします。
1つの関数や一連の関数向けに、簡素で実用に即した例を思い付いたならば、
それを書き上げて、送ってください。
章／節／関数の名前を適宜入れてください。
それから、どの版に対する意見かも書いてください。

   意見や訂正は、下記へメイルしてください。

     bug-lisp-manual@gnu.org

ここに蓄積されたメイルは、誰かが改訂作業を始めるまでは、読み出しません。
改訂までに、数か月、ときには、数年経過することもあります。
ですから、返事がないと憤慨しないでください。
あなたのメイルは、そのうち処理_されます_。
Emacs保守グループに迅速に連絡したい場合には、
`bug-gnu-emacs@gnu.org'にメイルしてください。


File: elisp-ja,  Node: Lisp History,  Next: Conventions,  Prev: Caveats,  Up: Introduction

1.2 Lispの歴史
=================

Lisp（LISt Processing language、リスト処理言語）は、
人工知能の研究向けに1950年代末にMITで初めて開発されました。
Lisp言語はとても強力なので、
エディタコマンドを記述するなどの他の目的にも理想的なのです。

   長年にわたって何ダースものLispが実装されており、
それぞれが独自の特徴を有しています。
その多くは、1960年代のMITのMACプロジェクトで開発されたMaclispの
影響を受けています。 最終的には、Maclispの系統の実装者達は共同して、
Common Lispと呼ばれるLispシステムの規格を開発しました。
そうこうするうちに、MITのGerry SussmanとGuy Steeleは、
単純化してあるが非常に強力なSchemeと呼ばれるLispの方言を開発しました。

   GNU EmacsはMaclispの影響を強く受けていますが、 Common
Lispからの影響は少ないです。 Common Lispを知っている読者は、 Common
Lispとの多くの類似点に気づかれるでしょう。 しかしながら、Common
Lispの多くの機能は、 省いてあるか、単純化してあります。 これは、GNU
Emacsが必要とするメモリ量を削減するためです。
ときには、劇的に単純化してあるために、 Common
Lispユーザーは混乱するかもしれません。 GNU Emacs LispとCommon
Lispとの相違点は、 ことあるごとに指摘するつもりです。 Common
Lispを知らない読者は、何も心配することはありません。
本書は自己完結しています。

   `cl'ライブラリにより、Common Lispをかなりエミュレートできます。
*Note Common Lisp Extension: (cl)Top。

   Emacs LispはSchemeの影響をまったく受けていません。
しかし、GNUプロジェクトには、Guileと呼ばれるSchemeの実装があります。
拡張が必要なすべての新たなGNUソフトウェアではGuileを使います。


File: elisp-ja,  Node: Conventions,  Next: Version Info,  Prev: Lisp History,  Up: Introduction

1.3 表記法
=============

本節では、本書で用いる表記法を説明します。
本節を読み飛ばして、あとで参照してもかまいません。

* Menu:

* Some Terms::               Explanation of terms we use in this manual.
* nil and t::                How the symbols `nil' and `t' are used.
* Evaluation Notation::      The format we use for examples of evaluation.
* Printing Notation::        The format we use when examples print text.
* Error Messages::           The format we use for examples of errors.
* Buffer Text Notation::     The format we use for buffer contents in examples.
* Format of Descriptions::   Notation for describing functions, variables, etc.


File: elisp-ja,  Node: Some Terms,  Next: nil and t,  Up: Conventions

1.3.1 用語
------------

本書では、『Lispリーダ』および『Lispプリンタ』という言葉で、
Lispオブジェクトのテキスト表現を実際のLispオブジェクトに変換する
Lisp内部のルーティン群、および、逆の変換を行うルーティン群を指します。
詳しくは、*Note Printed Representation::。
本書の読者を『プログラマ』と考えて『読者』と呼びます。
『ユーザー』とは作者自身を含めたLispプログラムを使う人のことです。

   Lispコードの例は、`(list 1 2 3)'という形式で、
このフォントで記します。
メタな変数の名前や説明対象の関数に対する引数の名前は、
FIRST-NUMBERという形式で、このフォントで書きます。


File: elisp-ja,  Node: nil and t,  Next: Evaluation Notation,  Prev: Some Terms,  Up: Conventions

1.3.2 `nil'と`t'
-----------------

Lispでは、シンボル`nil'には3つの異なる意味があります。
まず、`nil'という名前のシンボルです。 2つめは、真理値のŁ（false）です。
3つめは、空リスト、つまり、要素数が0個のリストです。
変数として使った場合、`nil'の値はつねに`nil'です。

   Lispリーダにとっては、`()'と`nil'は同一です。
どちらも、同じオブジェクト、シンボル`nil'を表します。
シンボルを異なった書き方にするのは、完全に人間向けです。
`()'や`nil'をLispリーダが読み取ったあとでは、
プログラマが実際にどちらの表記を用いたかわかりません。

   本書では、空リストを強調するときには`()'を使い、
真理値のŁを強調するときには`nil'を使います。
これは、Lispプログラムでも使うとよい慣習です。

     (cons 'foo ())                ; 空リストであることを強調する
     (not nil)                     ; 真理値のŁであることを強調する

   真理値の真を必要とする場面では、
`nil'以外の値は、ǜ（true）であるとみなします。
しかし、ǜを表す望ましい書き方は`t'です。 ǜを表す値が必要なとき、
適当な判断基準がない場合には`t'を使います。
シンボル`t'の値はつねに`t'です。

   Emacs Lispでは、`nil'と`t'は特別なシンボルであり、
評価するとそれ自身になります。
そのため、これらをプログラム内で定数として使うとき、
これらをクォートする必要はありません。
これらの値を変更しようとすると、エラー`setting-constant'になります。
コロン（`:'）で始まる名前のシンボルも同様です。 *Note Constant
Variables::。


File: elisp-ja,  Node: Evaluation Notation,  Next: Printing Notation,  Prev: nil and t,  Up: Conventions

1.3.3 評価の表記法
------------------------

評価可能なLisp式を"フォーム"（form、形式）と呼びます。
フォームを評価すると、Lispオブジェクトである結果を生じます。
本書の例題では、これを`=>'で表します。

     (car '(1 2))
          => 1

これは、『`(car '(1 2))'を評価すると1になる』と読みます。

   フォームがマクロ呼び出しの場合には、
Lispが評価すべき新たなフォームに展開します。 展開結果を`==>'で表します。
展開したフォームの評価結果を示す場合もあれば、 示さない場合もあります。

     (third '(a b c))
          ==> (car (cdr (cdr '(a b c))))
          => c

   あるフォームを説明するときに、
同一の結果を生じる別のフォームを示すことがあります。
2つのまったく等価なフォームを`=='で表します。

     (make-sparse-keymap) == (list 'keymap)


File: elisp-ja,  Node: Printing Notation,  Next: Error Messages,  Prev: Evaluation Notation,  Up: Conventions

1.3.4 結果表示の表記法
------------------------------

本書の数多くの例題は、評価するとテキストを表示します。
（`*scratch*'バッファのような）Lisp対話バッファで例題のコードを
実行すると、表示テキストはバッファに挿入されます。
（関数`eval-region'で評価するなどの）
別の手段で例題を実行すると、表示テキストはエコー領域に表示されます。
エコー領域に表示されるテキストは、1行に切り詰められていることに
注意してください。

   本書の例題では、表示場所には無関係に、 表示テキストを`-|'で表します。
フォームを評価した結果返される値（ここでは`bar'）は、
後続の行に分けて書きます。

     (progn (print 'foo) (print 'bar))
          -| foo
          -| bar
          => bar


File: elisp-ja,  Node: Error Messages,  Next: Buffer Text Notation,  Prev: Printing Notation,  Up: Conventions

1.3.5 エラーメッセージ
------------------------------

エラーを通知する例題もあります。
これは、通常、エコー領域にエラーメッセージを表示します。
エラーメッセージは、`error-->'で始まる行に示します。
エコー領域には、`error-->'は表示されないことに注意してください。

     (+ 23 'x)
     error--> Wrong type argument: number-or-marker-p, x


File: elisp-ja,  Node: Buffer Text Notation,  Next: Format of Descriptions,  Prev: Error Messages,  Up: Conventions

1.3.6 バッファ内のテキストの表記法
------------------------------------------------

バッファ内のテキストを修正する例題もあります。
このような場合、『実行前』と『実行後』のテキストを示します。
それらの例題では、バッファ名を含めたダッシュから成る2行で挟んで、
当該バッファの内容を示します。 さらに、ポイント位置を`-!-'で表します。
（もちろん、ポイントを表す記号は、バッファ内のテキストの一部ではない。
現在ポイントが位置する2つの文字の_あいだ_を表す。）

     ---------- Buffer: foo ----------
     This is the -!-contents of foo.
     ---------- Buffer: foo ----------

     (insert "changed ")
          => nil
     ---------- Buffer: foo ----------
     This is the changed -!-contents of foo.
     ---------- Buffer: foo ----------


File: elisp-ja,  Node: Format of Descriptions,  Prev: Buffer Text Notation,  Up: Conventions

1.3.7 記述形式
------------------

関数、変数、マクロ、コマンド、ユーザーオプション、
スペシャルフォームは、本書では統一した形式で記述します。
第1行目は、それぞれの名前と、引数があれば引数群です。
関数、変数、マクロ、コマンド、ユーザーオプションの分類を行頭に書きます。
これに説明文が続き、場合によっては例題も示します。

* Menu:

* A Sample Function Description::       A description of an imaginary
                                          function, `foo'.
* A Sample Variable Description::       A description of an imaginary
                                          variable,
                                          `electric-future-map'.


File: elisp-ja,  Node: A Sample Function Description,  Next: A Sample Variable Description,  Up: Format of Descriptions

1.3.7.1 関数の記述例
..........................

関数の記述では、まず始めに説明対象の関数名があります。
同じ行には、引数名の並びも続きます。
これらの名前は、説明文の中で引数の値を参照するために使います。

   引数ならびにキーワード`&optional'が現れていれば、
それ以降の引数を省略できることを示します（省略した引数の値は`nil'）。
関数を呼び出すときに`&optional'を書いてはいけません。

   キーワード`&rest' （このあとには1つの引数名だけが続く）は、
残りの引数が何個でもよいことを示します。
直後にある1つの引数名は、変数としての値を持ち、
その値は残りのすべての引数のリストです。
関数を呼び出すときに`&rest'を書いてはいけません。

   では、仮想的な関数`foo'の記述を以下に示します。

 -- Function: foo integer1 &optional integer2 &rest integers
     関数`foo'は、INTEGER2からINTEGER1を引き算し、
     残りのすべての引数を減算結果に加える。
     INTEGER2を指定しないと、デフォルトでは、数19から引き算する。

          (foo 1 5 3 9)
               => 16
          (foo 5)
               => 14

     より一般的には、つぎのとおり。

          (foo W X Y...)
          ==
          (+ (- X W) Y...)

   （INTEGER、INTEGER1、BUFFERなどの）型名を名前とする引数は、
その型の値であると仮定します。
（BUFFERSのように）型を複数形にした場合には、
しばしば、その型のオブジェクトのリストを意味します。
OBJECTという名前の引数は、任意の型でかまいません。
（Emacsオブジェクトの型の一覧については、*note Lisp Data Types::）。
（NEW-FILEなどの）その他の名前の引数は、関数の説明文の中で言及します。
複数の関数の引数に共通する特徴について、
節の始めで説明する場合もあります。

   `&optional'と`&rest'についての詳しい説明は、 *Note Lambda
Expressions::。

   コマンド、マクロ、スペシャルフォームの記述も同じ形式ですが、
「関数」のかわりに
「コマンド」、「マクロ」、「スペシャルフォーム」のいずれかです。
コマンドは、対話的に呼び出せる単なる関数です。
マクロは関数とは違った方法で引数を処理します（引数を評価しない）が、
同じ方法で引数を記します。

   スペシャルフォームの記述では、省略可能な引数や繰り返される引数を
示すために、より複雑な記法を使います。
というのは、引数並びを個々の引数に分離する方法が複雑だからです。
`[OPTIONAL-ARG]'は、 OPTIONAL-ARGが省略可能であることを示します。
また、`REPEATED-ARGS...'は、0個以上の引数を示します。
いくつかの引数をリスト構造の内側にまとめるときには、 括弧を使います。

 -- Special Form: count-loop (VAR [FROM TO [INC]]) BODY...
     この仮想的なスペシャルフォームは、
     フォーム群BODYを実行してから変数VARを増やすことを
     反復するループを実現する。 最初は、変数の値はFROMである。
     以降の反復では、変数を1（あるいは、指定があればINCだけ）増やす。
     VARがTOに等しくなると、 BODYを実行せずにループから抜ける。
     例を示す。

          (count-loop (i 0 10)
            (prin1 i) (princ " ")
            (prin1 (aref vector i))
            (terpri))

     FROMとTOを省略すると、 ループ開始前にVARに`nil'を束縛し、
     各反復の開始時にVARが`nil'以外であるとループから抜け出る。

          (count-loop (done)
            (if (pending)
                (fixit)
              (setq done t)))

     このスペシャルフォームでは、引数FROMとTOは省略できるが、
     両者を同時に指定するか、同時に省略すること。
     これらを指定した場合、INCを指定してもよい。
     これらの引数は、引数VARとともにリストにまとめる。
     これはBODYと区別するためであり、
     BODYは残りのフォームの要素すべてを含む。


File: elisp-ja,  Node: A Sample Variable Description,  Prev: A Sample Function Description,  Up: Format of Descriptions

1.3.7.2 変数の記述例
..........................

"変数"（variable）は、値を保持するための名前です。
ユーザーはどんな変数でも設定できますが、
ユーザーが変更可能な特定の変数群があり、
それらを"ユーザーオプション"（user options）と呼びます。
普通の変数もユーザーオプションも関数の記述と同じ形式で示しますが、
それらに引数はありません。

   仮想的な変数`electric-future-map'の記述例を示します。

 -- Variable: electric-future-map
     この変数の値は、Electric Command Futureモードで使用する
     完全なキーマップである。
     このマップに含まれる関数は、まだ実行していないコマンドの編集を可能にする。

   ユーザーオプションの記述も同じ形式ですが、
「変数」のかわりに「ユーザーオプション」です。


File: elisp-ja,  Node: Version Info,  Next: Acknowledgements,  Prev: Conventions,  Up: Introduction

1.4 版情報
=============

これらの機構は、使用中のEmacsの版に関する情報を提供します。

 -- コマンド: emacs-version
     この関数は、実行中のEmacsの版を記述した文字列を返す。
     この文字列はバグの報告に含めると有益である。

          (emacs-version)
            => "GNU Emacs 20.3.5 (i486-pc-linux-gnulibc1, X toolkit)
           of Sat Feb 14 1998 on psilocin.gnu.org"

     対話的に呼び出すと、この関数は同じ情報をエコー領域に表示する。

 -- Variable: emacs-build-time
     この変数の値は、ローカルのサイトでEmacsを構築した日時を示す。
     3つの整数から成るリストであり、 `current-time'と同様のもの（*note
     Time of Day::）。

          emacs-build-time
               => (13623 62065 344633)

 -- Variable: emacs-version
     この変数の値は、実行中のEmacsの版番号。
     `"20.3.1"'のような文字列である。
     この文字列の最後の数字は、Emacsのリリース版番号の一部ではなく、
     特定のディレクトリでEmacsを構築するたびに増える。

   つぎの2つの変数は、Emacs 19.23以降に存在します。

 -- Variable: emacs-major-version
     Emacsのメジャー版番号を表す整数。 Emacs 20.3では、値は20。

 -- Variable: emacs-minor-version
     Emacsのマイナ版番号を表す整数。 Emacs 20.3では、値は3。


File: elisp-ja,  Node: Acknowledgements,  Prev: Version Info,  Up: Introduction

1.5 謝辞
==========

本書は、Robert Krawitz、Bil Lewis、Dan LaLiberte、 Richard M.
Stallman、Chris Welty、GNUマニュアルプロジェクトのボランティア
による何年にもわたる努力で執筆されました。 Computational
Logic社のWarren A. Hunt, Jr.が手配した 国防省Advanced Research Projects
Agency、ARPA Order 6082の援助のもと、 Robert J.
Chassellは本書のレビューと編集に協力してくれました。

   以下の方々が訂正を送ってくれました。 Karl Berry、Jim Blandy、Bard
Bloom、 Stephane Boucher、David Boyes、Alan Carroll、Richard
Davis、Lawrence R. Dodd、Peter Doornbosch、David A. Duff、Chris
Eich、Beverly Erlebacher、David Eckelkamp、Ralf Fassel、Eirik
Fuller、Stephen Gildea、 Bob Glickstein、Eric Hanchrow、George
Hartzell、Nathan Hess、 Masayuki Ida、 Dan Jacobson、Jak Kirman、Bob
Knighten、Frederick M. Korz、Joe Lammens、Glenn M. Lewis、K. Richard
Magill、Brian Marick、Roland McGrath、Skip Montanaro、John Gardiner
Myers、Thomas A. Peterson、 Francesco Potorti、Friedrich
Pukelsheim、Arnold D. Robbins、Raul Rockwell、Per Starback、Shinichirou
Sugou、Kimmo Suominen、Edward Tharp、 Bill Trost、Rickard Westman、Jean
White、Matthew Wilding、Carl Witty、 Dale Worley、Rusty Wright、David
D. Zuhn。


File: elisp-ja,  Node: Lisp Data Types,  Next: Numbers,  Prev: Introduction,  Up: Top

2 Lispのデータ型
*********************

Lisp"オブジェクト"（object）とは、
Lispプログラムが使用し操作するデータのことです。
"型"（type）や"データ型"（data type）とは、ここでは、
可能なオブジェクトの集合を意味します。

   各オブジェクトは、少なくとも、1つの型に属します。
同じ型のオブジェクトは、構造に類似性があり、普通、同じ文脈で使われます。
型は互いに重複していてもよく、オブジェクトは複数の型に属することができます。
そのため、オブジェクトが特定の型に属するかどうかは判断できますが、
オブジェクトの型を『1つ』に限定することはできません。

   Emacsには少数の基本オブジェクト型を組み込んであります。
これらの型は他のすべてのオブジェクト型を構成するもとであり、
"基本型"（primitive types）と呼びます。
各オブジェクトはたった1つの基本型に属します。 基本型には、
"整数"（integer）、"浮動小数点数"（float）、
"コンス"（cons）、"シンボル"（symbol）、
"文字列"（string）、"ベクトル"（vector）、"subr"、
"バイトコード関数"（byte-code function）、
ならびに、編集に関連する"バッファ"（buffer）などの 特別な型があります。
（*note Editing Types::。）

   各基本型には、その型に属するオブジェクトであるかどうかを検査する
対応するLisp関数があります。

   Lispオブジェクトは"型を自己記述"（self-typing）するという点で、
Lispは他の多くの言語とは異なります。
つまり、オブジェクトの基本型は、オブジェクト自体に暗に含まれています。
たとえば、オブジェクトがベクトルであれば、それを数と扱うことはありません。
Lispには、ベクトルは数ではないとわかっているのです。

多くの言語では、プログラマは各変数のデータ型を宣言する必要があります。
型はコンパイラが知っているのであって、データの中には入っていません。
このような型宣言はEmacs Lispには存在しません。
Lisp変数はどんな型の値でも保持でき、
変数に入れた値と型を記録しています。

   本章では、GNU Emacs Lispの各標準型の表示表現と入力構文を説明します。
これらの型の使用方法の詳細は、あとの章に譲ります。

* Menu:

* Printed Representation::      How Lisp objects are represented as text.
* Comments::                    Comments and their formatting conventions.
* Programming Types::           Types found in all Lisp systems.
* Editing Types::               Types specific to Emacs.
* Type Predicates::             Tests related to types.
* Equality Predicates::         Tests of equality between any two objects.


File: elisp-ja,  Node: Printed Representation,  Next: Comments,  Up: Lisp Data Types

2.1 表示表現と入力構文
===============================

オブジェクトの"表示表現"（printed representation）とは、
Lispプリンタ（関数`prin1'）がそのオブジェクトを出力表示するときの
書式です。 オブジェクトの"入力構文"（read syntax）とは、
Lispリーダ（関数`read'）がそのオブジェクトを入力として受理する書式です。
*Note Read and Print::。

   ほとんどのオブジェクトには1つ以上の可能な入力構文があります。
ある種の型のオブジェクトには入力構文はありませんが、
そのような型のオブジェクトをLispプログラムに直接入力する意味がないからです。
このような場合を除くと、
オブジェクトの表示表現はそのオブジェクトの入力構文でもあります。

   他の言語では、式はテキストであって、これ以外の形はありません。
Lispでは、式はとにかくLispオブジェクトであって、
オブジェクトの入力構文であるテキストは副次的なものです。
この違いを強調する必要はありませんが、
このことを心に留めておかないと混乱することがあります。

   各型には表示表現があります。 入力構文のない型もあります。
たとえば、バッファ型には入力構文はありません。
このような型のオブジェクトは"ハッシュ記法"（hash
notation）で表示します。 つまり、文字列`#<'のあとに説明用の文字列
（典型的には型名にオブジェクトの名前を続けたもの）を続け、
対応する`>'で閉じます。 ハッシュ記法を読み取ることはできませんから、
Lispリーダが`#<'に出会うとエラー`invalid-read-syntax'を 通知します。 

     (current-buffer)
          => #<buffer objects.texi>

   読者が対話的に式を評価するとき、 Lispインタープリタは、まず、
式のテキスト表現を読み取ってLispオブジェクトを生成し、
そのオブジェクトを評価します（*note Evaluation::）。
しかしながら、評価と読み取りは別々の動作です。
読み取りでは、読み取ったテキストが表すLispオブジェクトを返します。
このオブジェクトを、のちに評価する場合もありますが、
評価しない場合もあります。
オブジェクトを読み取る基本関数`read'については、 *Note Input
Functions::。


File: elisp-ja,  Node: Comments,  Next: Programming Types,  Prev: Printed Representation,  Up: Lisp Data Types

2.2 コメント
================

"コメント"（comment）は、プログラム内に書かれたテキストであり、
プログラムを読む人間のためだけにあり、
プログラムの意味にはまったく影響しません。
Lispでは、文字列や文字定数の外にあるセミコロン（`;'）で
コメントを始めます。 コメントは行末までです。
Lispリーダは、コメントを破棄します。 コメントは、
Lispシステム内部でプログラムを表すLispオブジェクトの一部にはなりません。

   `#@COUNT'という書き方は、 後続のCOUNT個の文字を飛び越します。
これは、プログラムで生成したバイナリデータを含むコメントに便利です。
Emacs
Lispのバイトコンパイラは、出力ファイルにこのようなコメントを使います
（*note Byte Compilation::）。
しかしながら、ソースファイル向きではありません。

   コメントの体裁に関する慣習については、*Note Comment Tips::。


File: elisp-ja,  Node: Programming Types,  Next: Editing Types,  Prev: Comments,  Up: Lisp Data Types

2.3 プログラミング向けの型
=====================================

Emacs Lispには、大きく2種類の型があります。
Lispのプログラミングに関わるものと、編集に関わるものです。
前者は、さまざまな形でLispの多くの実装に見られます。 後者は、Emacs
Lispに固有です。

* Menu:

* Integer Type::        Numbers without fractional parts.
* Floating Point Type:: Numbers with fractional parts and with a large range.
* Character Type::      The representation of letters, numbers and
                        control characters.
* Symbol Type::         A multi-use object that refers to a function,
                        variable, or property list, and has a unique identity.
* Sequence Type::       Both lists and arrays are classified as sequences.
* Cons Cell Type::      Cons cells, and lists (which are made from cons cells).
* Array Type::          Arrays include strings and vectors.
* String Type::         An (efficient) array of characters.
* Vector Type::         One-dimensional arrays.
* Char-Table Type::     One-dimensional sparse arrays indexed by characters.
* Bool-Vector Type::    One-dimensional arrays of `t' or `nil'.
* Function Type::       A piece of executable code you can call from elsewhere.
* Macro Type::          A method of expanding an expression into another
                          expression, more fundamental but less pretty.
* Primitive Function Type::     A function written in C, callable from Lisp.
* Byte-Code Type::      A function written in Lisp, then compiled.
* Autoload Type::       A type used for automatically loading seldom-used
                        functions.


File: elisp-ja,  Node: Integer Type,  Next: Floating Point Type,  Up: Programming Types

2.3.1 整数型
---------------

Emacs Lispにおける整数の値の範囲は、ほとんどの計算機では、
-134217728から134217727（28ビット長。つまり -2**27 から 2**27 - 1）
です。 （計算機によっては、より広い範囲になる。） Emacs
Lispの算術演算関数は、桁溢れ（オーバフロー）を
検査しないことを覚えておいてください。
したがって、ほとんどの計算機では、 `(1+
134217727)'は-134217728となります。

   整数の入力構文は、（10を基数とした）数字の並びであり、
先頭に符号があってもよく、また、最後にピリオドがあってもかまいません。
Lispインタープリタが生成する表示表現では、
先頭の`+'や最後の`.'はありません。

     -1               ; 整数 -1
     1                ; 整数 1
     1.               ; これも整数 1
     +1               ; これも整数 1
     268435457        ; 28ビット長整数では、これも整数 1

   より詳しくは、*Note Numbers::。


File: elisp-ja,  Node: Floating Point Type,  Next: Character Type,  Prev: Integer Type,  Up: Programming Types

2.3.2 浮動小数点数
------------------------

Emacsは浮動小数点数を扱えます
（ただし、コンパイル時のオプションで使用不可にできる）。
浮動小数点数の範囲は、計算機に依存します。

   浮動小数点数の表示表現には、
小数点（に続けて1桁以上の小数部分）または指数、
あるいは、その両方が必要です。 たとえば、`1500.0'、`15e2'、`15.0e2'、
`1.5e3'、`.15e4'は、同じ1500という値の 浮動小数点数を書く5つの方法です。
どれも、まったく等価です。

   詳しくは、*Note Numbers::。


File: elisp-ja,  Node: Character Type,  Next: Symbol Type,  Prev: Floating Point Type,  Up: Programming Types

2.3.3 文字型
---------------

Emacs Lispにおける"文字"（character）は、 整数以外の何物でもありません。
いいかえれば、文字はその文字コードで表現されます。
たとえば、文字`A'は整数 65と表現されます。

   プログラムで個々の文字を独立に使うことはあまりありません。
文字を並べた_文字列_（strings）として扱うことが断然多いのです。 *Note
String Type::。

   文字列内、バッファ内、ファイル内の文字は、
現時点では、0から524287までの範囲、19ビット長に制限されます。
しかし、この範囲の値すべてが正しい文字コードではありません。
0から127までのコードはASCIIコードです。 それ以外は、非ASCIIです（*note
Non-ASCII Characters::）。
キーボード入力を表す文字は、コントロール、メタ、シフトなどの
修飾キーを符号化するために、範囲がより広くなります。

   文字は、実際には整数ですから、文字の表示表現は10進数です。
また、文字の入力構文として10進数も可能ですが、
Lispプログラムでこのように文字を書くのは最悪です。 Emacs
Lispに用意してある文字向けの特別な入力構文を _つねに_使うべきです。
これらの構文は疑問符で始まります。

   英数字向けの普通の入力構文は、疑問符に続けて1つの英数字を書きます。
したがって、文字`A'は`?A'、文字`B'は`?B'、 文字`a'は`?a'と書きます。

   たとえば、つぎのとおりです。

     ?Q => 81     ?q => 113

   同じ入力構文を句読点文字にも使えますが、
`\'を追加して、Lispコードを編集するEmacsコマンドが混乱しないように
することがよいでしょう。 たとえば、空白文字は`?\ 'と書きます。
文字`\'は、クォートするために2つめの`\'を使う_必要があり_ `?\\'です。

   コントロールg、バックスペース、タブ、改行、
垂直タブ、ページ送り、復帰、エスケープは、
それぞれ、`?\a'、`?\b'、`?\t'、`?\n'、`?\v'、
`?\f'、`?\r'、`?\e'と書きます。 つまり、つぎのとおりです。

     ?\a => 7                 ; `C-g'
     ?\b => 8                 ; バックスペース、 <BS>、`C-h'
     ?\t => 9                 ; タブ、 <TAB>、`C-i'
     ?\n => 10                ; 改行、`C-j'
     ?\v => 11                ; 垂直タブ、`C-k'
     ?\f => 12                ; ページ送り文字、`C-l'
     ?\r => 13                ; 復帰、<RET>, `C-m'
     ?\e => 27                ; エスケープ文字、<ESC>、`C-['
     ?\\ => 92                ; バックスラッシュ文字、`\'

   バックスラッシュで始まる系列は "エスケープシーケンス"（escape
sequences）とも呼びます。
バックスラッシュが、エスケープ文字の役割を果たすからです。
この使い方は、文字<ESC>とは関係ありません。

   コントロール文字は別の入力構文でも表現できます。
疑問符に続けてバックスラッシュ、カレット（`^'）、そして、
対応するコントロールでない文字を大文字か小文字で書きます。
たとえば、`?\^I'も`?\^i'も、 値が9である文字`C-i'の正しい入力構文です。

   カレットのかわりに、`C-'を使ってもかまいません。
ですから、`?\C-i'は、`?\^I'や`?\^i'と等価です。

     ?\^I => 9     ?\C-I => 9

   文字列やバッファ内ではASCIIのコントロール文字だけが許されますが、
キーボード入力においては`C-'で任意の文字をコントロール文字にできます。
これらの非ASCIIコントロール文字の文字コードは、
対応する非コントロール文字の文字コードと 2**26 のビットを含みます。
普通の端末では、非ASCIIコントロール文字を生成する手立てはありませんが、
Xウィンドウシステムや他のウィンドウシステムでは、 簡単に生成できます。

   歴史的な理由で、
Emacsは<DEL>文字を`?'に対応したコントロール文字として扱います。

     ?\^? => 127     ?\C-? => 127

その結果、今のところ、
Xウィンドウシステムのもとでは意味のある文字`Control-?'を
`\C-'では表現できません。

   ファイルや文字列に現れるコントロール文字を表現するには、
`^'構文を勧めます。
キーボード入力のコントロール文字には、`C-'構文が好ましいです。
どちらを使ってもプログラムの意味には影響しませんが、
それを読む人には理解の手助けになるかもしれません。

   "メタ文字"（meta character）は、
<META>修飾キーを使って打った文字です。
そのような文字を表す整数は、（ほとんどの計算機では負の数になる） 2**27
のビットがセットされています。
上位のビットをメタや他の修飾子に用いることで、
基本となる文字コードの範囲をできるだけ大きくします。

   文字列では、メタ文字を表すASCII文字には 2**7 のビットを付加します。
つまり、文字列に収められるメタ文字のコードは128から255の範囲であり、
任意のASCII文字のメタ変種を使えます。 （Emacs
18やそれ以前では、この方式を文字列の外にある文字にも使っていた。）

   メタ文字の入力構文には`\M-'を使います。
たとえば、`?\M-A'は`M-A'です。
`\M-'と一緒に8進文字コードも使えますし（下記参照）、
`\C-'や文字向けの他の構文も使えます。
したがって、`M-A'は`?\M-A'と書いたり`?\M-\101'と書けます。
同様に、`C-M-b'は`?\M-\C-b'、 `?\C-\M-b'、`?\M-\002'と書けます。

   図形文字の大文字小文字は、その文字コードで示されます。
たとえば、ASCIIでは`a'と`A'の文字を区別します。
しかし、ASCIIではコントロール文字の大文字小文字を表現できません。
Emacsでは、コントロール文字を打つときに使ったシフトキーを表すために
2**25 のビットを付加します。
このような区別はX端末や他の特別な端末を使っている場合に限り可能です。
普通の端末ではこのような区別を計算機に送れません。

   Xウィンドウシステムでは、
文字に設定可能な修飾ビットが他に3つあります。
"ハイパー"（hyper）、"スーパー"（super）、"アルト"（alt）です。
これらの修飾ビットの構文は、 `\H-'、`\s-'、`\A-'です。
（これらのプレフィックスでは、大文字小文字を区別する。）
したがって、`?\H-\M-\A-x'は`Alt-Hyper-Meta-x'を表します。 数値的には、
アルトは2**22、スーパーは2**23、ハイパーは2**24のビット値です。

   文字向けのもっとも汎用の入力構文では、
文字コードを8進数や16進数で表現します。 8進数を使うには、順に、
疑問符、バックスラッシュ、（3桁までの）8進数字文字コードを書きます。
たとえば、`?\101'は文字`A'を表し、
`?\001'は文字`C-a'を表し、`?\002'は文字`C-b'を表します。
この構文で任意のASCII文字を表現できますが、
ASCIIでの表現よりも8進数値で表現することが重要な場合に限るべきです。

     ?\012 => 10         ?\n => 10         ?\C-j => 10
     ?\101 => 65         ?A => 65

   16進数を使うには、順に、疑問符、バックスラッシュ、
`x'、16進数字文字コードを書きます。
16進数の桁数はいくつでもよいので、任意の文字コードを表現できます。
したがって、`?\x41'は文字`A'を表し、 `?\x1'は文字`C-a'を表し、
`?\x8e0'は グレーブアクセント付きの文字`a'を表します。

特別なエスケープの意味を持たないどんな文字のまえにもバックスラッシュを
付けることができ、しかも、無害です。 したがって、`?\+'は`?+'に等価です。
ほとんどの文字のまえにバックスラッシュを付ける理由はありません。
しかしながら、Lispコードを編集するEmacsコマンドが混乱しないように、
`()\|;'`"#.,'のいずれかの文字のまえにはバックスラッシュを付けるべきです。
空白、タブ、改行、ページ送りのような白文字のまえにも
バックスラッシュを付けるべきです。
しかしながら、タブなどの実際の白文字のかわりに、
`\t'などの読みやすいエスケープシーケンスを使ったほうが明確です。


File: elisp-ja,  Node: Symbol Type,  Next: Sequence Type,  Prev: Character Type,  Up: Programming Types

2.3.4 シンボル型
---------------------

GNU Emacs Lispにおける"シンボル"（symbol）は、
名前を持ったオブジェクトです。
シンボル名は、シンボルの表示表現としての役割があります。
普通の使い方では、名前は一意です。
つまり、2つのシンボルが同じ名前を持つことはありません。

   シンボルは、変数としての役割、関数名としての役割、
あるいは、属性リストを保持する役割を果たします。
また、他のすべてのLispオブジェクトと区別するためだけの役割を
果たすこともあり、データ構造の内部にそのようなシンボルが存在することを
正確に認識できます。
ある場面においては、普通、これらのうちの1つの使い方をします。
しかし、ある1つのシンボルに対してすべての使い方をしてもかまいません。

   シンボル名には、どんな文字でも含められます。
ほとんどのシンボル名は、英文字、数字、`-+=*/'の句読点文字で書かれます。
そのような名前では、特別な書き方は必要ありません。
名前が数に見えなければ、名前を構成する文字はなんでもよいのです。
（名前が数に見えるときには、
名前の先頭に`\'を書いてシンボルであると強制する。）
`_~!@$%^&:<>{}'の文字はあまり使われませんが、
これらにも特別な書き方は必要ありません。
これら以外の文字は、バックスラッシュでエスケープすれば、
シンボル名に含められます。
文字列におけるバックスラッシュの用法とは対照的に、
シンボル名におけるバックスラッシュは、直後の1文字をクォートするだけです。
たとえば、文字列では`\t'はタブ文字を表しますが、
シンボル名では英文字`t'をクォートするだけです。
名前にタブ文字を含むシンボルを書くには、
実際に（バックスラッシュの直後に）タブを使う必要があります。
しかし、そのようなことをするのは皆無でしょう。

     Common Lispに関した注意：` ' Common
     Lispでは、小文字を明示的にエスケープしない限り、
     小文字をつねに大文字に『変換』する。 Emacs
     Lispでは、大文字と小文字を区別する。

   シンボル名の例をいくつかあげましょう。
5番目の例の`+'は、数として読まれるのを防ぐために
エスケープしてあることに注意してください。
6番目の例では、これは必要ありません。
なぜなら、名前の残りの部分が数としては不正だからです。

     foo                 ; `foo'という名前のシンボル
     FOO                 ; `FOO'という名前のシンボル、`foo'とは別
     char-to-string      ; `char-to-string'という名前のシンボル
     1+                  ; `1+'という名前のシンボル
                         ;   （整数の`+1'ではない）
     \+1                 ; `+1'という名前のシンボル
                         ;   （読みにくい名前）
     \(*\ 1\ 2\)         ; `(* 1 2)'という名前のシンボル（悪い名前）
     +-*/_~!@$%^&=:<>{}  ; `+-*/_~!@$%^&=:<>{}'という名前のシンボル
                         ;   これらの文字をエスケープする必要はない


File: elisp-ja,  Node: Sequence Type,  Next: Cons Cell Type,  Prev: Symbol Type,  Up: Programming Types

2.3.5 シーケンス型
------------------------

"シーケンス"（sequence）とは、
要素の順序集合を表現するLispオブジェクトです。 Emacs
Lispには2種類のシーケンス、つまり、リストと配列があります。
したがって、リスト型や配列型のオブジェクトは、
シーケンス型でもあると考えられます。

配列はさらに、文字列、ベクトル、文字テーブル、ブールベクトルに細分されます。
ベクトルは任意の型の要素を保持できますが、
文字列の要素は文字である必要があり、
ブールベクトルの要素は`t'か`nil'のいずれかである必要があります。
バッファ内の文字のように、
文字列内の文字はテキスト属性を持てます（*note Text Properties::）。
ベクトルとブールベクトル (1) では、それらの要素が文字であったとしても、
テキスト属性を扱えません。
文字テーブルは、ベクトルに似ていますが、正しい文字コードで添字付けします。

   リスト、文字列、および、その他の配列型は別のものですが、
それらには重要な類似性があります。 たとえば、それらすべてに長さLがあり、
それらのすべての要素は0からL-1で添字付けできます。
シーケンス関数と呼ばれるいくつかの関数は、
任意のシーケンス型を扱います。
たとえば、シーケンスから指定した添字の要素を取り出すには、
関数`elt'を使います。 *Note Sequences Arrays Vectors::。

   一般には、同一のシーケンスを二度読み取ることは不可能です。
というのは、読むたびにつねに新たにシーケンスを作成するからです。
シーケンスの入力構文を二度読むと、
同じ内容の2つのシーケンスを得ることになります。 1つ例外があります。
空リスト`()'は、つねに同じオブジェクト`nil'を表します。

   ---------- Footnotes ----------

   (1) 【訳注】ベクトルのみの誤り？


File: elisp-ja,  Node: Cons Cell Type,  Next: Array Type,  Prev: Sequence Type,  Up: Programming Types

2.3.6 コンスセルとリスト型
------------------------------------

"コンスセル"（cons cell）とは、 CARスロットおよびCDRスロットと呼ばれる
2つのポインタから成るオブジェクトです。
各スロットは、任意のLispオブジェクトを"指す"ことができます。
また、現在CARスロットが指しているオブジェクトがなんであれ、
『コンスセルのCARは』といったいい方をします。 CDRについても同様です。

   "リスト"（list）はコンスセルが連なったものであり、
各コンスセルのCDRスロットは、
後続のコンスセルを指すか空リストを指します。
リストに作用する関数については、*Note Lists::。
ほとんどのコンスセルは、リストの一部分として使われるので、
"リスト構造"（list structure）という用語は、
コンスセルから成る任意の構造のことを意味します。

   CARやCDRという名称は、Lispの歴史に由来します。
最初のLispはIBM 704で動作していました。
この計算機では、ワードを2つの部分、『番地』（address）部分、
『減数』（decrement）部分と呼ばれるものに分けていました。
CARはレジスタの番地部分の内容（Contents of Address Register）を
取り出す命令であり、 CDRはレジスタの減数部分の内容（Contents of
Decrement Register）を 取り出す命令でした。
一方、『コンスセル』という名称は、
これらを作成する関数`cons'からきています。
この関数名は、その目的、セルを作る（construction of
cells）からきています。

   コンスセルはLispの核心なので、
『コンスセルではないオブジェクト』に対する名称もあります。
これらのオブジェクトを"アトム"（atoms）と呼びます。

   リストの入力構文と表示表現は同一です。
開き括弧で始まり、任意個の要素、閉じ括弧で終えます。

   読み取り時には、括弧の内側の各オブジェクトが、
リストの各要素になります。
つまり、これらの要素からなるコンスセルを作ります。
コンスセルのCARスロットで要素を指します。
同じコンスセルのCDRスロットで、 リスト上のつぎの要素を保持している、
リストのつぎのコンスセルを指します。
最後のコンスセルのCDRスロットは`nil'を指します。

   リストは、コンスセルを1対の箱で表して図示できます。
（Lispリーダがこのような図表示を読むことはない。
人間や計算機が理解できるテキスト表記と違い、
箱を用いた図表示は人間だけが理解できる。）
つぎの図は、3つの要素から成るリスト`(rose violet buttercup)'を表します。

         --- ---      --- ---      --- ---
        |   |   |--> |   |   |--> |   |   |--> nil
         --- ---      --- ---      --- ---
          |            |            |
          |            |            |
           --> rose     --> violet   --> buttercup

この図で、各箱は、任意のLispオブジェクトを指すことができるスロットを表します。
箱の対でコンスセルを表します。
各矢印は、アトムや他のコンスセルであるLispオブジェクトを指すポインタです。

   この例では、最初のコンスセルのCARを表す最初の箱は、
`rose'（シンボル）を指しています。
あるいは、`rose'（シンボル）を『含んでいる』ともいいます。
最初のコンスセルのCDRを表す2番目の箱は、
つぎの1対の箱、2番目のコンスセルを指しています。
2番目のコンスセルのCARは`violet'であり、
このコンスセルのCDRは3番目のコンスセルです。
3番目の（最後の）コンスセルのCDRは、`nil'です。

   同じリスト`(rose violet buttercup)'を
別の方法で図表示するとつぎのようになります。

      ---------------       ----------------       -------------------
     | car   | cdr   |     | car    | cdr   |     | car       | cdr   |
     | rose  |   o-------->| violet |   o-------->| buttercup |  nil  |
     |       |       |     |        |       |     |           |       |
      ---------------       ----------------       -------------------

   内部に要素を持たないリストは、"空リスト"（empty list）です。
これはシンボル`nil'と同一です。
いいかえれば、`nil'はシンボルでもありリストでもあります。

   Lispの構文で書き表したリストの例を示します。

     (A 2 "A")            ; 3要素のリスト
     ()                   ; 要素を持たないリスト（空リスト）
     nil                  ; 要素を持たないリスト（空リスト）
     ("A ()")             ; 文字列`"A ()"'だけの1要素のリスト
     (A ())               ; `A'と空リストから成る2要素のリスト
     (A nil)              ; 上と同じ
     ((A B C))            ; 1要素のリスト
                          ;   （その要素は3要素のリスト）

   リスト`(A ())'や、これと同じ`(A nil)'を
箱と矢印で書くとつぎのようになります。

         --- ---      --- ---
        |   |   |--> |   |   |--> nil
         --- ---      --- ---
          |            |
          |            |
           --> A        --> nil

* Menu:

* Dotted Pair Notation::        An alternative syntax for lists.
* Association List Type::       A specially constructed list.


File: elisp-ja,  Node: Dotted Pair Notation,  Next: Association List Type,  Up: Cons Cell Type

2.3.6.1 ドット対記法
..........................

"ドット対記法"（dotted pair notation）とは、
CARとCDRを明示したコンスセルを表すもう1つの構文です。 この構文では、`(A
. B)'で、 CARがオブジェクトAであり
CDRがオブジェクトBであるコンスセルを表します。
したがって、ドット対記法は、リストの構文よりさらに汎用性があります。
ドット対記法では、リスト`(1 2 3)'は、 `(1 .  (2 . (3 .
nil)))'と書けます。
`nil'で終るリストならば、どちらの記法でも書き表せますが、
リスト記法のほうがわかりやすくて便利です。
リストを表示するときには、コンスセルのCDRがリスト以外の場合に限って
ドット対記法を使います。

   ドット対記法を箱で表現してみます。 つぎの例は`(rose .
violet)'を表したものです。

         --- ---
        |   |   |--> violet
         --- ---
          |
          |
           --> rose

   最後のCDRが`nil'以外であるようなコンスセルの連鎖を表現するために、
リスト記法にドット対記法を組み合わせることもできます。
リストの最後の要素のあとにドットを書き、
続けて、最後のコンスセルのCDRを書きます。 たとえば、`(rose violet .
buttercup)'は、 `(rose . (violet . buttercup))'に等価です。
このオブジェクトはつぎのようになります。

         --- ---      --- ---
        |   |   |--> |   |   |--> buttercup
         --- ---      --- ---
          |            |
          |            |
           --> rose     --> violet

   `(rose . violet . buttercup)'という構文は不正です。
これが意味することはなにもありません。
たとえあったとしても、CDRを`violet'用にすでに使っているコンスセルの
CDRに`buttercup'を置けということになります。

   リスト`(rose violet)'は、`(rose . (violet))'に等価であり、
つぎのように図示できます。

         --- ---      --- ---
        |   |   |--> |   |   |--> nil
         --- ---      --- ---
          |            |
          |            |
           --> rose     --> violet

   同様に、3要素のリスト`(rose violet buttercup)'は、 `(rose . (violet
. (buttercup)))'に等価です。 つぎのように図示できます。

         --- ---      --- ---      --- ---
        |   |   |--> |   |   |--> |   |   |--> nil
         --- ---      --- ---      --- ---
          |            |            |
          |            |            |
           --> rose     --> violet   --> buttercup


File: elisp-ja,  Node: Association List Type,  Prev: Dotted Pair Notation,  Up: Cons Cell Type

2.3.6.2 連想リスト型
..........................

"連想リスト"（association list）、すなわち、"alist"は、
各要素がコンスセルであるように特別に構成したリストのことです。
各要素では、CARを"キー"（key）と考え、 CDRを"連想値"（associated
value）と考えます。
（場合によっては、連想値を、CDRのCARに保持することもある。）
連想リストはスタックとして使われることがままあります。
というのは、リストの先頭に対応関係を追加／削除するのが簡単だからです。

   たとえば、

     (setq alist-of-colors
           '((rose . red) (lily . white)  (buttercup . yellow)))

は、変数`alist-of-colors'に、3要素の連想リストを設定します。
最初の要素では、`rose'がキーであり、`red'が値です。

   連想リストとそれらを操作する関数について詳しい説明は、 *Note
Association Lists::。


File: elisp-ja,  Node: Array Type,  Next: String Type,  Prev: Cons Cell Type,  Up: Programming Types

2.3.7 配列型
---------------

"配列"（array）は、任意のLispオブジェクトを指すための
任意個のスロットから成り、メモリの連続した場所に取ります。
配列のどの要素を参照しても、ほぼ同じ時間かかります。
一方、リストの要素を参照するときには、
リスト内の要素の位置に比例した時間が必要です。
（リストの末尾の要素を参照するには、
リストの先頭の要素を参照するより時間がかかる。）

   Emacsには、4つの配列型、つまり、
文字列、ベクトル、ブールベクトル、文字テーブルがあります。

   文字列は文字の配列であり、 ベクトルは任意のオブジェクトの配列です。
ブールベクトルは、`t'や`nil'だけを保持できます。
これらの種類の配列は、最大の整数値までなら、任意の長さにできます。
文字テーブルは、正しい文字コードで添字付けする疎な配列であり、
任意のオブジェクトを保持できます。

   配列の最初の要素は0で添字付けする、
2番目の要素は1で添字付けする、というようになります。
これを"ゼロ原点"（zero-origin）の添字付けと呼びます。
たとえば、4つの要素からなる配列の添字は、0、1、2、そして、3です。
最大の添字は、配列の長さより1だけ小さくなります。
いったん配列を作成すると、その長さは固定されます。

   Emacs Lispのすべての配列は1次元です。
（多くの他のプログラム言語では多次元配列を扱えるが、
それは本質的ではない。 配列の配列を作れば同じ効果を得られる。）
配列のそれぞれの型に応じて、専用の入力構文があります。
詳しくは、以下を参照してください。

   配列型はシーケンス型に含まれ、
配列型は、文字型、ベクトル型、ブールベクトル型、文字テーブル型を含みます。


File: elisp-ja,  Node: String Type,  Next: Vector Type,  Prev: Array Type,  Up: Programming Types

2.3.8 文字列型
------------------

"文字列"（string）とは文字の配列です。
テキストエディタということから予想されるように、
Emacsではさまざまな目的に文字列を使います。
たとえば、Lispシンボルの名前として、 ユーザーへのメッセージとして、
バッファから取り出したテキストを表現するためなどです。
Lispの文字列は定数です。
つまり、文字列を評価すると同じ文字列になります。

   文字列を操作する関数については、*Note Strings and Characters::。

* Menu:

* Syntax for Strings::
* Non-ASCII in Strings::
* Nonprinting Characters::
* Text Props and Strings::


File: elisp-ja,  Node: Syntax for Strings,  Next: Non-ASCII in Strings,  Up: String Type

2.3.8.1 文字列の構文
..........................

文字列の入力構文は、`"like this"'のように、
ダブルクォートで始めて、任意個の文字を書き、ダブルクォートで終えます。
文字列の中にダブルクォートを含めるには、
バックスラッシュを直前に置きます。
つまり、`"\""'は、ダブルクォート1個だけから成る文字列です。
同様に、バックスラッシュを含めるには、 `"this \\ is a single embedded
backslash"'のように、 バックスラッシュを直前に置きます。

   文字列の入力構文において、改行文字は特別ではありません。
ダブルクォートのあいだに改行を書けば、 改行は文字列の文字になります。
一方、エスケープした改行、つまり、`\'を直前に書くと、
文字列の一部にはなりません。
すなわち、Lispリーダは、文字列を読む際にエスケープした改行を無視します。
エスケープした空白`\ 'も、同様に無視します。

     "It is useful to include newlines
     in documentation strings,
     but the newline is \
     ignored if escaped."
          => "It is useful to include newlines
     in documentation strings,
     but the newline is ignored if escaped."


File: elisp-ja,  Node: Non-ASCII in Strings,  Next: Nonprinting Characters,  Prev: Syntax for Strings,  Up: String Type

2.3.8.2 文字列内の非ASCII文字
.....................................

非ASCIIである国際化文字を文字列に含めるには、
その文字をそのまま書きます。 Emacsの文字列（および、バッファ）では、
非ASCIIの表現方法が2つあります。 ユニバイトとマルチバイトです。
マルチバイトバッファやマルチバイト文字列、あるいは、
マルチバイトとして訪問しているファイルなどの
マルチバイトのソースから文字列定数を読み取るときには、
文字をマルチバイト文字として読み取り、 マルチバイト文字列にします。
ユニバイトのソースから文字列定数を読み取るときには、
文字をユニバイト文字として読み取り、 文字列はユニバイトになります。

   マルチバイトの非ASCII文字は、
必要な桁数の16進エスケープ`\xNNNNNNN'を用いて 書くこともできます。
（マルチバイトの非ASCII文字のコードは、256より大きい。）
16進数字として正しくない文字で16進エスケープを終端します。
16進数字の文字があとに続く場合には、`\ '（バックスラッシュと空白）と
書いて16進エスケープを終端します。
たとえば、`\x8e0\ 'は、グレーブアクセント付きの`a'を表します。
文字列定数内の`\ 'は、バックスラッシュ＋改行と同じです。
文字列内の文字には含まれませんが、先行する16進エスケープを終えます。

   マルチバイトの16進エスケープを使うと、
文字列はマルチバイトになります。
ユニバイトの非ASCIIを文字コードで表現することもできますが、
文字コードは128（8進0200）から255（8進0377）の範囲である必要があります。
こうすると、文字列はユニバイトになります。

   2種類のテキストの表現方法について詳しくは、*Note Text
Representations::。


File: elisp-ja,  Node: Nonprinting Characters,  Next: Text Props and Strings,  Prev: Non-ASCII in Strings,  Up: String Type

2.3.8.3 文字列内の非印字文字
......................................

文字定数と同じバックスラッシュのエスケープシーケンスを文字列定数でも
使えます（ただし、文字定数を開始する疑問符は書かない）。
たとえば、コンマと空白で区切った非印字文字のタブと`C-a'を
含む文字列を書くには、`"\t, \C-a"'のようにします。
文字の入力構文については、*Note Character Type::。

   しかしながら、バックスラッシュのエスケープシーケンスすべてが、
文字列において正しいとは限りません。
文字列に含めることが可能なコントロール文字は、
ASCIIコントロール文字に限ります。
文字列では、ASCIIコントロール文字の大文字小文字を区別しません。

   正確にいえば、文字列はメタ文字を保持できません。
しかし、文字列をキー列として使う場合には、
文字列内のASCII文字のメタ変種を表現するための 特別な慣習があります。
文字列定数内でメタ文字を表すために`\M-'の構文を使うと、
文字列内のその文字に 2**7 のビットを設定します。
`define-key'や`lookup-key'に文字列を使うと、
このコードは、等価なメタ文字に変換されます。 *Note Character Type::。

   文字列では、ハイパー、スーパー、アルトの修飾子を保持できません。


File: elisp-ja,  Node: Text Props and Strings,  Prev: Nonprinting Characters,  Up: String Type

2.3.8.4 文字列内のテキスト属性
.........................................

文字列は、文字そのものに加えて、文字の属性も保持できます。
このため、特別なことをしなくても、
文字列とバッファのあいだでテキストをコピーするプログラムは、
テキスト属性をコピーできます。 テキスト属性の意味については、*Note Text
Properties::。 テキスト属性付きの文字列には、特別な入力構文があります。

     #("CHARACTERS" PROPERTY-DATA...)

ここで、PROPERTY-DATAは0個以上のつぎのような3つ組みです。

     BEG END PLIST

3つ組みの要素、BEGとENDは整数であり、 文字列内の添字の範囲を表します。
PLISTはその範囲の属性リストです。 たとえば、

     #("foo bar" 0 3 (face bold) 3 4 nil 4 7 (face italic))

は、最初の3文字が`face'属性として`bold'を持ち、
最後の3文字が`face'属性として`italic'を持つ、 `foo
bar'という文字列を表します。
（4番目の文字にはテキスト属性はなく、その属性リストは`nil'。
デフォルトでは、範囲に含まれない文字には属性はないので、
属性リストが`nil'であるような範囲を言及する必要はない。）


File: elisp-ja,  Node: Vector Type,  Next: Char-Table Type,  Prev: String Type,  Up: Programming Types

2.3.9 ベクトル型
---------------------

"ベクトル"（vector）は、任意の型の要素から成る1次元配列です。
ベクトルの任意の要素を参照しても、それに必要な時間は一定です。
（リストでは、ある要素を参照するために必要な時間は、
リストの先頭からの距離に比例する。）

   ベクトルの表示表現は、開き角括弧、要素、閉じ角括弧です。
これは、入力構文でもあります。
数や文字列と同様に、ベクトルは評価時には定数です。

     [1 "two" (three)]      ; 3要素のベクトル
          => [1 "two" (three)]

   ベクトルに作用する関数については、*Note Vectors::。


File: elisp-ja,  Node: Char-Table Type,  Next: Bool-Vector Type,  Prev: Vector Type,  Up: Programming Types

2.3.10 文字テーブル型
----------------------------

"文字テーブル"（char-table）は、 任意の型の要素から成る1次元配列であり、
文字コードで添字付けします。
文字テーブルには、文字コードに情報を与えるための多くの操作を簡単にする
付加的な機能があります。
たとえば、文字テーブルは、情報を継承するための親、
デフォルト値、特定目的向けの少数の追加スロットを持てます。
文字テーブルでは、文字集合全体に対して1つの値を指定することもできます。

   文字テーブルの表示表現はベクトルに似ていますが、
先頭に`#^'が余分に付きます。

   文字テーブルを操作する特別の関数については、*Note Char-Tables::。
文字テーブルはつぎのように使います。

   * 大文字小文字テーブル（*note Case Tables::）。

   * 文字カテゴリテーブル（*note Categories::）。

   * 表示テーブル（*note Display Tables::）。

   * 構文テーブル（*note Syntax Tables::）。


File: elisp-ja,  Node: Bool-Vector Type,  Next: Function Type,  Prev: Char-Table Type,  Up: Programming Types

2.3.11 ブールベクトル型
-------------------------------

"ブールベクトル"（bool-vector）は、
`t'か`nil'だけの要素から成る1次元配列です。

   ブールベクトルの表示表現は文字列に似ていますが、
`#&'と長さで始まります。
これに続く文字列定数が、ブールベクトルの実際の内容を
ビットマップで表します。
つまり、文字列の『各文字』は8ビット長のデータであり、
ブールベクトルのつぎの8個の要素を表します
（1は`t'を表し、0は`nil'を表す）。
文字の最下位ビットが、ブールベクトルの小さい添字に対応します。
長さが8の倍数でない場合には、
表示表現には余計な要素が含まれますが、余計な部分に意味はありません。

     (make-bool-vector 3 t)
          => #&3"\007"
     (make-bool-vector 3 nil)
          => #&3"\0"
     ;; 最初の3ビットだけを使っているので、以下はすべて同じ
     (equal #&3"\377" #&3"\007")
          => t


File: elisp-ja,  Node: Function Type,  Next: Macro Type,  Prev: Bool-Vector Type,  Up: Programming Types

2.3.12 関数型
----------------

他のプログラム言語の関数が実行可能であるように、 "Lisp関数"（Lisp
function）は実行可能なコードです。
しかしながら、Lispにおいては、関数は基本Lispオブジェクトであり、
そのテキスト表現は副次的なものです。
これらのLispオブジェクトはラムダ式です。
つまり、先頭要素がシンボル`lambda'であるリストです （*note Lambda
Expressions::）。

   ほとんどのプログラム言語では、名前のない関数を書くことは不可能です。
Lispでは、本質的には、関数に名前はありません。
ラムダ式のことを"無名関数"（anonymous function）とも呼びます （*note
Anonymous Functions::）。 Lispにおける名前付き関数は、実際には、
関数セルに正しい関数を収めたシンボルです （*note Defining
Functions::）。

多くの場合、LispプログラムのLisp式中に関数名を書くと関数が呼ばれます。
しかし、実行時に関数オブジェクトを構成したり取得して、
基本関数`funcall'や`apply'で、それを呼び出すことができます。 *Note
Calling Functions::。


File: elisp-ja,  Node: Macro Type,  Next: Primitive Function Type,  Prev: Function Type,  Up: Programming Types

2.3.13 マクロ型
-------------------

"Lispマクロ"（Lisp macro）は、
Lisp言語を拡張するユーザー定義の構造です。
関数に似たオブジェクトで表現しますが、引数渡しの意味は異なります。
Lispマクロは、リストの最初の要素がシンボル`macro'であり、
リストのCDRが`lambda'シンボルを
含むLisp関数オブジェクトであるフォームです。

   Lispマクロオブジェクトは、通常、組み込み関数`defmacro'で
定義しますが、 Emacsにとっては、`macro'で始まるリストはマクロです。
マクロの書き方の説明は、*Note Macros::。

   *警告*：` 'Lispマクロとキーボードマクロ （*note Keyboard
Macros::）は、まったく別のものです。
単に『マクロ』といった場合には、Lispマクロを意味するのであって、
キーボードマクロのことではありません。


File: elisp-ja,  Node: Primitive Function Type,  Next: Byte-Code Type,  Prev: Macro Type,  Up: Programming Types

2.3.14 基本関数型
----------------------

"基本関数型"（primitive function）は、
Lispから呼び出し可能な関数ですが、C言語で書いてあります。
基本関数のことを"subr"とか "組み込み関数"（built-in
functions）とも呼びます。 （『subr』は『subroutine』からきている。）
ほとんどの基本関数は、呼び出すときにすべての引数を評価します。
引数すべてを評価しない基本関数を"スペシャルフォーム"（special form）と
呼びます（*note Special Forms::）。

   関数を呼び出す側からすれば、関数が基本関数かどうかは関係ありません。
しかし、Lispで書いた関数で基本関数を再定義しようとすると、
問題があります。
というのは、基本関数はCのコードから直接呼ばれるからです。
再定義した関数をLispから呼び出す場合には新しい定義を使いますが、
Cのコードは組み込みの定義を使い続けるでしょう。
したがって、*基本関数を再定義しないでください*。

   "関数"（function）という用語で、
LispやCで書かれたEmacsのすべての関数を指します。
Lispで書いた関数に関しては、*Note Function Type::。

   基本関数には入力構文はなく、
サブルーティン名を含むハッシュ記法で表示します。

     (symbol-function 'car)          ; シンボルの関数セルを参照する
          => #<subr car>
     (subrp (symbol-function 'car))  ; 基本関数か？
          => t                       ; そのとおり


File: elisp-ja,  Node: Byte-Code Type,  Next: Autoload Type,  Prev: Primitive Function Type,  Up: Programming Types

2.3.15 バイトコード関数型
----------------------------------

バイトコンパイラは、"バイトコード関数オブジェクト" （byte-code function
objects）を作り出します。
内部的には、バイトコード関数オブジェクトはベクトルによく似ています。
しかしながら、評価過程においては、関数呼び出しのように見えるときには、
このデータ型を特別に扱います。 バイトコンパイラについては、*Note Byte
Compilation::。

   バイトコード関数オブジェクトの表示表現と入力構文は、
ベクトルに似ていますが、開き角括弧`['のまえに`#'が付きます。


File: elisp-ja,  Node: Autoload Type,  Prev: Byte-Code Type,  Up: Programming Types

2.3.16 自動ロード型
-------------------------

"自動ロードオブジェクト"（autoload object）は、
先頭要素がシンボル`autoload'であるリストです。
実際の定義のかわりにシンボルの関数定義として使われ、
必要なときにロードすべき実際の定義を収めたLispコードファイルを示します。
自動ロードオブジェクトには、ファイル名に加えて、
実際の関数定義に関する他の情報も入っています。

   ファイルをロードし終えると、
シンボルには、自動ロードオブジェクトではない新たな関数定義が入ります。
この新たな定義を始めからあったかのように呼び出します。
ユーザーの視点からは、ロードしたファイル内の関数定義を使って、
予想どおりに関数呼び出しが行われます。

   自動ロードオブジェクトは、普通、関数`autoload'で作ります。
この関数は、シンボルの関数セルにオブジェクトを格納します。
より詳しくは、*Note Autoload::。


File: elisp-ja,  Node: Editing Types,  Next: Type Predicates,  Prev: Programming Types,  Up: Lisp Data Types

2.4 編集向けの型
======================

前節の型は一般のプログラム向けに使うもので、
そのほとんどは、ほんどのLisp方言に共通しています。 Emacs
Lispには、編集に関連した目的向けにいくつかのデータ型があります。

* Menu:

* Buffer Type::         The basic object of editing.
* Marker Type::         A position in a buffer.
* Window Type::         Buffers are displayed in windows.
* Frame Type::		Windows subdivide frames.
* Window Configuration Type::   Recording the way a frame is subdivided.
* Frame Configuration Type::    Recording the status of all frames.
* Process Type::        A process running on the underlying OS.
* Stream Type::         Receive or send characters.
* Keymap Type::         What function a keystroke invokes.
* Overlay Type::        How an overlay is represented.


File: elisp-ja,  Node: Buffer Type,  Next: Marker Type,  Up: Editing Types

2.4.1 バッファ型
---------------------

"バッファ"（buffer）は、編集可能なテキストを保持するオブジェクトです
（*note Buffers::）。 ほとんどのバッファは、ディスクファイル（*note
Files::）の内容を保持して
編集できるようにしますが、他の目的に使われるものもあります。
ほとんどのバッファは、ユーザーが見るためのものであり、
ある期間、ウィンドウ（*note Windows::）に表示されます。
しかし、バッファがいずれかのウィンドウに必ずしも表示される必要はありません。

   バッファの内容は文字列によく似ていますが、 Emacs
Lispにおいては、バッファは文字列のようには使われず、
適用可能な操作も異なります。
たとえば、既存のバッファにテキストを効率よく挿入できますが、
文字列にテキストを『挿入』するには、
部分文字列を連結する必要があり、まったく新しい文字列オブジェクトになります。

   各バッファには、"ポイント"（point）と呼ばれる特別な箇所があります
（*note Positions::）。
どんなときにも、1つのバッファが"カレントバッファ"（current
buffer）です。
ほとんどの編集コマンドは、カレントバッファのポイント付近の内容に作用します。
多くのEmacsの標準関数は、カレントバッファ内にある文字を操作したり検査します。
本書には、これらの関数の説明にあてた章が1つあります（*note Text::）。

   各バッファに関連付けられたデータ構造には、つぎのものがあります。

   * ローカル構文テーブル（*note Syntax Tables::）

   * ローカルキーマップ（*note Keymaps::）。 および

   * バッファにローカルな変数束縛リスト（*note Buffer-Local
     Variables::）。

   * オーバレイ（*note Overlays::）。

   * バッファ内のテキストのテキスト属性（*note Text Properties::）。

ローカルキーマップと変数リストには、
それぞれ、グローバルな束縛や値に優先するものが入っています。
これらは、プログラムを変更せずに、各バッファごとに、
プログラムのふるまいをカスタマイズするために使われます。

   バッファは"間接"（indirect）でもよく、その場合、
別のバッファとテキストを共有しつつ異なった表示を行えます。 *Note
Indirect Buffers::。

   バッファには入力構文はありません。
バッファ名を含んだハッシュ記法で表示します。

     (current-buffer)
          => #<buffer objects.texi>


File: elisp-ja,  Node: Marker Type,  Next: Window Type,  Prev: Buffer Type,  Up: Editing Types

2.4.2 マーカ型
------------------

"マーカ"（marker）は、特定のバッファ内の位置を表します。
したがって、マーカには2つの構成要素、つまり、
バッファを示すものと位置を示すものがあります。
バッファ内のテキストを変更すると、
マーカがバッファ内の同じ2つの文字のあいだをつねに指すことを保証するように、
位置の値を更新します。

   マーカには入力構文はありません。
バッファ内の文字位置とバッファ名を含んだハッシュ記法で表示します。

     (point-marker)
          => #<marker at 10779 in objects.texi>

   マーカの検査、作成、コピー、移動の方法については、*Note Markers::。


File: elisp-ja,  Node: Window Type,  Next: Frame Type,  Prev: Marker Type,  Up: Editing Types

2.4.3 ウィンドウ型
------------------------

"ウィンドウ"（window）は、
Emacsがバッファを表示するために使用する端末画面の部分のことです。
各ウィンドウには、対応付けられたバッファが1つあり、
そのバッファの内容をウィンドウに表示しています。
一方、あるバッファが、1つのウィンドウや複数のウィンドウに表示されることもあり、
どのウィンドウにも表示されないこともあります。

   同時に複数のウィンドウが存在できますが、
どんなときにも1つのウィンドウだけが"選択されたウィンドウ" （selected
window）です。
これは、Emacsがコマンドを受け付け可能なときにカーソルを（通常）表示する
ウィンドウです。
選択されたウィンドウは、通常、カレントバッファを表示しますが、
これは必須ではありません。

   画面上のウィンドウはフレームにまとめられています。
各ウィンドウは、たった1つのフレームに属します。 *Note Frame Type::。

   ウィンドウには入力構文はありません。
ウィンドウ番号と表示中のバッファ名を含んだハッシュ記法で表示します。
ウィンドウ番号は、ウィンドウを一意に識別するためにあります。
これは、ウィンドウが表示しているバッファは頻繁に変わるからです。

     (selected-window)
          => #<window 1 on objects.texi>

   ウィンドウを操作する関数の説明は、*Note Windows::。


File: elisp-ja,  Node: Frame Type,  Next: Window Configuration Type,  Prev: Window Type,  Up: Editing Types

2.4.4 フレーム型
---------------------

"フレーム"（frame）は、画面上の矩形領域であって、
1つ以上のEmacsウィンドウを含みます。 フレームには最初は1つのウィンドウ
（とミニバッファウィンドウ）が含まれますが、
これを左右や上下に小さなウィンドウに分割できます。

   フレームには入力構文はありません。
フレームのタイトルとメモリ内のアドレス
（フレームを一意に識別するのに有用）を含んだハッシュ記法で表示します。

     (selected-frame)
          => #<frame emacs@psilocin.gnu.org 0xdac80>

   フレームを操作する関数の説明は、*Note Frames::。


File: elisp-ja,  Node: Window Configuration Type,  Next: Frame Configuration Type,  Prev: Frame Type,  Up: Editing Types

2.4.5 ウィンドウ構成型
------------------------------

"ウィンドウ構成"（window configuration）は、
フレーム内のウィンドウの位置／サイズ／内容に関する情報を記録し、
同じ配置のウィンドウをあとで再度作成できるようにします。

   ウィンドウ構成には入力構文はありません。
表示表現は、`#<window-configuration>'のようになります。
ウィンドウ構成に関連した関数の説明は、*Note Window Configurations::。


File: elisp-ja,  Node: Frame Configuration Type,  Next: Process Type,  Prev: Window Configuration Type,  Up: Editing Types

2.4.6 フレーム構成型
---------------------------

"フレーム構成"（frame configuration）は、
すべてのフレームのウィンドウの位置／サイズ／内容に関する情報の記録です。
これは、実際には、リストのCARが`frame-configuration'であり、
リストのCDRが連想リストであるリストです。
連想リストの各要素で、そのCARに現れるフレーム1個を記述します。

   フレーム構成に関連した関数の説明は、*Note Frame Configurations::。


File: elisp-ja,  Node: Process Type,  Next: Stream Type,  Prev: Frame Configuration Type,  Up: Editing Types

2.4.7 プロセス型
---------------------

単語"プロセス"（process）は、通常、実行中のプログラムを意味します。
Emacs自身、この種のプロセスとして実行されています。 しかし、Emacs
Lispでは、プロセスとは、
Emacsプロセスが作成したサブプロセスを表すLispオブジェクトのことです。
Emacsのサブプロセスで実行される、シェル、GDB、ftp、コンパイラなどの
プログラムは、Emacsの能力を拡張します。

   Emacsサブプロセスは、Emacsからテキスト入力を受け取り、
さらに処理できるようにEmacsにテキスト出力を返します。
Emacsはサブプロセスにシグナルを送ることもできます。

   プロセスオブジェクトに入力構文はありません。
プロセス名を含んだハッシュ記法で表示します。

     (process-list)
          => (#<process shell>)

   プロセスを作成したり削除したり、プロセスに関する情報を返したり、
プロセスへ入力やシグナルを送ったり、プロセスから出力を受け取る
関数に関する情報は、*Note Processes::。


File: elisp-ja,  Node: Stream Type,  Next: Keymap Type,  Prev: Process Type,  Up: Editing Types

2.4.8 ストリーム型
------------------------

"ストリーム"（stream）は、文字を出し入れする対象、
つまり、入力用に文字を供給したり、出力として文字を受け取ったりといった
ことに使えるオブジェクトです。 多くの異なる型をこのように使えます。
マーカ、バッファ、文字列、関数です。
ほとんどの場合、入力ストリーム（文字の供給源）は、
キーボード、バッファ、ファイルから文字を取得します。
出力ストリーム（文字の消費先）は、`*Help*'バッファなどのバッファや
エコー領域に文字を送ります。

   オブジェクト`nil'は、他の意味に加えて、 ストリームとしても使えます。
変数`standard-input'や`standard-output'の値になります。
また、オブジェクト`t'も、 ミニバッファ（*note
Minibuffers::）を使う入力ストリームや エコー領域への出力（*note The
Echo Area::）を意味します。

   ストリームには表示形式も入力構文もなく、その基本型で表示します。

   構文解析関数や表示関数を含むストリームに関連した関数の説明は、 *Note
Read and Print::。


File: elisp-ja,  Node: Keymap Type,  Next: Overlay Type,  Prev: Stream Type,  Up: Editing Types

2.4.9 キーマップ型
------------------------

"キーマップ"（keymap）は、ユーザーが打ったキーをコマンドに対応付けます。
この対応付けは、ユーザーのコマンド入力をどのように実行するかを制御します。
キーマップは、実際には、リストであり、 そのCARはシンボル`keymap'です。

   キーマップの作成、プレフィックスキーの扱い方、
グローバルやローカルなキーマップ、キーバインディングの変更に関する情報は、
*Note Keymaps::。


File: elisp-ja,  Node: Overlay Type,  Prev: Keymap Type,  Up: Editing Types

2.4.10 オーバレイ型
-------------------------

"オーバレイ"（overlay）は、バッファのある部分に作用する属性を指定します。
各オーバレイは、バッファの指定した範囲に作用し、
属性リスト（属性名と値の要素を交互に繰り返すリスト）を含んでいます。
オーバレイ属性は、
バッファの一部を一時的に異なった方式で表示するために使われます。
オーバレイ属性に入力構文はなく、
バッファ名と位置範囲を含んだハッシュ記法で表示します。

   オーバレイの作成と使用法については、*Note Overlays::。


File: elisp-ja,  Node: Type Predicates,  Next: Equality Predicates,  Prev: Editing Types,  Up: Lisp Data Types

2.5 型述語
=============

Emacs Lispインタープリタ自身は、関数を呼び出すときに渡す実引数の
型検査を行いません。
そうできないのは、他のプログラム言語が行うようには、
Lispの関数の引数にはデータ型の宣言がないからです。
したがって、各実引数がその関数で扱える型に属するかどうかを検査するのは、
各関数の責任です。

   すべての組み込み関数は、必要なときには実引数の型検査を行い、
引数が誤った型であれば、エラー`wrong-type-argument'を通知します。
たとえば、`+'に扱えない引数を渡すと、つぎのようになります。

     (+ 2 'a)
          error--> Wrong type argument: number-or-marker-p, a

   読者のプログラムで、異なる型を異なるように扱いたい場合には、
明示的に型検査を行う必要があります。
オブジェクトの型を検査するもっとも一般的な方法は、 "型述語"（type
predicate）関数を呼び出すことです。 Emacsには、各型ごとに型述語があり、
型を組み合わせたものに対する述語もあります。

   型述語関数は1つの引数を取ります。
引数が適切な型に属していれば`t'を返し、 さもなければ`nil'を返します。
述語関数に関するLisp一般の慣習に従って、
ほとんどの型述語の名前は`p'で終ります。

   以下は、リストの検査に述語`listp'を使い、
シンボルの検査に述語`symbolp'を使う例です。

     (defun add-on (x)
       (cond ((symbolp x)
              ;; Xがシンボルならば、それをLISTに加える
              (setq list (cons x list)))
             ((listp x)
              ;; Xがリストならば、その要素をLISTに追加する
              (setq list (append x list)))
             (t
              ;; シンボルとリストだけを扱う
              (error "Invalid argument %s in add-on" x))))

定義済みの型述語を、アルファベット順に、参照先を併記してあげておきます。

`atom'
     *note atom: List-related Predicates.。

`arrayp'
     *note arrayp: Array Functions.。

`bool-vector-p'
     *note bool-vector-p: Bool-Vectors.。

`bufferp'
     *note bufferp: Buffer Basics.。

`byte-code-function-p'
     *note byte-code-function-p: Byte-Code Type.。

`case-table-p'
     *note case-table-p: Case Tables.。

`char-or-string-p'
     *note char-or-string-p: Predicates for Strings.。

`char-table-p'
     *note char-table-p: Char-Tables.。

`commandp'
     *note commandp: Interactive Call.。

`consp'
     *note consp: List-related Predicates.。

`display-table-p'
     *note display-table-p: Display Tables.。

`floatp'
     *note floatp: Predicates on Numbers.。

`frame-configuration-p'
     *note frame-configuration-p: Frame Configurations.。

`frame-live-p'
     *note frame-live-p: Deleting Frames.。

`framep'
     *note framep: Frames.。

`functionp'
     *note functionp: Functions.。

`integer-or-marker-p'
     *note integer-or-marker-p: Predicates on Markers.。

`integerp'
     *note integerp: Predicates on Numbers.。

`keymapp'
     *note keymapp: Creating Keymaps.。

`listp'
     *note listp: List-related Predicates.。

`markerp'
     *note markerp: Predicates on Markers.。

`wholenump'
     *note wholenump: Predicates on Numbers.。

`nlistp'
     *note nlistp: List-related Predicates.。

`numberp'
     *note numberp: Predicates on Numbers.。

`number-or-marker-p'
     *note number-or-marker-p: Predicates on Markers.。

`overlayp'
     *note overlayp: Overlays.。

`processp'
     *note processp: Processes.。

`sequencep'
     *note sequencep: Sequence Functions.。

`stringp'
     *note stringp: Predicates for Strings.。

`subrp'
     *note subrp: Function Cells.。

`symbolp'
     *note symbolp: Symbols.。

`syntax-table-p'
     *note syntax-table-p: Syntax Tables.。

`user-variable-p'
     *note user-variable-p: Defining Variables.。

`vectorp'
     *note vectorp: Vectors.。

`window-configuration-p'
     *note window-configuration-p: Window Configurations.。

`window-live-p'
     *note window-live-p: Deleting Windows.。

`windowp'
     *note windowp: Basic Windows.。

   オブジェクトの型を調べるもっとも一般的な方法は、
関数`type-of'を呼び出すことです。
各オブジェクトはたった1つの基本型に属することを思い出してください。
`type-of'はどの1つかを教えてくれます（*note Lisp Data Types::）。
しかし、`type-of'は、基本型以外についてはなにも知りません。
多くの場合、`type-of'より型述語を使うほうが便利でしょう。

 -- Function: type-of object
     この関数は、OBJECTの基本型を示すシンボルを返す。 その値は、
     `symbol'、 `integer'、`float'、`string'、`cons'、`vector'、
     `char-table'、`bool-vector'、`subr'、
     `compiled-function'、`marker'、`overlay'、`window'、
     `buffer'、`frame'、`process'、`window-configuration'の
     シンボルのうちの1つ。

          (type-of 1)
               => integer
          (type-of 'nil)
               => symbol
          (type-of '())    ; `()'は`nil'
               => symbol
          (type-of '(x))
               => cons


File: elisp-ja,  Node: Equality Predicates,  Prev: Type Predicates,  Up: Lisp Data Types

2.6 同値述語
================

2つのオブジェクトの同値関係を調べる2つの関数を説明します。
文字列などの特定のオブジェクトが同値であるかを調べる関数群もあります。
これらの述語については、データ型を述べている適切な章を参照してください。

 -- Function: eq object1 object2
     この関数は、OBJECT1とOBJECT2が
     同一オブジェクトであれば`t'を返し、さもなければ`nil'を返す。
     『同一オブジェクト』とは、
     一方を変更すると、他方にも同じ変更が反映されることを意味する。

     `eq'は、OBJECT1とOBJECT2が同じ値の整数であると `t'を返す。
     また、シンボル名は、普通、一意であるので、
     引数が同じ名前のシンボルであれば、それらは`eq'である。
     （リスト、ベクトル、文字列などの）それ以外の型の場合、
     2つの引数が同じ内容や要素であっても、
     互いに`eq'であるとは限らない。
     それらが同一オブジェクトである場合に限り`eq'である。

          (eq 'foo 'foo)
               => t

          (eq 456 456)
               => t

          (eq "asdf" "asdf")
               => nil

          (eq '(1 (2 (3))) '(1 (2 (3))))
               => nil

          (setq foo '(1 (2 (3))))
               => (1 (2 (3)))
          (eq foo foo)
               => t
          (eq foo '(1 (2 (3))))
               => nil

          (eq [(1 2) 3] [(1 2) 3])
               => nil

          (eq (point-marker) (point-marker))
               => nil

     関数`make-symbol'は、インターンしたシンボルを返す。
     このシンボルは、Lisp式に書いた同じ名前のシンボルと区別される。
     名前が同じでも区別されるシンボルは`eq'ではない。 *note Creating
     Symbols::。

          (eq (make-symbol "foo") 'foo)
               => nil

 -- Function: equal object1 object2
     この関数は、 OBJECT1とOBJECT2が等しい要素を持てば`t'を返し、
     さもなければ`nil'を返す。
     `eq'は引数が同一オブジェクトかどうかを調べるが、
     `equal'は、同一ではない引数の内部を調べ、
     それらの要素が同じかどうかを調べる。
     したがって、2つのオブジェクトが`eq'ならば、
     それらは`equal'であるが、その逆はつねに真とは限らない。

          (equal 'foo 'foo)
               => t

          (equal 456 456)
               => t

          (equal "asdf" "asdf")
               => t
          (eq "asdf" "asdf")
               => nil

          (equal '(1 (2 (3))) '(1 (2 (3))))
               => t
          (eq '(1 (2 (3))) '(1 (2 (3))))
               => nil

          (equal [(1 2) 3] [(1 2) 3])
               => t
          (eq [(1 2) 3] [(1 2) 3])
               => nil

          (equal (point-marker) (point-marker))
               => t

          (eq (point-marker) (point-marker))
               => nil

     文字列の比較では大文字小文字を区別するが、テキスト属性は考慮しない。
     つまり、文字列内の文字だけを比較する。
     文字列の内容がすべてASCIIでなければ、
     ユニバイト文字列とマルチバイト文字列が等しいことはない （*note
     Text Representations::）。

          (equal "asdf" "ASDF")
               => nil

     たとえ内容が同じであっても、
     異なる2つのバッファが`equal'であることはない。

   `equal'の検査は再帰で実装されているので、
リストに循環があると無限再帰を引き起こし（エラーになり）ます。


File: elisp-ja,  Node: Numbers,  Next: Strings and Characters,  Prev: Lisp Data Types,  Up: Top

3 数
*****

GNU Emacsでは2種類の数値データを扱えます。
"整数"（integers）と"浮動小数点数"（floating point numbers）です。
整数は、-3、0、7、13、511のようなちょうどの数です。
これらの値は正確です。
浮動小数点数は、-4.5、0.0、2.71828のように小数部がある数です。
これらは指数表記で表します。 たとえば、1.5e2は150に等しいのです。
この例の`e2'は10の2乗を表し、それを1.5倍します。
浮動小数点数の値は厳密ではありません。
これらの精度には定まった限界があります。

* Menu:

* Integer Basics::            Representation and range of integers.
* Float Basics::	      Representation and range of floating point.
* Predicates on Numbers::     Testing for numbers.
* Comparison of Numbers::     Equality and inequality predicates.
* Numeric Conversions::	      Converting float to integer and vice versa.
* Arithmetic Operations::     How to add, subtract, multiply and divide.
* Rounding Operations::       Explicitly rounding floating point numbers.
* Bitwise Operations::        Logical and, or, not, shifting.
* Math Functions::            Trig, exponential and logarithmic functions.
* Random Numbers::            Obtaining random integers, predictable or not.


File: elisp-ja,  Node: Integer Basics,  Next: Float Basics,  Up: Numbers

3.1 整数の基本
===================

整数の値の範囲は計算機に依存します。
最小の範囲は、-134217728から134217727まで（28ビット長、つまり -2**27
から 2**27 - 1）ですが、 これより広い範囲を扱える計算機もあります。
本章の多くの例題では、整数は28長ビットであると仮定します。 

   Lispリーダは、
先頭に符号があってもよく、最後にピリオドがあってもよい、
数字の列として整数を読み取ります。

      1               ; 整数1
      1.              ; 整数1
     +1               ; これも整数1
     -1               ; 整数-1
      268435457       ; 桁溢れのため、これも整数1
      0               ; 整数0
     -0               ; 整数0

   整数を扱うさまざまな関数を理解するには、 特にビット演算（*note
Bitwise Operations::）を理解するには、 数を2進表現で考えるとよいです。

   28ビット長の2進表現では、10進整数5はつぎのようになります。

     0000  0000 0000  0000 0000  0000 0101

（4ビットのまとまりごとに空白を1個、
8ビットのまとまりごとに空白を2個挿入して、読みやすくする。）

   整数-1はつぎのようになります。

     1111  1111 1111  1111 1111  1111 1111

-1は、28個の1で表現されます。 （これを"2の補数"（two's
complement）表記と呼ぶ。）

   負の数-5は、-1から4を引いて作れます。 10進数4は、2進表記では100です。
したがって、-5は、つぎのようになります。

     1111  1111 1111  1111 1111  1111 1011

   この実装では、28ビット長の2進整数の最大値は、
10進で134,217,727になります。 2進表記では、つぎのようになります。

     0111  1111 1111  1111 1111  1111 1111

   算術関数は、整数がその範囲外に出たかどうか検査しないので、
134,217,727に1を足すと、値は負の数-134,217,728になります。

     (+ 1 134217727)
          => -134217728
          => 1000  0000 0000  0000 0000  0000 0000

   本章で述べる多くの関数は、数の引数としてマーカを受け付けます。
（*note Markers::）。 そのような関数の実際の引数は数かマーカであるので、
それらの引数をしばしばNUMBER-OR-MARKERという名前で書きます。
引数の値がマーカであるときには、その位置の値を使いバッファは無視します。


File: elisp-ja,  Node: Float Basics,  Next: Predicates on Numbers,  Prev: Integer Basics,  Up: Numbers

3.2 浮動小数点数の基本
===============================

浮動小数点数は、整数ではない数を表現するのに便利です。
浮動小数点数の正確な範囲は計算機に依存します。
使用している計算機のC言語のデータ型`double'の範囲と同じです。

浮動小数点数の入力構文は、小数点（に続けて1桁以上の小数部）または指数、
あるいは、その両方が必要です。 たとえば、`1500.0'、`15e2'、`15.0e2'、
`1.5e3'、`.15e4'は、同じ1500という値の
浮動小数点数を書き表す5つの方法です。 どれも、まったく等価です。
負の浮動小数点数を書くには、`-1.0'のようにマイナス符号を使います。

   現代の計算機はIEEEの浮動小数点数規格に基づいています。
この規格では、浮動小数点数の値には正の無限大と負の無限大があります。
また、NaNすなわち『非数値』（not-a-number）と呼ばれる値の種類もあります。
算術関数は、正しい答えがないときには、このような値を返します。
たとえば、`(sqrt -1.0)'はNaNを返します。 実用的には、Emacs
Lispでは異なるNaNの値に重要な違いはなく、
特定の場面で正確にはどのNaNの値を使うかの規則もないので、 Emacs
Lispではそれらを区別しようとはしません。
浮動小数点数の入力構文はつぎのとおりです。

正の無限大
     `1.0e+INF'

負の無限大
     `-1.0e+INF'

非数値
     `0.0e+NaN'。

   さらに、IEEEの浮動小数点数では値`-0.0'を普通のゼロと区別します
（しかし、`equal'と`='は、これらを等しい値と扱う）。

浮動小数点数の2進指数を取り出すには（あるいは、整数の対数を予測するには）、
`logb'を使います。

 -- Function: logb number
     この関数はNUMBERの2進指数を返す。
     より正確には、その値はNUMBERの2を底とする対数を整数に切り下げたもの。

          (logb 10)
               => 3
          (logb 10.0e20)
               => 69


File: elisp-ja,  Node: Predicates on Numbers,  Next: Comparison of Numbers,  Prev: Float Basics,  Up: Numbers

3.3 数向けの型述語
=========================

本節の関数は、引数が数であるか、とか、特定の種類の数であるか検査します。
関数`integerp'と`floatp'は
引数として任意の型のLispオブジェクトを取ります
（さもないと、述語の利用価値がない）。
しかし、述語`zerop'の引数には数が必要です。 *note Predicates on
Markers::の `integer-or-marker-p'と`number-or-marker-p'も
参照してください。

 -- Function: floatp object
     この述語は、引数が浮動小数点数かどうか調べ、
     そうならば`t'を返し、さもなければ`nil'を返す。

     Emacs 18以前の版には`floatp'はない。

 -- Function: integerp object
     この述語は、引数が整数かどうか調べ、
     そうならば`t'を返し、さもなければ`nil'を返す。

 -- Function: numberp object
     この述語は、引数が数（整数か浮動小数点数）かどうか調べ、
     そうならば`t'を返し、さもなければ`nil'を返す。

 -- Function: wholenump object
     （『whole-number-p』からきている名前の）述語`wholenump'は、
     引数が非負整数かどうか調べ、
     そうならば`t'を返し、さもなければ`nil'を返す。
     0は非負整数として扱う。

     `natnump'は、`wholenump'の廃れた同義語。

 -- Function: zerop number
     この述語は、引数が0かどうか調べ、
     そうならば`t'を返し、さもなければ`nil'を返す。 引数は数であること。

     つぎの2つのフォームは等価。 `(zerop x)' == `(= x 0)'。


File: elisp-ja,  Node: Comparison of Numbers,  Next: Numeric Conversions,  Prev: Predicates on Numbers,  Up: Numbers

3.4 数の比較
================

2つの数が数値的に等しいかどうか調べるには、普通、
`eq'ではなく`='を使うべきです。
数値的には等しい多くの異なる浮動小数点数が存在しえます。
それらの比較に`eq'を使うと、
2つの値が同一_オブジェクト_かどうか調べることになります。
対照的に、`='はオブジェクトの数値だけを比較します。

   現時点では、Emacs
Lispにおいて、各整数値は一意なLispオブジェクトです。
したがって、整数に限れば`eq'は`='と等価です。
未知の値と整数を比較するために`eq'を使うと便利な場面があります。
というのは、`eq'は任意の型の引数を受け付けるので、
`eq'は未知の値が数でなくてもエラーを報告しないからです。
対照的に、`='は、引数が数やマーカでないと、エラーを通知します。
しかしながら、Emacsの将来の版で整数の表現方法を変更する場合に備えて、
整数を比較するときであっても、可能ならば、`='を使うほうがよいでしょう。

   `equal'で数を比較したほうが便利なこともあります。
`equal'は、2つの数が同じデータ型
（どちらも整数であるか、どちらも浮動小数点数である）で、
同じ値であれば、2つの数を等しいと扱います。
一方、`='は、整数と浮動小数点数が等しいことを扱えます。

   別のことがらもあります。 浮動小数点数演算は厳密ではないので、
2つの浮動小数点数が等しいかどうか調べるのは正しくありません。
普通、近似的に等しいことを調べるほうがよいのです。
つぎの関数はそのようにします。

     (defvar fuzz-factor 1.0e-6)
     (defun approx-equal (x y)
       (or (and (= x 0) (= y 0))
           (< (/ (abs (- x y))
                 (max (abs x) (abs y)))
              fuzz-factor)))

     Common Lispに関した注意：` ' Common
     Lispでは、数の比較にはつねに`='を使う必要がある。
     というのは、Common Lispでは複数ワードの整数を実装しているため、
     2つの異なる整数オブジェクトが同じ数値を表すことがありえる。 Emacs
     Lispでは、整数値の範囲が制限されているため、
     任意の値の整数オブジェクトはそれぞれ1つしかない。

 -- Function: = number-or-marker1 number-or-marker2
     この関数は、引数が数値的に等しいか調べ、
     そうならば`t'を返し、さもなければ`nil'を返す。

 -- Function: /= number-or-marker1 number-or-marker2
     この関数は、引数が数値的に等しいか調べ、
     等しくなければ`t'を返し、等しければ`nil'を返す。

 -- Function: < number-or-marker1 number-or-marker2
     この関数は、第1引数が第2引数より小さいか調べ、
     そうならば`t'を返し、さもなければ`nil'を返す。

 -- Function: <= number-or-marker1 number-or-marker2
     この関数は、第1引数が第2引数より小さいか、あるいは、等しいか調べ、
     そうならば`t'を返し、さもなければ`nil'を返す。

 -- Function: > number-or-marker1 number-or-marker2
     この関数は、第1引数が第2引数より大きいか調べ、
     そうならば`t'を返し、さもなければ`nil'を返す。

 -- Function: >= number-or-marker1 number-or-marker2
     この関数は、第1引数が第2引数より大きいか、あるいは、等しいか調べ、
     そうならば`t'を返し、さもなければ`nil'を返す。

 -- Function: max number-or-marker &rest numbers-or-markers
     この関数は、引数の中で最大のものを返す。

          (max 20)
               => 20
          (max 1 2.5)
               => 2.5
          (max 1 3 2.5)
               => 3

 -- Function: min number-or-marker &rest numbers-or-markers
     この関数は、引数の中で最小のものを返す。

          (min -4 1)
               => -4

 -- Function: abs number
     この関数は、NUMBERの絶対値を返す。


File: elisp-ja,  Node: Numeric Conversions,  Next: Arithmetic Operations,  Prev: Comparison of Numbers,  Up: Numbers

3.5 数の変換
================

整数を浮動小数点数に変換するには、 関数`float'を使います。

 -- Function: float number
     この関数は、浮動小数点数に変換したNUMBERを返す。
     NUMBERがすでに浮動小数点数ならば、
     `float'はNUMBERを変更せずに返す。

   浮動小数点数を整数に変換する関数は4つあります。
これらの関数は、整数も引数に取りますが、整数引数は変更せずに返します。

 -- Function: truncate number
     これは、0に向けて切り捨てて整数に変換したNUMBERを返す。

 -- Function: floor number &optional divisor
     これは、（負の無限大に向けて）切り下げて整数に変換したNUMBERを返す。

     DIVISORを指定すると、切り下げるまえに NUMBERをDIVISORで除算する。
     これには、`mod'に対応した除算を使い切り下げる。
     DIVISORが0であると、結果は`arith-error'になる。

 -- Function: ceiling number
     これは、（正の無限大に向けて）切り上げて整数に変換したNUMBERを返す。

 -- Function: round number
     これは、もっとも近い整数に丸めて整数に変換したNUMBERを返す。
     2つの整数に等距離にある値を丸める場合には、
     使用している計算機に依存して、ゼロに近いほうの整数を選ぶか偶数を選ぶ。


File: elisp-ja,  Node: Arithmetic Operations,  Next: Rounding Operations,  Prev: Numeric Conversions,  Up: Numbers

3.6 算術演算
================

Emacs Lispには、伝統的な四則演算、加算、減算、乗算、除算があります。
除算関数を補う、余りと剰余の関数もあります。
Lispの伝統でもあり、また、多用するので、1を加算したり減算する関数もあります。

   これらの関数は、`%'を除いて、引数が1つでも浮動小数点数であると、
浮動小数点数を返します。

   Emacs Lispでは、算術関数は桁溢れ（オーバフロー）を検査しないことに
注意してください。 つまり、読者の計算機に依存しますが、 `(1+
134217727)'を評価すると-134217728になる場合もあります。

 -- Function: 1+ number-or-marker
     この関数は、NUMBER-OR-MARKER足す1を返す。

          (setq foo 4)
               => 4
          (1+ foo)
               => 5

     この関数はC言語の演算子`++'の類似ではない。
     つまり、変数を増加しない。 したがって、つぎのようになる。

          foo
               => 4

     変数を増加するには、つぎのように`setq'を使う必要がある。

          (setq foo (1+ foo))
               => 5

 -- Function: 1- number-or-marker
     この関数は、NUMBER-OR-MARKER引く1を返す。

 -- Function: + &rest numbers-or-markers
     この関数は、引数をすべて加算する。 引数を指定しないと`+'は0を返す。

          (+)
               => 0
          (+ 1)
               => 1
          (+ 1 2 3 4)
               => 10

 -- Function: - &optional number-or-marker &rest more-numbers-or-markers
     関数`-'は、2つの役割、つまり、符号反転と減算を果たす。
     `-'に1つの引数を指定すると、
     その値は、引数の符号を反転したものである。
     複数個の引数を指定すると、`-'は、
     NUMBER-OR-MARKERからMORE-NUMBERS-OR-MARKERSの1つ1つを減算する。
     引数を指定しないと結果は0である。

          (- 10 1 2 3 4)
               => 0
          (- 10)
               => -10
          (-)
               => 0

 -- Function: * &rest numbers-or-markers
     この関数は、引数をすべて掛け合わせた乗算結果を返す。
     引数を指定しないと`*'は1を返す。

          (*)
               => 1
          (* 1)
               => 1
          (* 1 2 3 4)
               => 24

 -- Function: / dividend divisor &rest divisors
     この関数は、DIVIDENDをDIVISORで除し商を返す。
     追加の引数DIVISORSを指定してあると、
     DIVIDENDをDIVISORSの1つ1つで除す。 各引数は数かマーカである。

     すべての引数が整数である場合、結果も整数となる。
     つまり、結果は切り捨てになる。
     ほとんどの計算機では各除算の結果は0に向けて切り捨てになるが、
     負の引数を別の方法で丸める計算機もある。
     これは、Lisp関数`/'をC言語の除算演算子で実装しているからであり、
     C言語の除算演算子では計算機依存に丸めることを許しているからである。
     実用上、すべての既知の計算機は標準的な方法で丸める。

     整数を0で除算すると、エラー`arith-error'を通知する。 （*note
     Errors::。）
     浮動小数点数を0で除算すると、IEEE浮動小数点数を使う計算機では、
     無限大かNaNを返す。 さもなければエラー`arith-error'を通知する。

          (/ 6 2)
               => 3
          (/ 5 2)
               => 2
          (/ 5.0 2)
               => 2.5
          (/ 5 2.0)
               => 2.5
          (/ 5.0 2.0)
               => 2.5
          (/ 25 3 2)
               => 4
          (/ -17 6)
               => -2

     原理的には、`(/ -17 6)'が-3になる計算機もある。

 -- Function: % dividend divisor
     この関数は、DIVIDENDをDIVISORで除したあとの整数の余りを返す。
     引数は整数かマーカである必要がある。

     負の引数では、余りは原理的に計算機依存である。
     実用上、すべての既知の計算機は同じようにふるまう。

     DIVISORが0であると`arith-error'になる。

          (% 9 4)
               => 1
          (% -9 4)
               => -1
          (% 9 -4)
               => 1
          (% -9 -4)
               => -1

     2つの任意の整数DIVIDENDとDIVISORにおいて、

          (+ (% DIVIDEND DIVISOR)
             (* (/ DIVIDEND DIVISOR) DIVISOR))

     は、つねにDIVIDENDに等しい。

 -- Function: mod dividend divisor
     この関数は、DIVIDENDのDIVISORによる剰余を返す。
     いいかえれば、DIVIDENDをDIVISORで除した余りを返す。
     ただし、その符号はDIVISORと同じ。
     引数は数かマーカである必要がある。

     `%'と違い、 `mod'は負の引数に対しても厳密に定義された結果を返す。
     浮動小数点の引数も許す。
     商を（負の無限大に向けて）切り下げて整数にし、
     その商を用いて余りを計算する。

     DIVISORが0であると`arith-error'になる。

          (mod 9 4)
               => 1
          (mod -9 4)
               => 3
          (mod 9 -4)
               => -3
          (mod -9 -4)
               => -1
          (mod 5.5 2.5)
               => .5

     2つの任意の整数DIVIDENDとDIVISORにおいて、

          (+ (mod DIVIDEND DIVISOR)
             (* (floor DIVIDEND DIVISOR) DIVISOR))

     は、つねにDIVIDENDに等しい。
     ただし、どちらかの引数が浮動小数点数の場合には、
     丸め誤差の範囲内で等しい。 `floor'については、*note Numeric
     Conversions::を参照。


File: elisp-ja,  Node: Rounding Operations,  Next: Bitwise Operations,  Prev: Arithmetic Operations,  Up: Numbers

3.7 丸め演算
================

関数、`ffloor'、`fceiling'、`fround'、`ftruncate'は、
浮動小数点数引数を受け取り、その値に近い整数を値とする浮動小数点数を返します。
`ffloor'は、もっとも近いより小さな整数を返します。
`fceiling'は、もっとも近いより大きな整数を返します。
`ftruncate'は、0に向けて切り捨てたもっとも近い整数を返します。
`fround'は、もっとも近い整数を返します。

 -- Function: ffloor float
     この関数は、FLOATをこれより小さな整数値に切り下げ、
     その値を浮動小数点数として返す。

 -- Function: fceiling float
     この関数は、FLOATをこれより大きな整数値に切り上げ、
     その値を浮動小数点数として返す。

 -- Function: ftruncate float
     この関数は、FLOATを0に向けて整数値に切り捨て、
     その値を浮動小数点数として返す。

 -- Function: fround float
     この関数は、FLOATをもっとも近い整数値に丸め、
     その値を浮動小数点数として返す。


File: elisp-ja,  Node: Bitwise Operations,  Next: Math Functions,  Prev: Rounding Operations,  Up: Numbers

3.8 整数のビット演算
============================

計算機内部では、整数は2進数、つまり、
"ビット"（bit、各桁は0か1）列で表現されます。
ビット演算は、そのようなビット列の各ビットごとに作用します。
たとえば、"シフト"（shifting）は、ビット列を全体として左や右に
1桁以上移動して、その『移動後の』パターンを結果とします。

   Emacs Lispにおけるビット演算は整数に限ります。

 -- Function: lsh integer1 count
     "論理シフト"（logical shift）の略からきている`lsh'は、
     INTEGER1のビット列をCOUNT桁左へ、
     あるいは、COUNTが負ならば右へずらし、空いたビットには0を詰める。
     COUNTが負であれば、`lsh'は最左（最上位）ビットに0を詰め、
     INTEGER1が負であっても結果は正になる。
     これと対照的なのが下の`ash'。

     `lsh'の例を2つ示す。 ビットパターンを1桁左へずらす。
     ビットパターンの上位ビットはすべて0なので下位8ビットだけを示す。

          (lsh 5 1)
               => 10
          ;; 10進数5は、 10進数10になる
          00000101 => 00001010

          (lsh 7 1)
               => 14
          ;; 10進数7は、10進数14になる
          00000111 => 00001110

     例からわかるように、ビットパターンを1桁左へずらすと、
     もとの数値の2倍の数になる。

     ビットパターンを2桁左へずらすと、（8ビット長の2進数では）つぎのようになる。

          (lsh 3 2)
               => 12
          ;; 10進数3は、10進数12になる
          00000011 => 00001100

     一方、右へずらすとつぎのようになる。

          (lsh 6 -1)
               => 3
          ;; 10進数6は、10進数3になる
          00000110 => 00000011

          (lsh 5 -1)
               => 2
          ;; 10進数5は、10進数2になる
          00000101 => 00000010

     例からわかるように、ビットパターンを1桁右へずらすと、
     正の整数の数を2で除して切り下げる。

     Emacs Lispのすべての算術関数と同様に、
     関数`lsh'は桁溢れ（オーバフロー）を検査しないので、
     左へずらすと上位ビットを捨てさり数の符号を変えてしまうことがある。
     たとえば、28ビット長の計算機では、
     134,217,727を左へずらすと-2になる。

          (lsh 134217727 1)          ; 左シフト
               => -2

     28ビット長の実装の2進数では、引数はつぎのようになっている。

          ;; 10進数134,217,727
          0111  1111 1111  1111 1111  1111 1111

     これを左へずらすと、つぎのようになる

          ;; 10進数-2
          1111  1111 1111  1111 1111  1111 1110

 -- Function: ash integer1 count
     `ash'（"算術シフト"（arithmetic shift））は、
     INTEGER1のビットをCOUNT桁左へ、あるいは、
     COUNTが負ならば右へずらす。

     `ash'は`lsh'と同じ結果になるが、
     INTEGER1とCOUNTの両者が負の場合を除く。
     この場合、`ash'は左の空いたビットには1を入れるが、
     `lsh'はそのようなビットには0を入れる。

     したがって、`ash'でビットパターンを1桁右へずらすとつぎのようになる。

          (ash -6 -1) => -3
          ;; 10進数-6は、10進数-3になる
          1111  1111 1111  1111 1111  1111 1010
               =>
          1111  1111 1111  1111 1111  1111 1101

     対照的に、`lsh'でビットパターンを1桁右へずらすとつぎのようになる。

          (lsh -6 -1) => 134217725
          ;; 10進数-6は、10進数134,217,725になる
          1111  1111 1111  1111 1111  1111 1010
               =>
          0111  1111 1111  1111 1111  1111 1101

     他の例を以下にしめす。

                             ;               28ビット2進値

          (lsh 5 2)          ;   5  =  0000  0000 0000  0000 0000  0000 0101
               => 20         ;      =  0000  0000 0000  0000 0000  0001 0100
          (ash 5 2)
               => 20
          (lsh -5 2)         ;  -5  =  1111  1111 1111  1111 1111  1111 1011
               => -20        ;      =  1111  1111 1111  1111 1111  1110 1100
          (ash -5 2)
               => -20
          (lsh 5 -2)         ;   5  =  0000  0000 0000  0000 0000  0000 0101
               => 1          ;      =  0000  0000 0000  0000 0000  0000 0001
          (ash 5 -2)
               => 1
          (lsh -5 -2)        ;  -5  =  1111  1111 1111  1111 1111  1111 1011
               => 4194302    ;      =  0011  1111 1111  1111 1111  1111 1110
          (ash -5 -2)        ;  -5  =  1111  1111 1111  1111 1111  1111 1011
               => -2         ;      =  1111  1111 1111  1111 1111  1111 1110

 -- Function: logand &rest ints-or-markers
     この関数は引数の『論理積』を返す。
     つまり、すべての引数のN番目のビットが1である場合に限り、
     結果のN番目のビットも1になる。

     たとえば、4ビットの2進数で考えると、 13と12の『論理積』は12になる。
     つまり、1101に1100を組み合わせると1100になる。
     どちらの2進数も最左の2ビットは1なので、戻り値の最左の2ビットも1になる。
     しかし、最右の2ビットは、一方の引数ではそれぞれが0なので、
     戻り値の最右の2ビットも0になる。

     したがって、つぎのとおり。

          (logand 13 12)
               => 12

     `logand'にまったく引数を指定しないと値-1を返す。
     この数は2進表現ではすべて1だけなので、 `logand'の恒等元である。
     `logand'に引数を1つだけ指定するとその引数を返す。

                             ;                28ビット2進値

          (logand 14 13)     ; 14  =  0000  0000 0000  0000 0000  0000 1110
                             ; 13  =  0000  0000 0000  0000 0000  0000 1101
               => 12         ; 12  =  0000  0000 0000  0000 0000  0000 1100

          (logand 14 13 4)   ; 14  =  0000  0000 0000  0000 0000  0000 1110
                             ; 13  =  0000  0000 0000  0000 0000  0000 1101
                             ;  4  =  0000  0000 0000  0000 0000  0000 0100
               => 4          ;  4  =  0000  0000 0000  0000 0000  0000 0100

          (logand)
               => -1         ; -1  =  1111  1111 1111  1111 1111  1111 1111

 -- Function: logior &rest ints-or-markers
     この関数は引数の『論理和』を返す。
     つまり、少なくともどれか1つの引数のN番目のビットが1である場合に限り、
     結果のN番目のビットも1になる。
     引数を指定しないと0を返すが、これはこの演算の恒等元である。
     `logior'に引数を1つだけ指定するとその引数を返す。

                             ;                28ビット2進値

          (logior 12 5)      ; 12  =  0000  0000 0000  0000 0000  0000 1100
                             ;  5  =  0000  0000 0000  0000 0000  0000 0101
               => 13         ; 13  =  0000  0000 0000  0000 0000  0000 1101

          (logior 12 5 7)    ; 12  =  0000  0000 0000  0000 0000  0000 1100
                             ;  5  =  0000  0000 0000  0000 0000  0000 0101
                             ;  7  =  0000  0000 0000  0000 0000  0000 0111
               => 15         ; 15  =  0000  0000 0000  0000 0000  0000 1111

 -- Function: logxor &rest ints-or-markers
     この関数は引数の『排他的論理和』を返す。
     つまり、引数のN番目のビットが1であるものが奇数個の場合に限り、
     結果のN番目のビットも1になる。
     引数を指定しないと0を返すが、これはこの演算の恒等元である。
     `logxor'に引数を1つだけ指定するとその引数を返す。

                             ;               28ビット2進値

          (logxor 12 5)      ; 12  =  0000  0000 0000  0000 0000  0000 1100
                             ;  5  =  0000  0000 0000  0000 0000  0000 0101
               => 9          ;  9  =  0000  0000 0000  0000 0000  0000 1001

          (logxor 12 5 7)    ; 12  =  0000  0000 0000  0000 0000  0000 1100
                             ;  5  =  0000  0000 0000  0000 0000  0000 0101
                             ;  7  =  0000  0000 0000  0000 0000  0000 0111
               => 14         ; 14  =  0000  0000 0000  0000 0000  0000 1110

 -- Function: lognot integer
     この関数は引数の論理的な補数を返す。
     つまり、INTEGERのN番目のビットが0である場合に限り、
     結果のN番目のビットは1になる。

          (lognot 5)
               => -6
          ;;  5  =  0000  0000 0000  0000 0000  0000 0101
          ;; becomes
          ;; -6  =  1111  1111 1111  1111 1111  1111 1010


File: elisp-ja,  Node: Math Functions,  Next: Random Numbers,  Prev: Bitwise Operations,  Up: Numbers

3.9 標準数学関数
======================

これらの数学関数は浮動小数点数に加えて整数も引数として受け付けます。

 -- Function: sin arg
 -- Function: cos arg
 -- Function: tan arg
     これらは普通の三角関数であり、引数は弧度法で表す。

 -- Function: asin arg
     `(asin ARG)'の値は-pi/2からpi/2までの数であり、
     その正弦（sin）はARGに等しい。 しかし、ARGが（[-1,
     1]の）範囲を越えていると結果はNaN。

 -- Function: acos arg
     `(acos ARG)'の値は0からpiまでの数であり、
     その余弦（cos）はARGに等しい。 しかし、ARGが（[-1,
     1]の）範囲を越えていると結果はNaN。

 -- Function: atan arg
     `(atan ARG)'の値は-pi/2からpi/2までの数であり、
     その正接（tan）はARGに等しい。

 -- Function: exp arg
     これは指数関数であり、 e のARG乗を返す。 e
     は数学の基本定数であり、自然対数の底とも呼ぶ。

 -- Function: log arg &optional base
     この関数はARGのBASEを底とする対数を返す。
     BASEを指定しなければ、底として e を使う。
     ARGが負であると結果はNaN。

 -- Function: log10 arg
     この関数はARGの10を底とする対数を返す。 ARGが負であると結果はNaN。
     少なくとも誤差を考慮すれば、 `(log10 X)' == `(log X 10)'。

 -- Function: expt x y
     この関数はXのY乗を返す。
     どちらの引数も整数でありYが正ならば、結果は整数。
     この場合、結果は整数値の可能な範囲に切り詰められる。

 -- Function: sqrt arg
     この関数はARGの平方根を返す。 ARGが負であると値はNaN。


File: elisp-ja,  Node: Random Numbers,  Prev: Math Functions,  Up: Numbers

3.10 乱数
===========

決定論的な計算機プログラムは真の乱数を発生できません。
しかし、ほとんどの目的には"疑似乱数"（pseudo-random
numbers）で十分です。 一連の疑似乱数を決定論的な方法で生成します。
それらの数は真の乱数ではありませんが、
乱数列のある種の性質に似た性質があります。
たとえば、疑似乱数列でもすべての可能な数がしばしば等しく生起します。

   Emacsでは、疑似乱数は『種』となる数から生成します。
指定した任意の種から始めても、関数`random'は同じ数の列を生成します。
Emacsはつねに同じ種の値で計算し始めるため、
それぞれのEmacsの実行でも`random'は実際には同じ数の列を生成します。
たとえば、あるオペレーティングシステムで、
Emacs開始直後に`random'を呼ぶとつねに-1457731を返し、
つぎに呼ぶとつねに-7692030を返します。
このような再現性はデバッグには有利です。

   予測不可能な乱数が必要ならば`(random t)'を実行します。
これは、現在時刻とEmacsプロセスのID番号に基づいて、
新たな種の値を選びます。

 -- Function: random &optional limit
     この関数は疑似乱数の整数を返す。
     繰り返し呼び出すと一連の疑似乱数の整数を返す。

     LIMITが正整数ならば、非負でLIMIT未満になるように値を選ぶ。

     LIMITが`t'ならば、 現在時刻とEmacsプロセスのID番号に基づいて、
     新たな種の値を選ぶことを意味する。

     `random'の結果は、Lispにおいて表現可能な任意の整数になる計算機もある。
     他の計算機では、結果はある最大値と（負数）最小値のあいだにある。



File: elisp-ja,  Node: Strings and Characters,  Next: Lists,  Prev: Numbers,  Up: Top

4 文字列と文字
********************

Emacs Lispの文字列は文字の順序列を保持している配列です。
文字列は、シンボル、バッファ、ファイルのそれぞれの名前として、
ユーザーへメッセージを送るため、
バッファ間でコピーするテキストを保持するため、
その他さまざまな目的に使われます。 文字列はとても重要なので、 Emacs
Lispには文字列を操作する関数が数多くあります。 Emacs
Lispのプログラムでは、個々の文字よりも文字列を多用します。

   キーボード文字イベントを表す文字列に関する特別な配慮については、
*Note Strings of Events::。

* Menu:

* Basics: String Basics.      Basic properties of strings and characters.
* Predicates for Strings::    Testing whether an object is a string or char.
* Creating Strings::          Functions to allocate new strings.
* Modifying Strings::         Altering the contents of an existing string.
* Text Comparison::           Comparing characters or strings.
* String Conversion::         Converting characters or strings and vice versa.
* Formatting Strings::        `format': Emacs's analogue of `printf'.
* Case Conversion::           Case conversion functions.
* Case Tables::		      Customizing case conversion.


File: elisp-ja,  Node: String Basics,  Next: Predicates for Strings,  Up: Strings and Characters

4.1 文字列と文字の基本
===============================

Emacs Lispの文字列は文字の順序列を保持している配列です。 Emacs
Lispでは文字を整数で表現します。
整数が文字であるかどうかは、その使われ方からしか判断できません。
したがって、文字列は、実際には、整数群を保持しているのです。

   （任意の配列と同様に）文字列の長さは固定されていて、
文字列をいったん作成すると変更できません。
Lispの文字列は特別な文字コードで終端されるのでは_ありません_。
（対照的に、C言語の文字列はASCIIコード0で終端される。）

   文字列は配列ですからシーケンスでもあり、
一般の配列関数やシーケンス関数で文字列を操作できます。 （*note
Sequences Arrays Vectors::。） たとえば、関数`aref'と`aset'（*note
Array Functions::）を
用いて、文字列内の個々の文字を参照したり変更できます。

   Emacs文字列（およびバッファ）内の非ASCII文字のテキスト表現は
2種類あります。 ユニバイトとマルチバイトです（*note Text
Representations::）。 ASCII文字は、文字列内ではつねに1バイトを占めます。
実際、すべてがASCII文字である文字列では、2つの表現に違いはありません。
ほとんどのLispプログラムでは、
読者はこれらの2つの表現を考慮する必要はないでしょう。

   キー列を文字列として表現することがあります。
文字列がキー列を表す場合、128から255の範囲にある文字列の要素は、
その範囲の文字コードとしてではなく、
（非常に大きな整数になる）メタ文字を表現します。

文字列は、ハイパー、スーパー、アルトの修飾子を持つ文字を保持できません。
文字列はASCIIコントロール文字を保持できますが、
それ以外のコントロール文字を保持できません。
文字列では、ASCIIコントロール文字の大文字小文字を区別できません。
キー列などのそのような文字をシーケンスに収めるには、
文字列のかわりにベクトルを使う必要があります。
キーボード入力文字に対するメタなどの修飾子の表現については、 *Note
Character Type::。

   文字列は正規表現を保持するのにも便利です。
文字列に対して正規表現の一致を取ることもできます（*note Regexp
Search::）。 関数`match-string'（*note Simple Match Data::）と
`replace-match'（*note Replacing Match::）は、
正規表現の一致に基づいて文字列を分解したり変更するのに便利です。

   バッファと同様に、文字列は、
文字そのものに加えて文字列内の文字に対するテキスト属性を保持できます。
*Note Text Properties::。
文字列からバッファや他の文字列へテキストをコピーするすべてのLisp基本関数は、
コピーする文字の属性もコピーします。

   文字列を表示したりバッファへコピーする関数については、*Note Text::。
文字と文字列の構文については、*note Character Type::と*Note String
Type::。
テキスト表現を変換したり、文字コードを符号化／復号化する関数については、
*Note Non-ASCII Characters::。


File: elisp-ja,  Node: Predicates for Strings,  Next: Creating Strings,  Prev: String Basics,  Up: Strings and Characters

4.2 文字列向けの述語
============================

一般のシーケンスや配列に対する述語について詳しくは、 *note Sequences
Arrays Vectors::と*Note Arrays::。

 -- Function: stringp object
     この関数は、OBJECTが文字列ならば`t'を返し、
     さもなければ`nil'を返す。

 -- Function: char-or-string-p object
     この関数は、OBJECTが文字列か文字（つまり、整数）ならば
     `t'を返し、さもなければ`nil'を返す。


File: elisp-ja,  Node: Creating Strings,  Next: Modifying Strings,  Prev: Predicates for Strings,  Up: Strings and Characters

4.3 文字列の作成
======================

以下の関数は、新たに文字列を作成したり、
文字列を連結したり分解して文字列を作成します。

 -- Function: make-string count character
     この関数は、文字CHARACTERをCOUNT回繰り返して作成した文字列を返す。
     COUNTが負であるとエラーを通知する。

          (make-string 5 ?x)
               => "xxxxx"
          (make-string 0 ?x)
               => ""

     この関数に対比するものに、 `char-to-string'（*note String
     Conversion::）、 `make-vector'（*note Vectors::）、
     `make-list'（*note Building Lists::）などがある。

 -- Function: string &rest characters
     これは、複数個の文字群CHARACTERSが入った文字列を返す。

          (string ?a ?b ?c)
               => "abc"

 -- Function: substring string start &optional end
     この関数は、STRINGのSTARTから
     END（の直前）までの範囲にある文字から成る新たな文字列を返す。
     先頭の文字を0で添字付けする。

          (substring "abcdefg" 0 3)
               => "abc"

     ここで、`a'の添字は0、`b'の添字は1、`c'の添字は2である。
     したがって、文字列`"abcdefg"'から3文字`abc'をコピーする。
     添字3はコピーする部分文字列の境界の文字位置を表す。
     添字が3である文字は、実際には文字列内の4番目の文字である。

     負の数は文字列の末尾から数える。
     したがって、-1は文字列の最後の文字の添字である。 たとえば、

          (substring "abcdefg" -3 -1)
               => "ef"

     この例では、`e'の添字は-3、`f'の添字は-2、 `g'の添字は-1である。
     したがって、`e'と`f'を含むが`g'は含まない。

     添字に`nil'を使うと、文字列の長さを意味する。
     したがって、つぎのようになる。

          (substring "abcdefg" -3 nil)
               => "efg"

     引数ENDを省略することは、`nil'を指定することと等価である。
     そのため、`(substring STRING 0)'は、
     STRING全体をコピーしたものを返す。

          (substring "abcdefg" 0)
               => "abcdefg"

     しかし、このような目的には`copy-sequence'を勧める （*note Sequence
     Functions::）。

     STRINGからコピーした文字にテキスト属性があれば、
     新たな文字列にもそのテキスト属性をコピーする。 *note Text
     Properties::。

     `substring'は第1引数としてベクトルも受け付ける。
     たとえば、つぎのとおり。

          (substring [a b (c) "d"] 1 3)
               => [b (c)]

     STARTやENDが整数でも`nil'でもないと、
     エラー`wrong-type-argument'を通知する。
     STARTがENDよりうしろの文字を指していたり、
     いずれかの整数がSTRINGの範囲外であると
     エラー`args-out-of-range'を通知する。

     この関数と対照的なのが`buffer-substring' （*note Buffer
     Contents::）であり、
     カレントバッファ内のテキストの一部を収めた文字列を返す。
     文字列の先頭は0で添字付けするが、バッファの先頭は1で添字付けする。

 -- Function: concat &rest sequences
     この関数は、渡した引数の文字から成る
     （テキスト属性があればそれも含めて）新たな文字列を返す。
     引数は、文字列、数のリスト、数のベクトルである。
     引数自身は変更しない。 `concat'に引数を指定しないと空文字列を返す。

          (concat "abc" "-def")
               => "abc-def"
          (concat "abc" (list 120 121) [122])
               => "abcxyz"
          ;; `nil'は空シーケンス
          (concat "abc" nil "-def")
               => "abc-def"
          (concat "The " "quick brown " "fox.")
               => "The quick brown fox."
          (concat)
               => ""

     関数`concat'は、
     既存の文字列と`eq'ではない新たな文字列をつねに作り出す。

     引数が（整数のシーケンスではなく）整数であると、
     その整数の表示表現を構成する文字列に変換する。
     *この機能を使わないでほしい。 削除する予定である。
     読者がこの機能を使っていたら、今すぐプログラムを直すこと！*` '
     整数をこのような10進数に変換する正しい方法は、 `format'（*note
     Formatting Strings::）や `number-to-string'（*note String
     Conversion::）を使うことである。

          (concat 137)
               => "137"
          (concat 54 321)
               => "54321"

     他の連結関数については、 *note Mapping Functions::の`mapconcat'、
     *note Vectors::の`vconcat'、 *note Building
     Lists::の`append'を参照。

 -- Function: split-string string separators
     STRINGを正規表現SEPARATORSの一致箇所で区切って
     部分文字列に分解する。
     SEPARATORSに一致するそれぞれの部分が分割箇所を定義する。
     分割箇所のあいだにある部分文字列をリストにまとめ、これを値とする。
     SEPARATORSが`nil'である（つまり、省略する）と、 デフォルトは`"[
     \f\t\n\r\v]+"'である。

     たとえば、つぎのようになる。

          (split-string "Soup is good food" "o")
          => ("S" "up is g" "" "d f" "" "d")
          (split-string "Soup is good food" "o+")
          => ("S" "up is g" "d f" "d")

     文字列の先頭や末尾で一致した場合には、
     リストの先頭や末尾に空文字列は現れない。

          (split-string "out to moo" "o+")
          => ("ut t" " m")

     空の一致箇所は、それらが連続していない限り分割点になる。

          (split-string "Soup is good food" "o*")
          =>("S" "u" "p" " " "i" "s" " " "g" "d" " " "f" "d")
          (split-string "Nice doggy!" "")
          =>("N" "i" "c" "e" " " "d" "o" "g" "g" "y" "!")


File: elisp-ja,  Node: Modifying Strings,  Next: Text Comparison,  Prev: Creating Strings,  Up: Strings and Characters

4.4 文字列の変更
======================

既存の文字列の内容を変更するもっとも基本的な方法は、 `aset'（*note
Array Functions::）を使うことです。 `(aset STRING IDX CHAR)'は、
STRINGの添字IDX位置にCHARを格納します。 各文字は1バイト以上を占めます。
CHARが必要とするバイト数が指定した添字位置の文字が占めるバイト数と
異なる場合には、`aset'はエラーを通知します。

   より強力な関数は`store-substring'です。

 -- Function: store-substring string idx obj
     この関数は、文字列STRINGの添字IDX位置から始まる部分にOBJを
     格納することで、文字列STRINGの内容の一部分を変更する。
     引数OBJは文字であるか（より小さな）文字列。

     既存の文字列の長さを変更することは不可能なので、
     新たな文字に必要なバイト数がSTRINGの当該箇所の文字のバイト数と
     異なるなどして、
     OBJがSTRINGの実際の長さに収まらないときにはエラーである。


File: elisp-ja,  Node: Text Comparison,  Next: String Conversion,  Prev: Modifying Strings,  Up: Strings and Characters

4.5 文字と文字列の比較
===============================

 -- Function: char-equal character1 character2
     この関数は、引数が同じ文字を表していれば`t'を返し、
     さもなければ`nil'を返す。 `case-fold-search'が`nil'以外であると、
     この関数は大文字小文字の違いを区別しない。

          (char-equal ?x ?x)
               => t
          (let ((case-fold-search nil))
            (char-equal ?x ?X))
               => nil

 -- Function: string= string1 string2
     この関数は、2つの文字列の各文字が正確に一致すれば`t'を返す。
     大文字小文字を区別する。

          (string= "abc" "abc")
               => t
          (string= "abc" "ABC")
               => nil
          (string= "ab" "ABC")
               => nil

     関数`string='は2つの文字列のテキスト属性を無視する。
     `equal'（*note Equality
     Predicates::）が2つの文字列を比較する際には、 `string='を使う。

     文字列に非ASCII文字が含まれ、
     一方がユニバイトであり他方がマルチバイトである場合、
     それらが等しいことはない。 *note Text Representations::。

 -- Function: string-equal string1 string2
     `string-equal'は`string='の別名。

 -- Function: string< string1 string2
     この関数は2つの文字列を1文字ずつ比較する。
     まず、文字列を走査し、対応する文字同士の対で一致しないものを探す。
     そのような対の文字の小さいほうがSTRING1の文字であるならば、
     STRING1が小さく、この関数は`t'を返す。
     文字の小さいほうがSTRING2の文字であるならば、
     STRING1が大きく、この関数は`nil'を返す。
     2つの文字列が完全に一致する場合、値は`nil'である。

     文字の対は、それらの文字コードで比較する。
     ASCII文字集合では、小文字は大文字より大きな数値であり、
     数字文字や多くの句読点文字は大文字より小さな数値であることに注意。
     ASCII文字はどんな非ASCII文字よりも小さい。
     ユニバイト非ASCII文字はマルチバイト非ASCII文字よりもつねに小さい。
     （*note Text Representations::）。

          (string< "abc" "abd")
               => t
          (string< "abd" "abc")
               => nil
          (string< "123" "abc")
               => t

     文字列の長さが異なりSTRING1の長さまで一致する場合、
     結果は`t'である。
     STRING2の長さまで一致する場合、結果は`nil'である。
     空文字列は他のどんな文字列よりも小さい。

          (string< "" "abc")
               => t
          (string< "ab" "abc")
               => t
          (string< "abc" "")
               => nil
          (string< "abc" "ab")
               => nil
          (string< "" "")
               => nil

 -- Function: string-lessp string1 string2
     `string-lessp'は`string<'の別名。

 -- Function: compare-strings string1 start1 end1 string2 start2 end2
          &optional ignore-case
     この関数は、STRING1の指定部分とSTRING2の指定部分を比較する。
     STRING1の指定部分は、
     添字START1位置から始まり添字END1位置までである
     （デフォルトは文字列の末尾）。 STRING2の指定部分は、
     添字START2位置から始まり添字END2位置までである
     （デフォルトは文字列の末尾）。

     どちらの文字列も比較のためにマルチバイトに変換するので （*note
     Text Representations::）、
     ユニバイト文字列とマルチバイトが等しくなる場合もある。
     IGNORE-CASEが`nil'でなければ、大文字小文字を区別しないので、
     大文字は小文字に等しくなる

     2つの文字列の指定部分が一致すれば、値は`t'。
     さもなければ、値は何文字目までが一致してどちらの文字列が小さいかを示す。
     その絶対値は、2つの文字列の始めから一致した文字の個数に1を加えたもの。
     STRING1（の指定部分）が小さいならば符号は負になる。

 -- Function: assoc-ignore-case key alist
     この関数は、`assoc'と同様に動作するが、
     KEYは文字列である必要があり、
     `compare-strings'を用いて比較する点が異なる。
     大文字小文字を区別しないで比較する。

 -- Function: assoc-ignore-representation key alist
     この関数は、`assoc'と同様に動作するが、
     KEYは文字列である必要があり、
     `compare-strings'を用いて比較する点が異なる。
     大文字小文字を区別して比較する。

   バッファ内のテキストを比較する *note Comparing
Text::の`compare-buffer-substrings'も参照してください。
文字列に対して正規表現の一致を取る関数`string-match'は、
ある種の文字列比較に使えます。 *Note Regexp Search::。


File: elisp-ja,  Node: String Conversion,  Next: Formatting Strings,  Prev: Text Comparison,  Up: Strings and Characters

4.6 文字と文字列の変換
===============================

本節では、文字や文字列と整数のあいだの変換関数について説明します。
`format'と`prin1-to-string'（*note Output Functions::）は、
Lispオブジェクトを文字列に変換するために使えます。
`read-from-string'（*note Input Functions::）は、
Lispオブジェクトの文字列表現をオブジェクトに『変換』できます。
関数`string-make-multibyte'と`string-make-unibyte'は、
文字列のテキスト表現を変換します（*note Converting Representations::）。

   テキスト文字と一般の入力イベントのテキスト表現を生成する関数
（`single-key-description'と`text-char-description'）については、 *Note
Documentation::。
これらの関数は、主に、ヘルプメッセージの作成に使います。

 -- Function: char-to-string character
     この関数は、1つの文字CHARACTERだけを含む新たな文字列を返す。
     関数`string'のほうがより汎用であるので、 この関数はほぼ廃れている。
     *note Creating Strings::。

 -- Function: string-to-char string
     この関数は、STRINGの先頭文字を返す。
     文字列が空であると関数は0を返す。
     文字列STRINGの先頭文字が、ASCIIコードが0のナル文字であるときも、
     値は0である。

          (string-to-char "ABC")
               => 65
          (string-to-char "xyz")
               => 120
          (string-to-char "")
               => 0
          (string-to-char "\000")
               => 0

     この関数は、存続させるほど有用でなければ、将来、取り除くかもしれない。

 -- Function: number-to-string number
     この関数は、NUMBERの表示表現である文字列を返す。
     NUMBERは整数か浮動小数点数。
     引数が負であれば値の文字列は符号で始まる。

          (number-to-string 256)
               => "256"
          (number-to-string -23)
               => "-23"
          (number-to-string -23.5)
               => "-23.5"

     `int-to-string'は、この関数のほぼ廃れている別名。

     *note Formatting Strings::の`format'も参照。

 -- Function: string-to-number string &optional base
     この関数は、STRING内の文字群が表す数値を返す。
     BASEが`nil'以外ならば、これを基数として整数に変換する。
     BASEが`nil'ならば10を基数とする。
     浮動小数点数の変換はつねに10を基数とする。
     浮動小数点数に対しては別の基数を実装していない。
     作業量も多くそのわりには有用とも思えないからである。

     解析するとき、STRINGの先頭にある空白やタブは無視し、
     数と解釈できる限りをSTRINGから読み取る。
     （先頭の空白やタブ以外の他の白文字を無視するシステムもある。）
     無視した白文字のあとの最初の文字が、数字文字、プラス記号、
     マイナス記号でなければ、この関数は0を返す。

          (string-to-number "256")
               => 256
          (string-to-number "25 is a perfect square.")
               => 25
          (string-to-number "X256")
               => 0
          (string-to-number "-4.5")
               => -4.5

     `string-to-int'はこの関数の廃れた別名。

   文字列へ／から変換するその他の関数を以下にあげておきます。

`concat'
     `concat'は、ベクトルやリストを文字列へ変換する。 *note Creating
     Strings::。

`vconcat'
     `vconcat'は、文字列をベクトルへ変換する。 *note Vector
     Functions::。

`append'
     `append'は、文字列をリストへ変換する。 *note Building Lists::。


File: elisp-ja,  Node: Formatting Strings,  Next: Case Conversion,  Prev: String Conversion,  Up: Strings and Characters

4.7 文字列の書式付け
============================

"書式付け"（formatting）とは、
定数文字列内のさまざま部分を計算値で置き換えた文字列を作ることです。
この文字列は、文字列自体に加えて、
他の値をどのように表示するかも制御します。
この文字列を"書式付け文字列"（format string）と呼びます。

   書式付けは、表示するメッセージを計算する場合に便利です。
実際、関数`message'と関数`error'には、
ここで説明するのと同じ書式付け機能があります。
それらと`format'との違いは、
書式付けした結果をどのように利用するかです。

 -- Function: format string &rest objects
     この関数は、STRINGをコピーし、
     コピー内の書式付け指定を対応するOBJECTSの表現で置き換えた
     新たな文字列を返す。 引数OBJECTSは書式付けすべき計算値である。

   書式付け指定は`%'で始まる文字の列です。
したがって、STRING内に`%d'があると、
関数`format'はそれを書式付けすべき値の1つ
（引数OBJECTSの1つ）の表示表現で置き換えます。
たとえば、つぎのとおりです。

     (format "The value of fill-column is %d." fill-column)
          => "The value of fill-column is 72."

   STRINGに2個以上の書式付け指定がある場合、
書式付け指定はOBJECTSの後続の値に対応します。
つまり、STRINGの最初の書式付け指定は最初の値を使い、
2番目の書式付け指定は2番目の値を使い、といった具合です。
（値が対応しない）余計な書式付け指定は、
予測不可能なふるまいを引き起こします。 余計な値は無視します。

   特定の書式付け指定は、特定の型の値を必要とします。
要求に適合しない値を読者が指定するとエラーを通知します。

   有効な書式付け指定をつぎに示します。

`%s'
     書式付け指定をオブジェクトのクォートしない
     （つまり、`prin1'ではなく`princ'を用いる。*note Output
     Functions::） 表示表現で置き換える。
     したがって、文字列は`"'文字なしでその内容を表示し、
     シンボルは`\'文字なしで表示する。

     対応するオブジェクトがなければ空文字列を使う。

`%S'
     書式付け指定をオブジェクトのクォートした
     （つまり、`prin1'を用いる。*note Output Functions::）
     表示表現で置き換える。 したがって、文字列は`"'文字で囲んで表示し、
     シンボルは特別な文字のまえには`\'文字を付けて表示する。

     対応するオブジェクトがなければ空文字列を使う。

`%o'
     書式付け指定を整数の基数8の表示表現で置き換える。

`%d'
     書式付け指定を整数の基数10の表示表現で置き換える。

`%x'
     書式付け指定を整数の基数16の表示表現で置き換える。

`%c'
     書式付け指定を指定値の文字で置き換える。

`%e'
     書式付け指定を浮動小数点数の指数表記で置き換える。

`%f'
     書式付け指定を浮動小数点数の小数点表記で置き換える。

`%g'
     書式付け指定を浮動小数点数の指数表記か小数点表記のどちらか短いほうで
     置き換える。

`%%'
     文字列に1個の`%'を入れる。
     この書式付け指定は、値を使わない点で特別である。
     たとえば、`(format "%% %d" 30)'は`"% 30"'を返す。

   上記以外の書式付け文字は、エラー`Invalid format
operation'になります。

   例をいくつか示します。

     (format "The name of this buffer is %s." (buffer-name))
          => "The name of this buffer is strings.texi."

     (format "The buffer object prints as %s." (current-buffer))
          => "The buffer object prints as strings.texi."

     (format "The octal value of %d is %o,
              and the hex value is %x." 18 18 18)
          => "The octal value of 18 is 22,
              and the hex value is 12."

   すべての書式付け文字には、`%'とその文字のあいだに、
数前置子を指定できます。
省略可能な数前置子はオブジェクトの最小幅を指定します。
オブジェクトの表示表現がこの幅より小さい場合、パディングします。
数前置子が正ならば（あるいはゼロで始まれば）左側にパディングし、
数前置子が負ならば右側にパディングします。
パディング文字は、通常、空白ですが、
数前置子がゼロで始まれば、ゼロでパディングします。
パディングの例を示します。

     (format "%06d is padded on the left with zeros" 123)
          => "000123 is padded on the left with zeros"

     (format "%-6d is padded on the right" 123)
          => "123    is padded on the right"

   `format'は、どんな幅を指定しても、
オブジェクトの表示表現を切り詰めることはありません。
つまり、情報を失うことなく、数前置子を使って最小の桁幅を指定できます。

   つぎの3つの例において、`%7s'は最小幅7を指定します。
最初の例では、`%7s'に置き換わる文字列は3文字ですから、
パディングとして空白4個を挿入します。
2番目の例では、文字列`"specification"'は13文字幅ですが切り詰めません。
3番目の例では、右側にパディングします。

     (format "The word `%7s' actually has %d letters in it."
             "foo" (length "foo"))
          => "The word `    foo' actually has 3 letters in it."

     (format "The word `%7s' actually has %d letters in it."
             "specification" (length "specification"))
          => "The word `specification' actually has 13 letters in it."

     (format "The word `%-7s' actually has %d letters in it."
             "foo" (length "foo"))
          => "The word `foo    ' actually has 3 letters in it."


File: elisp-ja,  Node: Case Conversion,  Next: Case Tables,  Prev: Formatting Strings,  Up: Strings and Characters

4.8 Lispの大文字小文字変換
===================================

大文字小文字変換関数は、1文字や文字列内の大文字小文字を変更します。
関数は、通常、アルファベット文字 （非ASCII文字のアルファベットに加えて、
`A'から`Z'と`a'から`z'）だけを変換します。
それ以外の文字は変わりません。
（大文字小文字テーブルを指定して異なる大文字小文字変換を指定できる。
*note Case Tables::）

   これらの関数は、引数として渡した文字列は変更しません。

   以下の例では、文字`X'と`x'を使います。
ASCIIコードは、それぞれ、88と120です。

 -- Function: downcase string-or-char
     この関数は、文字や文字列を小文字に変換する。

     `downcase'の引数が文字列であると、
     この関数は、引数の各文字の大文字を小文字に変換した新たな文字列を作成する。
     `downcase'の引数が文字であると、 `downcase'は対応する小文字を返す。
     この値は整数である。
     もとの文字が小文字であったりアルファベット文字でなければ、
     値はもとの文字に等しい。

          (downcase "The cat in the hat")
               => "the cat in the hat"

          (downcase ?X)
               => 120

 -- Function: upcase string-or-char
     この関数は、文字や文字列を大文字に変換する。

     `upcase'の引数が文字列であると、
     この関数は、引数の各文字の小文字を大文字に変換した新たな文字列を作成する。

     `upcase'の引数が文字であると、 `upcase'は対応する大文字を返す。
     この値は整数である。
     もとの文字が大文字であったりアルファベット文字でなければ、
     値はもとの文字に等しい。

          (upcase "The cat in the hat")
               => "THE CAT IN THE HAT"

          (upcase ?x)
               => 88

 -- Function: capitalize string-or-char
     この関数は、文字列や文字をキャピタライズ（先頭文字だけを大文字に）する。
     STRING-OR-CHARが文字列ならば、
     この関数は、STRING-OR-CHARのコピーの各単語をキャピタライズしたものを
     内容とする新たな文字列を作成して返す。
     つまり、各単語の先頭文字だけを大文字にして残りを小文字にする。

     単語の定義は、現在の構文テーブル（*Note Syntax Class
     Table::）において 単語構成文字に分類された文字が連続した列である。

     `capitalize'の引数が文字の場合には、
     `capitalize'は`upcase'の結果と同じである。

          (capitalize "The cat in the hat")
               => "The Cat In The Hat"

          (capitalize "THE 77TH-HATTED CAT")
               => "The 77th-Hatted Cat"

          (capitalize ?x)
               => 88

 -- Function: upcase-initials string
     この関数は、STRING内の単語の先頭文字だけを大文字にし、
     先頭文字以外の文字は変更しない。
     この関数は、STRINGのコピーの各単語の先頭文字を大文字に変換したものを
     内容とする新たな文字列を返す。

     単語の定義は、現在の構文テーブル（*Note Syntax Class
     Table::）において 単語構成文字に分類された文字が連続した列である。

          (upcase-initials "The CAT in the hAt")
               => "The CAT In The HAt"

   文字列を比較する関数については、*Note Text Comparison::。
これらは、大文字小文字を区別しないものもあれば、
場合によって大文字小文字を区別しないものもある。


File: elisp-ja,  Node: Case Tables,  Prev: Case Conversion,  Up: Strings and Characters

4.9 大文字小文字テーブル
==================================

特別な"大文字小文字テーブル"（case table）をインストールすれば、
大文字小文字変換をカスタマイズできます。
大文字小文字テーブルは、大文字と小文字の対応関係を指定します。
このテーブルは、Lispオブジェクトの大文字小文字変換関数（前節参照）と
バッファ内のテキストに作用する大文字小文字変換関数（*note Case
Changes::）の 両方に影響します。
各バッファごとに大文字小文字テーブルがあります。
新たなバッファの大文字小文字テーブルを初期化するために使う
標準の大文字小文字テーブルもあります。

   大文字小文字テーブルは、サブタイプが`case-table'である
文字テーブル（*note Char-Tables::）です。
この文字テーブルは、各文字を対応する小文字に対応付けます。
これには3つの追加スロットがあり、関連するテーブルを保持します。

UPCASE
     upcase（大文字）テーブルは、各文字を対応する大文字に対応付ける。

CANONICALIZE
     canonicalize（正則）テーブルは大文字小文字に関連する1組の文字群を
     その文字群の特定のメンバに対応付ける。

EQUIVALENCES
     equivalences（同値）テーブルは、大文字小文字に関連する1組の文字群の各要素を
     その文字群内のつぎの文字に対応付ける。

   単純な場合、必要なことは、小文字への対応付けを指定するだけです。
関連する3つのテーブルはこの対応付けから自動的に計算されます。

   言語によっては、大文字と小文字の対応関係が1対1でないことがあります。
2つの異なる小文字が同じ大文字に対応することがあります。
このような場合、大文字から小文字への対応付けと、
小文字から大文字への対応付けの両方を指定する必要があります。

追加のテーブルCANONICALIZE（正則）は、各文字を正則文字に対応付けます。
2つの任意の文字が大文字小文字変換で関連付けられている場合、
その2つの文字は同一の正則文字を持ちます。
たとえば、`a'と`A'は、大文字小文字変換で関連付けられているので、
これらは同一の正則文字を持つはずです
（両方の文字に対して`a'であるか、両方の文字に対して`A'である）。

   追加のテーブルEQUIVALENCES（同値）は、
同じ正則クラス（同一の正則文字を持つ文字群）の文字を巡回して対応付けます。
（普通のASCIIでは、`a'を`A'に対応付け、 `A'を`a'に対応付ける。
各正則クラスについても同様。）

   大文字小文字テーブルを作成するときには、
CANONICALIZE（正則）には`nil'を指定できます。
そうすると、Emacsはこのスロットを小文字と大文字の対応付けから埋めます。
EQUIVALENCES（同値）にも`nil'を指定できます。
そうすると、EmacsはこのスロットをCANONICALIZE（正則）から埋めます。
実際に使用している大文字小文字テーブルでは、
これらの要素は`nil'以外です。 CANONICALIZE（正則）を指定せずに
EQUIVALENCES（同値）を指定しないでください、

   つぎに、大文字小文字テーブルを操作する関数を示します。

 -- Function: case-table-p object
     この述語は、OBJECTが正しい
     大文字小文字テーブルならば`nil'以外を返す。

 -- Function: set-standard-case-table table
     この関数は、TABLEを標準の大文字小文字テーブルとし、
     これ以降に作成する任意のバッファに使用できるようにする。

 -- Function: standard-case-table
     これは、標準の大文字小文字テーブルを返す。

 -- Function: current-case-table
     この関数は、カレントバッファの大文字小文字テーブルを返す。

 -- Function: set-case-table table
     これは、カレントバッファの大文字小文字テーブルをTABLEとする。

   以下の3つ関数は、非ASCII文字集合を定義するパッケージ向けの
便利なサブルーティンです。
これらは、指定した大文字小文字テーブルCASE-TABLEを変更します。
さらに、標準の構文テーブルも変更します。 *Note Syntax Tables::。
普通、標準の大文字小文字テーブルを変更するためにこれらの関数を使います。

 -- Function: set-case-syntax-pair uc lc case-table
     この関数は対応する大文字と小文字を指定する。

 -- Function: set-case-syntax-delims l r case-table
     この関数は、文字LとRを 大文字小文字不変区切りの対応する対にする。

 -- Function: set-case-syntax char syntax case-table
     この関数は、CHARを構文SYNTAXの大文字小文字不変にする。

 -- コマンド: describe-buffer-case-table
     このコマンドは、カレントバッファの大文字小文字テーブルの内容を記述する。


File: elisp-ja,  Node: Lists,  Next: Sequences Arrays Vectors,  Prev: Strings and Characters,  Up: Top

5 リスト
***********

"リスト"（list）は、0個以上の（任意のLispオブジェクトの）要素の列を
表現します。 リストとベクトルの重要な相違点は、
複数のリストがそれらの構造の一部を共有できることです。
さらに、リスト全体をコピーすることなく、
リストに要素を追加したり削除できることです。

* Menu:

* Cons Cells::          How lists are made out of cons cells.
* Lists as Boxes::                 Graphical notation to explain lists.
* List-related Predicates::        Is this object a list?  Comparing two lists.
* List Elements::       Extracting the pieces of a list.
* Building Lists::      Creating list structure.
* Modifying Lists::     Storing new pieces into an existing list.
* Sets And Lists::      A list can represent a finite mathematical set.
* Association Lists::   A list can represent a finite relation or mapping.


File: elisp-ja,  Node: Cons Cells,  Next: Lists as Boxes,  Up: Lists

5.1 リストとコンスセル
===============================

Lispのリストは基本データ型ではありません。 リストは"コンスセル"（cons
cells）で構成されます。
コンスセルはドット対を表現するデータオブジェクトです。
ドット対は2つのLispオブジェクトを保持、つまり、『指し』ます。
その2つのLispオブジェクトの一方をCAR、他方をCDRといいます。
これらの名前は歴史的なものです。 *Note Cons Cell Type::。
CDRは『クダー』と読みます。

   リストはコンスセルを連ねたものであり、
リストの各要素ごとにコンスセルが1つあります。
慣習として、コンスセルのCARはリストの要素であり、
CDRはリストを繋ぐために使います。
つまり、各コンスセルのCDRは後続のコンスセルです。
最後のコンスセルのCDRは`nil'です。
CARとCDRの非対称性は単なる慣習によるものです。
コンスセルのレベルでは、CARとCDRには同じ性質があります。

   ほとんどのコンスセルはリストの一部として使われるので、
"リスト構造"（list structure）という用語は、
コンスセルで構成した任意の構造を意味するようになりました。

   シンボル`nil'は、シンボルであるとともにリストでもあるとみなします。
これは要素を持たないリストです。
慣習として、シンボル`nil'のCDR（およびCAR）は `nil'であるとみなします。

   空でない任意のリストLのCDRは、
Lの先頭要素を除くすべての要素を含んだリストです。


File: elisp-ja,  Node: Lists as Boxes,  Next: List-related Predicates,  Prev: Cons Cells,  Up: Lists

5.2 箱の対を連ねたリスト
==================================

コンスセルは1対の箱で図示できます。
最初の箱はCARを表し、2番目の箱はCDRを表します。
つぎは、2つのコンスセルから成る 2要素のリスト`(tulip
lily)'を図示したものです。

      ---------------         ---------------
     | car   | cdr   |       | car   | cdr   |
     | tulip |   o---------->| lily  |  nil  |
     |       |       |       |       |       |
      ---------------         ---------------

   各1対の箱がコンスセルを表します。
各箱は、Lispオブジェクトを『参照する』、『指す』、『含む』のです。
（これらの用語は同義語。） 最初のコンスセルのCARを表す最初の箱は、
シンボル`tulip'を含みます。
最初のコンスセルのCDR箱から2番目のコンスセルへ向かう矢印は、
最初のコンスセルのCDRが2番目のコンスセルであることを表します。

   同じリストは、つぎのような別の箱記法でも図示できます。

         --- ---      --- ---
        |   |   |--> |   |   |--> nil
         --- ---      --- ---
          |            |
          |            |
           --> tulip    --> lily

   つぎは、より複雑で、最初の要素が2要素リストであるような
3要素リストを図示したものです。

         --- ---      --- ---      --- ---
        |   |   |--> |   |   |--> |   |   |--> nil
         --- ---      --- ---      --- ---
          |            |            |
          |            |            |
          |             --> oak      --> maple
          |
          |     --- ---      --- ---
           --> |   |   |--> |   |   |--> nil
                --- ---      --- ---
                 |            |
                 |            |
                  --> pine     --> needles

   同じリストを最初の箱記法で表現するとつぎのようになります。

      --------------       --------------       --------------
     | car   | cdr  |     | car   | cdr  |     | car   | cdr  |
     |   o   |   o------->| oak   |   o------->| maple |  nil |
     |   |   |      |     |       |      |     |       |      |
      -- | ---------       --------------       --------------
         |
         |
         |        --------------       ----------------
         |       | car   | cdr  |     | car     | cdr  |
          ------>| pine  |   o------->| needles |  nil |
                 |       |      |     |         |      |
                  --------------       ----------------

   コンスセルとリストの入力構文と表示表現、および、
『箱と矢印』によるリストの図示については、*Note Cons Cell Type::


File: elisp-ja,  Node: List-related Predicates,  Next: List Elements,  Prev: Lists as Boxes,  Up: Lists

5.3 リスト向け述語
=========================

以下の述語は、Lispオブジェクトが、アトムであるか、
コンスセル、つまり、リストであるか、
特別なオブジェクト`nil'であるか調べます。
（これらの多く述語は、それぞれ残りの述語で定義可能である。
しかし、多用するため、これらすべてを用意しておく価値がある。）

 -- Function: consp object
     この関数は、OBJECTがコンスセルならば`t'を返し、
     さもなければ`nil'を返す。
     `nil'はコンスセルではないが、空リスト_である_。

 -- Function: atom object
     この関数は、OBJECTがアトムならば`t'を返し、
     さもなければ`nil'を返す。
     コンスセルを除くすべてのオブジェクトはアトムである。
     シンボル`nil'はアトムでもありリストでもある。
     このようなLispオブジェクトは`nil'だけである。

          (atom OBJECT) == (not (consp OBJECT))

 -- Function: listp object
     この関数は、OBJECTがコンスセルか`nil'ならば`t'を返す。
     さもなければ`nil'を返す。

          (listp '(1))
               => t
          (listp '())
               => t

 -- Function: nlistp object
     この関数は、`listp'の反対である。
     OBJECTがリストでなければ`t'を返す。 さもなければ`nil'を返す。

          (listp OBJECT) == (not (nlistp OBJECT))

 -- Function: null object
     この関数は、OBJECTが`nil'ならば`t'を返し、
     さもなければ`nil'を返す。
     この関数は、`not'と同一であるが、意図を明確にするために、
     OBJECTをリストと考えるときには`null'を使い、
     OBJECTを真理値と考えるときには`not'を使う （*note Combining
     Conditions::の`not'を参照）

          (null '(1))
               => nil
          (null '())
               => t


File: elisp-ja,  Node: List Elements,  Next: Building Lists,  Prev: List-related Predicates,  Up: Lists

5.4 リストの要素の参照
===============================

 -- Function: car cons-cell
     この関数は、コンスセルCONS-CELLの最初のポインタが指す値を返す。
     別のいい方をすれば、CONS-CELLのCARを返す。

     特別な場合として、CONS-CELLが`nil'のときには、
     `car'は`nil'を返すと定義する。
     したがって、任意のリストは`car'の正しい引数である。
     引数がコンスセルでも`nil'でもなければエラーを通知する。

          (car '(a b c))
               => a
          (car '())
               => nil

 -- Function: cdr cons-cell
     この関数は、コンスセルCONS-CELLの2番目のポインタが指す値を返す。
     別のいい方をすれば、CONS-CELLのCDRを返す。

     特別な場合として、CONS-CELLが`nil'のときには、
     `cdr'は`nil'を返すと定義する。
     したがって、任意のリストは`cdr'の正しい引数である。
     引数がコンスセルでも`nil'でもなければエラーを通知する。

          (cdr '(a b c))
               => (b c)
          (cdr '())
               => nil

 -- Function: car-safe object
     この関数は、コンスセルのCARを取り出すが、
     他のデータ型に対するエラーを回避する。
     OBJECTがコンスセルならばOBJECTのCARを返すが、
     さもなければ`nil'を返す。 これは`car'と対照的であり、
     `car'はOBJECTがリストでないとエラーを通知する。

          (car-safe OBJECT)
          ==
          (let ((x OBJECT))
            (if (consp x)
                (car x)
              nil))

 -- Function: cdr-safe object
     この関数は、コンスセルのCDRを取り出すが、
     他のデータ型に対するエラーを回避する。
     OBJECTがコンスセルならばOBJECTのCDRを返すが、
     さもなければ`nil'を返す。 これは`cdr'と対照的であり、
     `cdr'はOBJECTがリストでないとエラーを通知する。

          (cdr-safe OBJECT)
          ==
          (let ((x OBJECT))
            (if (consp x)
                (cdr x)
              nil))

 -- Function: nth n list
     この関数は、LISTのN番目の要素を返す。
     要素は0から数えるので、LISTのCARは要素番号0。
     LISTの長さがNかそれ未満であると、値は`nil'になる。

     Nが負であると、`nth'はLISTの最初の要素を返す。

          (nth 2 '(1 2 3 4))
               => 3
          (nth 10 '(1 2 3 4))
               => nil
          (nth -3 '(1 2 3 4))
               => 1

          (nth n x) == (car (nthcdr n x))

     関数`elt'も同様であるが、任意のシーケンスに適用できる。
     歴史的な理由で引数の順序は逆である。 *note Sequence Functions::。

 -- Function: nthcdr n list
     この関数は、LISTのN番目のCDRを返す。
     いいかえれば、LISTの始めのN個のリンクを飛び越えて、
     そのあとにあるものを返す。

     Nが0か負であると、`nthcdr'はLIST全体を返す。
     LISTの長さがNかそれ未満であると、 `nthcdr'は`nil'を返す。

          (nthcdr 1 '(1 2 3 4))
               => (2 3 4)
          (nthcdr 10 '(1 2 3 4))
               => nil
          (nthcdr -3 '(1 2 3 4))
               => (1 2 3 4)

 -- Function: safe-length list
     この関数は、エラーや無限ループを回避して、LISTの長さを返す。

     LISTが実際にはリストでない場合には、`safe-length'は0を返す。
     LISTに循環があると、少なくとも異なる要素の個数を表す有限値を返す。

   循環はないと思われるリストの長さを計算するもっとも一般的な方法は、
`length'です。 *Note Sequence Functions::。

 -- Function: caar cons-cell
     これは`(car (car CONS-CELL))'と同じ。

 -- Function: cadr cons-cell
     これは`(car (cdr CONS-CELL))'や `(nth 1 CONS-CELL)'と同じ。

 -- Function: cdar cons-cell
     これは`(cdr (car CONS-CELL))'と同じ。

 -- Function: cddr cons-cell
     これは`(cdr (cdr CONS-CELL))'や `(nthcdr 2 CONS-CELL)'と同じ。


File: elisp-ja,  Node: Building Lists,  Next: Modifying Lists,  Prev: List Elements,  Up: Lists

5.5 コンスセルとリストの構築
========================================

リストはLispの中核なので、多くの関数はリストを構築します。
`cons'は基本的なリスト構築関数です。
しかし、Emacsのソースコードでは、`cons'より`list'を
多用していることは興味深いことです。

 -- Function: cons object1 object2
     この関数は、新たなリスト構造を構築するために使う基本関数。
     OBJECT1をCAR、OBJECT2をCDRとする
     新たなコンスセルを作成し、このコンスセルを返す。
     引数OBJECT1とOBJECT2はどんなLispオブジェクトでもよいが、
     ほとんどの場合、OBJECT2はリストである。

          (cons 1 '(2))
               => (1 2)
          (cons 1 '())
               => (1)
          (cons 1 2)
               => (1 . 2)

     `cons'は、リストの先頭に要素を1つ追加するために しばしば使われる。
     これを"要素をリストにコンスする"という。 たとえば、つぎのとおり。

          (setq list (cons newelt list))

     この例における`list'という名前の変数と
     以下に述べる`list'という名前の関数とは衝突しない。
     任意のシンボルはどちらの目的にも使える。

 -- Function: list &rest objects
     この関数は、OBJECTSを要素とするリストを作成する。
     結果のリストはつねに`nil'終端になる。
     OBJECTSを指定しないと空リストを返す。

          (list 1 2 3 4 5)
               => (1 2 3 4 5)
          (list 1 2 '(3 4 5) 'foo)
               => (1 2 (3 4 5) foo)
          (list)
               => nil

 -- Function: make-list length object
     この関数は、すべての要素が同一の値OBJECTであり
     長さがLENGTHのリストを作成する。
     `make-string'と比較してほしい（*note Creating Strings::）。

          (make-list 3 'pigs)
               => (pigs pigs pigs)
          (make-list 0 'pigs)
               => nil

 -- Function: append &rest sequences
     この関数はSEQUENCESのすべての要素から成るリストを返す。
     SEQUENCESは、リスト、ベクトル、ブールベクトル、文字列のいずれかであるが、
     普通、最後の要素はリストである。
     最後の引数を除いてすべての引数をコピーするので、どの引数も変更しない
     （コピーせずにリストを繋ぐ方法については、 *note
     Rearrangement::の`nconc'を参照。）

     一般には、`append'の最後の引数はどんなLispオブジェクトでもよい。
     最後の引数をコピーしたり変換したりしない。
     それは、新たなリストの最後のコンスセルのCDRになる。
     最後の引数がそれ自体リストであれば、それらの要素は、実質的には、
     結果のリストの要素になる。
     最後の要素がリストでなければ、結果は『ドット対』になる。
     なぜなら、結果の最後のCDRは、
     真のリストに必要とされる`nil'ではないからである。

     関数`append'は、引数として整数も受け付ける。
     整数を10進の表示表現の文字列に変換してから、
     その文字列を整数のかわりに使う。 *この機能を使わないでほしい。
     削除する予定である。
     読者がこの機能を使っていたら、今すぐプログラムを直すこと！*` '
     整数をこのような10進数に変換する正しい方法は、 `format'（*note
     Formatting Strings::）や `number-to-string'（*note String
     Conversion::）を使うことである。

   `append'の使用例をつぎに示します。

     (setq trees '(pine oak))
          => (pine oak)
     (setq more-trees (append '(maple birch) trees))
          => (maple birch pine oak)

     trees
          => (pine oak)
     more-trees
          => (maple birch pine oak)
     (eq trees (cdr (cdr more-trees)))
          => t

   箱表示を見れば`append'の動作を理解できるでしょう。
変数`trees'にリスト`(pine oak)'を設定し、ついで、
変数`more-trees'にはリスト`(maple birch pine oak)'を設定します。
しかし、変数`trees'はもとのリストを指し続けます。

     more-trees                trees
     |                           |
     |     --- ---      --- ---   -> --- ---      --- ---
      --> |   |   |--> |   |   |--> |   |   |--> |   |   |--> nil
           --- ---      --- ---      --- ---      --- ---
            |            |            |            |
            |            |            |            |
             --> maple    -->birch     --> pine     --> oak

   空シーケンスは`append'が返す値にはまったく寄与しません。
この結果、最後の`nil'引数は直前の引数をコピーするように強制します。

     trees
          => (pine oak)
     (setq wood (append trees nil))
          => (pine oak)
     wood
          => (pine oak)
     (eq wood trees)
          => nil

この方法は、関数`copy-sequence'を導入するまでは、
リストをコピーする普通の方法でした。 *Note Sequences Arrays Vectors::。

   `append'の引数にベクトルと文字列を使った例をつぎに示します。

     (append [a b] "cd" nil)
          => (a b 99 100)

   `apply'（*note Calling Functions::）の助けを借りれば、
リストのリストの中にあるすべてのリストを連結できます。

     (apply 'append '((a b c) nil (x y z) nil))
          => (a b c x y z)

   SEQUENCESをまったく指定しないと`nil'を返します。

     (append)
          => nil

   最後の引数がリストではない例をいくつか示します。

     (append '(x y) 'z)
          => (x y . z)
     (append '(x y) [z])
          => (x y . [z])

最後の引数がリストではなくシーケンスである2番目の例は、
シーケンスの要素が結果のリストの要素にはならないことを示しています。
そのかわりに、最後の引数がリストでない場合と同様に、
シーケンスが最後のCDRになります。

 -- Function: reverse list
     この関数は、LISTの要素を逆順にした新たなリストを作成する。
     もとの引数LISTは変更_しない_。

          (setq x '(1 2 3 4))
               => (1 2 3 4)
          (reverse x)
               => (4 3 2 1)
          x
               => (1 2 3 4)


File: elisp-ja,  Node: Modifying Lists,  Next: Sets And Lists,  Prev: Building Lists,  Up: Lists

5.6 既存のリスト構造の修正
=====================================

基本関数`setcar'や`setcdr'を使って、
コンスセルのCARやCDRの内容を変更できます。
これらは、既存のリスト構造を変更するので、 『破壊的』な操作と呼びます。

     Common Lispに関した注意：` ' Common Lispでは、
     リスト構造を変更するには`rplaca'や`rplacd'を使う。
     これらは`setcar'や`setcdr'と同様に構造を変更する。 しかし、Common
     Lispの関数はコンスセルを返すが、
     `setcar'や`setcdr'は新たなCARやCDRを返す。

* Menu:

* Setcar::          Replacing an element in a list.
* Setcdr::          Replacing part of the list backbone.
                      This can be used to remove or add elements.
* Rearrangement::   Reordering the elements in a list; combining lists.


File: elisp-ja,  Node: Setcar,  Next: Setcdr,  Up: Modifying Lists

5.6.1 `setcar'によるリスト要素の変更
-----------------------------------------------

コンスセルのCARを変更するには、`setcar'を使います。
リストに対して使用すると、
`setcar'はリストの1つの要素を別の要素に置き換えます。

 -- Function: setcar cons object
     この関数は、CONSの新たなCARとしてOBJECTを格納し、
     以前のCARを置き換える。
     いいかえれば、CONSのCARスロットがOBJECTを指すように変更する。
     この関数は値OBJECTを返す。 たとえば、つぎのようになる。

          (setq x '(1 2))
               => (1 2)
          (setcar x 4)
               => 4
          x
               => (4 2)

   コンスセルが複数のリストの共有構造の一部であるときには、
コンスセルに新たなCARを格納すると、
そのような各リストの1つの要素を変更することになります。

     ;; 共有部分がある2つのリストを作る
     (setq x1 '(a b c))
          => (a b c)
     (setq x2 (cons 'z (cdr x1)))
          => (z b c)

     ;; 共有部分のCARを置き換える
     (setcar (cdr x1) 'foo)
          => foo
     x1                           ; 両方のリストが変更されている
          => (a foo c)
     x2
          => (z foo c)

     ;; 非共有部分のCARを置き換える
     (setcar x1 'baz)
          => baz
     x1                           ; 1つのリストだけが変更されている
          => (baz foo c)
     x2
          => (z foo c)

   変数`x1'と`x2'に入っている共有部分を持つ2つのリストを図示すると
つぎのようになります。
`b'を置き換えるとなぜ両者が変更されるのかわかるでしょう。

             --- ---        --- ---      --- ---
     x1---> |   |   |----> |   |   |--> |   |   |--> nil
             --- ---        --- ---      --- ---
              |        -->   |            |
              |       |      |            |
               --> a  |       --> b        --> c
                      |
            --- ---   |
     x2--> |   |   |--
            --- ---
             |
             |
              --> z

   同じ関係を別の箱表示で示します。

     x1:
      --------------       --------------       --------------
     | car   | cdr  |     | car   | cdr  |     | car   | cdr  |
     |   a   |   o------->|   b   |   o------->|   c   |  nil |
     |       |      |  -->|       |      |     |       |      |
      --------------  |    --------------       --------------
                      |
     x2:              |
      --------------  |
     | car   | cdr  | |
     |   z   |   o----
     |       |      |
      --------------


File: elisp-ja,  Node: Setcdr,  Next: Rearrangement,  Prev: Setcar,  Up: Modifying Lists

5.6.2 リストのCDRの変更
------------------------------

CDRを修正するもっとも低レベルの基本関数は`setcdr'です。

 -- Function: setcdr cons object
     この関数は、CONSの新たなCDRとしてOBJECTを格納し、
     以前のCDRを置き換える。
     いいかえれば、CONSのCDRスロットがOBJECTを指すように変更する。
     この関数は値OBJECTを返す。

   リストのCDRを別のリストで置き換える例を示します。
リストの最初の要素以外は取り除かれ、 要素の別のシーケンスになります。
最初の要素は変更されません。 というのは、それはリストのCARの中にあり、
CDRからは辿れないからです。

     (setq x '(1 2 3))
          => (1 2 3)
     (setcdr x '(4))
          => (4)
     x
          => (1 4)

   リスト内のコンスセル群のCDRを変更することで、
リストの中ほどの要素を削除できます。 つぎの例は、リスト`(a b
c)'の最初のコンスセルのCDRを変更することで、
このリストの第2要素`b'を削除します。

     (setq x1 '(a b c))
          => (a b c)
     (setcdr x1 (cdr (cdr x1)))
          => (c)
     x1
          => (a c)

   箱表記では、この結果はつぎのようになります。

                        --------------------
                       |                    |
      --------------   |   --------------   |    --------------
     | car   | cdr  |  |  | car   | cdr  |   -->| car   | cdr  |
     |   a   |   o-----   |   b   |   o-------->|   c   |  nil |
     |       |      |     |       |      |      |       |      |
      --------------       --------------        --------------

以前に要素`b'を保持していた2番目のコンスセルはまだ存在していて、
そのCARもまだ`b'ですが、このリストの一部ではありません。

   CDRを変更して新たな要素を挿入するのも同様に簡単です。

     (setq x1 '(a b c))
          => (a b c)
     (setcdr x1 (cons 'd (cdr x1)))
          => (d b c)
     x1
          => (a d b c)

   箱表記では、この結果はつぎのようになります。

      --------------        -------------       -------------
     | car  | cdr   |      | car  | cdr  |     | car  | cdr  |
     |   a  |   o   |   -->|   b  |   o------->|   c  |  nil |
     |      |   |   |  |   |      |      |     |      |      |
      --------- | --   |    -------------       -------------
                |      |
          -----         --------
         |                      |
         |    ---------------   |
         |   | car   | cdr   |  |
          -->|   d   |   o------
             |       |       |
              ---------------


File: elisp-ja,  Node: Rearrangement,  Prev: Setcdr,  Up: Modifying Lists

5.6.3 リストの順序を変更する関数
---------------------------------------------

以下は、リストを構成するコンスセルのCDRを変更することで、
『破壊的に』リストの順序を変更する関数です。
これらの関数を『破壊的』と呼ぶのは、
渡された引数であるもとのリストのコンスセルを繋ぎ換えて新たなリストに
変えるからです。

   コンスセルを変更する他の関数については、 *note Sets And Lists::のSee
`delq'を参照してください。

 -- Function: nconc &rest lists
     この関数は、LISTSのすべての要素を入れたリストを返す。
     `append'（*note Building Lists::）と異なり、
     LISTSをコピー_しない_。
     そのかわりに、各LISTSの最後のCDRを後続のリストを指すように変更する。
     LISTSの最後は変更しない。 たとえば、つぎのようになる。

          (setq x '(1 2 3))
               => (1 2 3)
          (nconc x '(4 5))
               => (1 2 3 4 5)
          x
               => (1 2 3 4 5)

     `nconc'は最後の引数を変更しないので、 上述の例のように、`'(4
     5)'などの定数リストを使ってよい。
     同じ理由で最後の引数はリストである必要もない。

          (setq x '(1 2 3))
               => (1 2 3)
          (nconc x 'z)
               => (1 2 3 . z)
          x
               => (1 2 3 . z)

     しかしながら、すべての引数は（最後のものを除いて）リストである必要がある。

     よくある落し穴は、`nconc'の最後以外の引数に、
     クォートした定数リストを使うことである。
     こうすると、読者のプログラムは実行するたびに定数を変えてしまう。
     たとえば、つぎのようになる。

          (defun add-foo (x)            ; この関数は引数の先頭に
            (nconc '(foo) x))           ;   `foo'を追加する、としたい

          (symbol-function 'add-foo)
               => (lambda (x) (nconc (quote (foo)) x))

          (setq xx (add-foo '(1 2)))    ; 動いているように見える
               => (foo 1 2)
          (setq xy (add-foo '(3 4)))    ; どうなってるの？
               => (foo 1 2 3 4)
          (eq xx xy)
               => t

          (symbol-function 'add-foo)
               => (lambda (x) (nconc (quote (foo 1 2 3 4) x)))

 -- Function: nreverse list
     この関数は、LISTの要素の順番を逆順にする。
     `reverse'と異なり、`nreverse'は
     リストを構成するコンスセルのCDRを逆向きにして引数を変えてしまう。
     LISTの最後にあったコンスセルは戻り値の最初のコンスセルになる。

     たとえば、つぎのようになる。

          (setq x '(1 2 3 4))
               => (1 2 3 4)
          x
               => (1 2 3 4)
          (nreverse x)
               => (4 3 2 1)
          ;; 先頭にあったコンスセルは、今、最後になっている
          x
               => (1)

     混乱を避けるために、`nreverse'の結果は、
     もとのリストを収めていたものと同じ変数に格納する。

          (setq x (nreverse x))

     `nreverse'を`(a b c)'に適用した結果を図示すると つぎのようになる。

          もとのリストの先頭                        逆順にしたリスト
           -------------        -------------        ------------
          | car  | cdr  |      | car  | cdr  |      | car | cdr  |
          |   a  |  nil |<--   |   b  |   o  |<--   |   c |   o  |
          |      |      |   |  |      |   |  |   |  |     |   |  |
           -------------    |   --------- | -    |   -------- | -
                            |             |      |            |
                             -------------        ------------

 -- Function: sort list predicate
     この関数は、破壊的にではあるが、
     LISTを順序を保ってソートしたリストを返す。
     要素の比較にはPREDICATEを使う。
     順序を保ったソートとは、同じソートキーを持つ要素の相対順序を、
     ソート実行前後で変更しないソートである。
     異なる基準でつぎつぎにソートするときには、
     順序を保つことは重要である。

     引数PREDICATEは、2つの引数を取る関数である必要がある。
     この関数は、LISTの2つの要素で呼び出される。
     昇順のソートでは、PREDICATEは、
     第1引数が第2引数より『小さい』ときに`t'を返し、
     さもなければ`nil'を返す必要がある。

     比較関数PREDICATEは、少なくとも単一の`sort'の呼び出し中は、
     引数の任意の対に対して信頼できる結果を返す必要がある。
     まず、"反対称"であること。 つまり、AがBより小さいときには、
     BがAより小さくてはいけない。 また、"遷移則"が成り立つこと。
     つまり、AがBより小さく、かつ、BがCより小さいときには、
     AはCより小さくなければならない。
     これらの要請を満たさない比較関数を用いると、
     `sort'の結果は予測できない。

     `sort'が破壊的であるというのは、
     LISTを構成するコンスセルのCDRを変更して、
     コンスセルの順序を変更するからである。
     非破壊的なソート関数では、ソートした要素を格納するために新たなコンスセルを
     作成するであろう。 もとのリストを破壊せずにソートしたければ、
     まず`copy-sequence'でコピーを作り、それをソートする。

     ソートする際、LISTのコンスセルのCARは変更しない。
     LIST内の要素`a'を入れていたコンスセルは、
     ソート後にもそのCARには`a'が入っている。
     しかし、CDRを変更してあるので、リスト内では異なる場所に現れる。
     たとえば、つぎのようになる。

          (setq nums '(1 3 2 6 5 4 0))
               => (1 3 2 6 5 4 0)
          (sort nums '<)
               => (0 1 2 3 4 5 6)
          nums
               => (1 2 3 4 5 6)

     *警告*：` '`nums'のリストには 0が入っていないことに注意。
     （`nums'が指す）コンスセルはソート前と同じコンスセルだが、
     それはもはやリストの先頭にはない。 引数を保持していた変数が、
     ソートしたリスト全体を保持していると仮定しないこと！` '
     かわりに、`sort'の結果を保存して、それを使う。
     多くの場合、つぎのように、もとのリストを保持していた変数に結果を保存し直す。

          (setq nums (sort nums '<))

     ソートを行う他の関数については、*note Sorting::。
     `sort'の有用な例については、 *note Accessing
     Documentation::の`documentation'を参照。


File: elisp-ja,  Node: Sets And Lists,  Next: Association Lists,  Prev: Modifying Lists,  Up: Lists

5.7 集合としてのリストの利用
========================================

リストで、数学の順序のない集合を表現できます。
つまり、リストに現れる要素を集合の要素と考え、
リスト内での順序は無視します。 2つの集合の和集合を作るには、
（要素が重複することを気にしなければ）`append'を使います。
集合向けの他の有用な関数には、`memq'や`delq'、および、
これらの`equal'版である`member'や`delete'があります。

     Common Lispに関した注意：` ' Common Lispには、集合演算向けに
     （要素の重複を避ける）関数`union'と`intersection'があるが、 GNU
     Emacs Lispにはない。 必要ならば、読者みずからLispでこれらを書ける。

 -- Function: memq object list
     この関数は、OBJECTがLISTの要素かどうか調べる。 そうならば、
     `memq'はOBJECTが最初に現れるところから始まるリストを返す。
     さもなければ`nil'を返す。
     `memq'の文字`q'は、リストの要素に対するOBJECTの比較に
     `eq'を使うことを意味する。 たとえば、

          (memq 'b '(a b c b a))
               => (b c b a)
          (memq '(2) '((1) (2)))    ; `(2)'と`(2)'は`eq'ではない
               => nil

 -- Function: delq object list
     この関数は、LISTからOBJECTに`eq'であるすべての要素を
     破壊的に削除する。 `delq'の文字`q'は、`memq'と同様に、
     リストの要素に対するOBJECTの比較に`eq'を使うことを意味する。

   `delq'がリストの先頭から要素を削除する場合には、
単にリストを辿って削除した要素のつぎから始まる部分リストを返します。

     (delq 'a '(a b c)) == (cdr '(a b c))

   リストの中ほどの要素を削除する場合には、
削除にはCDRの変更を伴います（*note Setcdr::）。

     (setq sample-list '(a b c (4)))
          => (a b c (4))
     (delq 'a sample-list)
          => (b c (4))
     sample-list
          => (a b c (4))
     (delq 'c sample-list)
          => (a b (4))
     sample-list
          => (a b (4))

   `(delq 'c sample-list)'は、
3番目の要素を切り取って`sample-list'を変更しますが、 `(delq 'a
sample-list)'では、
なにも切り取らずに単に短いリストを返すことに注意してください。
引数LISTを保持していた変数が、実行後には少ない要素を持つと仮定したり、
もとのリストを保持し続けていると仮定したりしないでください！` '
そのかわりに、`delq'の結果を保存して、それを使ってください。
多くの場合、つぎのように、
もとのリストを保持していた変数に結果を保存し直します。

     (setq flowers (delq 'rose flowers))

   つぎの例では、`delq'が一致を取ろうとしている`(4)'と
`sample-list'の`(4)'とは`eq'ではありません。

     (delq '(4) sample-list)
          => (a c (4))

   つぎの2つの関数は、`memq'や`delq'に似ていますが、
比較には`eq'のかわりに`equal'を使います。 *Note Equality Predicates::。

 -- Function: member object list
     関数`member'は、`equal'を使ってOBJECTと要素を比較して、
     OBJECTがLISTの要素かどうか調べる。 OBJECTが要素であれば、
     `member'はLIST内でそれが最初に現れるところから始まるリストを返す。
     さもなければ`nil'を返す。

     `memq'と比較してほしい。

          (member '(2) '((1) (2)))  ; `(2)'と`(2)'は`equal'である
               => ((2))
          (memq '(2) '((1) (2)))    ; `(2)'と`(2)'は`eq'ではない
               => nil
          ;; 同じ内容の2つの文字列は`equal'である
          (member "foo" '("foo" "bar"))
               => ("foo" "bar")

 -- Function: delete object list
     この関数は、LISTからOBJECTに`equal'であるすべての要素を
     破壊的に削除する。
     `member'が`memeq'に対応するように、`delq'に対応する。
     `member'と同様に、 要素とOBJECTとの比較には`equal'を使う。
     一致する要素をみつけると、`delq'と同様に要素を削除する。
     たとえば、つぎのとおり。

          (delete '(2) '((2) (1) (2)))
               => ((1))

     Common Lispに関した注意：` ' GNU Emacs
     Lispの関数`member'と関数`delete'は
     Maclispから受け継いだものであり、Common Lispからではない。 Common
     Lisp版では要素の比較には`equal'を使わない。

   変数に格納したリストに要素を追加する別の方法については、 *note
Setting Variables::の関数`add-to-list'を参照してください。


File: elisp-ja,  Node: Association Lists,  Prev: Sets And Lists,  Up: Lists

5.8 連想リスト
===================

"連想リスト"（association list）、略して"alist"は、
キーから値への対応付けを記録しています。
これは"連想"（associations）と呼ばれるコンスセルのリストです。
各コンスセルのCARは"key"であり、 CDRは"連想値"（associated value）です。
(1)

   連想リストの例を示します。
キー`pine'を値`cones'に、キー`oak'を値`acorns'に、
キー`maple'を値`seeds'に対応付けています。

     '((pine . cones)
       (oak . acorns)
       (maple . seeds))

   連想リスト内の連想値は任意のLispオブジェクトでよく、キーもそうです。
たとえば、つぎの連想リストでは、シンボル`a'に数`1'を、
文字列`"b"'に_リスト_`(2 3)'を対応付けています。 _リスト_`(2
3)'は連想リストの要素のCDRです。

     ((a . 1) ("b" 2 3))

   要素のCDRのCARに連想値を格納するように
連想リストを設計したほうがよい場合もあります。 つぎのようにします。

     '((rose red) (lily white) (buttercup yellow))

ここで、`red'は`rose'に対応付けた値と考えます。
この種の連想リストの利点の1つは、関連する別の情報を、
他の項目から成るリストでさえも、CDRのCDRに格納できることです。
1つの欠点は、`rassq'（下記参照）を使って
指定した値を含む要素を探せないことです。
これらの条件が重要でない場合には、1つの連想リストに関する限り、
一貫性があればどちらを選ぶかは好みの問題です。

   上に示した連想リストは、要素のCDRに連想値が収めてあると
考えることもできます。 `rose'の連想値はリスト`(red)'になります。

   連想リストはスタックなどに置くような情報の記録に使います。
というには、リストの先頭に新たな連想を追加するのが簡単だからです。
指定したキーに対する連想を連想リストから探すとき、
それらが複数個存在する場合には、最初にみつかったものを返します。

   Emacs Listでは、連想リストの要素がコンスセルでなくても
エラーでは_ありません_。
連想リスト探索関数はそのような要素を単に無視します。
他の多くのLispでは、そのような場面ではエラーを通知します。

   属性リストもいろいろな意味で連想リストに類似しています。
属性リストは、キーが一度しか現れない連想リストのようにふるまいます。
属性リストと連想リストの比較については、*Note Property Lists::。

 -- Function: assoc key alist
     この関数は、ALIST内のKEYに対する最初の連想を返す。
     KEYと連想リストの各要素との比較には、 `equal'（*note Equality
     Predicates::）を用いる。 ALISTの中にCARがKEYに`equal'である連想が
     存在しなければ、`nil'を返す。 たとえば、つぎのとおり。

          (setq trees '((pine . cones) (oak . acorns) (maple . seeds)))
               => ((pine . cones) (oak . acorns) (maple . seeds))
          (assoc 'oak trees)
               => (oak . acorns)
          (cdr (assoc 'oak trees))
               => acorns
          (assoc 'birch trees)
               => nil

     つぎは、キーと値がシンボルではない例。

          (setq needles-per-cluster
                '((2 "Austrian Pine" "Red Pine")
                  (3 "Pitch Pine")
                  (5 "White Pine")))

          (cdr (assoc 3 needles-per-cluster))
               => ("Pitch Pine")
          (cdr (assoc 2 needles-per-cluster))
               => ("Austrian Pine" "Red Pine")

   関数`assoc-ignore-representation'と`assoc-ignore-case'は
`assoc'に似ていますが、
それらは比較に`compare-strings'を使う点が異なります。 *Note Text
Comparison::。

 -- Function: rassoc value alist
     この関数は、ALISTの中でVALUEを値とする最初の連想を返す。
     ALISTの中にCDRがVALUEに`equal'である連想が
     存在しなければ、`nil'を返す。

     `rassoc'は`assoc'に似ているが、
     ALISTの各連想のCARのかわりにCDRを比較する点が異なる。
     指定した値に対するキーを探す『`assoc'の逆演算』と考えることができる。

 -- Function: assq key alist
     この関数は、ALIST内のKEYに対する最初の連想を返すという意味で
     `assoc'に似ているが、`equal'のかわりに`eq'で比較する。
     ALIST内の連想のCARがKEYに`eq'であるものが存在しないと、
     `assq'は`nil'を返す。 この関数は`assoc'より多用される。
     というのは、`eq'は`equal'より高速であり、
     ほとんどの連想リストではキーとしてシンボルを使うからである。

          (setq trees '((pine . cones) (oak . acorns) (maple . seeds)))
               => ((pine . cones) (oak . acorns) (maple . seeds))
          (assq 'pine trees)
               => (pine . cones)

     一方で、キーがシンボルではない連想リストでは、
     `assq'は、通常、有用ではない。

          (setq leaves
                '(("simple leaves" . oak)
                  ("compound leaves" . horsechestnut)))

          (assq "simple leaves" leaves)
               => nil
          (assoc "simple leaves" leaves)
               => ("simple leaves" . oak)

 -- Function: rassq value alist
     この関数は、ALISTの中でVALUEを値とする最初の連想を返す。
     ALISTの中にCDRがVALUEに`eq'である連想が
     存在しなければ、`nil'を返す。

     `rassq'は`assq'に似ているが、
     ALISTの各連想のCARのかわりにCDRを比較する点が異なる。
     指定した値に対するキーを探す『`assq'の逆演算』と考えることができる。

     たとえばつぎのとおり。

          (setq trees '((pine . cones) (oak . acorns) (maple . seeds)))

          (rassq 'acorns trees)
               => (oak . acorns)
          (rassq 'spores trees)
               => nil

     `rassq'では、 要素のCDRのCARに格納された値を探せないことに注意。

          (setq colors '((rose red) (lily white) (buttercup yellow)))

          (rassq 'white colors)
               => nil

     この場合、連想`(lily white)'のCDRは、
     シンボル`white'ではなくリスト`(white)'である。
     連想をドット対記法で書くとこれが明確になる。

          (lily white) == (lily . (white))

 -- Function: assoc-default key alist test default
     この関数は、KEYに一致するものをALISTから探す。
     ALISTの各要素について、（アトムならば）要素とKEYを、
     あるいは、（コンスならば）要素のCARとKEYを比較する。
     比較にはこれらを2つの引数としてTESTを呼び出す。
     引数を渡す順序はこの順なので、 正規表現（*note Regexp
     Search::）を収めた連想リストに対して
     `string-match'を使うと有益な結果を得られる。
     TESTを省略したり`nil'であると、比較には`equal'を用いる。

     上の条件で連想リストの要素がKEYに一致するならば、
     `assoc-default'はその要素に基づく値を返す。
     要素がコンスならば値は要素のCDR。 さもなければ、戻り値はDEFAULT。

     KEYに一致する連想リストの要素が存在しなければ、
     `assoc-default'は`nil'を返す。

 -- Function: copy-alist alist
     この関数は、ALISTを2レベルの深さまでコピーしたものを返す。
     各連想ごとに新たなコピーを作るので、
     新たな連想リストの連想を変更しても、もとの連想リストは変更しない。

          (setq needles-per-cluster
                '((2 . ("Austrian Pine" "Red Pine"))
                  (3 . ("Pitch Pine"))
                  (5 . ("White Pine"))))
          =>
          ((2 "Austrian Pine" "Red Pine")
           (3 "Pitch Pine")
           (5 "White Pine"))

          (setq copy (copy-alist needles-per-cluster))
          =>
          ((2 "Austrian Pine" "Red Pine")
           (3 "Pitch Pine")
           (5 "White Pine"))

          (eq needles-per-cluster copy)
               => nil
          (equal needles-per-cluster copy)
               => t
          (eq (car needles-per-cluster) (car copy))
               => nil
          (cdr (car (cdr needles-per-cluster)))
               => ("Pitch Pine")
          (eq (cdr (car (cdr needles-per-cluster)))
              (cdr (car (cdr copy))))
               => t

     この例は、`copy-alist'により、
     コピーの連想を変更して他のものになぜ影響しないかを示す。

          (setcdr (assq 3 copy) '("Martian Vacuum Pine"))
          (cdr (assq 3 needles-per-cluster))
               => ("Pitch Pine")


   ---------- Footnotes ----------

   (1) この『キー』の使い方は、『キー列』とは無関係。
キーとは、表の項目を探すために使う値を意味する。
ここでは、表は連想リストであり、項目は連想リストの連想値である。


File: elisp-ja,  Node: Sequences Arrays Vectors,  Next: Symbols,  Prev: Lists,  Up: Top

6 シーケンス、配列、ベクトル
*****************************************

"シーケンス"（sequence）型とは、Lispの2つの異なる型の和であることを
思い出してください。 いいかえれば、任意のリストはシーケンスであり、
任意の配列もシーケンスです。 すべてのシーケンスに共通する性質は、
それぞれ、要素の順序付けた集まりであるということです。

   "配列"（array）は、各要素ごとに1つ1つスロットを用意してある
単一の基本オブジェクトです。
すべての要素は一定時間内に参照できますが、既存の配列の長さは変更できません。
文字列、ベクトル、文字テーブル、ブールベクトルは、配列型の4つの型です。

   リストは、要素を並べたものですが、
単一の基本オブジェクトではありません。
コンスセルから作られていて、1つの要素あたり1つのセルがあります。
N番目の要素を探すには、N個のコンスセルを調べる必要があるので、
リストの先頭から遠い要素を参照するには余計に時間がかかります。
しかし、リストには要素を追加したり削除したりできます。

   以下の図は、これらの型の関係を示します。

     　　　　　┌────────────────────────┐
     　　　　　│　　　　　　シーケンス　　　　　　　　　　　　　│
     　　　　　│┌───┐　┌───────────────┐　│
     　　　　　││　　　│　│　　　　　　　　　　　　　　　│　│
     　　　　　││リスト│　│　　　　　　配列　　　　　　　│　│
     　　　　　││　　　│　│　┌────┐　┌───┐　　│　│
     　　　　　││　　　│　│　│　　　　│　│　　　｜　　│　│
     　　　　　│└───┘　│　│ベクトル│　│文字列｜　　│　│
     　　　　　│　　　　　　│　│　　　　│　│　　　｜　　│　│
     　　　　　│　　　　　　│　└────┘　└───┘　　│　│
     　　　　　│　　　　　　│　┌────┐　┌────┐　│　│
     　　　　　│　　　　　　│　│文字　　│　│ブール　│　│　│
     　　　　　│　　　　　　│　│テーブル│　│ベクトル│　│　│
     　　　　　│　　　　　　│　└────┘　└────┘　│　│
     　　　　　│　　　　　　└───────────────┘　│
     　　　　　└────────────────────────┘

   ベクトルやリストの要素は、どんなLispオブジェクトでもかまいません。
文字列の要素はすべて文字です。

* Menu:

* Sequence Functions::    Functions that accept any kind of sequence.
* Arrays::                Characteristics of arrays in Emacs Lisp.
* Array Functions::       Functions specifically for arrays.
* Vectors::               Special characteristics of Emacs Lisp vectors.
* Vector Functions::      Functions specifically for vectors.
* Char-Tables::           How to work with char-tables.
* Bool-Vectors::          How to work with bool-vectors.


File: elisp-ja,  Node: Sequence Functions,  Next: Arrays,  Up: Sequences Arrays Vectors

6.1 シーケンス
===================

Emacs Lispでは、"シーケンス"（sequence）とはリストか配列のことです。
すべてのシーケンスに共通する性質は、
要素の順序付けた集まりであるということです。
本節では任意のシーケンスを受け付ける関数を説明します。

 -- Function: sequencep object
     OBJECTが、リスト、ベクトル、あるいは、文字列ならば`t'を返し、
     さもなければ`nil'を返す。

 -- Function: length sequence
     この関数はSEQUENCE内の要素の個数を返す。
     SEQUENCEが（最後のCDRが`nil'ではないため）
     リストではないコンスセルであると、
     エラー`wrong-type-argument'を通知する。

     関連する関数`safe-length'については、*note List Elements::。

          (length '(1 2 3))
              => 3
          (length ())
              => 0
          (length "foobar")
              => 6
          (length [1 2 3])
              => 3
          (length (make-bool-vector 5 nil))
              => 5

 -- Function: elt sequence index
     この関数はINDEXで添字付けされるSEQUENCEの要素を返す。
     INDEXの正当な値は、0からSEQUENCEの長さより1小さい範囲の
     整数である。 SEQUENCEがリストである場合には、
     範囲外のINDEXに対しては`nil'を返す。
     さもなければエラー`args-out-of-range'を引き起こす。

          (elt [1 2 3 4] 2)
               => 3
          (elt '(1 2 3 4) 2)
               => 3
          ;; `string'を用いて`elt'が返す文字を明確にする
          (string (elt "1234" 2))
               => "3"
          (elt [1 2 3 4] 4)
               error--> Args out of range: [1 2 3 4], 4
          (elt [1 2 3 4] -1)
               error--> Args out of range: [1 2 3 4], -1

     この関数は、`aref'（*note Array Functions::）や `nth'（*note List
     Elements::）を汎用にしたものである。

 -- Function: copy-sequence sequence
     SEQUENCEのコピーを返す。
     コピーは、もとのシーケンスと同じ型のオブジェクトであり、
     同じ要素が同じ順序で入っている。

     コピーに新たな要素を格納しても、もとのSEQUENCEには影響せず、
     その逆もそうである。
     しかし、新たなシーケンスの要素はコピーしていない。
     つまり、それらはもとの要素と同一（`eq'）である。
     したがって、シーケンスのコピーにおいて、
     それらの要素の内部を変更すると、もとのシーケンスでもその変更がわかる。

     シーケンスがテキスト属性を持つ文字列である場合には、
     コピーの中の属性リストそのものもコピーであり、
     もとの属性リストを共有するのではない。
     しかし、属性の実際の値は共有される。

     シーケンスをコピーする別の方法については、 *note Building
     Lists::の`append'、*note Creating Strings::の`concat'、 *note
     Vectors::の`vconcat'を参照。

          (setq bar '(1 2))
               => (1 2)
          (setq x (vector 'foo bar))
               => [foo (1 2)]
          (setq y (copy-sequence x))
               => [foo (1 2)]

          (eq x y)
               => nil
          (equal x y)
               => t
          (eq (elt x 1) (elt y 1))
               => t

          ;; 1つのシーケンスの1つの要素を置き換える
          (aset x 0 'quux)
          x => [quux (1 2)]
          y => [foo (1 2)]

          ;; 共有された要素の内部を修正する
          (setcar (aref x 1) 69)
          x => [quux (69 2)]
          y => [foo (69 2)]


File: elisp-ja,  Node: Arrays,  Next: Array Functions,  Prev: Sequence Functions,  Up: Sequences Arrays Vectors

6.2 配列
==========

"配列"（array）オブジェクトには、配列の要素と呼ばれる
Lispオブジェクトを保持するためのスロットがいくつかあります。
配列の任意の要素は一定時間で参照できます。
一方、リストの要素の参照には、
リスト内でのその要素の位置に比例した時間が必要です。

   Emacsには4つの型の配列があり、すべて1次元です。
"文字列"（strings）、"ベクトル"（vectors）、
"ブールベクトル"（bool-vectors）、"文字テーブル"（char-tables）です。
ベクトルは汎用の配列であり、
その要素は任意のLispオブジェクトでかまいません。
文字列は特化された配列であり、その要素は文字（つまり、0から255までの整数）で
ある必要があります。 配列のそれぞれの型には、独自の入力構文があります。
*note String Type::と*Note Vector Type::。

   配列の4つの型すべてには、以下の性質があります。

   *
     配列の最初の要素は添字0であり、2番目の要素は添字1であり、といった具合。
     これを"ゼロ原点"（zero-origin）の添字付けと呼ぶ。
     たとえば、4要素の配列の添字は、0、1、2、そして、3。

   * 配列の長さは、いったん作成すると固定される。
     既存配列の長さは変更できない。

   * 配列は、評価上は定数である。 いいかえれば、それ自身に評価される。

   * 配列要素の参照や変更は、それぞれ、 関数`aref'や`aset'で行う
     （*note Array Functions::）。

   文字テーブル以外の配列を作成するときには、
その長さを指定する必要があります。 文字テーブルの長さは指定できません。
というのは、その長さは文字コードの範囲で決まるからです。

原理的には、テキスト文字の配列が必要ならば文字列かベクトルを使います。
実用上は、以下の4つの理由から、そのような場合には文字列を使います。

   * 同じ要素のベクトルの1/4の領域を専有するだけ。

   * 文字列の表示方法は、その内容をテキストとして明確に示す。

   * 文字列は、テキスト属性を保持できる。 *note Text Properties::。

   * Emacsの特化された編集機能や入出力機能の多くは、
     文字列だけを受け付ける。
     たとえば、文字のベクトルをバッファには挿入できないが、
     文字列ならば挿入できる。 *note Strings and Characters::。

   一方、（キー列のような）キーボード入力文字の配列には、
ベクトルが必要です。
というのは、キーボード入力文字の多くは、文字列に納まる範囲外だからです。
*Note Key Sequence Input::。


File: elisp-ja,  Node: Array Functions,  Next: Vectors,  Prev: Arrays,  Up: Sequences Arrays Vectors

6.3 配列操作関数
======================

本節では任意の配列型を受け付ける関数を説明します。

 -- Function: arrayp object
     この関数はOBJECTが配列
     （つまり、ベクトル、文字列、ブールベクトル、あるいは、文字テーブル）ならば、
     `t'を返す。

          (arrayp [a])
               => t
          (arrayp "asdf")
               => t
          (arrayp (syntax-table))    ;; 文字テーブル
               => t

 -- Function: aref array index
     この関数はARRAYのINDEX番目の要素を返す。 最初の要素の添字は0。

          (setq primes [2 3 5 7 11 13])
               => [2 3 5 7 11 13]
          (aref primes 4)
               => 11
          (aref "abcdefg" 1)
               => 98           ; `b'は、ASCIIコード98

     *note Sequence Functions::の関数`elt'も参照。

 -- Function: aset array index object
     この関数は配列ARRAYのINDEX番目の要素にOBJECTを設定する。
     OBJECTを返す。

          (setq w [foo bar baz])
               => [foo bar baz]
          (aset w 0 'fu)
               => fu
          w
               => [fu bar baz]

          (setq x "asdfasfd")
               => "asdfasfd"
          (aset x 3 ?Z)
               => 90
          x
               => "asdZasfd"

     ARRAYが文字列であり、かつ、OBJECTが文字でなければ、
     結果はエラー`wrong-type-argument'となる。
     ARRAYが文字列であり、かつ、OBJECTが文字であっても、 現在`(aref
     OBJECT INDEX)'に保存されている文字のバイト数と
     OBJECTが使うバイト数が異なれば、やはり、エラーとなる。 *note
     Splitting Characters::。

 -- Function: fillarray array object
     この関数は、配列ARRAYをOBJECTで埋め、
     ARRAYの各要素がOBJECTとなるようにする。 ARRAYを返す。

          (setq a [a b c d e f g])
               => [a b c d e f g]
          (fillarray a 0)
               => [0 0 0 0 0 0 0]
          a
               => [0 0 0 0 0 0 0]
          (setq s "When in the course")
               => "When in the course"
          (fillarray s ?-)
               => "------------------"

     ARRAYが文字列であり、かつ、OBJECTが文字でなければ、
     結果はエラー`wrong-type-argument'になる。

   配列であることが既知のオブジェクトに対しては、
汎用のシーケンス関数`copy-sequence'や`length'がしばしば有用です。 *Note
Sequence Functions::。


File: elisp-ja,  Node: Vectors,  Next: Vector Functions,  Prev: Array Functions,  Up: Sequences Arrays Vectors

6.4 ベクトル
================

Lispの配列は、ほとんどの言語の配列と同様に、
その要素を一定時間で参照可能なメモリのブロックです。
"ベクトル"（vector）は指定長の汎用配列です。
その要素はどんなLispオブジェクトでもかまいません。
（対照的に、文字列は要素としては文字だけを保持する。）
Emacsでは、オブジェクト配列obarray（シンボルのベクトル）、
キーマップ（コマンドのベクトル）の一部にベクトルを使っています。
これらは、内部的には、バイトコード関数の表現の一部にも使っています。
そのような関数を表示すると、その中にベクトルがあるのがわかります。

   Emacs Lispでは、ベクトルの要素の添字は0から始まります。

   ベクトルは要素を角括弧で囲んで表示します。
したがって、要素がシンボル`a'、`b'、`a'であるベクトルは、 `[a b
a]'と表示されます。 Lispへの入力では同じようにベクトルを書きます。

   文字列や数と同様に、評価上、ベクトルは定数とみなします。
それを評価した結果は、同じベクトルです。
この評価では、ベクトルの要素を評価したり調べたりはしません。

   以下は、これらの原理を例示するものです。

     (setq avector [1 two '(three) "four" [five]])
          => [1 two (quote (three)) "four" [five]]
     (eval avector)
          => [1 two (quote (three)) "four" [five]]
     (eq avector (eval avector))
          => t


File: elisp-ja,  Node: Vector Functions,  Next: Char-Tables,  Prev: Vectors,  Up: Sequences Arrays Vectors

6.5 ベクトル向け関数
============================

ベクトルに関連した関数はつぎのとおりです。

 -- Function: vectorp object
     この関数は、OBJECTがベクトルならば`t'を返す。

          (vectorp [a])
               => t
          (vectorp "asdf")
               => nil

 -- Function: vector &rest objects
     この関数は、引数OBJECTSを要素とするベクトルを作成しそれを返す。

          (vector 'foo 23 [bar baz] "rats")
               => [foo 23 [bar baz] "rats"]
          (vector)
               => []

 -- Function: make-vector length object
     この関数は、各要素をOBJECTに初期化した
     LENGTH個の要素から成る新たなベクトルを返す。

          (setq sleepy (make-vector 9 'Z))
               => [Z Z Z Z Z Z Z Z Z]

 -- Function: vconcat &rest sequences
     この関数は、SEQUENCESのすべての要素を入れた新たなベクトルを返す。
     引数SEQUENCESは、リスト、ベクトル、文字列を含む任意の配列でよい。
     SEQUENCESを指定しないと空ベクトルを返す。

     その値は、既存のベクトルと`eq'でない新たに作成したベクトルである。

          (setq a (vconcat '(A B C) '(D E F)))
               => [A B C D E F]
          (eq a (vconcat a))
               => nil
          (vconcat)
               => []
          (vconcat [A B C] "aa" '(foo (6 7)))
               => [A B C 97 97 foo (6 7)]

     関数`vconcat'は、引数としてバイトコード関数でも受け付ける。
     これは、バイトコード関数オブジェクトの全内容を簡単に参照できるように
     するための特別な機能である。 *note Byte-Code Objects::。

     関数`vconcat'は、引数として整数も受け付ける。
     整数はその10進の表示表現の文字列に変換してから、
     その文字列を整数のかわりに使う。 *この機能を使わないでほしい。
     削除する予定である。
     読者がこの機能を使っていたら、今すぐプログラムを直すこと！*` '
     整数をこのような10進数に変換する正しい方法は、 `format'（*note
     Formatting Strings::）や `number-to-string'（*note String
     Conversion::）を使うことである。

     他の連結関数については、 *note Mapping Functions::の`mapconcat'、
     *note Creating Strings::の`concat'、 *note Building
     Lists::の`append'を参照。

関数`append'は、ベクトルを同じ要素から成るリストへ変換する便利な方法です
（*note Building Lists::）。

     (setq avector [1 two (quote (three)) "four" [five]])
          => [1 two (quote (three)) "four" [five]]
     (append avector nil)
          => (1 two (quote (three)) "four" [five])


File: elisp-ja,  Node: Char-Tables,  Next: Bool-Vectors,  Prev: Vector Functions,  Up: Sequences Arrays Vectors

6.6 文字テーブル
======================

文字テーブルはベクトルによく似ていますが、
文字コードで添字付けする点が異なります。
修飾子を伴わない任意の正当な文字コードは、文字テーブルの添字に使えます。
文字テーブルの要素は、任意の配列のように、`aref'や`aset'で
参照できます。 さらに、文字テーブルでは、
特定の文字コードには対応しない追加データを保持するための"追加スロット"を
保持できます。 評価時には、文字テーブルは定数です。

   各文字テーブルには、シンボルである"サブタイプ"（subtype）があります。
サブタイプには2つの目的があります。
異なる使い方をする文字テーブルを区別するためと、
追加スロットの個数を制御するためです。
たとえば、表示テーブルはサブタイプが`display-table'である
文字テーブルであり、
構文テーブルはサブタイプが`syntax-table'である文字テーブルです。
正当なサブタイプには、`char-table-extra-slots'属性があるはずで、
その値は0から10までの整数です。
この整数が文字テーブルの"追加スロット"の個数を指定します。

   文字テーブルは、別の文字テーブルである"親"を持てます。
その場合、特定の文字Cに対する文字テーブルの指定が`nil'のときには、
親において指定された値を継承します。
いいかえれば、CHAR-TABLE自体に`nil'を指定してあると、 `(aref CHAR-TABLE
C)'は、 CHAR-TABLEの親の値を返します。

   文字テーブルは、"デフォルト値"も持てます。
その場合、文字テーブルが指定する値が`nil'であると、 `(aref CHAR-TABLE
C)'はデフォルト値を返します。

 -- Function: make-char-table subtype &optional init
     サブタイプがSUBTYPEである新たに作成した文字テーブルを返す。
     各要素をINITで初期化する。 なお、INITのデフォルトは`nil'である。
     文字テーブル作成後には、文字テーブルのサブタイプは変更できない。

     文字テーブルの長さを指定する引数はない。
     なぜなら、すべての文字テーブルでは、
     任意の正当な文字コードを添字として使えるからである。

 -- Function: char-table-p object
     この関数は、OBJECTが文字テーブルならば`t'を返し、
     さもなければ`nil'を返す。

 -- Function: char-table-subtype char-table
     この関数はCHAR-TABLEのサブタイプを表すシンボルを返す。

 -- Function: set-char-table-default char-table new-default
     この関数はCHAR-TABLEのデフォルト値をNEW-DEFAULTにする。

     文字テーブルのデフォルト値を参照するための特別な関数はない。
     それには`(char-table-range CHAR-TABLE nil)'を使う。

 -- Function: char-table-parent char-table
     この関数はCHAR-TABLEの親を返す。
     親は、`nil'であるか他の文字テーブルである。

 -- Function: set-char-table-parent char-table new-parent
     この関数はCHAR-TABLEの親をNEW-PARENTにする。

 -- Function: char-table-extra-slot char-table n
     この関数はCHAR-TABLEの追加スロットNの内容を返す。
     文字テーブル内の追加スロットの個数はそのサブタイプで決まる。

 -- Function: set-char-table-extra-slot char-table n value
     この関数はCHAR-TABLEの追加スロットNにVALUEを格納する。

   文字テーブルでは、1つの文字コードに対して1つの要素値を指定できます。
また、文字集合全体に対して1つの値を指定することもできます。

 -- Function: char-table-range char-table range
     これは、CHAR-TABLEにおいて文字範囲RANGEに指定されている値を返す。
     RANGEとして可能なものは以下のとおり。

    `nil'
          デフォルト値を指す。

    CHAR
          （CHARが正当な文字コードであると仮定して）
          文字CHARに対する要素を指す。

    CHARSET
          文字集合CHARSET全体に対して指定してある値を指す （*note
          Character Sets::）。

    GENERIC-CHAR
          文字集合に対する汎用文字を表す。
          引数として汎用文字を指定することは、文字集合名を指定することと同値。
          汎用文字の説明は、*note Splitting Characters::。

 -- Function: set-char-table-range char-table range value
     この関数は文字範囲RANGEに対するCHAR-TABLEの値を設定する。
     RANGEとして可能なものは以下のとおり。

    `nil'
          デフォルト値を指す。

    `t'
          文字コードの範囲全体を指す。

    CHAR
          （CHARが正当な文字コードであると仮定して）
          文字CHARに対する要素を指す。

    CHARSET
          文字集合CHARSET全体に対して指定してある値を指す （*note
          Character Sets::）。

    GENERIC-CHAR
          文字集合に対する汎用文字を表す。
          引数として汎用文字を指定することは、文字集合名を指定することと同値。
          汎用文字の説明は、*note Splitting Characters::。

 -- Function: map-char-table function char-table
     この関数は、CHAR-TABLEの各要素についてFUNCTIONを呼び出す。
     FUNCTIONをキーと値の2つの引数で呼び出す。
     キーは`char-table-range'に対する可能なRANGE引数であり、
     正当な文字か汎用文字である。 値は`(char-table-range CHAR-TABLE
     KEY)'である。

     全体として、FUNCTIONに渡すキー・値の対は、
     CHAR-TABLEに格納されたすべての値を表す。

     戻り値はつねに`nil'である。 この関数が有用であるようにするには、
     FUNCTIONには副作用があるべきである。
     たとえば、つぎは構文テーブルの各要素の調べ方である。

          (let (accumulator)
            (map-char-table
             #'(lambda (key value)
                 (setq accumulator
                       (cons (list key value) accumulator)))
             (syntax-table))
            accumulator)
          =>
          ((475008 nil) (474880 nil) (474752 nil) (474624 nil)
           ... (5 (3)) (4 (3)) (3 (3)) (2 (3)) (1 (3)) (0 (3)))


File: elisp-ja,  Node: Bool-Vectors,  Prev: Char-Tables,  Up: Sequences Arrays Vectors

6.7 ブールベクトル
=========================

ブールベクトルはベクトルによく似ていますが、
`t'と`nil'の値だけを保存できる点が異なります。
ブールベクトルの要素に`nil'以外の値を保存しようとすると、
その効果は`t'を保存することになります。
すべての配列と同様に、ブールベクトルの添字は0から始まり、
ブールベクトルをいったん作成すると長さは変更できません。
評価時には、ブールベクトルは定数です。

   ブールベクトルを操作する特別な関数は2つあります。
それに加えて、他の種類の配列を扱う関数でも操作できます。

 -- Function: make-bool-vector length initial
     INITIALに初期化した長さLENGTHの新たなブールベクトルを返す。

 -- Function: bool-vector-p object
     OBJECTがブールベクトルであれば`t'を返し、 さもなければ`nil'を返す。


File: elisp-ja,  Node: Symbols,  Next: Evaluation,  Prev: Sequences Arrays Vectors,  Up: Top

7 シンボル
**************

"シンボル"（symbol）とは、一意な名前が付いたオブジェクトです。
本章では、シンボル、その構成要素、属性リスト、作成方法とインターン方法に
ついて説明します。
シンボルの変数としての使用方法、関数名としての使用方法について説明した
別の章もあります。 *note Variables::と*Note Functions::。
シンボルの正確な入力構文については、*Note Symbol Type::。

   `symbolp'で、任意のLispオブジェクトがシンボルかどうか調べられます。

 -- Function: symbolp object
     この関数は、OBJECTがシンボルならば`t'を返し、
     さもなければ`nil'を返す。

* Menu:

* Symbol Components::        Symbols have names, values, function definitions
                               and property lists.
* Definitions::              A definition says how a symbol will be used.
* Creating Symbols::         How symbols are kept unique.
* Property Lists::           Each symbol has a property list
                               for recording miscellaneous information.


File: elisp-ja,  Node: Symbol Components,  Next: Definitions,  Prev: Symbols,  Up: Symbols

7.1 シンボルの構成要素
===============================

各シンボルには4つの構成要素（つまり、『セル』）があり、
それぞれで別のオブジェクトを参照します。

表示名（print name）
     "表示名セル"（print name cell）には、
     シンボルの入力や表示に使う名前である文字列が入っている。 *note
     Creating Symbols::の`symbol-name'を参照。

値（value）
     "値セル"（value cell）には、
     シンボルの変数としての現在値が入っている。
     シンボルをフォームとして使用したとき、
     フォームの値はシンボルの値セルの内容である。 *note Accessing
     Variables::の`symbol-value'を参照。

関数（function）
     "関数セル"（function cell）には、シンボルの関数定義が入っている。
     シンボルを関数として使用したとき、その関数定義を使う。
     シンボルが、編集コマンドを実行するためのキーマップやキーボードマクロを
     表すときもこのセルを使う。
     各シンボルには値セルと関数セルが別々にあるので、
     変数名と関数名は衝突しない。 *note Function
     Cells::の`symbol-function'を参照。

属性リスト（property list）
     "属性リストセル"（property list cell）には、
     シンボルの属性リストが入っている。 *note Property
     Lists::の`symbol-plist'を参照。

   表示名セルはつねに文字列を保持していて、変更できません。
他の3つのセルには、任意の指定したLispオブジェクトを個別に設定できます。

   表示名セルは、シンボルの名前である文字列を保持しています。
シンボルはテキスト上はその名前で表現されるので、
2つのシンボルが同じ名前を持たないことが重要です。
Lispリーダがこのことを保証します。
シンボルを読み取るたびに、新たにシンボルを作成するまえに、
指定した名前のシンボルが存在するかどうか調べます。 （GNU Emacs
Lispでは、これにはハッシュアルゴリズムと オブジェクト配列obarrayを使う。
*note Creating Symbols::。）

   普通の使い方では、関数セルには関数（*note Functions::）や
マクロ（*note Macros::）が入っていて、
Lispインタープリタはそのように仮定します（*note Evaluation::）。
シンボルの関数セルには、 キーボードマクロ（*note Keyboard
Macros::）、キーマップ（*note Keymaps::）、
自動ロードオブジェクト（*note
Autoloading::）が入っていることもあります。
『関数`foo'』といった場合、実際には、シンボル`foo'の関数セルに
入っている関数を意味します。 必要な場合に限って区別します。

   属性リストセルは、通常、正しい形式の属性リスト（*note Property
Lists::）が
入っている必要があり、さまざまな関数がそのように仮定しています。

   関数セルや値セルは"空"（void）でもかまいません。
つまり、セルはどんなオブジェクトも指していません。
（このことは、シンボル`void'を保持しているとか、
シンボル`nil'を保持しているのとは違う。）
空である関数セルや値セルを参照すると、 その結果は`Symbol's value as
variable is void'
（「変数としてのシンボルの値は空」）のようなエラーになります。

   4つの関数、`symbol-name'、`symbol-value'、
`symbol-plist'、`symbol-function'は、
シンボルの4つのセルの内容を返します。
以下に、シンボル`buffer-file-name'の
4つのセルの内容を表示する例を示します。

     (symbol-name 'buffer-file-name)
          => "buffer-file-name"
     (symbol-value 'buffer-file-name)
          => "/gnu/elisp/symbols.texi"
     (symbol-plist 'buffer-file-name)
          => (variable-documentation 29529)
     (symbol-function 'buffer-file-name)
          => #<subr buffer-file-name>

このシンボルは、カレントバッファで訪問しているファイルの名前を保持するので、
値セルの内容は本書Emacs Lispマニュアルの本章のソースファイルの名前です。
属性リストセルには、リスト`(variable-documentation 29529)'が入っていて、
ドキュメント関数に対してファイル`DOC-VERSION'のどこに
変数`buffer-file-name'の説明文字列が入っているか伝えます。
（29529は、当該説明文字列の開始位置を表す
`DOC-VERSION'の先頭からのオフセット。 *note Documentation
Basics::を参照。）
関数セルには、ファイルの名前を返す関数が入っています。
`buffer-file-name'は基本関数の名前です。 これには入力構文はなく、
ハッシュ記法（*note Primitive Function Type::）で表示されています。
Lispで書いた関数を表すシンボルでは、
このセルにラムダ式（あるいはバイトコードオブジェクト）が入っています。


File: elisp-ja,  Node: Definitions,  Next: Creating Symbols,  Prev: Symbol Components,  Up: Symbols

7.2 シンボルを定義する
===============================

Lispにおける"定義"（definition）とは、
特定のシンボルをどのように使うかを意思表示するスペシャルフォームです。
Emacs Lispでは、シンボルを変数と定義したり、
関数（あるいはマクロ）と定義したり、あるいは、それらを独立に定義できます。

   定義を行う構文では、典型的には、値を指定したり、
シンボルを特定の使い方をすると指定したりし、
さらに、そのような使い方をしたときの意味を表すための説明文字列を指定します。
したがって、シンボルを変数として定義するときには、
変数に初期値を与え、その変数の説明文字列を指定できます。

   `defvar'と`defconst'は、シンボルをグローバル変数として定義する
スペシャルフォームです。 これらは*note Defining
Variables::で詳しく説明してあります。
カスタマイズ可能なようにユーザーオプション用の変数を定義するには、
`defcustom'（*note Customization::）を使います。

   `defun'は、シンボルを関数として定義し、
ラムダ式を作ってシンボルの関数セルに格納します。
したがって、このラムダ式がシンボルの関数定義になります。
（用語『関数定義』は、関数セルの内容を意味し、
`defun'がシンボルに関数としての定義を与えることからきている。）
`defsubst'と`defalias'は、関数を定義する別の2つの方法です。 *Note
Functions::。

   `defmacro'は、シンボルをマクロとして定義します。
マクロオブジェクトを作ってシンボルの関数セルに格納します。
シンボルは、マクロか関数のいずれかであって、
同時に両方にはならないことに注意してください。
というのは、マクロ定義も関数定義も関数セルに収められ、
そのセルにはどんなときでもたった1つのLispオブジェクトしか
保持できないからです。 *Note Macros::。

   Emacs Lispでは、シンボルを変数や関数として使うための
定義は必須ではありません。
したがって、シンボルをあらかじめ定義しようがしまいが、
`setq'を使ってシンボルをグローバル変数にできます。
定義の真の目的は、プログラマに対する指針であり、プログラミングツールなのです。
これらは、コードを読むプログラマに対して、
特定のシンボルを変数として使うのか関数として使うのか、
その_意図_を伝えます。
さらに、`etags'や`make-docfile'などのユーティリティは、
定義を認識してタグテーブルやファイル`DOC-VERSION'に
適切な情報を追加します。 *Note Accessing Documentation::。


File: elisp-ja,  Node: Creating Symbols,  Next: Property Lists,  Prev: Definitions,  Up: Symbols

7.3 シンボルの作成とインターン
===========================================

GNU Emacs Lispにおいて、どのようにシンボルを作成するかを理解するには、
Lispがそれらをどのように読むかを知る必要があります。
Lispは、同じ文字群を読み取るたびに、同じシンボルをみつけることを保証する
必要があります。 これに失敗すると完全に混乱します。

   Lispリーダがシンボルに出会うと、名前の文字群をすべて読み取ります。
そして、これらの文字群を『ハッシュ化』して、
"オブジェクト配列"（obarray）と呼ばれる表の添字を探します。
ハッシュ化は効率的に探索する手法です。 たとえば、Jan
Jonesを電話番号簿の表紙から1ページずつ順に探すかわりに、
Jのページから探し始めます。 これは単純なハッシュ化です。
オブジェクト配列の各要素は、
あるハッシュコードを有するすべてのシンボルを格納した
"バケット"（bucket）です。
ある名前を探すには、その名前のハッシュコードに対応するバケット内の
すべてのシンボルを調べるだけで十分です。

   目的の名前のシンボルがみつかれば、リーダはそのシンボルを使います。
オブジェクト配列に目的の名前のシンボルがなければ、
リーダは新たなシンボルを作成し、それをオブジェクト配列に追加します。
ある名前のシンボルを探したり追加することをシンボルを
"インターン"（interning）するといい、
そのシンボルを"インターンしたシンボル"（interned symbol）と呼びます。

   インターンすることで、各オブジェクト配列には
特定の名前のシンボルが1個だけあることを保証します。
他の似たような名前のシンボルが存在しても、
同じオブジェクト配列には入っていません。
したがって、同じオブジェクト配列を使って読む限り、
リーダは同じ名前に対して同じシンボルを得ることができます。

   すべてのシンボルがオブジェクト配列に入っているとは限りません。
実際、どのオブジェクト配列にも属さないシンボルがいくつかあります。
これらを"インターンしてないシンボル"（uninterned symbols）と呼びます。
インターンしてないシンボルにも、他のシンボルと同様に4つのセルがあります。
しかし、それを参照する手段は、他のオブジェクトを介して探すか、
変数の値として探すしかありません。

   Emacs Lispでは、オブジェクト配列は実際にはベクトルです。
ベクトルの各要素はバケットです。
その値は、そのバケットにハッシュ化される名前のインターンしたシンボルであるか、
そのバケットが空ならば0です。
インターンした各シンボルには、バケットのつぎのシンボルを指す
（ユーザーには見えない）内部的なリンクがあります。
このリンクは見えないので、`mapatoms'（下記）を使う以外には、
オブジェクト配列内のすべてのシンボルを探す方法はありません。
バケット内でのシンボルの順序は関係ありません。

   空のオブジェクト配列では、各要素は0です。 `(make-vector LENGTH
0)'でオブジェクト配列を作成できます。
*これは、オブジェクト配列を作成する唯一の正当な方法です。*
長さとして素数を用いると、ハッシュ化の結果がよい傾向があります。
2の巾より1小さい長さもよい結果になります。

   *読者自身でオブジェクト配列にシンボルを入れないでください。*
うまくいきません。
オブジェクト配列にシンボルを正しく入れられるのは`intern'だけです。

     Common Lispに関した注意：` ' Common
     Lispでは、1つのシンボルを複数のオブジェクト配列に入れることができる。

   下記の関数のほとんどは、引数に名前を取り、
場合によってはオブジェクト配列を引数に取ります。
名前が文字列でなかったり、オブジェクト配列がベクトルでないと、
エラー`wrong-type-argument'を通知します。

 -- Function: symbol-name symbol
     この関数は、SYMBOLの名前を表す文字列を返す。
     たとえば、つぎのとおり。

          (symbol-name 'foo)
               => "foo"

     *警告：*` ' 文字列の文字を置き換えるとシンボルの名前を変更するが、
     オブジェクト配列は更新できないので変更しないこと！

 -- Function: make-symbol name
     この関数は、NAME（文字列であること）を名前とする
     新たに割り付けたインターンしていないシンボルを返す。
     その値と関数定義は空であり、属性リストは`nil'である。
     以下の例では、`sym'の値は`foo'と`eq'ではない。
     なぜなら、名前は`foo'ではあるが、
     インターンしていない別のシンボルであるため。

          (setq sym (make-symbol "foo"))
               => foo
          (eq sym 'foo)
               => nil

 -- Function: intern name &optional obarray
     この関数は、NAMEを名前とするインターンしたシンボルを返す。
     そのようなシンボルがオブジェクト配列OBARRAYに存在しなければ、
     `intern'は新たなものを作成し、それをオブジェクト配列に追加してから、
     それを返す。
     OBARRAYを省略すると、グローバル変数`obarray'の値を使う。

          (setq sym (intern "foo"))
               => foo
          (eq sym 'foo)
               => t

          (setq sym1 (intern "foo" other-obarray))
               => foo
          (eq sym 'foo)
               => nil

     Common Lispに関した注意：` ' Common
     Lispでは、既存のシンボルをオブジェクト配列にインターンできる。
     Emacs Lispでは、これはできない。
     なぜなら、`intern'の引数は文字列である必要があり、
     シンボルではない。

 -- Function: intern-soft name &optional obarray
     この関数は、OBARRAY内のNAMEを名前とするシンボルを返す。
     ただし、その名前のシンボルがOBARRAYになければ`nil'を返す。
     したがって、`intern-soft'を用いて、指定した名前のシンボルが
     インターンされているかどうか調べられる。
     OBARRAYを省略すると、グローバル変数`obarray'の値を使う。

          (intern-soft "frazzle")        ; そのようなシンボルは存在しない
               => nil
          (make-symbol "frazzle")        ; インターンしないものを作る
               => frazzle
          (intern-soft "frazzle")        ; そのようなものはみつからない
               => nil
          (setq sym (intern "frazzle"))  ; インターンしたものを作る
               => frazzle
          (intern-soft "frazzle")        ; そのようなものがみつかった！
               => frazzle
          (eq sym 'frazzle)              ; しかも、それらは同一
               => t

 -- Variable: obarray
     この変数は、`intern'や`read'が使う標準のオブジェクト配列。

 -- Function: mapatoms function &optional obarray
     この関数は、オブジェクト配列OBARRAYの各シンボルについて、
     1回ずつFUNCTIONを呼び出す。 そして、`nil'を返す。
     OBARRAYを省略すると、通常のシンボル向けの標準のオブジェクト配列である
     `obarray'の値をデフォルトにする。

          (setq count 0)
               => 0
          (defun count-syms (s)
            (setq count (1+ count)))
               => count-syms
          (mapatoms 'count-syms)
               => nil
          count
               => 1871

     `mapatoms'を使った別の例については、 *note Accessing
     Documentation::の`documentation'を参照。

 -- Function: unintern symbol &optional obarray
     この関数は、オブジェクト配列OBARRAYからSYMBOLを削除する。
     `symbol'が実際にはオブジェクト配列内になければ、
     `unintern'はなにもしない。
     OBARRAYが`nil'であると、現在のオブジェクト配列を使う。

     SYMBOLのシンボルのかわりに文字列を指定すると、
     それはシンボルの名前を表す。
     そして、`unintern'はその名前のシンボルを（あれば）オブジェクト配列から
     削除する。 そのようなシンボルがなければ、`unintern'はなにもしない。

     `unintern'は、シンボルを削除したときには`t'を返す。
     さもなければ`nil'を返す。


File: elisp-ja,  Node: Property Lists,  Prev: Creating Symbols,  Up: Symbols

7.4 属性リスト
===================

"属性リスト"（property list、略して"plist"）とは、
シンボルの属性リストセルに格納された対になった要素から成るリストです。
各対は、属性名（通常、シンボル）を属性、すなわち、属性値に対応付けます。
属性リストは、一般に、シンボルに関する情報を記録します。
変数としての説明文字列、定義されているファイルの名前、
言語理解システムにおいては（語を表す）シンボルの文法クラスなどです。

   文字列内やバッファ内の文字位置も属性リストを持てます。 *Note Text
Properties::。

属性リスト内の属性名と属性値は、任意のLispオブジェクトでかまいませんが、
普通、属性名はシンボルです。
属性リスト関数は、`eq'を使って属性名を比較します。
コンパイラをロードした際のシンボル`progn'の属性リストをつぎに示します。

     (lisp-indent-function 0 byte-compile byte-compile-progn)

ここで、`lisp-indent-function'や`byte-compile'は属性名であり、
他の2つの要素は対応する属性値です。

* Menu:

* Plists and Alists::           Comparison of the advantages of property
                                  lists and association lists.
* Symbol Plists::               Functions to access symbols' property lists.
* Other Plists::                Accessing property lists stored elsewhere.


File: elisp-ja,  Node: Plists and Alists,  Next: Symbol Plists,  Up: Property Lists

7.4.1 属性リストと連想リスト
---------------------------------------

連想リスト（*note Association Lists::）は、
属性リストに非常によく似ています。
連想リストと異なり、属性名は一意である必要があるので、
属性リスト内での対の出現順序は関係ありません。

   さまざまなLisp関数やLisp変数に情報を付加するには、
属性リストは連想リストより優れています。
読者のプログラムで1つの連想リストにすべての連想を入れておいたとすると、
1つの連想を探すたびに、リスト全体を探索する必要があります。
これには時間がかかります。
一方、同じ情報を関数名や変数自身の属性リストに保持しておけば、
各探索では1つの属性リストを走査するだけでよく、
属性リストは、普通、短いものです。
このため、変数の説明文字列を`variable-documentation'という名前の
属性に記録しているのです。 同様に、バイトコンパイラも、
特別な処理が必要な関数を属性を使って記録しています。

   しかしながら、連想リストにもそれ独自の利点があります。
読者のアプリケーションに依存しますが、
属性を更新するより、連想リストの先頭に連想を追加するほうが速いです。
あるシンボルのすべての属性は同一の属性リストに格納してあるので、
1つの属性名を異なる目的に使うと衝突します。
（この理由から、プログラムで普通に使う
変数名や関数名の接頭辞で始まる属性名を選ぶなどして、
一意な属性名を選ぶのがよい。）
連想リストは、リストの先頭に要素を追加し、先頭から要素を削除するので、
スタックのように使えます。 属性リストでは、これは不可能です。


File: elisp-ja,  Node: Symbol Plists,  Next: Other Plists,  Prev: Plists and Alists,  Up: Property Lists

7.4.2 シンボル向け属性リスト関数
---------------------------------------------

 -- Function: symbol-plist symbol
     この関数はSYMBOLの属性リストを返す。

 -- Function: setplist symbol plist
     この関数は、SYMBOLの属性リストをPLISTとする。
     通常、PLISTは正しい形の属性リストであるべきだが強要されない。

          (setplist 'foo '(a 1 b (2 3) c nil))
               => (a 1 b (2 3) c nil)
          (symbol-plist 'foo)
               => (a 1 b (2 3) c nil)

     普通の使い方を意図していない特別なオブジェクト配列内のシンボルに対しては、
     属性リストセルの非標準な使い方にも意味があろう。
     実際、略語機構（*note Abbrevs::）ではそのようにしている。

 -- Function: get symbol property
     この関数は、SYMBOLの属性リストから
     PROPERTYという名前の属性の値を探す。
     そのような属性がなければ、`nil'を返す。
     つまり、`nil'という値と属性の欠如を区別できない。

     名前PROPERTYは既存の属性名と`eq'で比較するため、
     どんなオブジェクトでも正当な属性である。

     例については、`put'を参照。

 -- Function: put symbol property value
     この関数は、SYMBOLの属性リストにおいて、
     属性名PROPERTYの古い属性値をVALUEで置き換える。
     関数`put'はVALUEを返す。

          (put 'fly 'verb 'transitive)
               =>'transitive
          (put 'fly 'noun '(a buzzing little bug))
               => (a buzzing little bug)
          (get 'fly 'verb)
               => transitive
          (symbol-plist 'fly)
               => (verb transitive noun (a buzzing little bug))


File: elisp-ja,  Node: Other Plists,  Prev: Symbol Plists,  Up: Property Lists

7.4.3 シンボルの外部の属性リスト
---------------------------------------------

シンボル以外の場所に保存した属性リストの操作に便利な2つの関数があります。

 -- Function: plist-get plist property
     これは、属性リストPLISTに保存されている属性PROPERTYの値を返す。
     たとえば、つぎのとおり。

          (plist-get '(foo 4) 'foo)
               => 4

 -- Function: plist-put plist property value
     これは、属性リストPLISTに、 PROPERTYの値としてVALUEを格納する。
     これはPLISTを破壊的に変更するか、あるいは、
     古いものを変更せずに新たなリスト構造を構築する。
     関数は変更した属性リストを返すので、
     PLISTを保持していたところへ保存し直せる。 たとえば、つぎのとおり。

          (setq my-plist '(bar t foo 4))
               => (bar t foo 4)
          (setq my-plist (plist-put my-plist 'foo 69))
               => (bar t foo 69)
          (setq my-plist (plist-put my-plist 'quux '(a)))
               => (bar t foo 69 quux (a))

   つぎのようにして、`plist-put'を用いて`put'を定義できます。

     (defun put (symbol prop value)
       (setplist symbol
                 (plist-put (symbol-plist symbol) prop value)))



File: elisp-ja,  Node: Evaluation,  Next: Control Structures,  Prev: Symbols,  Up: Top

8 評価
********

Emacs Lispにおける式の"評価"（evaluation）は、
"Lispインタープリタ"（Lisp interpreter）が行います。
これは、入力としてLispオブジェクトを受け取り、
"式としての値"を計算するプログラムです。
計算方法は、本章で述べる規則に従ってオブジェクトのデータ型に依存します。
インタープリタは、読者のプログラムのある部分を評価するために
自動的に動作しますが、Lisp基本関数`eval'を介して
インタープリタを明示的に呼ぶ出すこともできます。

* Menu:

* Intro Eval::  Evaluation in the scheme of things.
* Forms::       How various sorts of objects are evaluated.
* Quoting::     Avoiding evaluation (to put constants in the program).
* Eval::        How to invoke the Lisp interpreter explicitly.


File: elisp-ja,  Node: Intro Eval,  Next: Forms,  Up: Evaluation

8.1 評価とは
================

Lispインタープリタ、つまり、エバリュエータは、
与えられた式の値を計算するプログラムです。
Lispで書いた関数を呼び出すと、エバリュエータは、その関数本体内の
式を評価することで関数の値を計算します。
したがって、どんなLispプログラムの実行でも、
Lispインタープリタを実行することを意味します。

   エバリュエータによるオブジェクトの扱い方は、
主にオブジェクトのデータ型に依存します。

   評価することを意図したLispオブジェクトを
"式"（expression）とか"フォーム"（form）と呼びます。
式はデータオブジェクトであり単なるテキストではないという事実は、
Lisp様言語と典型的なプログラム言語との基本的な違いの1つです。
どんなオブジェクトでも評価できますが、実用上は、
数、シンボル、リスト、文字列を評価することが多いのです。

   Lisp式を読み取りその式を評価することはとても一般的なことですが、
読み取りと評価は別々の動作であり、それぞれを別々に実行することもできます。
読み取り自体では、なにも評価しません。
Lispオブジェクトの表示表現をオブジェクトそのものに変換します。
このオブジェクトを評価すべきフォームとするか、
まったく別の目的に使うかは、`read'の呼び出し側で決まります。

   評価とコマンドキーの解釈を混同しないでください。
エディタコマンドループは、有効なキーマップを用いて
キーボード入力をコマンド（対話的に呼び出し可能な関数）に変換し、
`call-interactively'を使ってコマンドを起動します。
コマンドがLispで書いてあれば、
コマンド自体の実行には評価が関わってきますが、
そのことは、コマンドキーの解釈自体には含まれていません。

   評価は再帰的な処理です。 つまり、フォームの評価では、
`eval'を呼び出してそのフォームの一部分を評価することもあります。
たとえば、関数呼び出しの評価においては、まず、
関数呼び出しの各引数を評価してから、関数本体の各フォームを評価します。
`(car x)'の評価を考えてみましょう。
まず最初に`x'を再帰的に評価する必要があります。
その値を関数`car'の引数として渡せるようにするのです。

   関数呼び出しの評価においては、最終的に指定した関数を呼び出します。
*Note Functions::。
関数の実行そのものも、関数定義を評価する場合もあります。
あるいは、関数はC言語で実装されたLisp基本関数かもしれませんし、
バイトコード関数かもしれません（*note Byte Compilation::）。

   フォームの評価は、"環境"（environment）と呼ばれる文脈において
行われます。 環境とは、すべてのLisp変数の現在値と束縛です (1)。
フォームが新たな束縛を作らずに変数を参照する場合には、
現在の環境におけるその変数の束縛の値を使います。 *Note Variables::。

   フォームを評価すると、変数（*note Local Variables::）を束縛して、
再帰的評価のための新たな環境を作ることがあります。
これらの環境は一時的なもので、そのフォームの評価を完了すると
消えてしまいます。 フォームは恒久的な変更を行ってもかまいません。
このような変更を"副作用"（side effects）と呼びます。
副作用を持つフォームの例は、`(setq foo 1)'です。

   フォームの各種類ごとの評価の意味の詳細は、 以下で説明します（*note
Forms::）。

   ---------- Footnotes ----------

   (1) 『環境』のこの定義は、プログラムの結果に影響する
すべてのデータを含むことは意図していない。


File: elisp-ja,  Node: Forms,  Next: Quoting,  Prev: Intro Eval,  Up: Evaluation

8.2 フォームの種類
=========================

評価することを意図したLispオブジェクトを"フォーム"（form）と呼びます。
Emacsがどのようにフォームを評価するかは、そのデータ型に依存します。
Emacsには、評価方法が異なる3種類のフォームがあります。
シンボル、リスト、および、『その他すべての型』です。
本節では、3種類すべてについて1つ1つ説明します。
まず、自己評価型フォームである『その他すべての型』から説明します。

* Menu:

* Self-Evaluating Forms::   Forms that evaluate to themselves.
* Symbol Forms::            Symbols evaluate as variables.
* Classifying Lists::       How to distinguish various sorts of list forms.
* Function Indirection::    When a symbol appears as the car of a list,
			      we find the real function via the symbol.
* Function Forms::          Forms that call functions.
* Macro Forms::             Forms that call macros.
* Special Forms::           ``Special forms'' are idiosyncratic primitives,
                              most of them extremely important.
* Autoloading::             Functions set up to load files
                              containing their real definitions.


File: elisp-ja,  Node: Self-Evaluating Forms,  Next: Symbol Forms,  Up: Forms

8.2.1 自己評価型フォーム
---------------------------------

"自己評価型フォーム"（self-evaluating form）とは、
リストでもシンボルでもない任意のフォームのことです。
自己評価型フォームはそれ自身に評価され、
評価結果は評価されるオブジェクトと同じものです。
つまり、数25は25と評価され、
文字列`"foo"'は文字列`"foo"'と評価されます。
同様に、ベクトルを評価してもベクトルの個々の要素を評価することはありません。
その内容をまったく変更することなく、同じベクトルを返します。

     '123               ; 評価していない数
          => 123
     123                ; 普通どおり評価。結果は同じ
          => 123
     (eval '123)        ; 『手で』評価。結果は同じ
          => 123
     (eval (eval '123)) ; 2回評価してもなにも変わらない
          => 123

   Lispコードにおいては、数、文字、文字列、さらにベクトルでさえも、
それらが自己評価型である事実を利用して書くのが普通です。
しかし、入力構文を持たない型については、このようにしません。
というのは、それらをテキストとして書く方法がないからです。
そのような型を含むLisp式を構成するには、Lispプログラムを使います。

     ;; バッファオブジェクトを含む式を作る
     (setq print-exp (list 'print (current-buffer)))
          => (print #<buffer eval.texi>)
     ;; それを評価する
     (eval print-exp)
          -| #<buffer eval.texi>
          => #<buffer eval.texi>


File: elisp-ja,  Node: Symbol Forms,  Next: Classifying Lists,  Prev: Self-Evaluating Forms,  Up: Forms

8.2.2 シンボルフォーム
------------------------------

シンボルを評価するときには、シンボルを変数として扱います。
その結果は、値があれば、変数の値です。
（値セルが空であり）値がなければ、エラーを通知します。
変数の使い方について詳しくは、*Note Variables::。

   つぎの例では、`setq'を使ってシンボルの値を設定します。
そのあとでシンボルを評価すると、`setq'で保存した値を取り出せます。

     (setq a 123)
          => 123
     (eval 'a)
          => 123
     a
          => 123

   シンボル`nil'と`t'は特別に扱い、 `nil'の値はつねに`nil'であり、
`t'の値はつねに`t'です。
これらに別の値を設定したり、別の値を束縛することはできません。
したがって、`eval'はこれらを他のシンボルと同様に扱いますが、
これら2つのシンボルは自己評価型フォームのようにふるまいます。
`:'で始まる名前のシンボルも同じ意味で自己評価型であり、
同様に、その値を変更できません。 *Note Constant Variables::。


File: elisp-ja,  Node: Classifying Lists,  Next: Function Indirection,  Prev: Symbol Forms,  Up: Forms

8.2.3 リストフォームの分類
------------------------------------

フォームが空ではないリストならば、その最初の要素に依存して、
関数呼び出し、マクロ呼び出し、スペシャルフォームのいずれかです。
これらの3種類のフォームは、以下に説明するように、異なる方法で評価されます。
リストの残りの要素は、関数、マクロ、スペシャルフォームの
"引数"（arguments）になります。

   空ではないリストを評価する最初の手順は、
その先頭要素を調べることです。
この要素は、それだけで、空ではないリストのフォームの種類を決定し、
リストの残りをどのように処理するかを決定します。
SchemeなどのLispの一部の方言と違って、先頭要素は評価_しません_。


File: elisp-ja,  Node: Function Indirection,  Next: Function Forms,  Prev: Classifying Lists,  Up: Forms

8.2.4 シンボルの関数間接
---------------------------------

リストの先頭要素がシンボルであると、
評価処理ではシンボルの関数セルを調べ、
もとのシンボルのかわりにその内容を使います。
その内容が別のシンボルであると、 "シンボルの関数間接"（symbol function
indirection）と呼ばれる
この処理をシンボルでないものを得るまで繰り返します。
シンボルの関数セルに格納された関数名としてのシンボルの使い方について
詳しくは、*Note Function Names::。

   この処理の結果、無限ループになる場合もあります。
つまり、シンボルの関数セルが同じシンボルを指している場合です。
あるいは、シンボルの関数セルが空の場合もありえます。
その場合、サブルーティン`symbol-function'は、
エラー`void-function'を通知します。
いずれの場合でもなければ、最終的にはシンボルでないものを取得し、
それは関数などの適切なオブジェクトであるはずです。

   より正確にいえば、Lisp関数（ラムダ式）、バイトコード関数、
基本関数、Lispマクロ、スペシャルフォーム、自動ロードオブジェクトの
いずれかを取得しているはずです。
これらの各種類ごとに、以下の1つ1つの節で説明します。
オブジェクトがこれらのいずれの型でもない場合には、
エラー`invalid-function'を通知します。

   つぎの例は、シンボルの関数間接の処理を図示したものです。
`fset'を使ってシンボルの関数セルに設定し、
`symbol-function'を使って関数セルの内容を取り出します （*note Function
Cells::）。 具体的には、シンボル`car'を`first'の関数セルに格納し、
シンボル`first'を`erste'の関数セルに格納します。

     ;; このような関数セルのリンクを作る
     ;;   -------------       -----        -------        -------
     ;;  | #<subr car> | <-- | car |  <-- | first |  <-- | erste |
     ;;   -------------       -----        -------        -------

     (symbol-function 'car)
          => #<subr car>
     (fset 'first 'car)
          => car
     (fset 'erste 'first)
          => first
     (erste '(1 2 3))   ; `erste'が指す関数を呼び出す
          => 1

   一方、つぎの例では、シンボルの関数間接を使わずに関数を呼び出します。
というのは、先頭引数はLispの無名関数であって、
シンボルではないからです。

     ((lambda (arg) (erste arg))
      '(1 2 3))
          => 1

関数を実行することは、その本体を評価することです。
この過程では、`erste'を呼び出すときにシンボルの関数間接が関わります。

   組み込み関数`indirect-function'は、
明示的にシンボルの関数間接を行う簡単な方法です。

 -- Function: indirect-function function
     この関数は、関数としてのFUNCTIONの意味を返す。
     FUNCTIONがシンボルであればFUNCTIONの関数定義を探し、
     その値から再度繰り返す。
     FUNCTIONがシンボルでなければFUNCTIONそのものを返す。

     Lispで`indirect-function'を定義するとつぎのようになる。

          (defun indirect-function (function)
            (if (symbolp function)
                (indirect-function (symbol-function function))
              function))


File: elisp-ja,  Node: Function Forms,  Next: Macro Forms,  Prev: Function Indirection,  Up: Forms

8.2.5 関数フォームの評価
---------------------------------

評価すべきリストの先頭要素が、Lisp関数オブジェクト、
バイトコードオブジェクト、基本関数オブジェクトの場合、
そのリストは"関数呼び出し"（function call）です。
たとえば、つぎは、関数`+'の呼び出しです。

     (+ 1 x)

   関数呼び出しを評価する最初の手順は、
リストの残りの要素を左から右へ順に評価することです。
その結果は実引数の値になり、1つの値がリストの1つの要素に対応します。
つぎの手順は、引数のリストで関数を呼び出すことで、
実質的には、関数`apply'（*note Calling Functions::）を使います。
関数がLispで書いてあれば、関数の引数変数を束縛するために引数を使います
（*note Lambda Expressions::）。
そして、関数本体のフォーム群を順番に評価し、
本体の最後のフォームの値が関数呼び出しの値になります。


File: elisp-ja,  Node: Macro Forms,  Next: Special Forms,  Prev: Function Forms,  Up: Forms

8.2.6 Lispマクロの評価
----------------------------

評価すべきリストの先頭要素がマクロオブジェクトの場合、
そのリストは"マクロ呼び出し"（macro call）です。
マクロ呼び出しを評価するときは、リストの残りの要素を評価_しません_。
そのかわりに、要素そのものをマクロの引数として使います。 マクロ定義は、
マクロの"展開形"（expansion）と呼ばれる置換フォームを計算し、
もとのフォームのかわりに展開形を評価します。
展開形は、どんな種類のフォームでもかまいません。
自己評価型の定数、シンボル、あるいは、リストです。
展開形そのものがマクロ呼び出しであると、
マクロ呼び出し以外のフォームを得られるまで、
展開形を得る処理を繰り返します。

   通常のマクロ呼び出しの評価は、展開形を評価することで完了します。
しかし、マクロの展開形を必ずしもただちに評価する必要はなく、
まったく評価しなくてもかまいません。
というのは、別のプログラムもマクロ呼び出しを展開し、
それらは展開形を評価するものもあれば、評価しないものもあるからです。

   普通、引数の式は、マクロ展開の計算過程では評価せず、
展開形の一部として現れます。
そして、展開形を評価するときに引数が計算されます。

   たとえば、つぎのようなマクロ定義があったとします。

     (defmacro cadr (x)
       (list 'car (list 'cdr x)))

`(cadr (assq 'handler list))'のような式はマクロ呼び出しであり、
つぎのような展開形になります。

     (car (cdr (assq 'handler list)))

引数`(assq 'handler list)'が展開形に現れていることに 注意してください。

   Emacs Lispのマクロに関する完全な記述は、*Note Macros::。


File: elisp-ja,  Node: Special Forms,  Next: Autoloading,  Prev: Macro Forms,  Up: Forms

8.2.7 スペシャルフォーム
---------------------------------

"スペシャルフォーム"（special form）は、
その引数を評価しないように特別な印が付いた基本関数です。
ほとんどのスペシャルフォームは、制御構造を定義したり、
変数を束縛したりします。 これらはどれも関数ではできないことです。

   各スペシャルフォームには、どの引数は評価し、
どの引数は評価せずに使うかといったそれぞれに独自の規則があります。
特定の引数を評価するかどうかは、他の引数の評価結果に依存することもあります。

   以下に、Emacs Lispのすべてのスペシャルフォームをアルファベット順に、
参照箇所とともにあげておきます。

`and'
     *note Combining Conditions::

`catch'
     *note Catch and Throw::

`cond'
     *note Conditionals::

`condition-case'
     *note Handling Errors::

`defconst'
     *note Defining Variables::

`defmacro'
     *note Defining Macros::

`defun'
     *note Defining Functions::

`defvar'
     *note Defining Variables::

`function'
     *note Anonymous Functions::

`if'
     *note Conditionals::

`interactive'
     *note Interactive Call::

`let'
`let*'
     *note Local Variables::

`or'
     *note Combining Conditions::

`prog1'
`prog2'
`progn'
     *note Sequencing::

`quote'
     *note Quoting::

`save-current-buffer'
     *note Current Buffer::

`save-excursion'
     *note Excursions::

`save-restriction'
     *note Narrowing::

`save-window-excursion'
     *note Window Configurations::

`setq'
     *note Setting Variables::

`setq-default'
     *note Creating Buffer-Local::

`track-mouse'
     *note Mouse Tracking::

`unwind-protect'
     *note Nonlocal Exits::

`while'
     *note Iteration::

`with-output-to-temp-buffer'
     *note Temporary Displays::

     Common Lispに関した注意：` ' GNU Emacs LispとCommon
     Lispのスペシャルフォームを比較してみる。
     `setq'、`if'、および、`catch'は、Emacs Lispでも Common
     Lispでもスペシャルフォームである。 `defun'は、Emacs
     Lispではスペシャルフォームであるが、 Common Lispではマクロである。
     `save-excursion'は、Emacs Lispではスペシャルフォームであるが、
     Common Lispには存在しない。 `throw'は、Common
     Lispでは（複数の値を返す必要があるため）
     スペシャルフォームであるが、 Emacs
     Lispでは（複数の値はないため）関数である。


File: elisp-ja,  Node: Autoloading,  Prev: Special Forms,  Up: Forms

8.2.8 自動ロード
---------------------

"自動ロード"（autoload）は、
関数やマクロの関数定義をEmacsにまだロードしていなくても、
関数やマクロを呼び出せるようにする機構です。
定義を収めたファイルを指定します。
シンボルの関数定義に自動ロードオブジェクトあるとき、
そのシンボルを関数として呼び出すと、指定したファイルを自動的にロードします。
そうしてから、当該ファイルからロードした実際の定義を呼び出します。
*Note Autoload::。


File: elisp-ja,  Node: Quoting,  Next: Eval,  Prev: Forms,  Up: Evaluation

8.3 クォート
================

スペシャルフォーム`quote'は、単一の引数を
評価せずに書かれたとおりに返します。
これは、自己評価型オブジェクトではない
定数シンボルや定数リストをプログラム内に書く手段です。
（数、文字列、ベクトルなどの自己評価型オブジェクトをクォートする必要はない。）

 -- Special Form: quote object
     このフォームはOBJECTを評価せずに返す。

   `quote'はプログラム内で頻繁に使うので、
Lispには便利な入力構文が用意してあります。
アポストロフ文字（`''）に続けた（入力構文で書いた）Lispオブジェクトは、
先頭要素が`quote'であり2番目の要素がそのオブジェクトである
リストに展開されます。 したがって、入力構文`'x'は、`(quote
x)'の省略形です。

   `quote'を使った式の例をいくつかあげておきます。

     (quote (+ 1 2))
          => (+ 1 2)
     (quote foo)
          => foo
     'foo
          => foo
     ''foo
          => (quote foo)
     '(quote foo)
          => (quote foo)
     ['foo]
          => [(quote foo)]

   他のクォートの書き方には、`function'（*note Anonymous Functions::）が
あります。
これは、Lispで書いた無名ラムダ式をコンパイルするようにします。
また、``'（*note Backquote::）は、
リストの一部分をクォートし、他の部分は計算結果で置き換えるために使います。


File: elisp-ja,  Node: Eval,  Prev: Quoting,  Up: Evaluation

8.4 評価（eval）
====================

ほとんどの場合、実行中のプログラムにフォームが現れると
フォームは自動的に評価されます。
稀なことですが、実行時に計算したフォームを評価するように
コードを書く必要があるかもしれません。
たとえば、編集中のテキストからフォームを読み取ったり、
属性リストからフォームを取り出した場合などです。
このような場合には、関数`eval'を使います。

   本節で説明した関数や変数は、フォームを評価したり、
評価処理に制限を課したり、最後の戻り値を記録したりします。
ファイルをロードしても評価が行われます（*note Loading::）。

   *注意：*` ' データ構造の中に関数を格納して
それを`funcall'や`apply'で呼び出すほうが、
データ構造の中に式を格納してそれを評価するより、
一般に明確で柔軟性があります。
関数を使うとそれらに引数として情報を渡すことができます。

 -- Function: eval form
     この関数は、式を評価する基本的な関数である。
     FORMを現在の環境において評価し、その結果を返す。
     評価処理はオブジェクトの型に依存する（*note Forms::）。

     `eval'は関数なので、`eval'の呼び出しに現れる
     引数の式は2度評価される。 `eval'を呼び出すまえの準備で1回、
     関数`eval'自身による評価でもう1回である。 例を示す。

          (setq foo 'bar)
               => bar
          (setq bar 'baz)
               => baz
          ;; `eval'は引数`foo'を受け取る
          (eval 'foo)
               => bar
          ;; `eval'は引数`bar'を受け取る。それは`foo'の値
          (eval foo)
               => baz

     `eval'の呼び出しの深さは、
     `max-lisp-eval-depth'（下記参照）に制限される。

 -- コマンド: eval-region start end &optional stream read-function
     この関数は、カレントバッファのSTARTとENDで指定した
     リージョン内のフォーム群を評価する。
     リージョンからフォームを読み取り、
     それらに対して`eval'を呼び出すことを
     リージョンの末尾に達するまで、あるいは、処理されないエラーが通知されるまで
     繰り返す。

     STREAMが`nil'以外ならば、
     リージョン内の式を評価した結果の値はSTREAMを使って表示する。 *note
     Output Streams::。

     READ-FUNCTIONが`nil'以外にならば、 それは関数である必要があり、
     `read'のかわりに式を1つ1つ読むために使われる。
     この関数は、入力用のストリームである1つの引数で呼び出される。
     変数`load-read-function'（*note How Programs Do Loading::）を
     使ってこの関数を指定することもできるが、
     引数READ-FUNCTIONを用いたほうが堅牢である。

     `eval-region'はつねに`nil'を返す。

 -- コマンド: eval-current-buffer &optional stream
     これは`eval-region'と同様だが、バッファ全体に作用する。

 -- Variable: max-lisp-eval-depth
     この変数は、 （エラーメッセージ`"Lisp nesting exceeds
     max-lisp-eval-depth"'で）
     エラーを通知までの`eval'、`apply'、`funcall'の呼び出しの
     最大の深さを制限する。
     この制限、および、これを超えたときのエラーは、
     不正に定義された関数によってLispが無限に再帰することを防止する
     1つの方法である。 

     深さ制限は、Lispコードによる明示的な呼び出しに加えて、
     Lisp式で書かれた関数の呼び出しや関数呼び出しの引数や関数本体のフォームの
     再帰的な評価などの内部的な`eval'、`apply'、`funcall'の
     呼び出しも数える。

     この変数のデフォルト値は300。
     これに100未満の値を設定すると、指定した値に達するとLispは100に設定し直す。
     Lispデバッガに入ったとき、
     制限に近い場合にはデバッガ自身が実行できることを保証するために値を増やす。

     `max-specpdl-size'は、入れ子の深さを制限する別の方法である。 *note
     Local Variables::。

 -- Variable: values
     この変数の値は、
     バッファから式を読み取り、評価し、結果を表示するEmacsの標準コマンドが行った
     すべての式の戻り値のリストである。
     リストの順序は、最新のものが最初にくる。

          (setq x 1)
               => 1
          (list 'A (1+ 2) auto-save-default)
               => (A 3 t)
          values
               => ((A 3 t) 1 ...)

     この変数は、最近評価したフォームの値を参照するのに便利である。
     `values'そのものの値の表示は非常に長くなる可能性があるので、
     その値を表示するのはよくない。
     そのかわりに、つぎのようにして特定の要素を調べる。

          ;; もっとも最近の評価結果を参照する
          (nth 0 values)
               => (A 3 t)
          ;; こうすると、新たな要素が追加され、
          ;;   すべての要素が1つうしろへさがる
          (nth 1 values)
               => (A 3 t)
          ;; この例を実行するまえの最新のもののつぎの要素を取得する
          (nth 3 values)
               => 1


File: elisp-ja,  Node: Control Structures,  Next: Variables,  Prev: Evaluation,  Up: Top

9 制御構造
**************

Lispプログラムは、式、すなわち、"フォーム"（forms、*note Forms::）から
成ります。 フォームを"制御構造"（control structures）で囲むことで、
フォームの実行順序を制御します。 制御構造はスペシャルフォームであり、
その内側にあるフォームの実行をいつ行うか、行わないか、
何回行うかを制御します。

   もっとも単純な実行順序は逐次実行です。 最初のフォームAを実行し、
それからつぎのフォームBを実行し、といった具合です。
関数の本体やLispコードのファイルのトップレベルに複数のフォームを順に書くと、
このようになります。 つまり、書かれている順番にフォームを実行します。
これを"テキスト上の順序"（textual order）と呼びます。
たとえば、関数本体が2つのフォームAとBから成る場合、
関数を評価すると、まずAを評価し、つぎにBを評価して、
関数の値はBの値になります。

   明示的な制御構造により、逐次実行以外の実行順序が可能になります。

   Emacs Lispには数種類の制御構造があり、
逐次実行の変形、条件付き実行、繰り返し実行、
（制御された）ジャンプなどです。 これらすべては、以下に説明します。
組み込みの制御構造はスペシャルフォームです。
というのは、それらのサブフォームは必ずしも評価しませんし、
逐次評価するわけでもないからです。
マクロを使えば、独自の制御構造の構文を定義できます（*note Macros::）。

* Menu:

* Sequencing::             Evaluation in textual order.
* Conditionals::           `if', `cond', `when', `unless'.
* Combining Conditions::   `and', `or', `not'.
* Iteration::              `while' loops.
* Nonlocal Exits::         Jumping out of a sequence.


File: elisp-ja,  Node: Sequencing,  Next: Conditionals,  Up: Control Structures

9.1 逐次実行
================

現れる順番にフォームを評価することは、
1つのフォームから別のフォームへ制御を移すもっとも一般的な方法です。
関数本体などのある種の文脈では、自動的にこのようになります。
それ以外では、これを行う制御構造の構文を使う必要があります。
`progn'がその制御構造で、Lispのもっとも単純な制御構造です。

   スペシャルフォーム`progn'はつぎのような形です。

     (progn A B C ...)

これは、フォーム、A、B、C、…をこの順に評価します。
これらのフォームを`progn'フォームの本体と呼びます。
本体の最後のフォームの値が、`progn'全体の値になります。

   初期のころのLispでは、`progn'は、
2つ以上のフォームを逐次実行しそれらの最後の値を使う唯一の方法でした。
しかし、プログラマは、（当時は）1つのフォームしか許されていない
関数の本体では、 `progn'を使う必要がしばしばあることに気づきました。
そのため、関数本体を『暗黙の`progn'』にしたのです。
つまり、実際の`progn'の本体のように、
複数のフォームを許すようにしたのです。
多くの他の制御構造も、同様に、暗黙の`progn'です。
その結果、`progn'は、かつてほどは多用されません。
現在では、`unwind-protect'、`and'、`or'の内側や、
`if'のTHEN部分で必要とされるのがほとんどです。

 -- Special Form: progn forms...
     このスペシャルフォームは、FORMSのフォームすべてを
     テキスト上の順に評価し、最後のフォームの結果を返す。

          (progn (print "The first form")
                 (print "The second form")
                 (print "The third form"))
               -| "The first form"
               -| "The second form"
               -| "The third form"
          => "The third form"

   他の2つの制御構造も同様にフォームを逐次評価しますが、
返す値が異なります。

 -- Special Form: prog1 form1 forms...
     このスペシャルフォームは、FORM1、FORMSのフォームすべてを
     テキスト上の順に評価し、FORM1の結果を返す。

          (prog1 (print "The first form")
                 (print "The second form")
                 (print "The third form"))
               -| "The first form"
               -| "The second form"
               -| "The third form"
          => "The first form"

     変数のリストから先頭要素を取り除き、取り除いた要素を返すにはつぎのように書く。

          (prog1 (car x) (setq x (cdr x)))

 -- Special Form: prog2 form1 form2 forms...
     このスペシャルフォームは、FORM1、FORM2、FORMSの
     フォームすべてをテキスト上の順に評価し、FORM2の結果を返す。

          (prog2 (print "The first form")
                 (print "The second form")
                 (print "The third form"))
               -| "The first form"
               -| "The second form"
               -| "The third form"
          => "The second form"


File: elisp-ja,  Node: Conditionals,  Next: Combining Conditions,  Prev: Sequencing,  Up: Control Structures

9.2 条件付き実行
======================

条件付き制御構造は、選択肢を選びます。 Emacs
Lispには、4つの条件付きフォームがあります。
他の言語のものとほとんど同じ`if'、 `if'の変形である`when'や`unless'、
一般化したcase文である`cond'です。

 -- Special Form: if condition then-form else-forms...
     `if'は、CONDITIONをもとにして、 THEN-FORMかELSE-FORMSを選ぶ。
     CONDITIONが`nil'以外に評価されると、
     THEN-FORMを評価し、その結果を返す。
     さもなければ、ELSE-FORMSをテキスト上の順に評価し、
     その最後のものの値を返す。
     （`if'のELSE部分は、暗黙の`progn'の例である。 *note
     Sequencing::。）

     CONDITIONが値`nil'であり、かつ、ELSE-FORMSがないと、
     `if'は`nil'を返す。

     `if'がスペシャルフォームであるのは、
     選択しなかった分岐をけっして評価しないからである。
     したがって、つぎの例では、
     `print'はけっして呼ばれないため`true'は表示されない。

          (if nil
              (print 'true)
            'very-false)
          => very-false

 -- Macro: when condition then-forms...
     これは`if'の変形であり、ELSE-FORMSがなく、
     THEN-FORMSは複数のフォームでもよい。 特に、

          (when CONDITION A B C)

     は、つぎとまったく等価である。

          (if CONDITION (progn A B C) nil)

 -- Macro: unless condition forms...
     これはTHEN-FORMがない`if'の変形である。

          (unless CONDITION A B C)

     は、つぎとまったく等価である。

          (if CONDITION nil
             A B C)

 -- Special Form: cond clause...
     `cond'は任意個数の選択肢から1つを選ぶ。
     `cond'の各節CLAUSEはリストである必要がある。
     このリストのCARがCONDITION（条件）である。
     残りの要素は、あれば、BODY-FORMS（本体フォーム）である。
     つまり、各節はつぎのようになる。

          (CONDITION BODY-FORMS...)

     `cond'は、各節のCONDITIONを評価して、 各節をテキスト上の順に試す。
     CONDITIONの値が`nil'以外であれば、 その節は『成功』する。
     そうすると、`cond'はその節のBODY-FORMSを評価し、
     BODY-FORMSの最後の値が`cond'の値となる。 残りの節は無視する。

     CONDITIONの値が`nil'であると、 その節は『失敗』し、
     `cond'はつぎの節へ移りそのCONDITIONを試す。

     各CONDITIONが`nil'に評価されると、
     すべての節が失敗し、`cond'は`nil'を返す。

     節CLAUSEは、つぎの形式でもよい。

          (CONDITION)

     この場合、CONDITIONが`nil'以外であると、
     CONDITIONが`cond'フォームの値になる。

     以下の例には4つの節があり、
     `x'の値が、数、文字列、バッファ、シンボルかどうか調べる。

          (cond ((numberp x) x)
                ((stringp x) x)
                ((bufferp x)
                 (setq temporary-hack x) ; 1つの節に
                 (buffer-name x))        ; 複数個の本体フォーム
                ((symbolp x) (symbol-value x)))

     最後の節を除くそれよりまえの節がどれも成功しないときには、
     最後の節を実行したいことがしばしばある。 これを行うには、`(t
     BODY-FORMS)'のように 最後の節のCONDITIONに`t'を使う。
     フォーム`t'は`t'と評価され、けっして`nil'ではない。
     そのため、`cond'がこの節に達したときには、
     この節が失敗することはない。

     たとえば、つぎのとおり。

          (cond ((eq a 'hack) 'foo)
                (t "default"))
          => "default"

     この式は、`a'の値が`hack'のときには`foo'を返し、
     さもなければ文字列`"default"'を返す`cond'である。

   任意の条件付き構造は、`cond'や`if'で表現できます。
したがって、どちらを使うかは好みの問題です。
たとえば、つぎのとおりです。

     (if A B C)
     ==
     (cond (A B) (t C))


File: elisp-ja,  Node: Combining Conditions,  Next: Iteration,  Prev: Conditionals,  Up: Control Structures

9.3 条件の組み合わせ
============================

本節では、`if'や`cond'とともに用いて複雑な条件を表現するために
しばしば使われる3つの構造を説明します。 `and'や`or'の構造は、
複数の条件付き構造の一種として単独で使うこともできます。

 -- Function: not condition
     この関数は、CONDITIONが偽であるかどうか調べる。
     CONDITIONが`nil'であれば`t'を返し、 さもなければ`nil'を返す。
     関数`not'は`null'と同一であるが、
     空リストかどうか調べる場合には、`null'を使うことを勧める。

 -- Special Form: and conditions...
     スペシャルフォーム`and'は、
     すべてのCONDITIONSが真であるかどうか調べる。
     CONDITIONSを1つ1つ書かれた順に評価して調べる。

     CONDITIONSのどれかが`nil'に評価されると、
     `and'の結果は、残りのCONDITIONSに関係なく、`nil'になる。
     つまり、`and'はただちに完了し、 CONDITIONSの残りを無視する。

     CONDITIONSすべてが`nil'以外であることがわかると、
     それらの最後の値がフォーム`and'の値となる。

     例を示そう。 最初の条件は整数1を返し、これは`nil'ではない。
     同様に、2番目の条件は整数2を返し、`nil'ではない。
     3番目の条件は`nil'なので、残りの条件を評価しない。

          (and (print 1) (print 2) nil (print 3))
               -| 1
               -| 2
          => nil

     `and'を使ったより現実的な例はつぎのとおり。

          (if (and (consp foo) (eq (car foo) 'x))
              (message "foo is a list starting with x"))

     `(consp foo)'が`nil'を返すと`(car foo)'は実行されず、
     そのためエラーを回避することに注意。

     `and'は、`if'や`cond'で表現できる。 たとえば、つぎのとおり。

          (and ARG1 ARG2 ARG3)
          ==
          (if ARG1 (if ARG2 ARG3))
          ==
          (cond (ARG1 (cond (ARG2 ARG3))))

 -- Special Form: or conditions...
     スペシャルフォーム`or'は、
     CONDITIONSの少なくとも1つが真であるかどうか調べる。
     CONDITIONSを1つ1つ書かれた順に評価して調べる。

     CONDITIONSのどれかが`nil'以外に評価されると、
     `or'の結果は`nil'以外になる。 そして、`or'はただちに完了し、
     CONDITIONSの残りを無視する。
     戻り値は、`nil'以外に評価された値である。

     CONDITIONSすべてが`nil'であることがわかると、 `or'は`nil'を返す。

     たとえば、つぎの式は、`x'が0か`nil'であることを調べる。

          (or (eq x nil) (eq x 0))

     `and'構造と同様に、`or'は`cond'で書き表せる。
     たとえば、つぎのとおり。

          (or ARG1 ARG2 ARG3)
          ==
          (cond (ARG1)
                (ARG2)
                (ARG3))

     `or'を`if'で書くこともだいたいできるが、 途中で抜け出せない。

          (if ARG1 ARG1
            (if ARG2 ARG2
              ARG3))

     これは完全には同一ではない。
     というのは、ARG1やARG2を2度評価するからである。 一方、`(or ARG1
     ARG2 ARG3)'は、 どの引数も一度だけ評価する。


File: elisp-ja,  Node: Iteration,  Next: Nonlocal Exits,  Prev: Combining Conditions,  Up: Control Structures

9.4 繰り返し
================

繰り返しとは、プログラムのある部分を何度も実行することです。
たとえば、リストの各要素や0からNの各整数について
1回ずつある計算を行いたい場合です。 Emacs
Lispでこれを行うには、スペシャルフォーム`while'を使います。

 -- Special Form: while condition forms...
     `while'は、まずCONDITIONを評価する。
     結果が`nil'以外であれば、FORMSをテキスト上の順で評価する。
     そして、CONDITIONを評価し直し、その結果が`nil'以外であれば、
     再度FORMSを評価する。
     この処理をCONDITIONが`nil'に評価されるまで繰り返す。

     繰り返し回数に制限はない。 ループは、CONDITIONが`nil'に評価される、
     エラーが発生する、`throw'によりループから抜け出す （*note Nonlocal
     Exits::）のいずれかが起こるまで繰り返される。

     フォーム`while'の値はつねに`nil'である。

          (setq num 0)
               => 0
          (while (< num 4)
            (princ (format "Iteration %d." num))
            (setq num (1+ num)))
               -| Iteration 0.
               -| Iteration 1.
               -| Iteration 2.
               -| Iteration 3.
               => nil

     終了検査のまえに各繰り返しごとに実行したいことがあれば、
     以下のように、それらと終了検査を`progn'でまとめたものを
     `while'の第1引数にする。

          (while (progn
                   (forward-line 1)
                   (not (looking-at "^$"))))

     これは、1行先へ移動し、空行に達するまで、移動を繰り返す。
     この`while'には本体がなく、
     終了検査（かつポイントを実際に動かす）だけであるという点で、
     風変わりである。


File: elisp-ja,  Node: Nonlocal Exits,  Prev: Iteration,  Up: Control Structures

9.5 非ローカル脱出
=========================

"非ローカル脱出"（nonlocal exit）とは、
プログラムのある場所から別の離れた場所へ制御を移すことです。 Emacs
Lispでは、エラーの結果として非ローカル脱出が発生します。
非ローカル脱出は、明示的な制御にも使えます。
非ローカル脱出は、脱出対象の構造で作成したすべての変数束縛を解きます。

* Menu:

* Catch and Throw::     Nonlocal exits for the program's own purposes.
* Examples of Catch::   Showing how such nonlocal exits can be written.
* Errors::              How errors are signaled and handled.
* Cleanups::            Arranging to run a cleanup form if an error happens.


File: elisp-ja,  Node: Catch and Throw,  Next: Examples of Catch,  Up: Nonlocal Exits

9.5.1 明示的な非ローカル脱出：` '`catch'と`throw'
--------------------------------------------------------------

ほとんどの制御構造は、その構造内での制御の流れだけに影響します。
関数`throw'は、通常のプログラム実行のこのような規則の例外です。
つまり、要求に従って非ローカルな脱出を行います。
（ほかにも例外はあるが、それらはエラー処理のためだけである。）
`throw'は`catch'の内側で使い、 その`catch'へ戻ります。

     (defun foo-outer ()
       (catch 'foo
         (foo-inner)))

     (defun foo-inner ()
       ...
       (if x
           (throw 'foo t))
       ...)

フォーム`throw'を実行すると、対応する`catch'へ制御が戻り、
その`catch'はただちに終了します。 `throw'に続くコードは実行されません。
`throw'の第2引数は、`catch'の戻り値として使われます。

   関数`throw'は、その第1引数に基づいて対応する`catch'を探します。
つまり、`catch'の第1引数が
`throw'に指定されたものに`eq'である`catch'を探します。
そのような`catch'が複数個ある場合には、 もっとも内側のものを優先します。
したがって、上の例では、`throw'は`foo'を指定し、
`foo-outer'の`catch'は同じシンボルを指定しているので、
その`catch'を使います
（ただし、これらのあいだには他の一致する`catch'がないとして）。

   `throw'の実行により、
対応する`catch'までのすべてのLispの構造を抜け出します。
これには関数呼び出しも含みます。
`let'や関数呼び出しなどの束縛を作る構造からもこのように抜け出すので、
通常どおり抜け出す場合と同様に束縛を解きます （*note Local
Variables::）。 同様に、`throw'は、`save-excursion'（*note
Excursions::）で 保存したバッファや位置情報、
`save-restriction'で保存したナロイング状態、
`save-window-excursion'（*note Window Configurations::）で保存した
ウィンドウの選択状態も復元します。
さらに、スペシャルフォーム`unwind-protect'で設定した後始末を
このフォームから抜け出すときに実行します（*note Cleanups::）。

   `throw'は、テキスト上で、
ジャンプ先である`catch'の内側に現れる必要はありません。
`throw'は、`catch'内から呼ばれた別の関数からも戻ることもできます。
`throw'の実行が、
時間的に`catch'に入ったあとで、かつ、それから抜けるまえである限り、
`throw'は対応する`catch'を参照できます。 エディタコマンドループ（*note
Recursive Editing::）から抜ける `exit-recursive-edit'などのコマンドで
`throw'を使えるのは、このような理由からです。

     Common Lispに関した注意：` ' Common
     Lispを含むほとんどの他のLispには、
     非逐次的に制御を移す方法がいくつかある。
     たとえば、`return'、`return-from'、`go'。 Emacs
     Lispには`throw'しかない。

 -- Special Form: catch tag body...
     `catch'は、関数`throw'向けに戻り位置を確立する。
     その戻り位置は、TAGによって他の戻り位置と区別される。
     TAGは、`nil'以外ならば任意のLispオブジェクトでよい。
     引数TAGは、戻り位置を確立するまえに、通常どおり評価される。

     戻り位置を確立してから、`catch'は、BODYのフォームを
     テキスト上の順に評価する。
     エラーや非ローカル脱出なしにフォームの実行が普通に終了した場合、
     `catch'は、最後の本体フォームの値を返す。

     BODYの内側で、TAGと同じ値を指定した`throw'が実行されると、
     `catch'はただちに終了する。
     このとき返す値は、`throw'の第2引数に指定されたものである。

 -- Function: throw tag value
     `throw'の目的は、
     `catch'でまえもって確立しておいた戻り位置へ復帰することである。
     引数TAGは、さまざまな既存の戻り位置から選ぶために使う。
     TAGは、`catch'で指定した値と`eq'である必要がある。
     TAGに複数の戻り位置が一致する場合には、もっとも内側のものを使う。

     引数VALUEは、対応する`catch'の戻り値として使う。

     タグTAGである有効な戻り位置がなければ、 `(TAG
     VALUE)'を伴ったエラー`no-catch'を通知する。


File: elisp-ja,  Node: Examples of Catch,  Next: Errors,  Prev: Catch and Throw,  Up: Nonlocal Exits

9.5.2 `catch'と`throw'の例
-----------------------------

`catch'と`throw'の使い方の1つは、 2重のループからの脱出です。
（ほとんどの言語では、これを『go to』で行うであろう。）
ここでは、IとJを0から9に変えながら、 `(foo I J)'を計算します。

     (defun search-foo ()
       (catch 'loop
         (let ((i 0))
           (while (< i 10)
             (let ((j 0))
               (while (< j 10)
                 (if (foo i j)
                     (throw 'loop (list i j)))
                 (setq j (1+ j))))
             (setq i (1+ i))))))

`foo'がある時点で`nil'以外を返すと、
ただちに止まってIとJのリストを返します。 `foo'がつねに`nil'を返すと、
`catch'は通常どおりに戻って、その値は`nil'です。
というのは、`while'の結果は`nil'だからです。

   2つの巧妙な例をあげましょう。
多少異なる2つの戻り位置が同時に存在します。
まず、同じタグ`hack'で2つの戻り位置があります。

     (defun catch2 (tag)
       (catch tag
         (throw 'hack 'yes)))
     => catch2

     (catch 'hack
       (print (catch2 'hack))
       'no)
     -| yes
     => no

どちらの戻り位置も`throw'に一致するタグなので、
内側のもの、つまり、`catch2'で確立したものに戻ります。
したがって、`catch2'は値`yes'で通常どおり戻り、 この値が表示されます。
最後に、外側の`catch'の2番目の本体フォーム、
つまり、`'no'が評価され、外側の`catch'から戻ります。

   今度は、`catch2'に指定する引数を変更してみます。

     (defun catch2 (tag)
       (catch tag
         (throw 'hack 'yes)))
     => catch2

     (catch 'hack
       (print (catch2 'quux))
       'no)
     => yes

ここでも2つの戻り位置がありますが、
今度は外側のものだけがタグ`hack'です。 内側のものはタグ`quux'です。
したがって、`throw'により、外側の`catch'が値`yes'を返します。
関数`print'はけっして呼ばれず、
本体フォーム`'no'もけっして評価されません。


File: elisp-ja,  Node: Errors,  Next: Cleanups,  Prev: Examples of Catch,  Up: Nonlocal Exits

9.5.3 エラー
---------------

Emacs
Lispが、なんらかの理由で評価できないフォームを評価しようとしたときには、
Emacs Lispは"エラー"（error）を"通知"（signals）します。

   エラーが通知されると、Emacsのデフォルトの動作は、
エラーメッセージを表示し、現在のコマンドの実行を終了します。
バッファの末尾で`C-f'を打ったときなどのように、
これはほとんどの場合、適切なことです。

複雑なプログラムでは、単に終了するだけでは満足できないこともあります。
たとえば、プログラムではデータ構造に一時的な変更を加えていたり、
プログラム終了時には削除する必要がある一時的なバッファを作成するでしょう。
そのような場合には、`unwind-protect'を使って、
エラー発生時に評価される"後始末式"（cleanup expressions）を
確立しておきます。 （*note Cleanups::。）
場合によっては、サブルーティンでエラーが発生しても、
プログラムの実行を継続したいこともあるでしょう。
このような場合には、`condition-case'を使って、
エラー状態から制御を回復するための "エラーハンドラ"（error
handlers）を確立しておきます。

   エラー処理を用いてプログラムのある場所から別の場所へ制御を移す、
という誘惑には耐えてください。
そのかわりに`catch'と`throw'を使いましょう。 *Note Catch and Throw::。

* Menu:

* Signaling Errors::      How to report an error.
* Processing of Errors::  What Emacs does when you report an error.
* Handling Errors::       How you can trap errors and continue execution.
* Error Symbols::         How errors are classified for trapping them.


File: elisp-ja,  Node: Signaling Errors,  Next: Processing of Errors,  Up: Errors

9.5.3.1 エラーの通知方法
................................

ほとんどのエラーは、他の目的で呼び出したLisp関数の内部で『自動的』に
通知されます。 整数のCARを計算しようとしたり、
バッファの末尾で1文字進めようとしたりしたときなどです。
関数`error'や関数`signal'で、 明示的にエラーを通知することもできます。

   ユーザーが`C-g'を打ったときに発生する中断は、
エラーとは考えませんが、エラーのように扱います。

 -- Function: error format-string &rest args
     この関数は、FORMAT-STRINGとARGSに `format'（*note String
     Conversion::）を適用して作った
     エラーメッセージを伴ったエラーを通知する。

     `error'の典型的な使い方を以下に示す。

          (error "That is an error -- try something else")
               error--> That is an error -- try something else

          (error "You have committed %d errors" 10)
               error--> You have committed 10 errors

     `error'は、2つの引数、
     エラーシンボル`error'と`format'が返す文字列を含むリスト
     で`signal'を呼び出すことで動作する。

     *警告：*` ' 独自のエラーメッセージをそのまま使いたい場合に、
     単に`(error STRING)'とは書かないこと。
     STRINGに`%'が含まれていると、
     それは書式付け指定と解釈され、予測不能な結果を招く。
     そのかわりに、`(error "%s" STRING)'を使う。

 -- Function: signal error-symbol data
     この関数は、ERROR-SYMBOLという名前のエラーを通知する。
     引数DATAは、エラーの状況に関連したLispオブジェクトのリストである。

     引数ERROR-SYMBOLは、"エラーシンボル"（error symbol）である
     必要がある。 つまり、属性`error-conditions'を持つシンボルであり、
     その属性値は条件名のリストである。
     これにより、Emacsはエラーの異なる種類を分類する。

     DATAのオブジェクトの個数と重要性はERROR-SYMBOLに依存する。
     たとえば、エラー`wrong-type-arg'では、
     リストには2つのオブジェクトがあるはずで、
     予期した型を表す述語とその型に一致しなかったオブジェクトである。
     エラーシンボルの説明は、*note Error Symbols::。

     ERROR-SYMBOLとDATAの両者は、 任意のエラーハンドラで利用できる。
     `condition-case'は、ローカル変数に フォーム`(ERROR-SYMBOL .
     DATA)'のリストを束縛する （*note Handling Errors::）。
     エラーが処理されないと、これらの2つの値はエラーメッセージの表示に使われる。

     関数`signal'はけっして戻らない
     （しかし、Emacsの古い版では戻る場合もある）。

          (signal 'wrong-number-of-arguments '(x y))
               error--> Wrong number of arguments: x, y

          (signal 'no-such-error '("My unknown error condition"))
               error--> peculiar error: "My unknown error condition"

     Common Lispに関した注意：` ' Emacsには、Common
     lispの継続可能なエラーの概念に相当するものはない。


File: elisp-ja,  Node: Processing of Errors,  Next: Handling Errors,  Prev: Signaling Errors,  Up: Errors

9.5.3.2 Emacsのエラー処理方法
.....................................

エラーが通知されると、`signal'は、
エラーに対する有効な"ハンドラ"（handler）を探します。
ハンドラは、Lispプログラムの一部でエラーが発生した場合に
実行されるように指定されたLisp式の列です。
エラーに対して適用可能なハンドラがあると、
そのハンドラが実行され、ハンドラに続いて制御は復旧します。
ハンドラは、そのハンドラを設定した`condition-case'の環境で実行されます。
`condition-case'の内側で呼び出された関数はすべて終了しているので、
ハンドラからそれらへ戻ることはできません。

   エラーに適用可能なハンドラがなければ、
現在のコマンドは終了し、制御はエディタコマンドループへ戻ります。
というのは、コマンドループには、
すべての種類のエラーに対する暗黙のハンドラがあるからです。
コマンドループのハンドラは、エラーシンボルと関連するデータを使って
エラーメッセージを表示します。

明示的なハンドラがないエラーは、Lispデバッガを呼び出すこともあります。
変数`debug-on-error'（*note Error Debugging::）が
`nil'以外であると、デバッガが有効になります。
エラーハンドラと違って、デバッガはエラーの環境で実行されるので、
エラー時の変数の正確な値を調べることができます。


File: elisp-ja,  Node: Handling Errors,  Next: Error Symbols,  Prev: Processing of Errors,  Up: Errors

9.5.3.3 エラーハンドラの書き方
.........................................

エラーを通知することの普通の効果は、
実行中のコマンドを終了し、Emacsのエディタコマンドループにただちに戻ります。
読者のプログラムの一部で発生したエラーを捕捉するようにするには、
スペシャルフォーム`condition-case'を使ってエラーハンドラを設定します。
単純な例はつぎのようになります。

     (condition-case nil
         (delete-file filename)
       (error nil))

これはFILENAMEという名前のファイルを削除しますが、
エラーが発生するとどんなエラーでも捕捉して`nil'を返します。

   `condition-case'の第2引数を "保護されたフォーム"（protected
form）と呼びます。
（上の例では、保護されたフォームは`delete-file'の呼び出し。）
このフォームの実行を開始するとエラーハンドラが有効になり、
このフォームから戻るとエラーハンドラは取り除かれます。
そのあいだは、つねにエラーハンドラは有効です。
特に、このフォームから呼び出される関数の実行中、
それらのサブルーティンの実行中などには、エラーハンドラは有効です。
これは大切なことで、厳密にいえば、
エラーが通知されるのは、保護されたフォームから呼び出された
（`signal'や`error'を含む）Lisp基本関数の実行中であって、
保護されたフォームそのものからではないからです。

   保護されたフォームのうしろにある引数は、ハンドラです。
各ハンドラは1つ以上の（シンボルである）"条件名" （condition
names）を列挙し、処理するエラーを指定します。
エラーが通知されたときのエラーシンボルも条件名のリストを定義します。
それらに共通の条件名があるとき、 エラーハンドラがエラーに適用されます。
上の例では、1つのハンドラがあり、条件名は1つ、`error'を指定しています。
この条件名はすべてのエラーを意味します。

   適用可能なハンドラの探索では、
もっとも最近に確立されたハンドラから始めて、
確立されたすべてのハンドラを調べます。
したがって、フォーム`condition-case'が2つ入れ子になっていて
同じ名前のハンドラを確立していると、内側のものが実際に処理を受け持ちます。

   フォーム`condition-case'でエラーが処理されるときには、
`debug-on-error'でエラーによりデバッガを起動するように指定してあっても
デバッガは実行されません。 *Note Error Debugging::。
`condition-case'で捕捉されるエラーをデバッグしたいときには、
変数`debug-on-signal'に`nil'以外の値を設定します。

   エラーを処理できる場合には、制御はハンドラに移ります。
こうするまえに、Emacsは、抜け出し対象となる束縛作成構造が設定した
すべての変数束縛を解き、抜け出し対象となるフォーム`unwind-protect'
すべての後始末を実行します。
ハンドラに制御が移ると、ハンドラの本体を実行します。

   ハンドラ本体の実行を完了すると、
フォーム`condition-case'から戻ります。
ハンドラを実行するまえに保護されたフォームから完全に抜けているので、
ハンドラでは、エラー発生時点から再開したり、
保護されたフォームの内側で作られた変数束縛を調べたりすることはできません。
ハンドラでできることは、後始末をして先へ進むことだけです。

   `condition-case'構造は、`insert-file-contents'の呼び出しで
ファイルのオープンに失敗するなどの予測可能なエラーを捕捉するために
しばしば使われます。
プログラムがユーザーから読み取った式を評価する場合のように、
まったく予測不可能なエラーを捕捉するためにも使われます。

   エラー通知とエラー処理は、`throw'と`catch'に多少似ていますが、
それらはまったく別の機能です。 `catch'ではエラーを捕捉できませんし、
エラーハンドラでは`throw'を処理できません
（しかしながら、適切な`catch'がない`throw'を使うと、
処理できるエラーを通知する）。

 -- Special Form: condition-case var protected-form handlers...
     このスペシャルフォームは、PROTECTED-FORMの実行中は
     エラーハンドラHANDLERSを確立する。
     PROTECTED-FORMがエラーなしに完了すると、
     その戻り値がフォーム`condition-case'の値になる。
     この場合、`condition-case'はなんの効果もない。
     フォーム`condition-case'で違いがでるのは、
     PROTECTED-FORMの実行中にエラーが起こった場合である。

     各HANDLERSは、`(CONDITIONS BODY...)'の形式の リストである。
     ここでCONDITIONSは、処理すべきエラーの条件名か条件名のリストである。
     BODYは1つ以上のLisp式であり、
     このハンドラがエラーを処理するときに実行される。
     ハンドラの例を示す。

          (error nil)

          (arith-error (message "Division by zero"))

          ((arith-error file-error)
           (message
            "Either division by zero or failure to open a file"))

     生起する各エラーには、
     そのエラーの種類を表す"エラーシンボル"（error symbol）がある。
     そのシンボルの属性`error-conditions'は、
     条件名のリストである（*note Error Symbols::）。
     Emacsは、有効なフォーム`condition-case'すべてを探索し、
     これらの条件名を1つ以上指定したハンドラを探す。
     もっとも内側の一致する`condition-case'がエラーを処理する。
     この`condition-case'の内側では、
     適用可能な最初のハンドラがエラーを処理する。

     ハンドラの本体の実行を完了すると、
     `condition-case'は通常のように戻り、
     ハンドラの本体の最後のフォームの値を全体としての値に使う。

     引数VARは変数である。
     `condition-case'は、PROTECTED-FORMを実行するときには
     この変数を束縛せず、エラーを処理するときだけ束縛する。
     そのとき、VARはローカルに"エラー記述" （error
     description）に束縛される。
     これは、エラーの詳細を与えるリストである。
     エラー記述は、`(ERROR-SYMBOL . DATA)'の形式である。
     ハンドラは、動作を決定するためにこのリストを参照できる。
     たとえば、ファイルのオープンに失敗したエラーであれば、
     DATAの第2要素、エラー記述の第3要素がファイル名である。

     VARが`nil'であると、変数を束縛しなことを意味する。
     そうすると、ハンドラではエラーシンボルと関連するデータを使えない。

 -- Function: error-message-string error-description
     この関数は、指定したエラー記述に対するエラーメッセージ文字列を返す。
     エラーに対する普通のエラーメッセージを表示して、
     エラーを処理したい場合に便利である。

ゼロ除算の結果であるエラーを処理する`condition-case'の使用例を示します。
ハンドラはエラーメッセージを（ベルを鳴らさずに）表示して、
大きな数を返します。

     (defun safe-divide (dividend divisor)
       (condition-case err
           ;; 保護されたフォーム
           (/ dividend divisor)
         ;; ハンドラ
         (arith-error                        ; 条件
          ;; このエラーに対する普通のメッセージを表示する
          (message "%s" (error-message-string err))
          1000000)))
     => safe-divide

     (safe-divide 5 0)
          -| Arithmetic error: (arith-error)
     => 1000000

ハンドラは条件名`arith-error'を指定しているので、
ゼロ除算エラーだけを処理します。
少なくともこの`condition-case'では他の種類のエラーは処理しません。
したがって、つぎのようになります

     (safe-divide nil 3)
          error--> Wrong type argument: number-or-marker-p, nil

   以下は、`error'で通知されるエラーも含めて、
すべての種類のエラーを捕捉する`condition-case'です。

     (setq baz 34)
          => 34

     (condition-case err
         (if (eq baz 35)
             t
           ;; これは関数`error'の呼び出し
           (error "Rats!  The variable %s was %s, not 35" 'baz baz))
       ;; これはハンドラ。フォームではない
       (error (princ (format "The error was: %s" err))
              2))
     -| The error was: (error "Rats!  The variable baz was 34, not 35")
     => 2


File: elisp-ja,  Node: Error Symbols,  Prev: Handling Errors,  Up: Errors

9.5.3.4 エラーシンボルと条件名
.........................................

エラーを通知するときには、読者が意図するエラーの種類を指定する
"エラーシンボル"（error symbol）を指定します。
各エラーには、それを分類する一意な名前があります。 これは、Emacs
Lisp言語で定義されたエラーを細分類したものです。

   これらの細分類は、"エラー条件"（error conditions）と呼ばれる
より大きなクラスの階層にまとめられています。
エラー条件は、"条件名"（condition names）で識別します。
もっとも細かい分類は、エラーシンボルそのものです。
各エラーシンボルは条件名でもあります。
より大きなクラスを表す条件名`error'もあります。
これはすべての種類のエラーを表します。
したがって、各エラーには、1つ以上の条件名があります。
つまり、`error'、`error'とは別のエラーシンボル、あるいは、
その中間の分類に属するものです。

   あるシンボルがエラーシンボルであるためには、そのシンボルには、
条件名のリストを与える属性`error-conditions'があることが必要です。
このリストは、そのエラーが属するエラー条件を定義します。
（エラーシンボルそのものと、シンボル`error'は、
つねにこのリストの要素であること。） したがって、条件名の階層は、
エラーシンボルの属性`error-conditions'で定義されます。

   `error-conditions'リストに加えて、
エラーシンボルには、属性`error-message'も必要です。
この属性の値は、そのエラーが処理されないときに表示される文字列です。
属性`error-message'があるのに、それが文字列でなければ、
エラーメッセージ`peculiar error'を使います。 

   以下に、新たなエラーシンボル`new-error'の定義方法を示します。

     (put 'new-error
          'error-conditions
          '(error my-own-errors new-error))
     => (error my-own-errors new-error)
     (put 'new-error 'error-message "A new error")
     => "A new error"

このエラーには、3つの条件名があります。
もっとも細かい分類である`new-error'、
それより大きな分類とであると考えている`my-own-error'、
もっとも大きな分類である`error'です。

   エラー文字列は大文字で始めるべきですが、ピリオドで終えません。
これは、Emacsの他の慣習と整合をとるためです。

   普通、Emacs自身が`new-error'を通知することはありえません。
つぎのように、読者のコードで明示的に `signal'（*note Signaling
Errors::）を呼んだときだけです。

     (signal 'new-error '(x y))
          error--> A new error: x, y

   このエラーは、3つの条件名のどれでも処理できます。
つぎの例は、`new-error'と
クラス`my-own-errors'の任意の他のエラーを処理します。

     (condition-case foo
         (bar nil t)
       (my-own-errors nil))

   エラーを分類する重要な方法は、それらの条件名によることです。
つまり、エラーに一致するハンドラを探すために条件名を使います。
エラーシンボルは、意図したエラーメッセージと条件名のリストを指定する
簡便な方法を提供するだけです。 `signal'に、1つのエラーシンボルではなく、
条件名のリストを指定するのではわずらわしいでしょう。

   一方、条件名なしにエラーシンボルだけを使うのでは、
`condition-case'の能力をいちじるしく損ないます。
条件名があることで、エラーハンドラを書くときにさまざまなレベルに
一般化してエラーを分類できるのです。 エラーシンボルだけを使ったのでは、
最細分類以外のレベルを削除してしまうことになります。

   すべての標準エラー名とそれらの条件名については、 *Note Standard
Errors::。


File: elisp-ja,  Node: Cleanups,  Prev: Errors,  Up: Nonlocal Exits

9.5.4 非ローカル脱出時の後始末
------------------------------------------

`unwind-protect'構造は、データ構造を一時的に整合性のない状態に
するときには本質的です。
この構造により、エラーや非ローカル脱出が起こったときに、
データの整合性を回復できます。

 -- Special Form: unwind-protect body cleanup-forms...
     `unwind-protect'は、BODYからどのように制御が離れた場合にも
     CLEANUP-FORMSの実行を保証して、BODYを実行する。
     BODYは通常どおり完了するか、
     `throw'を実行して`unwind-protect'から脱出するか、
     エラーを引き起こす。 いずれの場合でも、CLEANUP-FORMSは評価される。

     フォームBODYが正常に終了すると、
     `unwind-protect'は、CLEANUP-FORMSを評価したあとに、
     フォームBODYの最後の値を返す。 フォームBODYが完了しなかった場合、
     `unwind-protect'は普通の意味での値は返さない。

     `unwind-protect'が保護するのはBODYだけである。
     CLEANUP-FORMSそのもののどれかが（`throw'やエラーで）
     非ローカル脱出を行うと、`unwind-protect'は、
     CLEANUP-FORMSの残りを評価することを保証_しない_。
     CLEANUP-FORMSのどれかが失敗するとトラブルになる危険性がある場合には、
     CLEANUP-FORMSを別の`unwind-protect'で保護する。

     フォーム`unwind-protect'の現在の入れ子の個数は、
     ローカル変数束縛の個数とともに数えられ、
     `max-specpdl-size'に制限されている（*note Local Variables::）。

   たとえば、表示しないバッファを一時的に作成し、
終了前に確実にそれを消去したいとしましょう。

     (save-excursion
       (let ((buffer (get-buffer-create " *temp*")))
         (set-buffer buffer)
         (unwind-protect
             BODY
           (kill-buffer buffer))))

変数`buffer'を使わずに`(kill-buffer (current-buffer))'と
書くだけで十分だと考えるかもしれません。
しかし、別のバッファに切り替えたあとでBODYでエラーが発生した場合には、
上の方法はより安全です。
（あるいは、BODYの周りに別の`save-excursion'を書いて、
一時バッファを消去するときに、それがカレントバッファになることを
保証する。）

   Emacsには、上のようなコードに展開される`with-temp-buffer'という
標準マクロがあります（*note Current Buffer::）。
本書で定義しているマクロのいくつかでは、
このように`unwind-protect'を使っています。

   ファイル`ftp.el'から持ってきた実際の例を示しましょう。
リモートの計算機への接続を確立するプロセス（*note
Processes::）を作ります。
関数`ftp-login'は、その関数の作成者が予想できないほどの
数多くの問題に対してとても敏感ですから、
失敗したときにプロセスを消去することを保証するフォームで保護します。
さもないと、Emacsは、無用なサブプロセスで満たされてしまいます。

     (let ((win nil))
       (unwind-protect
           (progn
             (setq process (ftp-setup-buffer host file))
             (if (setq win (ftp-login process host user password))
                 (message "Logged in")
               (error "Ftp login failed")))
         (or win (and process (delete-process process)))))

   この例には、小さなバグが1つあります。
ユーザーが`C-g'を打って中断しようとして、かつ、
関数`ftp-setup-buffer'の終了後に
変数`process'を設定するまえに実際に中断が行われると、
プロセスは消去されません。 このバグを直す簡単な方法はありませんが、
少なくとも、ほとんど起こりえません。


File: elisp-ja,  Node: Variables,  Next: Functions,  Prev: Control Structures,  Up: Top

10 変数
*********

"変数"（variable）は、プログラムにおいて値を表すために使う名前です。
ほとんどすべてのプログラム言語には、ある種の変数があります。
Lispプログラムのテキストでは、シンボルの構文を使って変数を書きます。

   ほとんどのプログラム言語と違って、Lispでは、
プログラムはLispオブジェクトで表現し、テキスト表現は副次的なものです。
変数として使うLispオブジェクトはシンボルです。
シンボル名が変数名であり、変数の値はシンボルの値セルに格納されています。
変数としてのシンボルの使い方は、関数名としての使い方とは独立しています。
*Note Symbol Components::。

   Lispプログラムを構成するLispオブジェクト群は、
プログラムのテキスト表現を決定します。
つまり、Lispオブジェクト群に対する単なる入力構文です。
これは、たとえば、Lispプログラムのテキスト表現では、
変数を表現するシンボルの入力構文で変数を書く理由です。

* Menu:

* Global Variables::      Variable values that exist permanently, everywhere.
* Constant Variables::    Certain "variables" have values that never change.
* Local Variables::       Variable values that exist only temporarily.
* Void Variables::        Symbols that lack values.
* Defining Variables::    A definition says a symbol is used as a variable.
* Tips for Defining::     How to avoid bad results from quitting
                            within the code to initialize a variable.
* Accessing Variables::   Examining values of variables whose names
                            are known only at run time.
* Setting Variables::     Storing new values in variables.
* Variable Scoping::      How Lisp chooses among local and global values.
* Buffer-Local Variables::  Variable values in effect only in one buffer.
* Frame-Local Variables::   Variable values in effect only in one frame.
* Future Local Variables::  New kinds of local values we might add some day.


File: elisp-ja,  Node: Global Variables,  Next: Constant Variables,  Up: Variables

10.1 グローバル変数
==========================

変数を使うもっとも簡単な方法は、
"グローバルに"（globally、大局的に）使うことです。
つまり、どんなときにも変数にはたった1つの値だけがあり、
（少なくともここでは）Lispシステム全体にその値が有効になります。
新たな値を設定するまで、その値が有効であり続けます。
新たな値で古い値を置き換えると、変数には古い値の痕跡はなにも残りません。

   シンボルの値は`setq'で指定します。 たとえば、

     (setq x '(a b))

は、変数`x'に値`(a b)'を与えます。
`setq'は、最初の引数、つまり、変数の名前を評価せず、
新しい値である第2引数を評価することに注意してください。

   変数にいったん値を与えれば、
式としてシンボルそのものを使うことによりその値を参照できます。
つまり、つぎのとおりです。

     x => (a b)

ただし、上に示したフォーム`setq'を実行してあると仮定します。

   同じ変数に値を設定し直すと、 新しい値で古い値を置き換えます。

     x
          => (a b)
     (setq x 4)
          => 4
     x
          => 4


File: elisp-ja,  Node: Constant Variables,  Next: Local Variables,  Prev: Global Variables,  Up: Variables

10.2 変更不可能な変数
=============================

Emacs Lispには、通常それ自身に評価されるある種のシンボルがあります。
`:'で始まる名前の任意の変数、および、`nil'と`t'です。
これらのシンボルを再束縛することはできず、
それらの値を変更することもできません。
`nil'や`t'を設定しようとしたり束縛しようとすると、
エラー`setting-constant'を通知します。
`:'で始まる名前のシンボルに関してもそうですが、
そのようなシンボルにそれ自身を設定することはできます。

     nil == 'nil
          => nil
     (setq nil 500)
     error--> Attempt to set constant symbol: nil

 -- Variable: keyword-symbols-constant-flag
     この変数が`nil'であると、
     `:'で始まる名前の変数を望みの値に設定したり束縛したりできる。
     これは、そのようなことを行う古いLispプログラムの実行を可能にするためである。


File: elisp-ja,  Node: Local Variables,  Next: Void Variables,  Prev: Constant Variables,  Up: Variables

10.3 ローカル変数
=======================

グローバル変数は、
明示的に新しい値で置き換えない限り存続する値を持ちます。
一時的にしか存在しない変数値、
つまり、プログラムのある部分を完了するまでのみ存在する変数値を
作れると便利なことがあります。
このような値を"ローカル"（local、局所的）と呼び、
そのように使われる変数を"ローカル変数"（local variables）と呼びます。

   たとえば、関数を呼び出したとき、その引数変数は、
関数を抜けるまで存続する新たなローカルな値を受け取ります。
スペシャルフォーム`let'は、指定した変数の新たなローカル値を
明示的に確立します。 これらはフォーム`let'を抜けるまで存続します。

   ローカル値を確立すると、
変数の以前の値（あるいは値がないこと）を保存します。
ローカル値の存続期間が終了すると、以前の値を復元します。
この期間は、以前の値を"隠して"（shadowed）いて 以前の値は"見えません"。
グローバル値でもローカル値でも隠せます（*note Scope::）。

   変数がローカルなときに（`setq'などで）その変数を設定すると、
ローカル値を置き換えます。
隠されているグローバル値や以前のローカル値を変更しません。
このふるまいをモデル化するために、
変数のローカル値に加えて変数の"ローカル束縛"（local binding）を
考えます。

   ローカル束縛とは、ローカル値を保持する概念的な場所です。
関数や`let'などのスペシャルフォームに入るたびに
ローカル束縛を作成します。
関数やフォーム`let'から抜けるとローカル束縛を削除します。
ローカル束縛が存続する限り、変数の値はそこに保持されています。
ローカル束縛が存在するときに`setq'や`set'を使うと、
ローカル束縛の中に別の値を格納します。
新たな束縛を作るのではありません。

   グローバル値を保持する概念的な場所を "グローバル束縛"（global
binding）ともいいます。

   変数には一度に複数のローカル束縛がありえます
（たとえば、同じ変数を束縛する入れ子になったフォーム`let'があるとき）。
そのような場合、既存のもっとも最近に作成されたローカル束縛が、
変数の"現在の束縛"（current binding）です。
（この規則を"動的スコープ"（dynamic scoping）と呼びます。 *note
Variable Scoping::）
ローカル束縛がまったくなければ、変数のグローバル束縛が現在の束縛です。
現在の束縛のことを強調して"既存の最ローカル束縛"と呼ぶこともあります。
シンボルの通常の評価では、その現在の束縛の値を返します。

   スペシャルフォーム`let'や`let*'は、
ローカル束縛を作るためにあります。

 -- Special Form: let (bindings...) forms...
     このスペシャルフォームは、BINDINGSに従って変数を束縛し、
     FORMSのすべてをテキスト上の順に評価する。
     `let'フォームは、FORMSの最後のフォームの値を返す。

     BINDINGSのおのおのは、(i)シンボルであるか、 (ii)フォーム`(SYMBOL
     VALUE-FORM)'のリストである。 前者は、シンボルに`nil'を束縛する。
     後者は、SYMBOLにVALUE-FORMの評価結果を束縛する。
     VALUE-FORMを省略すると`nil'を使う。

     BINDINGSのVALUE-FORM群すべてを現れる順に評価して_から_、
     シンボルにそれらの値を束縛する。 例をつぎに示す。
     `Z'は、`Y'の古い値2に束縛され、`Y'の新しい値1ではない。

          (setq Y 2)
               => 2
          (let ((Y 1)
                (Z Y))
            (list Y Z))
               => (1 2)

 -- Special Form: let* (bindings...) forms...
     このスペシャルフォームは`let'に似ているが、
     変数のローカル値を計算し終えた直後にその変数を束縛し、
     つぎの変数のローカル値の計算に進む。
     したがって、BINDINGS内の式では、この`let*'フォーム内で
     まえにあるシンボルを参照できる。
     つぎの例を上の`let'の例と比較してほしい。

          (setq Y 2)
               => 2
          (let* ((Y 1)
                 (Z Y))    ; 設定し終えたばかりの`Y'の値を使う
            (list Y Z))
               => (1 1)

以下にローカル束縛を作成するその他の機能の完全な一覧をあげておきます。

   * 関数呼び出し（*note Functions::）。

   * マクロ呼び出し（*note Macros::）。

   * `condition-case'（*note Errors::）。

   変数は、バッファローカルな束縛（*note Buffer-Local Variables::や
フレームローカルな束縛（*note Frame-Local
Variables::）を持つことができます。
少数の変数は、端末にローカルな束縛（*note Multiple Displays::）
を持つこともできます。
この種の束縛は普通のローカル束縛と同じように働きますが、
これらはEmacsの『どの部分』にいるかに依存したローカル化であり、
時間的なローカル化ではありません。

 -- Variable: max-specpdl-size
     この変数は、（`"Variable binding depth exceeds max-specpdl-size"'を
     伴った）エラーを通知するまでに許される、 ローカル変数束縛と
     `unwind-protect'による後始末（*note Nonlocal Exits::）の
     全体の個数の制限を定義する。

     この制限、および、これを超えたときのエラーは、
     不正に定義された関数によってLispが無限に再帰することを防止する
     1つの方法である。

     デフォルト値は600である。 Lispデバッガに入ったとき、
     制限に近い場合にはデバッガ自身が実行できることを保証するために値を増やす。


File: elisp-ja,  Node: Void Variables,  Next: Defining Variables,  Prev: Local Variables,  Up: Variables

10.4 変数が『空』であるとき
======================================

シンボルにグローバル変数としての値を一度も与えていないとき、
そのシンボルのグローバル値は"空"（void）であるといいます。
いいかえれば、シンボルの値セルにはどんなLispオブジェクトも入っていません。
シンボルを評価しようとすると、値ではなくエラー`void-variable'を得ます。

   `nil'という値は空とは異なることに注意してください。
シンボル`nil'はLispオブジェクトであり、他のオブジェクトと同様に
変数の値になりえます。 それは_値_なのです。
空な変数はいかなる値も持たないのです。

   変数に値を与えたあとでは、`makunbound'を使って
再度その変数を空にできます。

 -- Function: makunbound symbol
     この関数は、SYMBOLの現在の変数束縛を空にする。
     これ以降に変数としてこのシンボルの値を使おうとすると、
     再度設定していない限り、エラー`void-variable'を通知する。

     `makunbound'はSYMBOLを返す。

          (makunbound 'x)      ; 変数`x'のグローバル値を空にする
               => x
          x
          error--> Symbol's value as variable is void: x

     SYMBOLがローカルに束縛されていると、
     `makunbound'は既存の最ローカル束縛に作用する。
     ローカル束縛を作成するすべての構文は変数に値を与えるため、
     これはシンボルのローカル束縛を空にする唯一の方法である。
     この場面では、空の状態は、束縛が存在する限り存続する。
     束縛を作成した構造から抜け出して束縛が削除されると、
     通常どおりそれ以前のローカル束縛かグローバル束縛が有効になり、
     その束縛が空でなければ変数は空ではない。

          (setq x 1)               ; グローバル束縛に値を入れる
               => 1
          (let ((x 2))             ; ローカルに束縛する
            (makunbound 'x)        ; ローカル束縛を空にする
            x)
          error--> Symbol's value as variable is void: x
          x                        ; グローバル束縛は変更されていない
               => 1

          (let ((x 2))             ; ローカルに束縛する
            (let ((x 3))           ; もう一度
              (makunbound 'x)      ; もっとも内側のローカル束縛を空にする
              x))                  ; 参照するが、それは空
          error--> Symbol's value as variable is void: x

          (let ((x 2))
            (let ((x 3))
              (makunbound 'x))     ; 内側の束縛を空にし、それを削除する
            x)                     ; 外側の`let'の束縛が見える
               => 2

   `makunbound'で空にした変数は、
一度も値を受け取ったことがなく、そのために空である変数と区別できません。

   変数が現在、空であるかどうかは関数`boundp'を使って調べられます。

 -- Function: boundp variable
     `boundp'は、（シンボル）VARIABLEが空でなければ、
     より正確にいえば、現在の束縛が空でなければ`t'を返す。
     さもなければ`nil'を返す。

          (boundp 'abracadabra)          ; 空で始める
               => nil
          (let ((abracadabra 5))         ; ローカルに束縛する
            (boundp 'abracadabra))
               => t
          (boundp 'abracadabra)          ; グローバルにはまだ空である
               => nil
          (setq abracadabra 5)           ; グローバルに空でなくする
               => 5
          (boundp 'abracadabra)
               => t


File: elisp-ja,  Node: Defining Variables,  Next: Tips for Defining,  Prev: Void Variables,  Up: Variables

10.5 グローバル変数を定義する
=========================================

スペシャルフォーム`defconst'や`defvar'の"変数定義"を使って、
シンボルをグローバル変数として使う意図を表明できます。

   Emacs Lispでは、定義には3つの目的があります。
まず、コードを読む人向けに、特定のシンボルを（変数として）特定目的に
使う_意図_があることを知らせます。
第2に、Lispシステムに対しては、値と説明文字列を提供して
これらのことを伝えます。
第3に、プログラム内の関数や変数のデータベースを作成する
`etags'や`make-docfile'などのユーティリティに情報を提供します。

   `defconst'と`defvar'の違いは、主に好みの問題であり、
値が変更されるかどうかを人に伝えます。 Emacs
Lispは、`defconst'や`defvar'の宣言に基づいて
変数の使い方を制限することはしません。
しかしながら、初期化に関しては違いがあります。
`defconst'は無条件に変数を初期化しますが、
`defvar'は変数が空である場合にのみ初期化します。

 -- Special Form: defvar symbol [value [doc-string]]
     このスペシャルフォームは、SYMBOLを変数として定義し、
     初期値や説明文字列を設定する。 この定義は、コードを読む人向けに、
     値を設定したり変更する変数としてSYMBOLを使うことを伝える。
     SYMBOLは評価されないことに注意。
     定義するシンボルは、`defvar'に明示的に現れる必要がある。

     SYMBOLの値が空でありVALUEを指定してあると、
     `defvar'はVALUEを評価し、その結果をSYMBOLに設定する。
     しかし、SYMBOLにすでに値があれば（つまり、空でなければ）、
     VALUEをまったく評価せず、SYMBOLの値も変更しない。
     VALUEを省略した場合、SYMBOLの値をいっさい変更しない。

     SYMBOLにカレントバッファでバッファローカルな束縛がある場合には、
     `defvar'はデフォルト値に作用する。
     それは、バッファには独立であり、現在の（バッファローカルな）束縛ではない。
     `defvar'は、デフォルト値が空の場合にデフォルト値を設定する。 *note
     Buffer-Local Variables::。

     emacs-lispモードにおいて`C-M-x'（`eval-defun'）でトップレベルの
     フォーム`defvar'を評価すると、 `eval-defun'の特別な機能により、
     変数の値が空かどうかを調べずに無条件に変数に設定する。

     DOC-STRINGがあれば、それは変数の説明文を指定する。
     （説明文を指定できるのは、変数定義の主な利点の1つである。）
     説明文はシンボルの属性`variable-documentation'に格納する。
     Emacsのヘルプ関数（*note Documentation::）は、この属性を調べる。

     DOC-STRINGの最初の文字が`*'であると、
     この変数をユーザーオプションと考えることを意味する。
     これにより、ユーザーはコマンド`set-variable'や`edit-options'を
     使って簡単に変数を設定できる。
     しかしながら、ユーザーオプションの変数には、
     `defvar'ではなく`defcustom'を使ったほうがよく、
     そうすればカスタマイズ情報を指定できる。 *note Customization::。

     いくつか例をあげる。
     つぎのフォームは`foo'を定義するが初期化はしない。

          (defvar foo)
               => foo

     つぎの例は、`bar'の値を`23'に初期化し、説明文字列を与える。

          (defvar bar 23
            "The normal weight of a bar.")
               => bar

     つぎの例は、`bar'の説明文字列を変更し、
     この変数をユーザーオプションにする。
     しかし、`bar'にはすでに値が設定してあるので、 その値は変更しない。
     （さらに`(1+ nil)'は評価するとエラーになるが、
     評価されないのでエラーはない。）

          (defvar bar (1+ nil)
            "*The normal weight of a bar.")
               => bar
          bar
               => 23

     つぎの例は、スペシャルフォーム`defvar'に等価な式である。

          (defvar SYMBOL VALUE DOC-STRING)
          ==
          (progn
            (if (not (boundp 'SYMBOL))
                (setq SYMBOL VALUE))
            (if 'DOC-STRING
              (put 'SYMBOL 'variable-documentation 'DOC-STRING))
            'SYMBOL)

     フォーム`defvar'はSYMBOLを返すが、
     通常このフォームはファイルのトップレベルで使われ、そこでは値は関係ない。

 -- Special Form: defconst symbol [value [doc-string]]
     このスペシャルフォームは、SYMBOLを変数として定義し初期化する。
     この定義は、コードを読む人向けに、
     SYMBOLはこれ以降標準のグローバル値を持ち、
     ユーザーや他のプログラムが変更すべきでないことを伝える。
     SYMBOLは評価されないことに注意。
     定義するシンボルは、`defconst'に明示的に現れる必要がある。

     `defconst'は、VALUEがあればつねにVALUEを評価し、
     その結果をSYMBOLに設定する。
     SYMBOLにカレントバッファのバッファローカルな束縛がある場合には、
     `defconst'はデフォルト値を設定し、 バッファローカルな値にではない。
     （しかし、`defconst'で定義するシンボルには、
     バッファローカルな束縛を作るべきではない。）

     つぎの例では、`pi'は、（インディアナ州立法府はいうにおよばず）
     だれも変更すべきではないと考えられる定数である。
     しかし、2番目のフォームからわかるように、これは単に助言でしかない。

          (defconst pi 3.1415 "Pi to five places.")
               => pi
          (setq pi 3)
               => pi
          pi
               => 3

 -- Function: user-variable-p variable
     この関数は、VARIABLEがユーザーオプション、つまり、
     カスタマイズのためにユーザーが設定することを意図した変数であると、
     `t'を返し、さもなければ`nil'を返す。
     （ユーザーオプション向け以外の変数は、Lispプログラムの内部目的用にあり、
     それらについてユーザーが知る必要はない。）

     ユーザーオプション変数は、
     属性`variable-documentation'の最初の文字で他の変数と区別される。
     その属性が存在して文字列であり、最初の文字が`*'であれば、
     その変数はユーザーオプションである。

   ユーザーオプション変数に属性`variable-interactive'があると、
コマンド`set-variable'はその属性値を使って、
変数の新しい値の読み取りを制御します。
この属性値は、`interactive'の引数（*note Using Interactive::）
のように使われます。 しかしながら、この機能は`defcustom'（*note
Customization::）により ほとんど廃れています。

   *警告：*` ' 変数にローカル束縛があるときに
スペシャルフォーム`defconst'や`defvar'を使うと、
ローカル束縛の値を変更し、グローバル束縛は変更しない。
これは望む効果ではない。
これを防ぐには、これらのスペシャルフォームはファイルのトップレベルで使う。
そうすれば、普通は有効なローカル束縛はない。
さらに、変数のローカル束縛を作るまえに、
確実にファイルをロードしておく。


File: elisp-ja,  Node: Tips for Defining,  Next: Accessing Variables,  Prev: Defining Variables,  Up: Variables

10.6 変数を堅牢に定義するためのヒント
=====================================================

（内部に束縛を含むようなキーマップなどの）複雑な値を保持する変数を
定義し初期化するときには、つぎのように、
値の計算全体を`defvar'の内部に入れておくのが最良です。

     (defvar my-mode-map
       (let ((map (make-sparse-keymap)))
         (define-key map "\C-c\C-a" 'my-command)
         ...
         map)
       DOCSTRING)

この方法には、いくつかの利点があります。
まず、ファイルのロード中にユーザーが中断した場合、
変数は初期化されないか正しく初期化されるかのいずれかであり、
その中間状態ということはありません。
第2に、変数をすでに初期化したあとにファイルをロードし直しても、
変数を変更しません。
（キーをバインドし直すなどの）内容の一部を変更するために
ユーザーがフックを実行した場合などには、これは重要です。
第3に、`C-M-x'でフォーム`defvar'を評価すると、
マップを完全に初期化し_直せます_。

フォーム`defvar'の内側に多くのコードを置くことには、欠点が1つあります。
変数の名前を指定した行から説明文字列が離れすぎてしまうことです。
つぎのようにしてこれを安全に防げます。

     (defvar my-mode-map nil
       DOCSTRING)
     (if my-mode-map
         nil
       (let ((map (make-sparse-keymap)))
         (define-key my-mode-map "\C-c\C-a" 'my-command)
         ...
         (setq my-mode-map map)))

これには、`defvar'の内側に初期化を入れたときと同じ利点がありますが、
変数を再初期化するには、各フォームそれぞれについて
`C-M-x'を打つ必要があります。

   しかし、つぎのようなコードは書かないでください。

     (defvar my-mode-map nil
       DOCSTRING)
     (if my-mode-map
         nil
       (setq my-mode-map (make-sparse-keymap))
       (define-key my-mode-map "\C-c\C-a" 'my-command)
       ...)

このコードでは、変数を設定してから変更しますが、
それを複数の手順で行います。 `setq'の直後にユーザーが中断すると、
変数は正しく初期化されておらず、空でも`nil'でもありません。
こうなったときにファイルを再ロードしても変数を初期化できません。
変数は不完全な状態のままです。


File: elisp-ja,  Node: Accessing Variables,  Next: Setting Variables,  Prev: Tips for Defining,  Up: Variables

10.7 変数値の参照
=======================

変数を参照する普通の方法は、
変数を指名するシンボルを書くことです（*note Symbol Forms::）。
これには、プログラムを書くときに変数名を指定する必要があります。
読者は、普通このようにするでしょう。
場合によっては、実行時にどの変数を参照するか選ぶ必要があり、
そのときには`symbol-value'を使います。

 -- Function: symbol-value symbol
     この関数はSYMBOLの値を返す。
     これは、シンボルのもっとも内側のローカル束縛の値、あるいは、
     ローカル束縛がなければグローバル値である。

          (setq abracadabra 5)
               => 5
          (setq foo 9)
               => 9

          ;; ここで、`abracadabra'は、
          ;;   その値を調べるシンボル
          (let ((abracadabra 'foo))
            (symbol-value 'abracadabra))
               => foo

          ;; ここで、`abracadabra'の値、
          ;;   つまり`foo'が、
          ;;   その値を調べるシンボル
          (let ((abracadabra 'foo))
            (symbol-value abracadabra))
               => 9

          (symbol-value 'abracadabra)
               => 5

     SYMBOLの現在の束縛が空であると、 エラー`void-variable'を通知する。


File: elisp-ja,  Node: Setting Variables,  Next: Variable Scoping,  Prev: Accessing Variables,  Up: Variables

10.8 変数値の変更
=======================

変数の値を変更する普通の方法は、スペシャルフォーム`setq'を使うことです。
実行時に選択する変数を計算する必要があるときには、 関数`set'を使います。

 -- Special Form: setq [symbol form]...
     このスペシャルフォームは、変数の値を変更するもっとも一般的な方法である。
     各SYMBOLに、対応するFORMの評価結果である新たな値を与える。
     シンボルの既存の際、ローカルの束縛を変更する。

     `setq'はSYMBOLを評価しない。 読者が書いたシンボルに設定する。
     この変数は"自動的にクォートされる"のである。
     `setq'の`q'は、『quoted（クォートする）』を表す。

     フォーム`setq'の値は、最後のFORMの値である。

          (setq x (1+ 2))
               => 3
          x                   ; `x'はグローバル値を持つ
               => 3
          (let ((x 5))
            (setq x 6)        ; `x'のローカル束縛を設定する
            x)
               => 6
          x                   ; グローバル値は変更されない
               => 3

     最初のFORMを評価して最初のSYMBOLに設定し、
     つぎに、2番目のFORMを評価して2番目のSYMBOLに設定し、
     といった具合になることに注意。

          (setq x 10          ; `x'は、`y'の値を計算するまえに
                y (1+ x))     ;   設定されることに注意
               => 11

 -- Function: set symbol value
     この関数は、SYMBOLの値としてVALUEを設定し、VALUEを返す。
     `set'は関数なので、SYMBOLとして書いた式は、
     設定するシンボルを得るために評価される。

     変数の既存の最ローカルの束縛に設定する。
     隠されている束縛には影響しない。

          (set one 1)
          error--> Symbol's value as variable is void: one
          (set 'one 1)
               => 1
          (set 'two 'one)
               => one
          (set two 2)         ; `two'はシンボル`one'に評価される
               => 2
          one                 ; そのため、`one'に設定される
               => 2
          (let ((one 1))      ; `one'のこの束縛が設定され、
            (set 'one 3)      ;   グローバル値は設定されない
            one)
               => 3
          one
               => 2

     SYMBOL（の評価結果）が実際にはシンボルでないと、
     エラー`wrong-type-argument'を通知する。

          (set '(x y) 'z)
          error--> Wrong type argument: symbolp, (x y)

     論理的には、`set'は`setq'よりもさらに基本的な操作である。
     どんな`setq'の使い方でも、`set'で素直に書き直せる。
     `setq'は、`set'を使ってマクロとして定義することも可能である。
     しかし、`set'そのものを使うことは稀であり、
     初心者は`set'を知る必要がほとんどない。
     設定する変数を実行時に選ぶときにのみ有用である。
     たとえば、コマンド`set-variable'は、
     ユーザーから変数名を読み取りその変数に設定するので、
     `set'を使う必要がある。

          Common Lispに関した注意：` ' Common
          Lispでは、`set'はつねにシンボルの『スペシャル』な、つまり、
          動的な値を変更し、文脈上の束縛を無視する。 Emacs
          Lispでは、すべての変数とすべての束縛は動的であり、
          `set'はつねに既存の最ローカルの束縛に作用する。

   変数に設定する別の関数は、リストに既存でない要素を追加するように
設計されたものです。

 -- Function: add-to-list symbol element
     この関数は、ELEMENTが変数SYMBOLの値のリストのメンバでなければ、
     ELEMENTと変数SYMBOLの値をコンスした値を 変数SYMBOLに設定する。
     リストを変更してもしなくても結果のリストを返す。
     呼び出すまえに、SYMBOLの値はリストであるほうがよい。

     引数SYMBOLは暗黙にクォートされない。
     `add-to-list'は、`set'のように普通の関数であり、 `setq'とは違う。
     必要ならば、読者自身でクォートする。

   `add-to-list'の使い方を以下に示します。

     (setq foo '(a b))
          => (a b)

     (add-to-list 'foo 'c)     ;; `c'を追加する
          => (c a b)

     (add-to-list 'foo 'b)     ;; なんの効果もない
          => (c a b)

     foo                       ;; `foo'は変更されている
          => (c a b)

   `(add-to-list 'VAR VALUE)'に等価な式はつぎのとおりです。

     (or (member VALUE VAR)
         (setq VAR (cons VALUE VAR)))


File: elisp-ja,  Node: Variable Scoping,  Next: Buffer-Local Variables,  Prev: Setting Variables,  Up: Variables

10.9 変数束縛のスコープルール
=========================================

あるシンボル`foo'は、さまざまなローカルな変数束縛を持つことができます。
Lispプログラムの異なる場所で確立されたものや グローバル束縛です。
もっとも最近に確立した束縛が他のものに優先します。

   Emacs Lispのローカル束縛は、"無限のスコープ"（indefinite scope）と
"動的存続期間"（dynamic extent）を持ちます。
"スコープ"（scope）とは、ソースコードのテキスト上の
_どこ_から束縛を参照できるかを表します。
無限のスコープとは、プログラムのどこからでも変数束縛を参照できることを
意味します。 "存続期間"（extent）とは、プログラムの実行にしたがって、
_いつ_束縛が存在するかを表します。
動的存続期間とは、束縛を作成した構造が有効である限り、
束縛が存続することを意味します。

   動的存続期間と無限のスコープの組み合せを "動的スコープ"（dynamic
scoping）と呼びます。 対照的に、ほとんどのプログラム言語は、
"レキシカルスコープ"（lexical scoping）を用います。
つまり、ローカル変数の参照は、
その変数を束縛する関数やブロックのテキスト上で内側にある必要があります。

     Common Lispに関した注意：` ' Common
     Lispでは、『スペシャル』と宣言した変数は、 Emacs
     Lispのすべての変数と同様に、動的スコープである。

* Menu:

* Scope::          Scope means where in the program a value is visible.
                     Comparison with other languages.
* Extent::         Extent means how long in time a value exists.
* Impl of Scope::  Two ways to implement dynamic scoping.
* Using Scoping::  How to use dynamic scoping carefully and avoid problems.


File: elisp-ja,  Node: Scope,  Next: Extent,  Up: Variable Scoping

10.9.1 スコープ
-------------------

Emacs Lispでは、 ローカル変数束縛は"無限のスコープ"（indefinite
scope）です。 つまり、プログラムテキスト上のどの関数からでも、
ある変数束縛を参照できるのです。 つぎの関数定義を考えてみましょう。

     (defun binder (x)   ; `x'は、`binder'で束縛
        (foo 5))         ; `foo'は別の関数

     (defun user ()      ; `x'は、`user'において『自由』
       (list x))

   テキスト上のスコープを用いる言語では、
`binder'内の`x'の束縛を、`user'で参照することはできません。
なぜなら、`user'は、テキスト上で関数`binder'の内側にはないからです。
しかしながら、動的スコープのEmacs Lispでは、
状況に応じて、`binder'内で確立した`x'の束縛を
`user'から参照してもしなくてもよいのです。

   * `binder'をまったく呼び出さずに、直接`user'を呼び出したときには、
     とにかくみつかった`x'の束縛を使うが、
     それは`binder'のものではありえない。

   * `foo'をつぎのように定義して`binder'を呼び出したときには、
     `binder'が作った束縛を`user'で見える。

          (defun foo (lose)
            (user))

   * しかし、`foo'をつぎのように定義して`binder'を呼び出したときには、
     `binder'が作った束縛は`user'では_見えない_。

          (defun foo (x)
            (user))

     ここで、`binder'が`foo'を呼び出すと、 `foo'は`x'を束縛する。
     （`foo'の束縛は`binder'の束縛を"隠す"（shadow）という。）
     したがって、`user'は、`binder'の束縛ではなく、
     `foo'の束縛を参照することになる。

   Emacs Lispで動的スコープを使うのは、
テキスト上のスコープの単純な実装は遅いからです。
さらに、すべてのLispシステムは、少なくともオプションとして、
動的スコープを使えるようにする必要があります。
テキスト上のスコープが標準であると、
特定の変数に対して動的スコープを指定する方法が必要になります。
Emacsで両方のスコープを使えるようにしてもよいのですが、
動的スコープだけだと実装がより簡単になります。


File: elisp-ja,  Node: Extent,  Next: Impl of Scope,  Prev: Scope,  Up: Variable Scoping

10.9.2 存続期間
-------------------

"存続期間"（Extent）とは、プログラムの実行中において、
変数名が有効である期間を指します。 Emacs
Lispでは、束縛を作ったフォームを実行している期間中だけ、
変数は有効です。 これを"動的存続期間"（dynamic extent）と呼びます。
CやPascalなどのほとんどの言語の『ローカル』変数や『自動』変数も
動的存続期間です。

   動的存続期間とは別のものに"無限の存続期間"（indefinite
extent）があります。
つまり、変数束縛は、その束縛を作ったフォームから抜けても存続するのです。
たとえば、Common LispやSchemeにはこれがありますが、Emacs
Lispにはありません。

   これを説明するために、つぎの関数`make-add'を考えます。
この関数は、Nに自身の引数Mを加算する関数を返します。 この関数はCommon
Lispでは動作しますが、Emacs Lispではだめです。
というのは、`make-add'の呼び出しを抜けると、
変数Nは実引数2に束縛されなくなるからです。

     (defun make-add (n)
         (function (lambda (m) (+ n m))))  ; 関数を返す
          => make-add
     (fset 'add2 (make-add 2))  ; 関数`add2'を
                                ;   `(make-add 2)'を使って定義する
          => (lambda (m) (+ n m))
     (add2 4)                   ; 4に2を加算してみる
     error--> Symbol's value as variable is void: n

   Lispの方言のいくつかには『クロージャ』（closure）があります。
それは関数のようなオブジェクトですが、追加の変数束縛を記録します。
Emacs Lispにはクロージャはありません。


File: elisp-ja,  Node: Impl of Scope,  Next: Using Scoping,  Prev: Extent,  Up: Variable Scoping

10.9.3 動的スコープの実装
----------------------------------

（Emacs Lispの実際の動作とは異なるが）単純な実装例が、
動的束縛を理解する助けになるでしょう。
この技法を"深い束縛"（ディープバインディング、deep binding）と呼び、
初期のLispシステムで使われていました。

   変数・値の対である束縛のスタックがあるとしましょう。
関数やフォーム`let'に入ると、
引数やローカル変数の束縛をスタックに積みます。
束縛を作った構造から抜けるとそれらの束縛を取りさります。

   変数の値は、スタックの先頭から底へ向けてその変数の束縛を探索します。
その束縛から得る値が変数の値になります。
変数に設定するには、現在の束縛を探して、その束縛に新たな値を格納します。

   これからわかるように、関数の束縛は、その関数の実行中には、
たとえ別の関数を呼び出していても、存続しています。
これが束縛の存続が動的であるという理由です。
また、その束縛が有効である期間中ならば、同じ変数を使えば他の関数からも
束縛を参照できるのです。 これがスコープが無限であるという理由です。

   GNU Emacs Lispにおいて、変数のスコープの実際の実装には、
"浅い束縛"（シャローバインディング、shallow binding）と呼ばれる
技法を用いています。
各変数には現在値を保存しておく標準の場所、シンボルの値セルがあります。

   浅い束縛では、変数の設定は値セルに値を格納することで動作します。
新たな束縛を作成すると（以前の束縛に属する）古い値をスタックに積み、
新たなローカル値を値セルに格納します。
束縛を解くときには、古い値をスタックから取り出して値セルに格納します。

   浅い束縛を用いる理由は、束縛を探索する必要がないため、
深い束縛と同じ結果を持ちながら高速に動作するからです。


File: elisp-ja,  Node: Using Scoping,  Prev: Impl of Scope,  Up: Variable Scoping

10.9.4 動的スコープの正しい使い方
----------------------------------------------

ある関数で変数を束縛し別の関数でそれを使うことは、強力な技法ですが、
なんの制限もせずに使うとプログラムを理解し難いものにしてしまいます。
この技法を見通しよく使うための2つの方法があります。

   * 1つのファイル内で近くに書いた関連する少数の関数でだけ、
     変数を使ったり束縛したりする。
     そのような変数は、1つのプログラム内での通信に使う。

     他のプログラマに対して、彼らがそのような変数を目にするまえに、
     そのような変数の使い方がわかるようなコメントを書き、
     他の場所では使わないように助言しておく。

   * 変数にはよくわかる意味を与え、
     それに関連する適切なすべての関数が（束縛も設定もしないで）参照するようにする。
     たとえば、変数`case-fold-search'は、
     『`nil'以外であれば探索時に大文字小文字を区別しない』と定義されている。
     さまざまな探索関数や置換関数が、この変数を直接に、あるいは、
     サブルーティンを介して参照するが、
     この変数を束縛したり設定したりしない。

     こうしておいて別のプログラムで変数を束縛するが、
     それにどのような効果があるか確実に知ってから行える。

   いずれの場合でも、変数は`defvar'で定義するべきです。
これは、関数間での変数の使い方を見るように伝えることで、
他人が読者のプログラムを理解するのを助けます。
また、バイトコンパイラからの警告も防ぎます。
変数名が衝突しないようにも注意しましょう。
`x'のような短い名前を使わないでください。


File: elisp-ja,  Node: Buffer-Local Variables,  Next: Frame-Local Variables,  Prev: Variable Scoping,  Up: Variables

10.10 バッファローカルな変数
=======================================

グローバルとローカルの変数束縛は、
ほとんどのプログラム言語にいろいろな形であります。
Emacsには、あまり普通でない追加の種類の変数束縛があります。
1つのバッファだけに適用される"バッファローカル"な束縛、
1つのフレームだけに適用されるフレームローカルな束縛です。
異なるバッファやフレームごとに変数に異なる値があるということは、
重要なカスタマイズ技法です。

   本節では、バッファローカルな束縛を説明します。
フレームローカルな束縛については、つぎの節と *Note Frame-Local
Variables::。 （各端末にローカルな束縛を持つ変数も少数ある。 *note
Multiple Displays::。）

* Menu:

* Intro to Buffer-Local::      Introduction and concepts.
* Creating Buffer-Local::      Creating and destroying buffer-local bindings.
* Default Value::              The default value is seen in buffers
                                 that don't have their own buffer-local values.


File: elisp-ja,  Node: Intro to Buffer-Local,  Next: Creating Buffer-Local,  Up: Buffer-Local Variables

10.10.1 バッファローカルな変数の紹介
--------------------------------------------------

バッファローカルな変数には、特定のバッファに関連したバッファローカルな
束縛があります。
この束縛は、そのバッファがカレントバッファであるときに有効になります。
さもなければなんの効果もありません。
バッファローカルな束縛が有効なときに変数に設定すると、
新しい値はその束縛に入り、他の束縛は変更されません。
つまり、その変更は、変更を行ったバッファだけで見ることができるのです。

   変数の通常の束縛、つまり、特定のバッファに関連していない束縛を
"デフォルトの束縛"（default binding）と呼びます。
多くの場合、これはグローバル束縛です。

   変数は、あるバッファ群ではバッファローカルな束縛を持ち、
他のバッファではそのような束縛を持たないようにできます。
変数に対する独自の束縛を持たないバッファすべてでは、
デフォルトの束縛を共有します。
（これには、新たに作成されるバッファも含む。）
バッファローカルな束縛を持たないバッファで変数に設定すると、
（状況を複雑にするフレームローカルな束縛はないと仮定して）
デフォルトの束縛を使います。
したがって、新たな値はデフォルトの束縛を見るバッファすべてで見えます。

   バッファローカルな束縛のもっとも一般的な使い方は、
メジャーモードでコマンドのふるまいを制御する変数に変更することです。
たとえば、CモードやLispモードでは、変数`paragraph-start'を設定して、
空行だけが段落を区切るように指定します。
これには、CモードやLispモードになったバッファでは、
変数をバッファローカルにしてから、
そのモード用の新たな値を変数に設定するのです。 *Note Major Modes::。

   バッファローカルな束縛を作る普通の方法は、
`make-local-variable'です。
メジャーモードのコマンドは典型的にこれを使います。
これはカレントバッファだけに影響します。
（これから作成するものも含めて）他のすべてのバッファは、
それ専用のバッファローカルな束縛を明示的に与えない限り、
デフォルト値を共有し続けます。

   より強力な操作は、`make-variable-buffer-local'を呼び出して
変数を"自動的にバッファローカルに"するように印を付けることです。
これは、これから作成するものも含めたバッファすべてで、
変数をバッファローカルにすると考えることができます。
より正確には、変数がカレントバッファにローカルでなければ、
自動的に変数をカレントバッファにローカルにするように設定する効果があります。
すべてのバッファは通常どおり変数のデフォルト値を共有して始まりますが、
変数に設定するとカレントバッファにバッファローカルな束縛を作ります。
新たな値はバッファローカルな束縛に格納され、デフォルトの束縛は変更しません。
つまり、どのバッファでもデフォルト値を`setq'では変更できません。
デフォルト値を変更する唯一の方法は、`setq-default'を使うことです。

   *警告：*` '
複数のバッファにおいて変数にバッファローカルな値があるときに、
変数を`let'で束縛してから、
別の束縛が有効である別のバッファに切り替えて`let'を抜けると、
Emacsをとても混乱させることになる。
こうすると、バッファローカルな束縛とデフォルトの束縛を混ぜ合わせてしまう。

   混乱を避けるために、このような変数の使い方は避けてください。
別のバッファに切り替える各コード部分を`save-excursion'で囲めば、
このような問題はありません。

     (setq foo 'b)
     (set-buffer "a")
     (make-local-variable 'foo)
     (setq foo 'a)
     (let ((foo 'temp))
       (set-buffer "b")
       BODY...)
     foo => 'a      ; バッファ`a'の古いバッファローカルな値が
                    ;   現在のデフォルト値
     (set-buffer "a")
     foo => 'temp   ; 消えているべきローカルな`let'の値が
                    ;   バッファ`a'の現在のバッファローカルな値

しかし、つぎに示すように`save-excursion'を使えば、この問題を回避できます。

     (let ((foo 'temp))
       (save-excursion
         (set-buffer "b")
         BODY...))

   BODY内での`foo'への参照は、
バッファ`b'のバッファローカルな束縛を使います。

   ファイルでローカル変数の値を指定していると、
そのファイルを訪問したときに、それらはバッファローカルな値になります。
*Note ファイルにローカルな変数: (emacs)File Variables。


File: elisp-ja,  Node: Creating Buffer-Local,  Next: Default Value,  Prev: Intro to Buffer-Local,  Up: Buffer-Local Variables

10.10.2 バッファローカルな束縛の作成と削除
-----------------------------------------------------------

 -- コマンド: make-local-variable variable
     この関数は、カレントバッファにおいて、
     VARIABLE（シンボル）のバッファローカルな束縛を作る。
     他のバッファは影響されない。 返す値はVARIABLE。

     VARIABLEのバッファローカルな値は、 VARIABLEの以前と同じ値で始まる。
     VARIABLEが空であれば、空のままである。

          ;; バッファ`b1'では、
          (setq foo 5)                ; すべてのバッファに影響する
               => 5
          (make-local-variable 'foo)  ; `b1'にローカル
               => foo
          foo                         ; これは値を
               => 5                   ;   変えない
          (setq foo 6)                ; `b1'での値を
               => 6                   ;   変更する
          foo
               => 6

          ;; バッファ`b2'では、値は変わっていない
          (save-excursion
            (set-buffer "b2")
            foo)
               => 5

     変数の`let'束縛の内側でその変数をバッファローカルにしても、
     そのバッファが`let'に入るときや抜けるときに
     カレントバッファになっていないと、正しく動作しない。
     これは、`let'が、異なる種類の束縛を区別しないからであり、
     どの変数の束縛を作るかだけを知っているからである。

     変数が端末にローカルなときには、この関数はエラーを通知する。
     そのような変数は、同時にバッファローカルな束縛を持てない。 *Note
     Multiple Displays::。

     *注意：*` ' フック変数に対して`make-local-variable'を使わないこと。
     そのかわりに`make-local-hook'を使う。 *note Hooks::。

 -- コマンド: make-variable-buffer-local variable
     この関数は、VARIABLE（シンボル）を
     自動的にバッファローカルにするように印を付け、
     これ以降にその変数に設定しようとすると、
     その時点のカレントバッファにローカルにする。

     この機能の重要な点は、
     （`let'や他の束縛を作る構文で）変数を束縛しても、
     その変数のバッファローカルな束縛を作らないことである。
     （`set'や`setq'で）変数を設定して初めてそのようにする。

     返す値はVARIABLEである。

     *警告：*` '
     ユーザーが異なるバッファでは異なったカスタマイズをするかも_しれない_と
     いうだけで、ユーザーオプション変数に`make-variable-buffer-local'を
     使うべきだと仮定しないこと。
     ユーザーは、必要ならば、どんな変数でもローカルにできる。
     選択はユーザーに任せるのがよい。

     2つのバッファが同じ束縛を共有しないことが重要な場面では、
     `make-variable-buffer-local'を使う。
     たとえば、異なるバッファでは異なる値を持つことに依存するような
     Lispプログラムで内部目的に変数を使うときには、
     `make-variable-buffer-local'を使うのが最良である。

 -- Function: local-variable-p variable &optional buffer
     これは、VARIABLEがバッファBUFFER
     （デフォルトはカレントバッファ）において
     バッファローカルであれば`t'を返し、 さもなければ`nil'を返す。

 -- Function: buffer-local-variables &optional buffer
     この関数は、バッファBUFFERのバッファローカルな変数を
     記述したリストを返す。
     （BUFFERを省略するとカレントバッファを使う。）
     バッファローカルな変数とその値を入れた要素から成る連想リスト
     （*note Association Lists::）を返す。
     しかし、BUFFERにおける変数のバッファローカルな束縛が空であると、
     変数は結果のリストに直接現れる。

          (make-local-variable 'foobar)
          (makunbound 'foobar)
          (make-local-variable 'bind-me)
          (setq bind-me 69)
          (setq lcl (buffer-local-variables))
              ;; まず、すべてのバッファでローカルな組み込み変数
          => ((mark-active . nil)
              (buffer-undo-list . nil)
              (mode-name . "Fundamental")
              ...
              ;; 続いて、組み込みでないバッファローカルな変数
              ;; これはバッファローカルで、かつ、空
              foobar
              ;; これはバッファローカルで、かつ、空ではない
              (bind-me . 69))

     このリストのコンスセルのCDRに新たな値を格納しても、
     変数のバッファローカルな値を変更_しない_ことに注意してほしい。

 -- コマンド: kill-local-variable variable
     この関数は、カレントバッファにおけるVARIABLE（シンボル）の
     バッファローカルな束縛を（あれば）削除する。
     その結果、このバッファでは、VARIABLEのデフォルトの束縛が
     見えるようになる。 典型的には、VARIABLEの値が変わる。
     なぜなら、デフォルト値は、削除したバッファローカルな値とは
     普通は異なるからである。

     自動的にバッファローカルにする印が付いた変数のバッファローカルな束縛を
     削除すると、カレントバッファではデフォルト値が見えるようになる。
     しかし、変数に再度設定すると、それに対するバッファローカルな束縛が
     再度作成される。

     `kill-local-variable'はVARIABLEを返す。

     この関数がコマンドであるのは、
     対話的にバッファローカルな変数を作るのが有用なように、
     対話的にバッファローカルな変数を削除するのが有用な場合があるからである。

 -- Function: kill-all-local-variables
     この関数は、カレントバッファにおいて、
     『恒久的』と印付けしてある変数を除いて、
     すべてのバッファローカルな変数束縛を削除する。
     その結果、バッファでは、ほとんどの変数のデフォルト値が見えるようになる。

     この関数は、バッファに属する他のある種の情報もリセットする。
     つまり、ローカルキーマップに`nil'、
     構文テーブルに`(standard-syntax-table)'の値、
     大文字小文字テーブルに`(standard-case-table)'、
     略語テーブルに`fundamental-mode-abbrev-table'の値を設定する。

     この関数が最初に行うことは、
     ノーマルフック`change-major-mode-hook'（下記参照）を
     実行することである。

     各メジャーモードコマンドはこの関数を呼び出すことから始める。
     つまり、基本（fundamental）モードに切り替え、
     それ以前のメジャーモードのほとんどの効果を消しさる。
     この処理を保証するために、メジャーモードで設定する変数には、
     恒久的の印を付けないこと。

     `kill-all-local-variables'は`nil'を返す。

 -- Variable: change-major-mode-hook
     関数`kill-all-local-variables'は、最初にこのノーマルフックを実行する。
     このフックはメジャーモードに対して、
     ユーザーが別のメジャーモードに切り替えていた場合には、
     なにか特別なことを行う情報を提供する。
     最良の結果を得るためには、この変数をバッファローカルにしておくと
     その役目を終えると変数は消えてしまい、それ以降のメジャーモードに干渉しない。
     *note Hooks::。

   バッファローカル変数は、
変数名（シンボル）の属性`permanent-local'が`nil'以外であると、
"恒久的"（permanent）です。
恒久的なローカル変数は、編集作業の文脈ではなく、
どのファイルを訪問中であるとかどのように保存するとかに関連する情報に
適しています。


File: elisp-ja,  Node: Default Value,  Prev: Creating Buffer-Local,  Up: Buffer-Local Variables

10.10.3 バッファローカル変数のデフォルト値
-----------------------------------------------------------

バッファローカルな束縛がある変数のグローバル値を、
"デフォルト"値とも呼びます。
カレントバッファや選択したフレームに変数の独自の束縛がない場合に、
グローバル値を使うからです。

   関数`default-value'と関数`setq-default'は、
カレントバッファにバッファローカルな束縛があるかどうかに関わらず、
変数のデフォルト値を参照したり変更したりします。
たとえば、`setq-default'を使って、
ほとんどのバッファの`paragraph-start'のデフォルト値を変更できます。
この変数のバッファローカルな値があるCモードやLispモードのバッファで
行ってもこれは動作します。

   スペシャルフォーム`defvar'や`defconst'も、
バッファローカルやフレームローカルな値ではなく、
（変数に設定する場合には）デフォルト値を設定します。

 -- Function: default-value symbol
     この関数は、SYMBOLのデフォルト値を返す。
     この値は、この変数に対して独自の値を持たないバッファやフレームで見える
     値である。 SYMBOLがバッファローカルでなければ、
     これは、`symbol-value'（*note Accessing Variables::）と等価。

 -- Function: default-boundp symbol
     関数`default-boundp'は、
     SYMBOLのデフォルト値が空でないことを調べる。 `(default-boundp
     'foo)'が`nil'を返せば、 `(default-value 'foo)'はエラーになる。

     `default-boundp'は、`boundp'が`symbol-value'に対応するように、
     `default-value'に対応する。

 -- Special Form: setq-default [symbol form]...
     このスペシャルフォームは、各SYMBOLに、
     対応するFORMの評価結果である新たなデフォルト値を与える。
     SYMBOLは評価しないが、FORMは評価する。
     フォーム`setq-default'の値は、最後のFORMの値である。

     SYMBOLがカレントバッファでバッファローカルではなく、かつ、
     自動的にバッファローカルにする印が付いていなければ、
     `setq-default'は`setq'と同じ効果がある。
     SYMBOLがカレントバッファでバッファローカルならば、
     （バッファローカルな値を持たない）別のバッファが見る値を変更し、
     カレントバッファが見る値は変更しない。

          ;; バッファ`foo'において、
          (make-local-variable 'buffer-local)
               => buffer-local
          (setq buffer-local 'value-in-foo)
               => value-in-foo
          (setq-default buffer-local 'new-default)
               => new-default
          buffer-local
               => value-in-foo
          (default-value 'buffer-local)
               => new-default

          ;; （新たな）バッファ`bar'では、
          buffer-local
               => new-default
          (default-value 'buffer-local)
               => new-default
          (setq buffer-local 'another-default)
               => another-default
          (default-value 'buffer-local)
               => another-default

          ;; バッファ`foo'に戻ってみると
          buffer-local
               => value-in-foo
          (default-value 'buffer-local)
               => another-default

 -- Function: set-default symbol value
     この関数は`setq-default'に似ているが、
     SYMBOLは普通どおりに評価される引数である。

          (set-default (car '(a b c)) 23)
               => 23
          (default-value 'a)
               => 23


File: elisp-ja,  Node: Frame-Local Variables,  Next: Future Local Variables,  Prev: Buffer-Local Variables,  Up: Variables

10.11 フレームローカルな変数
=======================================

変数にバッファローカルな束縛があるように、
変数にはフレームローカルな束縛もあります。
これらの束縛は1つのフレームに属し、
そのフレームを選択しているときに有効になります。
フレームローカルな束縛は、実際にはフレームパラメータです。
特定のフレームでフレームローカルな束縛を作るには
`modify-frame-parameters'を呼び出し、
パラメータ名として変数名を指定します。

   特定の変数に対するフレームローカルな束縛を有効にするには、
関数`make-variable-frame-local'を呼び出します。

 -- コマンド: make-variable-frame-local variable
     VARIABLEに対してフレームローカルな束縛を使うようにする。
     この関数そのものはVARIABLEに対してフレームローカルな束縛を作成しない。
     しかし、フレームパラメータとしてVARIABLEの値を持つフレームが
     すでに存在すれば、その値は自動的にフレームローカルな束縛になる。

     変数が端末にローカルであると、この関数はエラーを通知する。
     そのような変数はフレームローカルな束縛を同時には持てないからである。
     *note Multiple Displays::。
     Emacsで特別に実装されている少数の変数は（普通）
     バッファローカルになることができるが、フレームローカルにはならない。

   バッファローカルな束縛はフレームローカルな束縛に優先します。
変数`foo'を考えてみましょう。
カレントバッファに`foo'のバッファローカルな束縛があると、
その束縛が有効になります。
選択したフレームに`foo'のフレームローカルな束縛があると、
その束縛が有効になります。
さもなければ、`foo'のデフォルトの束縛が有効になります。

   つぎに例を示します。 まず、`foo'の束縛を準備しておきます。

     (setq f1 (selected-frame))
     (make-variable-frame-local 'foo)

     ;; `b1'において、`foo'のバッファローカルな束縛を作る
     (set-buffer (get-buffer-create "b1"))
     (make-local-variable 'foo)
     (setq foo '(b 1))

     ;; 新しいフレームで`foo'のフレームローカルな束縛を作る
     ;; そのフレームを`f2'に格納する
     (setq f2 (make-frame))
     (modify-frame-parameters f2 '((foo . (f 2))))

   では、さまざまな文脈で`foo'を調べてみましょう。
バッファ`b1'がカレントバッファであれば、 選択したフレームに関係なく、
`b1'のバッファローカルな束縛が有効になっています。

     (select-frame f1)
     (set-buffer (get-buffer-create "b1"))
     foo
          => (b 1)

     (select-frame f2)
     (set-buffer (get-buffer-create "b1"))
     foo
          => (b 1)

さもなければ、フレームの束縛を使う可能性があります。
フレーム`f2'を選択していると、
そのフレームローカルな束縛が有効になります。

     (select-frame f2)
     (set-buffer (get-buffer "*scratch*"))
     foo
          => (f 2)

カレントバッファにもフレームにも束縛がなければ、
デフォルトの束縛を使います。

     (select-frame f1)
     (set-buffer (get-buffer "*scratch*"))
     foo
          => nil

変数の有効な束縛がフレームローカルな束縛であるとき、
変数に設定するとその束縛を変更します。
`frame-parameters'でその結果を見ることができます。

     (select-frame f2)
     (set-buffer (get-buffer "*scratch*"))
     (setq foo 'nobody)
     (assq 'foo (frame-parameters f2))
          => (foo . nobody)


File: elisp-ja,  Node: Future Local Variables,  Prev: Frame-Local Variables,  Up: Variables

10.12 将来のローカル変数
=================================

フレームに分類されるものでローカルな束縛というアイデアを考察しています。
たとえば、すべてのカラーフレーム、暗い背景色のすべてのフレームなどです。
この機能が本当に有用なのか明らかでないので、それらをまだ実装してはいません。
`after-make-frame-hook'に関数を追加して、
各フレームの適切な状態に応じたフレームパラメータを設定すれば、
同じような結果を得られます。

   ウィンドウローカルな束縛を実装することも可能です。
これが有用である多くの状況を知りませんが、
バッファローカルな束縛を持つ間接バッファ（*note Indirect Buffers::）で、
そのような状況をより堅牢に扱えると思います。

これら2種類のローカル束縛のいずれかを必要とする十分な数のアプリケーションが
みつかれば、Emacsの将来の版でそのような束縛を提供するでしょう。


File: elisp-ja,  Node: Functions,  Next: Macros,  Prev: Variables,  Up: Top

11 関数
*********

Lispプログラムは、主にLisp関数から構成されます。
本章では、関数とはなにか、引数をどのように受け取るのか、
どのように関数を定義するのかを説明します。

* Menu:

* What Is a Function::    Lisp functions vs. primitives; terminology.
* Lambda Expressions::    How functions are expressed as Lisp objects.
* Function Names::        A symbol can serve as the name of a function.
* Defining Functions::    Lisp expressions for defining functions.
* Calling Functions::     How to use an existing function.
* Mapping Functions::     Applying a function to each element of a list, etc.
* Anonymous Functions::   Lambda expressions are functions with no names.
* Function Cells::        Accessing or setting the function definition
                            of a symbol.
* Inline Functions::	  Defining functions that the compiler will open code.
* Related Topics::        Cross-references to specific Lisp primitives
                            that have a special bearing on how functions work.


File: elisp-ja,  Node: What Is a Function,  Next: Lambda Expressions,  Up: Functions

11.1 関数とはなにか
==========================

一般的には、関数とは、"引数"（arguments）と呼ばれる値を与えられ、
計算を行うための規則です。 この計算結果を関数の値と呼びます。
計算では副作用、つまり、変数の値やデータ構造の内容に継続する変更
を伴うこともできます。

   Emacs
Lispの関数や関数のようなオブジェクトに関する重要な用語をあげておきます。

"関数"
     Emacs Lispでは、Lispプログラムにおいて引数に適用可能ものは
     なんであれ"関数"（function）である。
     Lispで書いた関数を意味する場合もある。
     スペシャルフォームやマクロは関数ではない。

"基本関数"
     "基本関数"（primitive）は、`car'や`append'などのCで書いた
     Lispから呼び出し可能な関数である。
     これらの関数は、"組み込み"関数とか"subrs"とも呼ぶ。
     （スペシャルフォームは基本関数とも考えられる。）

     関数を基本関数として実装する理由は、 それが基本的なものである、
     それがオペレーティングシステムの機能に対する
     低レベルのインターフェイスを提供する、
     あるいは、高速に動作する必要があるからである。
     基本関数を変更したり追加する唯一の方法は、
     Cソースを変更してエディタを再コンパイルすることである。 *note
     Writing Emacs Primitives::。

"ラムダ式"
     "ラムダ式"（lambda expression）は、Lispで書いた関数である。
     これらについては以下の節で説明する。 *Note Lambda Expressions::。

"スペシャルフォーム"
     "スペシャルフォーム"（special form）は関数に似た基本関数であるが、
     その引数すべてを普通のようには評価しない。
     引数の一部を評価したり、普通とは異なる順序で評価したり、
     複数回評価したりする。 多くのスペシャルフォームについては、 *note
     Control Structures::で説明してある。

"マクロ"
     "マクロ"（macro）は、プログラマがLispで定義した構文である。
     マクロと関数との違いは、マクロは、
     読者が書いたLisp式をもとの式のかわりに評価される等価な式に変換する。
     マクロは、スペシャルフォームでできる種類のことを
     Lispプログラマに提供する。
     マクロの定義方法と使い方については、*note Macros::。

"コマンド"
     "コマンド"（command）とは、
     `command-execute'が起動できるオブジェクトであり、
     キー列に対して定義できる。 いくつかの関数はコマンドである。
     Lispで書いた関数に対話宣言（*note Defining
     Commands::）が含まれているとき、 その関数はコマンドである。
     そのような関数は、他の関数と同様にLisp式から呼び出すことができる。
     その場合、関数がコマンドであるという事実は関係ない。

     キーボードマクロ（文字列かベクトル）もコマンドであるが、
     それらは関数ではない。
     シンボルの関数定義がコマンドであれば、シンボルはコマンドである。
     そのようなシンボルは、`M-x'で起動できる。
     シンボルの定義が関数であれば、シンボルは関数でもある。

"打鍵コマンド"
     "打鍵コマンド"（keystroke command）とは、
     キー列（典型的には1から3打鍵）にバインドされたコマンドである。
     ここでの区別は、Emacs以外のエディタの『コマンド』の意味との
     混乱を防ぐためであるが、
     Lispプログラムにとっては、この区別は普通は重要ではない。

"バイトコード関数"
     "バイトコード関数"（byte-code function）とは、
     バイトコンパイラでコンパイルした関数である。 *note Byte-Code
     Type::。

 -- Function: functionp object
     この関数は、OBJECTが、なんらかの関数、スペシャルフォーム、
     マクロであれば、`t'を返す。

 -- Function: subrp object
     この関数は、OBJECTが組み込み関数（つまり、Lisp基本関数）であれば
     `t'を返す。

          (subrp 'message)            ; `message'はシンボルであり、
               => nil                 ;   subrオブジェクトではない
          (subrp (symbol-function 'message))
               => t

 -- Function: byte-code-function-p object
     この関数は、OBJECTがバイトコード関数であれば`t'を返す。
     たとえば、つぎのとおり。

          (byte-code-function-p (symbol-function 'next-line))
               => t


File: elisp-ja,  Node: Lambda Expressions,  Next: Function Names,  Prev: What Is a Function,  Up: Functions

11.2 ラムダ式
=================

Lispで書いた関数はつぎのようなリストです。

     (lambda (ARG-VARIABLES...)
       [DOCUMENTATION-STRING]
       [INTERACTIVE-DECLARATION]
       BODY-FORMS...)

このようなリストを"ラムダ式"（lambda expression）と呼びます。 Emacs
Lispでは、これは式として正しいもので、 それ自身に評価されます。
Lispの他の方言では、ラムダ式は正しい式ではありません。
いずれの場合でも、その主な用途は式として評価することではなく、
関数として呼び出すことです。

* Menu:

* Lambda Components::       The parts of a lambda expression.
* Simple Lambda::           A simple example.
* Argument List::           Details and special features of argument lists.
* Function Documentation::  How to put documentation in a function.


File: elisp-ja,  Node: Lambda Components,  Next: Simple Lambda,  Up: Lambda Expressions

11.2.1 ラムダ式の構成要素
----------------------------------

Lispで書いた関数（『ラムダ式』）はつぎのようなリストです。

     (lambda (ARG-VARIABLES...)
       [DOCUMENTATION-STRING]
       [INTERACTIVE-DECLARATION]
       BODY-FORMS...)

ラムダ式の先頭要素は、つねにシンボル`lambda'です。
このシンボルは、リストが関数を表すことを示します。
関数は`lambda'で始まると定義してあるのは、
他の目的向けの他のリストが誤って正しい関数とならないようにするためです。

   第2要素は、シンボルのリスト、つまり、引数変数名です。
これを"ラムダリスト"（lambda list）と呼びます。
Lisp関数が呼ばれると、引数値をラムダリストの変数に対応させ、
指定した値を持つローカル束縛になります。 *Note Local Variables::。

   説明文字列は、関数定義の内側にあるLisp文字列オブジェクトであり、
Emacsのヘルプ機能に対して関数を記述します。 *Note Function
Documentation::。

   対話宣言は、`(interactive CODE-STRING)'の形式のリストです。
この宣言は、関数が対話的に使われたときに、
どのように引数を与えるかを指定します。
この宣言を有する関数を"コマンド"（commands）と呼びます。
コマンドは、`M-x'で呼び出したり、キーにバインドできます。
このように呼ばれることを意図していない関数には、
対話宣言を付けてはいけません。 対話宣言の書き方については、*Note
Defining Commands::。

   残りの要素は、関数の"本体"（body）です。
関数の動作を行うLispコードです
（Lispプログラマとしては、『評価するべきLispフォームのリスト』という）。
関数が返す値は、本体の最後の要素が返す値です。


File: elisp-ja,  Node: Simple Lambda,  Next: Argument List,  Prev: Lambda Components,  Up: Lambda Expressions

11.2.2 簡単なラムダ式の例
----------------------------------

つぎの関数を考えてみましょう。

     (lambda (a b c) (+ a b c))

この関数を呼び出すには、つぎのように式のCARにこの関数を書きます。

     ((lambda (a b c) (+ a b c))
      1 2 3)

この呼び出しは、変数`a'には1、変数`b'には2、
変数`c'には3を束縛し、ラムダ式の本体を評価します。
本体の評価ではこれらを加算し、結果6を生じます。
したがって、この関数呼び出しは6を返します。

   つぎの例のように、他の関数呼び出しの結果が引数になることもあります。

     ((lambda (a b c) (+ a b c))
      1 (* 2 3) (- 5 4))

これは、引数、`1'、`(* 2 3)'、`(- 5 4)'を 左から右へ順に評価します。
そして、引数値、1、6、1にラムダ式を適用し、値8を生じます。

   このようにフォームのCARとしてラムダ式を書くのは、
あまり便利ではありません。 スペシャルフォーム`let'（*note Local
Variables::）を使って、
ローカル変数を作ってそれらに値を与えても、同じ結果を得られます。
さらに、`let'は見通しがよく使いやすいです。
実用上、ラムダ式は、シンボルの関数定義として格納して名前付き関数を作るか、
他の関数に引数として渡します（*note Anonymous Functions::）。

   しかしながら、スペシャルフォーム`let'がなかった初期のLispでは、
ラムダ式を明示的に呼び出すことはとても便利でした。
その頃では、ラムダ式はローカル変数を束縛し初期化する唯一の方法でした。


File: elisp-ja,  Node: Argument List,  Next: Function Documentation,  Prev: Simple Lambda,  Up: Lambda Expressions

11.2.3 引数リストのその他の機能
-------------------------------------------

単純な関数の例`(lambda (a b c) (+ a b c))'では、
3つの引数変数を指定しているので、これは3引数で呼び出す必要があります。
2引数や4引数で呼び出そうとすると、
エラー`wrong-number-of-arguments'になります。

   特定の引数を省略できる関数を書けると便利なことがしばしばあります。
たとえば、関数`substring'は3つの引数、つまり、
文字列、開始と終了の添字を取りますが、
第3引数を省略するとデフォルトは文字列のLENGTHになります。
`list'や`+'のように、
特定の関数では任意個数の引数を受け付けると便利なこともあります。

   関数呼び出し時に省略してもよい引数を指定するには、
省略可能な引数のまえにキーワード`&optional'を含めるだけです。
0個以上の引数のリストを指定するには、
最後の引数のまえにキーワード`&rest'を含めます。

   したがって、引数リストの完全な構文はつぎのようになります。

     (REQUIRED-VARS...
                    ; 必須の引数
      [&optional OPTIONAL-VARS...]
                    ; 省略可能な引数
      [&rest REST-VAR])
                    ; 残りの引数

角括弧は、`&optional'や`&rest'の節や
それに続く変数は省略できることを示します。

   関数呼び出し時には、各REQUIRED-VARSに1つの実引数が必要です。
0個以上のOPTIONAL-VARSにも実引数が必要ですが、
ラムダリストに`&rest'がない限り、
OPTIONAL-VARSの個数を超える実引数は指定できません。
`&rest'があれば、任意個の余分な実引数を指定できます。

   `&optional'や`&rest'に対応する実引数を省略すると、
それらのデフォルトは`nil'です。
関数では、`nil'を明示した引数と省略した引数とを区別する方法はありません。
しかしながら、関数本体で`nil'を適切な意味ある値の省略と
みなすことは自由です。 `substring'はそのようにしています。
`substring'の第3引数が`nil'であると、
指定した文字列の長さを使うことを意味します。

     Common Lispに関した注意：` ' Common
     Lispでは、省略可能引数を省略したときのデフォルト値を関数で指定できる。
     Emacs Lispではつねに`nil'を使う。 Emacs
     Lispには、明示的に引数を指定したかどうか調べる
     『supplied-p』変数はない。

   たとえば、引数リストはつぎのようになります。

     (a b &optional c d &rest e)

これは、`a'と`b'に最初の2つの実引数を束縛し、これらは必須です。
さらに1個か2個の引数を指定すると、
それらは、それぞれ`c'と`d'に束縛します。
最初の4個よりあとの引数はリストにまとめ、 `e'にそのリストを束縛します。
引数が2個だけであると、`c'は`nil'です。
引数が2個か3個だけであると、`d'は`nil'です。
引数が4個以下であると、`e'は`nil'です。

   省略可能な引数のあとに必須引数を指定する方法はありませんし、
それには意味がありません。 なぜそうなのかを理解するために、上の例で、
`c'は省略可能であり、`d'は必須であるとしましょう。
3つの実引数を指定したとき、どの引数を3番目と考えるのでしょう？` '
同様に、`&rest'のうしろに余分に（必須、もしくは省略可能な）引数が
あっても意味がありません。

   引数リストと正しい呼び出しの例をあげます。

     ((lambda (n) (1+ n))                ; 1個が必須
      1)                                 ; 引数は1個だけ
          => 2
     ((lambda (n &optional n1)           ; 1個は必須、1個は省略可
              (if n1 (+ n n1) (1+ n)))   ; 引数は1個か2個
      1 2)
          => 3
     ((lambda (n &rest ns)               ; 1個は必須、あとは残り全部
              (+ n (apply '+ ns)))       ; 引数は1個以上いくつでもよい
      1 2 3 4 5)
          => 15


File: elisp-ja,  Node: Function Documentation,  Prev: Argument List,  Up: Lambda Expressions

11.2.4 関数の説明文字列
-------------------------------

ラムダ式には、ラムダリストの直後に "説明文字列"（documentation
string）があってもかまいません。
この文字列は関数の実行には影響しません。
コメントのようなものですが、Lisp内部に現れる系統的なコメントであり、
Emacsのヘルプ機能が使用します。
DOCUMENTATION-STRINGの参照方法については、*Note Documentation::。

   読者のプログラムの関数すべてに、
たとえ内部的に使用されるものであっても説明文字列を与えることはよいことです。
説明文字列はコメントに似ていますが、参照するのはもっと簡単です。

   説明文字列の先頭行は、その1行で完結しているべきです。
というのは、`apropos'は先頭行だけを表示するからです。
関数の機能をまとめた1つか2つの文にしましょう。

説明文字列の先頭は、ソースファイル上では普通字下げしてあるでしょうが、
それらの空白は文字列を始めるダブルクォートのまえにありますから、
それらは文字列の一部ではありません。 説明文字列の残りの行を字下げして、
プログラムソース上でテキスト行が揃うようにする人もいます。
しかし、_それはまちがいです_。
後続の行の字下げは文字列の内側にあります。
ソースファイルで綺麗に見えても、
ヘルプコマンドの表示では不恰好になります。

   関数の必須の構成要素（本体）があとに続くのに、
説明文字列を省略できるのを不思議に思うかもしれません。
文字列を評価すると、副作用なしに、その文字列を返すので、
それが本体の最後のフォームでなければ、なんの効果もありません。
したがって、実用上、本体の最初のフォームと
説明文字列を混同することはありません。
本体のフォームが文字列だけであると、
それは戻り値でもあり説明文字列でもあります。


File: elisp-ja,  Node: Function Names,  Next: Defining Functions,  Prev: Lambda Expressions,  Up: Functions

11.3 関数を命名する
==========================

ほとんどの計算機言語では、各関数には名前があります。
名前のない関数という考えは本質的ではありません。
Lispでは、もっとも厳密にいえば、関数には名前はありません。
関数は、先頭要素が単に`lambda'であるリスト、
バイトコード関数オブジェクト、あるいは、基本関数のsubrオブジェクトです。

   しかしながら、シンボルは関数の名前として働きます。
シンボルの"関数セル"（function cell、*note Symbol Components::）に
関数を入れると、このようになります。
そうすると、シンボルそのものは正当な呼び出し可能な関数となり、
関数セルが参照するリストやsubrオブジェクトと等価になります。
関数セルの内容をシンボルの"関数定義"（function
definition）とも呼びます。
シンボルのかわりにシンボルの関数定義を使う処理を
"シンボルの関数間接"（symbol function indirection）と呼びます。 *Note
Function Indirection::。

   実用上、ほとんどすべての関数には、このようにして名前が付いていて、
その名前で参照します。 たとえば、シンボル`car'は、
その関数セルに基本関数のsubrオブジェクト`#<subr
car>'が格納してあるので、 その動作を行う関数として動作します。

関数に名前を与えるのは、Lisp式からその名前で参照できると便利だからです。
`#<subr car>'のような基本関数のsubrオブジェクトでは、
名前はそれらを参照する唯一の方法です。
そのようなオブジェクトには入力構文はありません。
Lispで書いた関数では、明示的なラムダ式より名前を使うほうがより便利です。
また、関数に名前があればそれを参照できます。
つまり、再帰呼び出しができます。
関数の名前をその定義そのものに書くことは、
関数定義がそれ自身を指すようにする
（これは不可能ではないにしても、実用上はさまざまな欠点がある）よりは、
とても便利です。

   関数を指名するシンボルで関数をしばしば識別します。
たとえば、しばしば『関数`car'』といって、
シンボル`car'と関数定義である基本関数のsubrオブジェクトとを区別しません。
ほとんどの目的には、区別する必要はありません。

   たとえそうであっても、関数に一意な名前は必要ないことを
心に留めておいてください。
関数オブジェクトは_普通_1つのシンボルの関数セルだけに現れますが、
これは単なる便法です。
`fset'を使って、複数のシンボルに格納するのは簡単です。
そうすると、各シンボルは同じ関数を同等に指名します。

   関数名として使うシンボルは、変数としても使えます。
シンボルのこれら2つの使い方は独立していて衝突しません。
（SchemeなどのLispの方言のなかには、
シンボルの値とその関数定義を区別しないものもある。
変数としてのシンボルの値は、その関数定義でもある。）
シンボルに関数定義を与えていないと、そのシンボルを関数としては使えません。
これは、シンボルに変数としての値があるかどうかには関係しません。


File: elisp-ja,  Node: Defining Functions,  Next: Calling Functions,  Prev: Function Names,  Up: Functions

11.4 関数を定義する
==========================

関数を作成するときには、普通、関数に名前を与えます。
これを"関数を定義する"と呼び、 スペシャルフォーム`defun'で行います。

 -- Special Form: defun name argument-list body-forms
     `defun'は、新たにLisp関数を定義する普通の方法である。
     これは、シンボルNAMEをつぎのような関数として定義する。

          (lambda ARGUMENT-LIST . BODY-FORMS)

     `defun'は、このラムダ式をNAMEの関数セルに格納する。
     値NAMEを返すが、普通、これは無視する。

     前述（*note Lambda Expressions::）のように、
     ARGUMENT-LISTは引数名のリストであり、
     キーワード`&optional'や`&rest'が入っていてもよい。
     また、BODY-FORMSの最初の2つは、説明文字列と対話宣言でもよい。

     同一のシンボルNAMEを変数として使っていても衝突はない。
     というのは、シンボルの値セルは関数セルとは独立だからである。 *note
     Symbol Components::。

     例を示そう。

          (defun foo () 5)
               => foo
          (foo)
               => 5

          (defun bar (a &optional b &rest c)
              (list a b c))
               => bar
          (bar 1 2 3 4 5)
               => (1 2 (3 4 5))
          (bar 1)
               => (1 nil nil)
          (bar)
          error--> Wrong number of arguments.

          (defun capitalize-backwards ()
            "Upcase the last letter of a word."
            (interactive)
            (backward-word 1)
            (forward-word 1)
            (backward-char 1)
            (capitalize-word 1))
               => capitalize-backwards

     既存の関数を意図せずに再定義しないように注意すること。
     `defun'は、たとえ`car'などの基本関数であっても、
     なんの躊躇も注意もせずに再定義してしまう。
     既存関数の再定義は注意深く行うが、
     不本意な再定義と熟考した再定義を区別する方法はない。

 -- Function: defalias name definition
     このスペシャルフォームは、
     シンボルNAMEを定義DEFINITION（任意の正しいLisp関数）とする
     関数として定義する。

     `defalias'を使う正しい場所は、
     特定の関数名が定義されている場所である。
     特に、ロード中のソースファイルで明示的に名前が現れている場所である。
     というのは、`defalias'は、`defun'と同様に、
     関数が定義されたファイルを記録するからである（*note Unloading::）。

     一方、他の目的で関数定義を操作するプログラムでは、
     そのような記録を保持しない`fset'を使うのがよい。

   `defun'のように関数を定義し、かつ、
Lispコンパイラに関数定義を展開するように指示する
`defsubst'も参照してください。 *Note Inline Functions::。


File: elisp-ja,  Node: Calling Functions,  Next: Mapping Functions,  Prev: Defining Functions,  Up: Functions

11.5 関数呼び出し
=======================

関数を定義することは、全体の半分でしかありません。
関数を"呼ぶ"までは、つまり、実行を命じなければ、関数はなにもしません。
関数呼び出しは"起動"（invocation）ともいいます。

   関数を起動するもっとも一般的な方法は、リストを評価することです。
たとえば、リスト`(concat "a" "b")'を評価すると、
関数`concat'を引数`"a"'と`"b"'で呼び出します。 評価については*Note
Evaluation::。

   読者のプログラムで式としてリストを書くときには、
呼び出す関数名を読者のプログラムに書きます。
つまり、プログラムを書くときに、
どの関数をどれだけの引数で呼び出すかを指定できることを意味します。
これが、普通にしたいことでしょう。
呼び出す関数を実行時に計算する必要がある場合もあるでしょう。
それには、関数`funcall'を使います。
渡す引数の個数を実行時に決定する必要があるときには、 `apply'を使います。

 -- Function: funcall function &rest arguments
     `funcall'は、FUNCTIONをARGUMENTSで呼び出し、
     FUNCTIONがなにを返そうともそれを返す。

     `funcall'は関数なので、FUNCTIONの呼び出しを評価するまえに
     FUNCTIONを含めた引数すべてを評価する。
     つまり、呼び出す関数を得るためのどんな式でも使えることを意味する。
     また、`funcall'は、読者がARGUMENTSに書いた式を見ることはなく、
     それらの値だけを見ることになる。
     これらの値は、FUNCTIONを呼び出す操作において、
     2回目の評価を行うことは_ない_。
     `funcall'は、通常の関数呼び出し処理において、
     引数を評価し終えたところから始める。

     引数FUNCTIONは、Lisp関数か基本関数である必要がある。
     スペシャルフォームやマクロは許されない。
     それらには、『未評価』の引数式を与えたときだけ意味があるからである。
     `funcall'ではそのようにできない。
     なぜなら、上の説明でわかるように、
     未評価の引数をまったく知らないからである。

          (setq f 'list)
               => list
          (funcall f 'x 'y 'z)
               => (x y z)
          (funcall f 'x 'y '(z))
               => (x y (z))
          (funcall 'and t nil)
          error--> Invalid function: #<subr and>

     これらの例を`apply'の例と比較してほしい。

 -- Function: apply function &rest arguments
     `apply'は、`funcall'のように、
     FUNCTIONをARGUMENTSで呼び出すが、1点だけ異なる。
     ARGUMENTSの最後はオブジェクトのリストであり、
     FUNCTIONにはこれを、単一のリストではなく、個々の引数として渡す。
     これを、`apply'は、
     このリストの個々の要素が引数となるように"分配する"という。

     `apply'は、FUNCTIONの呼び出し結果を返す。
     `funcall'と同様に、FUNCTIONはLisp関数か基本関数である必要がある。
     スペシャルフォームやマクロは、`apply'では意味がない。

          (setq f 'list)
               => list
          (apply f 'x 'y 'z)
          error--> Wrong type argument: listp, z
          (apply '+ 1 2 '(3 4))
               => 10
          (apply '+ '(1 2 3 4))
               => 10

          (apply 'append '((a b c) nil (x y z) nil))
               => (a b c x y z)

     `apply'を使った興味深い例として、 *note Mapping
     Functions::の`mapcar'の説明を見てほしい。

   Lisp関数にとっては、引数として関数を受け取ったり、
データ構造（特に、フック変数や属性リスト）内の関数を探して
`funcall'や`apply'を使ってそれを呼び出すことは一般的です。
関数引数を受け付ける関数を
しばしば"ファンクショナル"（functionals）と呼びます。

   場合によっては、ファンクショナルを呼び出すときには、
引数としてなにもしない関数（no-op）を指定できると有用です。
つぎのものは、2種類のなにもしない関数です。

 -- Function: identity arg
     この関数はARGを返し、副作用を持たない。

 -- Function: ignore &rest args
     この関数は引数を無視し、`nil'を返す。


File: elisp-ja,  Node: Mapping Functions,  Next: Anonymous Functions,  Prev: Calling Functions,  Up: Functions

11.6 マップ関数
====================

"マップ関数"（mapping function）は、
リストや他の集まりの各要素に指定した関数を適用します。 Emacs
Lispにはそのような関数がいくつかあります。
`mapcar'と`mapconcat'はリストを走査するもので、ここで説明します。
オブジェクト配列obarray内のシンボルについて
マップする関数`mapatoms'については、 *Note Creating Symbols::。

   これらのマップ関数では、文字テーブルは扱えません。
というのは、文字テーブルは疎な配列であり、その添字範囲も非常に大きいからです。
文字テーブルの疎な性質を考慮して文字テーブルについてマップするには、
関数`map-char-table'（*note Char-Tables::）を使います。

 -- Function: mapcar function sequence
     `mapcar'は、SEQUENCEの各要素に順にFUNCTIONを適用し、
     結果のリストを返す。

     引数SEQUENCEは文字テーブル以外の任意の種類のシーケンスでよい。
     つまり、リスト、ベクトル、ブールベクトル、あるいは、文字列である。
     結果はつねにリストである。 結果の長さはSEQUENCEの長さと同じである。

     たとえば、つぎのとおり。

          (mapcar 'car '((a b) (c d) (e f)))
               => (a c e)
          (mapcar '1+ [1 2 3])
               => (2 3 4)
          (mapcar 'char-to-string "abc")
               => ("a" "b" "c")

          ;; `my-hooks'の各関数を呼び出す
          (mapcar 'funcall my-hooks)

          (defun mapcar* (function &rest args)
            "Apply FUNCTION to successive cars of all ARGS.
          Return the list of results."
            ;; リストをつくしていなければ
            (if (not (memq 'nil args))
                ;; CARに関数を適用する
                (cons (apply function (mapcar 'car args))
                      (apply 'mapcar* function
                             ;; Recurse for rest of elements.
                             (mapcar 'cdr args)))))

          (mapcar* 'cons '(a b c) '(1 2 3 4))
               => ((a . 1) (b . 2) (c . 3))

 -- Function: mapconcat function sequence separator
     `mapconcat'は、SEQUENCEの各要素にFUNCTIONを適用する。
     それらの結果は、文字列である必要があり、連結される。
     `mapconcat'は、結果の文字列のあいだに文字列SEPARATORを挿入する。
     普通、SEPARATORは、空白やコンマ、その他の句読点を含む。

     引数FUNCTIONは、引数を1つ取る関数であり、 文字列を返す必要がある。
     引数SEQUENCEは、文字テーブル以外の任意の種類のシーケンスでよい。
     つまり、リスト、ベクトル、ブールベクトル、あるいは、文字列である。

          (mapconcat 'symbol-name
                     '(The cat in the hat)
                     " ")
               => "The cat in the hat"

          (mapconcat (function (lambda (x) (format "%c" (1+ x))))
                     "HAL-8000"
                     "")
               => "IBM.9111"


File: elisp-ja,  Node: Anonymous Functions,  Next: Function Cells,  Prev: Mapping Functions,  Up: Functions

11.7 無名関数
=================

Lispでは、関数とは、`lambda'で始まるリスト、
そのようなリストをコンパイルしたバイトコード関数、
あるいは、基本関数のsubrオブジェクトです。 名前は『余分』なのです。
普通の関数は`defun'で定義し、そのとき名前を与えますが、
明示的なラムダ式、つまり、無名関数を使ったほうがより簡素な場合もあります。
そのようなリストは、関数名を使える場面ならば、どこでも使えます。

   そのようなリストをどんな方法で作っても、正しい関数となります。
つぎのようにしてもかまわないのです。

     (setq silly (append '(lambda (x)) (list (list '+ (* 3 4) 'x))))
     => (lambda (x) (+ 12 x))

これは、`(lambda (x) (+ 12 x))'のようなリストを計算し、
その値を`silly'の値（関数定義では_ない_！）とします。

   この関数はつぎのように呼び出せます。

     (funcall silly 1)
     => 13

（`(silly 1)'と書いても動作_しない_。
なぜなら、この関数は、`silly'の_関数定義_ではないからである。
`silly'には関数定義を与えてなく、 変数としての値を与えただけである。）

   ほとんどの場合、無名関数は読者のプログラムに現れる定数です。
たとえば、関数`mapcar'の引数の1つに渡したいときなどです。
`mapcar'は、リストの各要素に指定した関数を適用します。

   第3引数に関数を取る関数`change-property'を定義します。

     (defun change-property (symbol prop function)
       (let ((value (get symbol prop)))
         (put symbol prop (funcall function value))))

ここで、数を2倍する関数を渡して`change-property'を使う
関数を定義します。

     (defun double-property (symbol prop)
       (change-property symbol prop '(lambda (x) (* 2 x))))

このような場合、つぎのように、無名関数をクォートするには、
単純なクォートのかわりにスペシャルフォーム`function'を使います。

     (defun double-property (symbol prop)
       (change-property symbol prop
                        (function (lambda (x) (* 2 x)))))

   `quote'のかわりに`function'を使った場合に違いがでるのは、
関数`double-property'をコンパイルしたときです。
たとえば、`double-property'の2番目の定義をコンパイルすると、
無名関数もコンパイルされます。
一方、普通の`quote'を使った最初の定義をコンパイルすると、
`change-property'へ渡す引数は、書いたとおりのリストです。

     (lambda (x) (* x 2))

Lispコンパイラは、このリストが関数に見えたとしても、
このリストを関数とはみなしません。
というのは、コンパイラには`change-property'がリストになにを行うか
わからないからです。 たぶん、第3要素のCARがシンボル`*'か
どうか調べればよいのでしょう！` '
`function'を使うと、コンパイラに対して先へ進んで
定数の関数をコンパイルしても安全であることを伝えます。

   関数名をクォートするときに`quote'のかわりに`function'を
書くこともありますが、この用法はコメントのようなものです。

     (function SYMBOL) == (quote SYMBOL) == 'SYMBOL

   入力構文`#''は、`function'の省略形です。 たとえば、

     #'(lambda (x) (* x x))

は、つぎと等価です。

     (function (lambda (x) (* x x)))

 -- Special Form: function function-object
     このスペシャルフォームは、FUNCTION-OBJECTを評価せずに
     FUNCTION-OBJECTを返す。 この意味では`quote'に等価である。
     しかし、これは、Emacs Lispコンパイラに対しては注意書きとして働き、
     FUNCTION-OBJECTを関数としてのみ使う意図があり、
     したがって、コンパイルしても安全であることを意味する。 *note
     Quoting::の`quote'と比較してほしい。

   `function'と無名関数を用いた実際的な例は、 *note Accessing
Documentation::の`documentation'を参照してください。


File: elisp-ja,  Node: Function Cells,  Next: Inline Functions,  Prev: Anonymous Functions,  Up: Functions

11.8 関数セルの内容の参照
===================================

シンボルの"関数定義"（function definition）とは、
シンボルの関数セルに格納されたオブジェクトです。
ここで説明する関数は、シンボルの関数セルを参照したり、調べたり、
設定したりします。

   *note Function
Indirection::の関数`indirect-function'も参照してください。

 -- Function: symbol-function symbol
     これは、SYMBOLの関数セルのオブジェクトを返す。
     シンボルの関数セルが空であると、エラー`void-function'を通知する。

     この関数は、返すオブジェクトが正しい関数であるかどうか検査しない。

          (defun bar (n) (+ n 2))
               => bar
          (symbol-function 'bar)
               => (lambda (n) (+ n 2))
          (fset 'baz 'bar)
               => bar
          (symbol-function 'baz)
               => bar

   シンボルに一度も関数定義を与えていないと、
そのシンボルの関数セルは"空"（void）であるといいます。
いいかえれば、関数セルにはどんなLispオブジェクトも入っていません。
そのようなシンボルを関数として呼び出そうとすると、
エラー`void-function'を通知します。

   空（void）は、`nil'やシンボル`void'と違うことに注意してください。
シンボル`nil'も`void'もLispオブジェクトであり、
それらは他のオブジェクトと同様に関数セルに格納できます
（そして、それらを`defun'で定義しておけば、正しい関数である）。
空の関数セルには、どんなオブジェクトも含まれていません。

   シンボルの関数定義が空かどうかは`fboundp'で調べることができます。
シンボルに関数定義を与えたあとでも、
`fmakunbound'を使ってふたたび空にできます。

 -- Function: fboundp symbol
     この関数は、シンボルの関数セルにオブジェクトが入っていれば`t'を返し、
     さもなければ`nil'を返す。
     オブジェクトが正しい関数であるかどうか検査しない。

 -- Function: fmakunbound symbol
     この関数はSYMBOLの関数セルを空にする。
     これ以降にこのセルを参照しようとすると、
     エラー`void-function'を引き起こす。 （*note Void
     Variables::の`makunbound'も参照）。

          (defun foo (x) x)
               => foo
          (foo 1)
               =>1
          (fmakunbound 'foo)
               => foo
          (foo 1)
          error--> Symbol's function definition is void: foo

 -- Function: fset symbol definition
     この関数は、SYMBOLの関数セルにDEFINITIONを格納する。
     結果はDEFINITIONである。
     通常、DEFINITIONは関数か関数名であるべきだが、
     そうであるかどうか検査しない。
     引数SYMBOLは通常どおり評価される引数である。

     この関数の普通の3つの使い方はつぎのとおり。

        * あるシンボルの関数定義を別のものにコピーする。
          いいかえれば、関数の別名を作る。
          （これを新たな名前の定義と考えるならば、
          `fset'のかわりに`defalias'を使うべきである。 *note Defining
          Functions::。）

        * リストではない関数定義をシンボルに与える。
          これは、`defun'ではできない。
          たとえば、`fset'を使って、`s1'に関数定義として
          別のシンボル`s2'を与えることができる。
          すると、`s1'は、`s2'の現在の定義の別名として働く。
          （これを`s1'の定義と考えるのであれば、
          やはり、`fset'のかわりに`defalias'を使う。）

        * 関数を定義したり変更したりする構文で使う。
          `defun'が基本関数でなかったならば、
          `fset'を使って（マクロとして）Lispで`defun'を書くことができる。

     これらの使用例を示す。

          ;; `foo'の定義を`old-foo'に保存する
          (fset 'old-foo (symbol-function 'foo))

          ;; シンボル`car'を`xfirst'の関数定義にする
          ;; （これには、`fset'より`defalias'のほうがよい）
          (fset 'xfirst 'car)
               => car
          (xfirst '(1 2 3))
               => 1
          (symbol-function 'xfirst)
               => car
          (symbol-function (symbol-function 'xfirst))
               => #<subr car>

          ;; 名前付きのキーボードマクロを定義する
          (fset 'kill-two-lines "\^u2\^k")
               => "\^u2\^k"

          ;; 他の関数を変更する関数
          (defun copy-function-definition (new old)
            "Define NEW with the same function definition as OLD."
            (fset new (symbol-function old)))

   既存の関数定義を拡張する関数を書くときには、
つぎのような常套句を使うこともあります。

     (fset 'old-foo (symbol-function 'foo))
     (defun foo ()
       "Just like old-foo, except more so."
       (old-foo)
       (more-so))

`foo'が自動ロードと定義されていると、これは正しく動作しません。
そのような場合には、`foo'が`old-foo'を呼び出すと、
Lispはファイルをロードして`old-foo'を定義しようとします。
しかし、これは`old-foo'ではなく`foo'を定義するので、
正しい結果を得られません。 この問題を回避する唯一の方法は、
`foo'の古い定義を移すまえに、確実にファイルをロードしておくことです。

   しかし、別の箇所で定義された関数を再定義するLispファイルに対しては、
いずれにしても、これではモジュール化も見通しもよくありません。
アドバイズ機能（*note Advising
Functions::）を使えば、見通しがよくなります。


File: elisp-ja,  Node: Inline Functions,  Next: Related Topics,  Prev: Function Cells,  Up: Functions

11.9 インライン関数
==========================

`defun'のかわりに`defsubst'を使うことで、 "インライン関数"（inline
function）を定義できます。
インライン関数は、1つの点を除いて、普通の関数と同様に動作します。
そのような関数の呼び出しをコンパイルすると、
関数定義は呼び出し側で展開されます。

   関数を展開すると明示的な呼び出しが高速になります。
しかし、それには欠点もあります。 その1つは、柔軟性を減らすことです。
関数の定義を変更しても、コンパイルし直すまでは、
すでに展開された呼び出しは古い定義を使い続けます。
関数を再定義できる柔軟性はEmacsでは重要な機能ですから、
速度が本当に重要でなければ、関数を展開すべきではありません。

   別の欠点は、大きな関数を展開すると、コンパイルした関数のサイズが
ファイル内でもメモリ上でも増加します。
インライン関数のスピードの利点は、小さな関数でもっとも大きいので、
一般には大きな関数を展開すべきではありません。

インライン関数が実行するのと同じコードに展開するようにマクロを定義する
ことも可能です。 （*note Macros::。）
しかし、マクロは式で直接使った場合に制限されます。
マクロは、`apply'や`mapcar'などで呼び出せません。
さらに、普通の関数をマクロに変換するには、多少の作業が必要です。
普通の関数をインライン関数に変換するのはとても簡単です。
単に、`defun'を`defsubst'で置き換えるだけです。
インライン関数の各引数は、ちょうど1回だけ評価されるので、
マクロのように本体で引数を何回使うかを考慮する必要はありません。
（*note Argument Evaluation::。）

   インライン関数は、マクロと同様に、
同じファイル内の定義位置よりうしろで使われ展開されます。


File: elisp-ja,  Node: Related Topics,  Prev: Inline Functions,  Up: Functions

11.10 関数に関連したその他の話題
=============================================

関数呼び出しと関数定義に関連したいくつかの関数の一覧をあげておきます。
これらは別の場所で説明してありますが、相互参照をあげておきます。

`apply'
     *note Calling Functions::。

`autoload'
     *note Autoload::。

`call-interactively'
     *note Interactive Call::。

`commandp'
     *note Interactive Call::。

`documentation'
     *note Accessing Documentation::。

`eval'
     *note Eval::。

`funcall'
     *note Calling Functions::。

`function'
     *note Anonymous Functions::。

`ignore'
     *note Calling Functions::。

`indirect-function'
     *note Function Indirection::。

`interactive'
     *note Using Interactive::。

`interactive-p'
     *note Interactive Call::。

`mapatoms'
     *note Creating Symbols::。

`mapcar'
     *note Mapping Functions::。

`map-char-table'
     *note Char-Tables::。

`mapconcat'
     *note Mapping Functions::。

`undefined'
     *note Key Lookup::。


File: elisp-ja,  Node: Macros,  Next: Customization,  Prev: Functions,  Up: Top

12 マクロ
************

"マクロ"（macros）により、
新たな制御構造の構文を定義したり、他の言語の機能を定義したりできます。
マクロは関数のように定義しますが、値の計算方法を指示するかわりに、
値を計算するための別のLisp式の計算方法を指示します。
この式をマクロの"展開形"（expansion）と呼びます。

   マクロでこのようなことができるのは、
関数が評価済みの引数を操作するのに対して、
マクロは引数の未評価の式を操作するからです。
そのため、これらの引数の式やその一部を含む展開形を構築できるのです。

   実行速度のために普通の関数でできることにマクロを使うのであれば、
そのかわりにインライン関数を使うことを考えてください。

* Menu:

* Simple Macro::            A basic example.
* Expansion::               How, when and why macros are expanded.
* Compiling Macros::        How macros are expanded by the compiler.
* Defining Macros::         How to write a macro definition.
* Backquote::               Easier construction of list structure.
* Problems with Macros::    Don't evaluate the macro arguments too many times.
                              Don't hide the user's variables.


File: elisp-ja,  Node: Simple Macro,  Next: Expansion,  Up: Macros

12.1 マクロの簡単な例
=============================

C言語の演算子`++'のように、
変数の値を増加させるLispの構文を定義したいとしましょう。 `(inc
x)'のように書いて、 `(setq x (1+ x))'のような効果を得たいのです。
これを行うマクロ定義はつぎのようになります。

     (defmacro inc (var)
        (list 'setq var (list '1+ var)))

   これを`(inc x)'のように呼び出すと、 引数VARはシンボル`x'になります。
関数のように`x'の_値_では_ありません_。
マクロの本体では、これを使って展開形`(setq x (1+ x))'を構築します。
マクロ定義がこの展開形を返すと、
Lispはそれを評価することに進み、`x'を増やします。


File: elisp-ja,  Node: Expansion,  Next: Compiling Macros,  Prev: Simple Macro,  Up: Macros

12.2 マクロ呼び出しの展開
===================================

マクロ呼び出しはマクロ名で始まるリストであり、
関数呼び出しとほとんど同じに見えます。
リストの残りの要素はマクロの引数です。

   マクロ呼び出しの評価は、関数呼び出しの評価のように始められますが、
1つだけ重要な違いがあります。
マクロの引数は、マクロ呼び出しに現れた実際の引数です。
マクロ定義に渡すまえに、それらを評価しません。
一方、関数の引数は、関数呼び出しのリストの要素を評価した結果です。

引数を得ると、Lispは関数定義を起動するのと同様にマクロ定義を起動します。
マクロの引数変数は、マクロ呼び出しの引数値や
`&rest'引数の場合にはそれらのリストに束縛されます。
そうして、マクロ本体を実行し、関数本体と同様に値を返します。

   マクロと関数の重要な違いの2つめは、
マクロ本体が返した値はマクロ呼び出しの値ではないことです。
戻り値は値を計算するためのかわりの式であり、
これをマクロの"展開形"（expansion）といいます。
Lispインタープリタは、マクロから戻ってくると、
ただちに展開形を評価することへ進みます。

   展開形は、通常どおりに評価されるので、
展開形から他のマクロを呼び出してもかまいません。
同一のマクロを呼び出してもかまいませんが、 それは一般的ではありません。

   `macroexpand'を呼ぶと、指定したマクロの展開形を調べることができます。

 -- Function: macroexpand form &optional environment
     この関数は、FORMがマクロ呼び出しならば、それを展開する。
     その結果がまた別のマクロ呼び出しであれば、さらに展開する。
     マクロ呼び出しでない結果を得るまでこれを繰り返す。
     それが、`macroexpand'が返す値である。
     FORMが始めからマクロ呼び出しでなければ、
     与えられたとおりのものを返す。

     `macroexpand'はFORMの部分式を調べないことに注意してほしい
     （ただし、マクロ定義によっては調べるかもしれない）。
     部分式がマクロ呼び出しであったとしても、
     `macroexpand'はそれらを展開しない。

     関数`macroexpand'は、インライン関数の呼び出しは展開しない。
     インライン関数の呼び出しを理解することは普通の関数呼び出しを理解するのと
     かわりないので、通常、そのような展開を行う必要はない。

     ENVIRONMENTを指定すると、
     それは、現在定義済みのマクロを隠すマクロ定義の連想リストを表す。
     バイトコンパイルではこの機能を使う。

          (defmacro inc (var)
              (list 'setq var (list '1+ var)))
               => inc

          (macroexpand '(inc r))
               => (setq r (1+ r))

          (defmacro inc2 (var1 var2)
              (list 'progn (list 'inc var1) (list 'inc var2)))
               => inc2

          (macroexpand '(inc2 r s))
               => (progn (inc r) (inc s))  ; ここでは`inc'を展開しない


File: elisp-ja,  Node: Compiling Macros,  Next: Defining Macros,  Prev: Expansion,  Up: Macros

12.3 マクロとバイトコンパイル
=========================================

なぜ、マクロの展開形をわざわざ計算してから展開形を評価するのか、
疑問に思うかもしれません。
なぜ、マクロ本体で望みの結果を直接出さないのでしょう？` '
その理由には、コンパイルが関係しています。

   コンパイルするLispプログラムにマクロ呼び出しが現れると、
Lispコンパイラは、インタープリタがするのと同様にマクロ定義を呼び出し、
その展開形を受け取ります。 この展開形を評価するかわりに、コンパイラは、
展開形がプログラムに直接現れたかのようにそれをコンパイルします。
その結果、コンパイル済みのコードは、マクロが意図した値と副作用を生じ、
かつ、実行速度はコンパイルした速度になるのです。
マクロ本体そのもので値と副作用を計算したのでは、
このように動作しません。
コンパイル時に計算してしまい、それでは意味がありません。

   マクロ呼び出しが正しくコンパイルされるためには、
それらの呼び出しをコンパイルするときに、
Lisp内でマクロが定義済みである必要があります。
コンパイラには、読者がこのようにすることを補佐する機能があります。
コンパイル対象のファイルにフォーム`defmacro'が含まれていると、
そのファイルの残りをコンパイルするあいだは、
一時的にマクロを定義します。 この機能が動作するためには、
`defmacro'を同じファイルの最初に利用する箇所よりまえに
入れておく必要があります。

   ファイルをバイトコンパイルすると、
そのファイルのトップレベルにある`require'の呼び出しを実行します。
これは、ファイルを正しくコンパイルするために必要なパッケージを表します。
コンパイル中に必要なマクロ定義が使えることを保証する1つの方法は、
それらのマクロを定義するファイルを
`require'に指定しておくことです（*note Named Features::）。
コンパイル済みのプログラムを_実行_するときに、
マクロを定義したファイルをロードしてしまうことを避けるには、
`require'の呼び出しの周りに`eval-when-compile'を書いておきます （*note
Eval During Compile::）。


File: elisp-ja,  Node: Defining Macros,  Next: Backquote,  Prev: Compiling Macros,  Up: Macros

12.4 マクロ定義
====================

Lispのマクロは、そのCARが`macro'であるリストです。
そのCDRは関数であるべきです。
マクロの展開は、マクロ呼び出しの未評価の引数式に
（`apply'で）関数を適用して動作します。

   無名関数のように無名Lispマクロを使うことも可能ですが、
けっしてしないでしょう。
`mapcar'のようなファンクショナルに無名マクロを渡す意味がないからです。
実用上は、すべてのLispマクロには名前があり、
普通、スペシャルフォーム`defmacro'で定義します。

 -- Special Form: defmacro name argument-list body-forms...
     `defmacro'は、シンボルNAMEをつぎのようなマクロとして定義する。

          (macro lambda ARGUMENT-LIST . BODY-FORMS)

     （このリストのCDRは関数、つまり、ラムダ式であることに注意。）
     このマクロオブジェクトは、NAMEの関数セルに格納される。
     フォーム`defmacro'を評価した結果、返される値はNAMEであるが、
     通常この値は無視する。

     ARGUMENT-LISTの形式と意味は、関数のそれと同じであり、
     キーワード`&rest'や`&optional'を使ってもよい （*note Argument
     List::）。 マクロにも説明文字列を指定できるが、
     マクロを対話的に呼び出すことはできないので、
     `interactive'宣言は無視する。


File: elisp-ja,  Node: Backquote,  Next: Problems with Macros,  Prev: Defining Macros,  Up: Macros

12.5 バッククォート
==========================

マクロでは、定数部分と非定数部分を組み合わせた大きなリスト構造を
構築する必要がしばしばあります。 これを簡単に行うためには、
（通常、"バッククォート"（backquote）と呼ばれる）``'構文を 使います。

   バッククォートにより、リストの要素を選択に評価しつつ、
リストをクォートできます。
もっとも単純な場合、これはスペシャルフォーム`quote'（*note Quoting::）と
等価です。 たとえば、つぎの2つのフォームは等価な結果になります。

     `(a list of (+ 2 3) elements)
          => (a list of (+ 2 3) elements)
     '(a list of (+ 2 3) elements)
          => (a list of (+ 2 3) elements)

   バッククォートの引数の内側にある特別な印`,'は、
値が定数ではないことを表します。
バッククォートは、リスト構造の中の`,'の引数を評価し、 値で置き換えます。

     (list 'a 'list 'of (+ 2 3) 'elements)
          => (a list of 5 elements)
     `(a list of ,(+ 2 3) elements)
          => (a list of 5 elements)

   `,'による置き換えは、リスト構造の深いレベルでも許されます。
たとえば、つぎのとおりです。

     (defmacro t-becomes-nil (variable)
       `(if (eq ,variable t)
            (setq ,variable nil)))

     (t-becomes-nil foo)
          == (if (eq foo t) (setq foo nil))

   特別な印`,@'を使って、
評価結果を結果となるリストに"繋ぎ合わせる"（splice）こともできます。
繋ぎ合わせたリストの要素は、結果となるリストの他の要素と同じレベルになります。
``'を使わない等価なコードはしばしば読み難くなります。 例をあげましょう。

     (setq some-list '(2 3))
          => (2 3)
     (cons 1 (append some-list '(4) some-list))
          => (1 2 3 4 2 3)
     `(1 ,@some-list 4 ,@some-list)
          => (1 2 3 4 2 3)

     (setq list '(hack foo bar))
          => (hack foo bar)
     (cons 'use
       (cons 'the
         (cons 'words (append (cdr list) '(as elements)))))
          => (use the words foo bar as elements)
     `(use the words ,@(cdr list) as elements)
          => (use the words foo bar as elements)

   19.29版よりまえのEmacsの旧版では、 ``'の構文は異なっていて、
バッククォート構文全体を囲む括弧の余分なレベルが必要でした。
同様に、`,'や`,@'の置換でも、
`,'や`,@'、および後続の式を囲む括弧の余分なレベルが1つ必要でした。
古い構文では、``'、 `,'、`,@'と後続の式とのあいだには 空白が必要でした。

   この構文も受け付けますが、これはEmacsの旧版との互換性のためであり、
新しいプログラムでは使わないことを勧めます。


File: elisp-ja,  Node: Problems with Macros,  Prev: Backquote,  Up: Macros

12.6 マクロ使用時の一般的な問題
============================================

マクロ展開に関する基本的事実には、直観的でない結果があります。
本節では、問題を引き起こしかねない重要な結果を説明し、
問題を回避するための規則を説明します。

* Menu:

* Argument Evaluation::    The expansion should evaluate each macro arg once.
* Surprising Local Vars::  Local variable bindings in the expansion
                              require special care.
* Eval During Expansion::  Don't evaluate them; put them in the expansion.
* Repeated Expansion::     Avoid depending on how many times expansion is done.


File: elisp-ja,  Node: Argument Evaluation,  Next: Surprising Local Vars,  Up: Problems with Macros

12.6.1 マクロ引数の複数回評価
----------------------------------------

マクロを定義するときには、展開形を実行するときに、
引数が何回評価かされるかに注意を払う必要があります。
つぎの（繰り返しを行う）マクロで、この問題を示しましょう。
このマクロで、Pascalにあるような単純な『for』ループを書けます。

     (defmacro for (var from init to final do &rest body)
       "Execute a simple \"for\" loop.
     For example, (for i from 1 to 10 do (print i))."
       (list 'let (list (list var init))
             (cons 'while (cons (list '<= var final)
                                (append body (list (list 'inc var)))))))
     => for

     (for i from 1 to 3 do
        (setq square (* i i))
        (princ (format "\n%d %d" i square)))
     ==>
     (let ((i 1))
       (while (<= i 3)
         (setq square (* i i))
         (princ (format "%d      %d" i square))
         (inc i)))

          -|1       1
          -|2       4
          -|3       9
     => nil

このマクロの引数、`from'、`to'、`do'は、
『シンタックスシュガー』であり、完全に無視します。
（`from'、`to'、`do'などの）余分な単語を
マクロ呼び出しのこの引数位置に書けるようにするのです。

   バッククォートを使って単純化した等価な定義をつぎに示します。

     (defmacro for (var from init to final do &rest body)
       "Execute a simple \"for\" loop.
     For example, (for i from 1 to 10 do (print i))."
       `(let ((,var ,init))
          (while (<= ,var ,final)
            ,@body
            (inc ,var))))

   この定義の（バッククォートありとなしの）どちらの形式でも、
各繰り返しごとにFINALが評価されるという欠陥があります。
FINALが定数ならば、これは問題になりません。
たとえば`(long-complex-calculation x)'のような、
より複雑なフォームであると、実行速度をかなり遅くしてしまいます。
FINALに副作用があると、複数回評価するのは正しくありません。

   繰り返し評価することがマクロの意図している目的の一部でなければ、
よく設計されたマクロ定義では、
引数をちょうど1回だけ評価するような展開形を生成して、
上のような問題を回避するように手立てします。

     (let ((i 1)
           (max 3))
       (while (<= i max)
         (setq square (* i i))
         (princ (format "%d      %d" i square))
         (inc i)))

   このような展開形を作るマクロ定義はつぎのようになります。

     (defmacro for (var from init to final do &rest body)
       "Execute a simple for loop: (for i from 1 to 10 do (print i))."
       `(let ((,var ,init)
              (max ,final))
          (while (<= ,var max)
            ,@body
            (inc ,var))))

   残念なことに、この修正は、 次節に説明する別の問題を引き起こします。


File: elisp-ja,  Node: Surprising Local Vars,  Next: Eval During Expansion,  Prev: Argument Evaluation,  Up: Problems with Macros

12.6.2 マクロ展開形内のローカル変数
-------------------------------------------------

前節では、`for'の定義をつぎのように修正して、
マクロ引数を適切な回数だけ評価する展開形にしました。

     (defmacro for (var from init to final do &rest body)
       "Execute a simple for loop: (for i from 1 to 10 do (print i))."
       `(let ((,var ,init)
              (max ,final))
          (while (<= ,var max)
            ,@body
            (inc ,var))))

`for'の新しい定義には、新たな問題があります。
ユーザーが予期していないローカル変数`max'を導入しているのです。
これは、つぎのような場合、問題を引き起こします。

     (let ((max 0))
       (for x from 0 to 10 do
         (let ((this (frob x)))
           (if (< max this)
               (setq max this)))))

`for'の本体内での`max'の参照は、
ユーザーが束縛した`max'を参照するものと期待されていますが、
実際には`for'が作った束縛を使います。

   これを修正するには、`max'のかわりに、
インターンしてないシンボル（*note Creating Symbols::）を使います。
インターンしてないシンボルは、他のシンボルと同様に、
束縛したり参照したりできますが、`for'で作ったので、
ユーザープログラムには現れていないことがわかっています。
インターンしてないので、ユーザーがプログラムのあとの部分で
参照する方法もありません。 `for'で使った箇所以外には現れえないのです。
このように動作する`for'の定義をつぎに示します。

     (defmacro for (var from init to final do &rest body)
       "Execute a simple for loop: (for i from 1 to 10 do (print i))."
       (let ((tempvar (make-symbol "max")))
         `(let ((,var ,init)
                (,tempvar ,final))
            (while (<= ,var ,tempvar)
              ,@body
              (inc ,var)))))

これは、`max'という名前のインターンしてないシンボルを作成し、
もとの式に現れていたインターンしたシンボル`max'のかわりに
展開形内部で使います。


File: elisp-ja,  Node: Eval During Expansion,  Next: Repeated Expansion,  Prev: Surprising Local Vars,  Up: Problems with Macros

12.6.3 展開形におけるマクロ引数の評価
----------------------------------------------------

`eval'（*note Eval::）を呼び出すなどして、
マクロ定義そのものの中でマクロ引数の式を評価すると、
別の問題を生じます。 引数でユーザーの変数を参照する場合、
ユーザーがマクロ引数の1つと同じ名前を使っていると、 問題になります。
マクロ本体の内側では、マクロ引数の束縛が最ローカルな束縛ですから、
そのフォームの内側からの参照は、この束縛を使います。 例を示しましょう。

     (defmacro foo (a)
       (list 'setq (eval a) t))
          => foo
     (setq x 'b)
     (foo x) ==> (setq b t)
          => t                  ; `b'を設定する
     ;; しかし
     (setq a 'c)
     (foo a) ==> (setq a t)
          => t                  ; `c'ではなく`a'を設定する

   ユーザーの引数の名前が`a'か`x'かで違いがでます。
というのは、マクロ引数の変数`a'と`a'が衝突するからです。

   マクロ定義内で`eval'を呼び出したときの別の問題点は、
コンパイルしたプログラムでは、意図した動作をしないだろうということです。
バイトコンパイラは、プログラムをコンパイル中にマクロ定義を実行しますから、
（`eval'で参照したい）プログラムそのものの計算は行われず、
そのローカル変数の束縛も存在しません。

   これらの問題を回避するには、
*マクロ展開の計算過程では、引数の式を評価しない*ことです。
そのかわりに、マクロ展開では式の置換を使って、
展開時にその値が計算されるようにします。
このようにすれば、本章の他の例題は動作します。


File: elisp-ja,  Node: Repeated Expansion,  Prev: Eval During Expansion,  Up: Problems with Macros

12.6.4 マクロは何回展開されるか
-------------------------------------------

関数を解釈実行しているときには、マクロ呼び出しを評価するたびに展開しますが、
コンパイルした関数では、（コンパイル時に）1回だけ展開します。
この違いが問題になることもあります。 マクロ定義に副作用があると、
マクロを何回展開したかに依存して動作が異なります。

   したがって、マクロ展開の計算では、
本当になにをしているのか理解していない限り、副作用は避けてください。

   特別な種類の副作用の1つ、つまり、
Lispオブジェクトを構築することは回避できません。
ほとんどすべてのマクロ展開では、リストを構築し、
それがマクロの重要な点でもあります。 これは、通常、安全ですが、
1つだけ注意する必要があります。 読者が構築したオブジェクトが、
マクロ展開形の中のクォートした定数の一部であるときです。

   コンパイル時にマクロを1回だけ展開すると、
コンパイル中にはオブジェクトは一度だけ作られます。
しかし、解釈実行中には、マクロ呼び出しを行うたびにマクロを展開するので、
そのたびに新たなオブジェクトが作成されたことを意味します。

   見通しのよいほとんどのLispコードでは、この違いは関係ありません。
マクロ定義で構築したオブジェクトに副作用のある操作を行うと
違いが出てきます。 したがって、問題を回避するには、
*マクロ定義で構築したオブジェクトに副作用のある操作は行わない*
ということです。
そのような副作用がどのように問題を引き起こすのか、例をあげましょう。

     (defmacro empty-object ()
       (list 'quote (cons nil nil)))

     (defun initialize (condition)
       (let ((object (empty-object)))
         (if condition
             (setcar object condition))
         object))

`initialize'を解釈実行しているときには、
`initialize'を呼び出すたびに新たなリスト`(nil)'が作られます。
したがって、2つの呼び出しのあいだで副作用が残ることはありません。
`initialize'をコンパイルしてあると、
マクロ`empty-object'はコンパイル時に展開され、
1つの『定数』`(nil)'を作りますが、
これは、`initialize'を呼び出すたびに、 再利用され変更されてしまいます。

   このような病的な場面を回避する1つの方法は、
`empty-object'を、メモリ割り付けではなく、
ある種の定数と考えることです。
`'(nil)'のような定数に`setcar'は使わないでしょうから、
`(empty-object)'も自然にそのように使わないでしょう。


File: elisp-ja,  Node: Customization,  Next: Loading,  Prev: Macros,  Up: Top

13 カスタマイズ定義の書き方
***************************************

本章では、カスタマイズのためのユーザーオプションの宣言方法、
および、それらを分類するカスタマイズグループの宣言方法を説明します。
フェイスの定義（*note Defining Faces::）に加えて、
カスタマイズの両方の種類を含めて、 "カスタマイズ項目"（customization
item）という用語を使います。

* Menu:

* Common Keywords::
* Group Definitions::
* Variable Definitions::
* Customization Types::


File: elisp-ja,  Node: Common Keywords,  Next: Group Definitions,  Up: Customization

13.1 すべての種類の項目に共通のキーワード
===========================================================

（変数やグループ、フェイスの）すべての種類のカスタマイズ宣言では、
さまざまな情報を指定するためのキーワード引数を受け付けます。
本節では、全種類に適用できるキーワードを説明します。

   `:tag'を除くこれらのキーワードすべては、各項目で複数回使えます。
キーワードのそれぞれの使用には、独立の効果があります。
キーワード`:tag'は例外です。
任意の項目には名前を1つしか表示できないからです。

`:tag NAME'
     カスタマイズメニューやカスタマイズバッファ内で
     項目に付けるラベルとして、項目の名前のかわりに文字列NAMEを使う。

`:group GROUP'
     このカスタマイズ項目をグループGROUPに入れる。
     `defgroup'の中で`:group'を使うと、
     新たなグループをGROUPの下位グループにする。

     このキーワードを複数回使うと、
     1つの項目を複数のグループに入れることができる。
     それらのグループのどれを表示しても、この項目が表示される。
     これを多用しすぎないように注意すること！

`:link LINK-DATA'
     この項目に対する説明文字列のうしろに外部リンクを含める。
     これは、他の説明文字列を参照するアクティブフィールドを含む文である。

     LINK-DATAとして使えるものは3種類ある。

    `(custom-manual INFO-NODE)'
          infoのノードへリンクする。
          INFO-NODEは、`"(emacs)Top"'のようなノード名を指定する文字列。
          リンクは、カスタマイズバッファでは`[manual]'のように表示される。

    `(info-link INFO-NODE)'
          `custom-manual'と同様であるが、
          カスタマイズバッファに現れるリンクはinfoのノード名になる。

    `(url-link URL)'
          webページへリンクする。 URLは、URLを指定する文字列。
          カスタマイズバッファに現れるリンクはURLになる。

     LINK-DATAの先頭要素のうしろに`:tag NAME'を使うことで、
     カスタマイズバッファに使うテキストを指定できる。
     たとえば、`(info-link :tag "foo" "(emacs)Top")'とすると、
     バッファでは`foo'と表示されるEmacsマニュアルへのリンクを作れる。

     1つの項目に複数個の外部リンクがあってもよいが、
     ほとんどの項目には外部リンクはない。

`:load FILE'
     このカスタマイズ項目を表示するまえにファイルFILE（文字列）をロードする。
     ファイルをすでにロードしていない場合に限り、
     `load-library'でロードする。

`:require FEATURE'
     カスタマイズ機能を用いて保存するこの項目に対する値をインストールするときに
     必要となる機能FEATURE（シンボル）を指定する。 `require'を呼び出す。

     `:require'を使うもっとも一般的な理由は、
     変数がマイナモードなどの機能をオンにするとき、
     そのモードを実装するコードをロードしてないと、
     変数にはなんの効果もないからである。


File: elisp-ja,  Node: Group Definitions,  Next: Variable Definitions,  Prev: Common Keywords,  Up: Customization

13.2 カスタマイズグループを定義する
==================================================

Emacs Lispの各パッケージには、
そのパッケージのすべてのオプション、フェイス、他のグループを含んだ
1つの主要なカスタマイズグループがあるべきです。
パッケージに少数のオプションやフェイスしかなければ、
それらを1つのグループにまとめます。
12個を超えるオプションやフェイスがある場合には、
それらを下位グループに構造化して、
下位グループすべてをパッケージの主カスタマイズグループに入れておきます。
パッケージの主グループに下位グループとともにいくつかのオプションやフェイスを
入れておくのもよいでしょう。

   パッケージの主グループや単一のグループは、
標準カスタマイズグループの1つかそれ以上のメンバであるべきです。
（それらの完全な一覧を表示するには`M-x customize'を使う。）
それらの中から1個か数個を選び（多すぎないこと）、
キーワード`:group'を使って、それぞれに読者のグループを追加します。

   新たなカスタマイズグループは、`defgroup'で宣言します。

 -- Macro: defgroup group members doc [keyword value]...
     MEMBERSを含むカスタマイズグループとしてGROUPを宣言する。
     シンボルGROUPをクォートしないこと。
     引数DOCは、グループの説明文字列を指定する。

     引数MEMBERSは、グループのメンバとなる
     カスタマイズ項目の初期集合を指定するリストである。
     しかし、ほとんどの場合、MEMBERSは`nil'であり、
     それらのメンバを定義するときに、キーワード`:group'を使って、
     グループのメンバであることを指定する。

     MEMBERSでグループのメンバを指定する場合には、 各要素は`(NAME
     WIDGET)'という形式であること。 ここで、NAMEはシンボル、
     WIDGETはそのシンボルを編集するためのウィジェット型である。
     有用なウィジェットは、変数に対しては`custom-variable'、
     フェイスに対しては`custom-face'、
     グループに対しては`custom-group'である。

     共通のキーワード（*note Common Keywords::）に加えて、
     `defgroup'ではつぎのキーワードも使える。

    `:prefix PREFIX'
          グループ内の項目の名前がPREFIXで始まるときには、
          その項目に対するタグを（デフォルトでは）PREFIXを省略して作る。

          1つのグループに`prefix'がいくつあってもよい。

   接頭辞を取りさる機能は、現在、オフにしてあります。
つまり、`:prefix'は、現在、なんの効果もありません。
このようにしたのは、指定した接頭辞を取りさると、
オプション名がしばしば混乱するからです。
さまざまなグループの`defgroup'定義を書く人は、
論理的と考えられるとき、つまり、ライブラリに共通の接頭辞があるときには
キーワード`:prefix'を追加するので、このようになるのです。

   `:prefix'を使ってよい結果を得るには、
グループ内の特定の項目とそれらの名前と説明文字列に関して、
特定の接頭辞を取りさった場合の効果を調べる必要があります。
その結果、テキストがわかり難ければ、
その場面では、`:prefix'を使うべきではないのでしょう。

   カスタマイズグループすべてを調べ直して、
わかり難くなる結果をもたらす`:prefix'指定を削除し、
この機能をオンにすることは、誰かが頑張れば、可能です。


File: elisp-ja,  Node: Variable Definitions,  Next: Customization Types,  Prev: Group Definitions,  Up: Customization

13.3 カスタマイズ変数を定義する
============================================

`defcustom'を使って、ユーザーが編集可能な変数を宣言します。

 -- Macro: defcustom option default doc [keyword value]...
     カスタマイズ可能なユーザーオプション変数としてOPTIONを宣言する。
     OPTIONをクォートしないこと。 引数DOCは変数の説明文字列を指定する。

     OPTIONが空であると、`defcustom'はDEFAULTで初期化する。
     DEFAULTは値を計算する式であること。
     これは複数回評価される可能性があるので、書き方には注意すること。

   `defcustom'では、つぎの追加キーワードも使えます。

`:type TYPE'
     このオプションのデータ型としてTYPEを使う。
     これは、正しい値とその表示方法を指定する。 詳しくは、*note
     Customization Types::。

`:options LIST'
     このオプションに使える合理的な値のリストとしてLISTを指定する。

     これは、現時点では、型が`hook'のときだけ意味を持つ。
     その場合、LISTの要素は、フックの値の要素として使える関数であること。
     ユーザーはこれらの関数以外も使えるが、便利な選択肢として提示する。

`:version VERSION'
     このオプションは、変数を最初に導入したり、デフォルト値を変更したりした
     Emacsの版VERSIONを指定する。 値VERSIONは、文字列であること。
     たとえば、つぎのとおり。

          (defcustom foo-max 34
            "*Maximum number of foo's allowed."
            :type 'integer
            :group 'foo
            :version "20.3")

`:set SETFUNCTION'
     このオプションの値を変更する方法としてSETFUNCTIONを指定する。
     関数SETFUNCTIONは、2つの引数、つまり、シンボルと新しい値を取り、
     このオプションの値を（Lisp変数としてオプションを設定するだけでなく）
     適切に更新するために必要なことを行うこと。
     SETFUNCTIONのデフォルトは`set-default'。

`:get GETFUNCTION'
     このオプションの値を取り出す方法としてGETFUNCTIONを指定する。
     関数GETFUNCTIONは、1つの引数、つまり、シンボルを取り、
     そのシンボル（のLisp値とは必ずしも限らない）の『現在値』を返すこと。
     デフォルトは`default-value'。

`:initialize FUNCTION'
     FUNCTIONは、`defcustom'を評価したときに変数の初期化に使う関数。
     この関数は、2つの引数、つまり、シンボルと値を取ること。
     このように使うことを意図した定義済みの関数がいくつかある。

    `custom-initialize-set'
          変数の`:set'関数を使って変数を初期化するが、
          変数の値が空でないときには再初期化しない。
          これは`:initialize'のデフォルト。

    `custom-initialize-default'
          `custom-initialize-set'に似ているが、
          変数の`:set'関数のかわりに関数`set-default'を使って変数を設定する。
          変数の`:set'関数がマイナモードをオン／オフする場合には、
          普通はこれを選ぶ。
          これを選ぶと、変数を定義してもマイナモード関数を呼び出さないが、
          変数をカスタマイズするとマイナモード関数を呼び出す。

    `custom-initialize-reset'
          変数を初期化するにはつねに`:set'関数を使う。
          変数の値が空でない場合には、（`:get'で得られる）現在値で
          `:set'関数を呼び出して、変数をリセットする。

    `custom-initialize-changed'
          変数がすでに設定されていたりカスタマイズしてあるときに、
          変数を初期化するために`:set'関数を使う。
          さもなければ、`set-default'を使う。

   `:require'オプションは、
特定の機能をオンにするようなオプションには便利です。
パッケージがオプション変数の値を検査するように書かれていたとしても、
パッケージをロードするようにする必要があります。
これを`:require'で行えるのです。 *Note Common Keywords::。
ライブラリ`paren.el'からとった例をつぎに示します。

     (defcustom show-paren-mode nil
       "Toggle Show Paren mode..."
       :set (lambda (symbol value)
              (show-paren-mode (or value 0)))
       :initialize 'custom-initialize-default
       :type 'boolean
       :group 'paren-showing
       :require 'paren)

   内部的には、`defcustom'は、
デフォルト値を与える式は属性`standard-value'を使って記録し、
ユーザーがカスタマイズバッファで保存した値は
属性`saved-value'を使って記録しています。
属性`saved-value'は実際にはリストであり、
そのCARが値に評価される式です。


File: elisp-ja,  Node: Customization Types,  Prev: Variable Definitions,  Up: Customization

13.4 カスタマイズ型
==========================

`defcustom'でユーザーオプションを定義するときには、
その"カスタマイズ型"（customization type）を定義する必要があります。
これはLispオブジェクトであり、 （1）どのような値が正しいものであり、
（2）編集用にカスタマイズバッファに表示する方法、 を示します。

   カスタマイズ型は、`defcustom'内の`:type'キーワードで指定します。
`:type'の引数は評価されます。
実行時に型が変わるものはほとんど使い途がないので、
普通、クォートした型を指定します。 たとえば、つぎのとおりです。

     (defcustom diff-command "diff"
       "*The command to use to run diff."
       :type '(string)
       :group 'diff)

   一般に、カスタマイズ型はリストであり、
その先頭要素はシンボルで、次節以降で定義するカスタマイズ型名の1つです。
このシンボルのあとには、シンボルに依存した数個の引数が続きます。
型シンボルとその引数のあいだには、
キーワード・値の対を書くこともできます （*note Type Keywords::）。

   型シンボルには、引数を取らないものもあります。
これらを"単純型"（simple types）と呼びます。
単純型では、キーワード・値の対を指定しなければ、
型シンボルを囲む括弧を省略できます。
たとえば、カスタマイズ型としての`string'は、 `(string)'と等価です。

* Menu:

* Simple Types::
* Composite Types::
* Splicing into Lists::
* Type Keywords::


File: elisp-ja,  Node: Simple Types,  Next: Composite Types,  Up: Customization Types

13.4.1 単純型
----------------

本節では、すべての単純型を説明します。

`sexp'
     値は、表示したり読み取れるならば、任意のLispオブジェクトでよい。
     使用する型をより限定する手間を省きたければ、
     任意のオプションに対するデフォルトとして、
     `sexp'を使うことができる。

`integer'
     値は整数である必要があり、カスタマイズバッファではテキストで表示する。

`number'
     値は数である必要があり、カスタマイズバッファではテキストで表示する。

`string'
     値は文字列である必要があり、
     カスタマイズバッファでは、その内容だけを表示し、
     文字`"'で区切ったり、`\'でクォートしない。

`regexp'
     `string'と同様であるが、 文字列は正規表現である必要がある。

`character'
     値は文字コードである必要がある。 文字コードは実際には整数であるが、
     この型では、数として表示するのではなく、
     文字としてバッファに挿入してその値を表示する。

`file'
     値はファイル名である必要があり、`M-<TAB>'で補完できる。

`(file :must-match t)'
     値は既存のファイル名である必要があり、`M-<TAB>'で補完できる。

`directory'
     値はディレクトリ名である必要があり、`M-<TAB>'で補完できる。

`hook'
     値は関数のリスト（あるいは、単一の関数。ただし、この使い方は廃れている）
     である必要がある。 このカスタマイズ型は、フック変数に使用する。
     フックに使う推奨される関数のリストを指定するために、
     フック変数の`defcustom'で`:options'キーワードを使用できる。 *note
     Variable Definitions::。

`symbol'
     値はシンボルである必要がある。
     カスタマイズバッファでは、シンボルの名前を表示する。

`function'
     値はラムダ式か関数名である必要がある。
     関数名の場合、`M-<TAB>'で補完できる。

`variable'
     値は変数名である必要があり、`M-<TAB>'で補完できる。

`face'
     値はフェイス名を表すシンボルである必要があり、`M-<TAB>'で補完できる。

`boolean'
     値は真理値、つまり、`nil'か`t'である必要がある。
     `choice'と`const'を同時に使うと（次節参照）、
     値は`nil'か`t'である必要があることを指定し、
     さらに、どちらの値がどの選択肢に合うかを記述するテキストを
     指定できることに注意。


File: elisp-ja,  Node: Composite Types,  Next: Splicing into Lists,  Prev: Simple Types,  Up: Customization Types

13.4.2 複合型
----------------

単純型が適切でない場合には、
他の型から新たな型を作り上げる複合型を使えます。
これには、いくつかの方法があります。

`(restricted-sexp :match-alternatives CRITERIA)'
     値は、CRITERIAの1つを満たす任意のLispオブジェクトでよい。
     CRITERIAはリストであり、その各要素は以下の1つであること。

        * 述語。 つまり、引数を1つ取る副作用のない関数であり、
          引数に応じて`nil'か`nil'以外を返す。
          リスト内の述語がオブジェクトに対して`nil'以外を返せば
          そのオブジェクトを受理することを意味する。

        * クォートした定数。 つまり、`'OBJECT'。
          リスト内のこの種の要素は、
          OBJECTそのものが受理できる値であることを意味する。

     たとえば、

          (restricted-sexp :match-alternatives
                           (integerp 't 'nil))

     は、整数、`t'、`nil'が正しい値である。

     カスタマイズバッファでは、すべての正しい値はその入力構文で表示し、
     ユーザーはそれらをテキストとして編集する。

`(cons CAR-TYPE CDR-TYPE)'
     値はコンスセルである必要があり、 そのCARはCAR-TYPEに合い、かつ、
     そのCDRはCDR-TYPEに合う必要がある。 たとえば、`(cons string
     symbol)'は、 `("foo" .
     foo)'などの値に一致するカスタマイズ型である。

     カスタマイズバッファでは、 CARとCDRは、
     それらに指定した型に応じて別々に表示され、個別に編集できる。

`(list ELEMENT-TYPES...)'
     値はELEMENT-TYPESに指定したとおりの個数のリストである必要があり、
     各要素はELEMENT-TYPEに合うこと。

     たとえば、`(list integer string function)'は、
     3要素のリストを意味し、
     第1要素は整数、第2要素は文字列、第3要素は関数であることを指定する。

     カスタマイズバッファでは、
     各要素は、それらに指定した型に応じて別々に表示され、個別に編集できる。

`(vector ELEMENT-TYPES...)'
     `list'と同様だが、値はリストではなくベクトルである必要がある。
     その要素は`list'の場合と同じ。

`(choice ALTERNATIVE-TYPES...)'
     値は、ALTERNATIVE-TYPESの少なくとも1つに合う必要がある。
     たとえば、`(choice integer string)'は、整数か文字列を許す。

     カスタマイズバッファでは、ユーザーはメニューを使って選択肢を選び、
     その選択肢において普通の方法で値を編集する。

     通常、このメニューの選択肢名は、選択肢から自動的に決定されるが、
     選択肢に`:tag'キーワードを含めることで、
     メニューに異なる名前を指定できる。
     たとえば、整数が空白の個数を表し、文字列がそのまま使うテキストを表す場合には、
     つぎのようにカスタマイズ型を書く。

          (choice (integer :tag "Number of spaces")
                  (string :tag "Literal text"))

     そうすると、メニューには、 `Number of spaces'と`Literal
     Text'が表示される。

     `const'以外の`nil'が正当な値ではない選択肢では、
     そのような選択肢には`:value'キーワードを使って
     正当なデフォルト値を指定すること。 *Note Type Keywords::。

`(const VALUE)'
     値はVALUEであること。 それ以外は許さない。

     `const'の主な用途は`choice'の内側である。 たとえば、`(choice
     integer (const nil))'は、整数か`nil'を許す。

     `choice'の内側では、`const'にしばしば`:tag'を使う。 たとえば、

          (choice (const :tag "Yes" t)
                  (const :tag "No" nil)
                  (const :tag "Ask" foo))

     は、`t'は『yes』（はい）、`nil'は『no』（いいえ）、
     `foo'は『ask』（問い合わせる）を意味する変数を記述する。

`(other VALUE)'
     この選択肢は任意のLisp値に一致するが、
     ユーザーがこの選択肢を選ぶと、値VALUEを選ぶことになる。

     `other'は、主に、`choice'の最後の要素として使うことである。
     たとえば、

          (choice (const :tag "Yes" t)
                  (const :tag "No" nil)
                  (other :tag "Ask" foo))

     は、`t'は『yes』（はい）、`nil'は『no』（いいえ）、
     それ以外は『ask』（問い合わせる）を意味することを示す。
     ユーザーが選択肢のメニューから`Ask'を選ぶと、値`foo'を指定する。
     しかし、（`t'でも`nil'でも`foo'でもない）それ以外の値は、
     `foo'と同様に`Ask'と表示される。

`(function-item FUNCTION)'
     `const'と同様だが、関数であるような値に使う。
     これは、関数名に加えて説明文字列を表示する。
     説明文字列は、`:doc'に指定したものか、
     FUNCTIONそのものの説明文字列である。

`(variable-item VARIABLE)'
     `const'と同様だが、変数名であるような値に使う。
     これは、変数名に加えて説明文字列を表示する。
     説明文字列は、`:doc'に指定したものか、
     VARIABLEそのものの説明文字列である。

`(set ELEMENTS...)'
     値はリストである必要があり、
     その各要素はELEMENTSに指定したものの1つである必要がある。
     これは、カスタマイズバッファにはチェックリストとして表示される。

`(repeat ELEMENT-TYPE)'
     値はリストである必要があり、
     その各要素はELEMENT-TYPEに指定した型に合う必要がある。
     これは、カスタマイズバッファには、
     要素を追加したり削除したりする`[INS]'や`[DEL]'ボタンを伴って、
     要素のリストとして表示される。


File: elisp-ja,  Node: Splicing into Lists,  Next: Type Keywords,  Prev: Composite Types,  Up: Customization Types

13.4.3 リストに繋ぎ合わせる
-------------------------------------

`:inline'機能により、可変個数の要素をリストやベクトルの
途中に繋ぎ合わせることができます。 `list'や`vector'の要素型に現れる
`set'型、`choice'型、`repeat'型の中に使います。

   通常、`list'や`vector'のおのおのの要素型は、
リストやベクトルのたった1つの要素を記述します。
したがって、要素型が`repeat'であると、
1要素として表示される長さを指定しないリストを指定します。

   しかし、要素型に`:inline'を使うと、
これに一致する値は、`:inline'を含むシーケンスに直接に併合されます。
たとえば、3要素のリストに一致すると、
それがシーケンス全体の3つの要素になります。
これはバッククォート構文の`,@'の使い方に似ています。

   たとえば、先頭要素が`t'であり、
残りが`foo'か`bar'の0個以上の繰り返しであるリストを指定するには、
つぎのカスタマイズ型を使います。

     (list (const t) (set :inline t foo bar))

これは、`(t)'、`(t foo)'、`(t bar)'、`(t foo bar)'などの
値に一致します。

   要素型が`choice'であるときには、
`choice'そのものには`:inline'を使いませんが、
`choice'の選択肢（のどれか）に`:inline'を使います。
たとえば、ファイル名で始まりシンボル`t'か2つの文字列が続くような
リストに一致するようにするには、 つぎのカスタマイズ型を使います。

     (list file
           (choice (const t)
                   (list :inline t string string)))

ユーザーが最初の選択肢を選ぶと、全体としてのリストは2要素になり、
第2要素は`t'です。 ユーザーが2番目の選択肢を選ぶと、
全体としてのリストは3要素になり、
第2要素と第3要素は文字列である必要があります。


File: elisp-ja,  Node: Type Keywords,  Prev: Splicing into Lists,  Up: Customization Types

13.4.4 型キーワード
-------------------------

型名のシンボルのあとに、カスタマイズ型内にキーワード・引数の対を指定できます。
使えるキーワードとその意味を以下に示します。

`:value DEFAULT'
     `choice'の内側の選択肢として現れる型に使う。
     これは、カスタマイズバッファのメニューでユーザーがこの選択肢を選ぶと、
     使用するデフォルト値をまず指定する。

     もちろん、オプションの実際の値がこの選択肢に合えば、
     DEFAULTではなく実際の値が表示される。

     選択肢の値として`nil'が不正であるときには、
     `:value'で正当なデフォルトを指定することが本質的である。

`:format FORMAT-STRING'
     この文字列は、型に対応する値を表現するためにバッファに挿入される。
     FORMAT-STRINGには、以下に示す`%'を使える。

    `%[BUTTON%]'
          ボタンとして印を付けたテキストBUTTONを表示する。
          `:action'属性は、ユーザーがボタンを起動したらなにを行うかを指定する。
          その値は2つの引数、つまり、ボタンが現れるウィジェットとイベント
          を取る関数であること。

          異なるアクションを有する異なるボタンを指定する方法はない。

    `%{SAMPLE%}'
          `:sample-face'で指定した特別なフェイスでSAMPLEを表示する。

    `%v'
          項目の値で置き換える。 値の表示方法は項目の種類と、
          （変数の）カスタマイズ型に依存する。

    `%d'
          項目の説明文字列で置き換える。

    `%h'
          `%d'と同様だが、説明文字列が1行を超えるときには、
          説明文字列全体を表示するか先頭行だけを表示するかを
          制御するアクティブフィールドを追加する。

    `%t'
          タグで置き換える。 タグは`:tag'キーワードで指定する。

    `%%'
          `%'をそのまま表示する。

`:action ACTION'
     ユーザーがボタンをクリックしたらACTIONを行う。

`:button-face FACE'
     `%[...%]'で表示するボタンテキストに
     フェイスFACE（フェイス名かフェイス名のリスト）を使う。

`:button-prefix PREFIX'
`:button-suffix SUFFIX'
     これらは、以下のようにボタンの前後に表示するテキストを指定する。

    `nil'
          テキストを挿入しない。

    文字列
          文字列をそのまま挿入する。

    シンボル
          シンボルの値を使う。

`:tag TAG'
     この型に対応する値（やその一部）に対するタグとして
     TAG（文字列）を使う

`:doc DOC'
     この型に対応する値（やその一部）に対する説明文字列として
     DOCを使う。 これが動作するためには、 `:format'の値を指定し、かつ、
     その値の中で`%d'や`%h'を使う必要がある。

     型に対して説明文字列を指定するのは、
     `:choice'の選択肢や他の複合型の一部の意味について
     より多くの情報をユーザーに与えるためである。

`:help-echo MOTION-DOC'
     `widget-forward'や`widget-backward'でこの項目に移動すると、
     エコー領域に文字列MOTION-DOCを表示する。

`:match FUNCTION'
     値がこの型に一致することを調べる方法を指定する。
     対応する値FUNCTIONは、2つの引数、つまり、
     ウィジェットと値を取る関数であること。
     受理できる値の場合には`nil'以外を返すこと。




File: elisp-ja,  Node: Loading,  Next: Byte Compilation,  Prev: Customization,  Up: Top

14 ロード
************

Lispコードのファイルをロードするとは、
その内容をLispオブジェクトの形でLisp環境に取り込むことです。
Emacsは、ファイルを探してオープンし、テキストを読み取り、
各フォームを評価し、そしてファイルをクローズします。

   ロード関数は、関数`eval-current-buffer'がバッファ内の
すべての式を評価するように、ファイル内のすべての式を評価します。
異なる点は、ロード関数は、Emacsバッファ内のテキストではなく
ディスク上のファイル内のテキストを読み取って評価することです。

ロードするファイルには、Lisp式のソースコードかバイトコンパイル済みコードが
入っている必要があります。
ファイルの各フォームを"トップレベルのフォーム"（top-level form）と
呼びます。
ロード可能なファイル内のフォーム向けの特別な書式はありません。
ファイル内のどんなフォームでも、バッファに直接打ち込んで評価できます。
（もちろん、ほとんどのコードはこのようにして試したはず。）
ほとんどの場合、フォームは関数定義や変数定義です。

Lispコードを収めたファイルをしばしば"ライブラリ"（library）と呼びます。
したがって、『rmailライブラリ』は、rmailモード用のコードを収めたファイルです。
同様に、『Lispライブラリディレクトリ』は、
Lispコードを収めたファイルのディレクトリです。

* Menu:

* How Programs Do Loading::     The `load' function and others.
* Library Search::              Finding a library to load.
* Loading Non-ASCII::           Non-ASCII characters in Emacs Lisp files.
* Autoload::                    Setting up a function to autoload.
* Repeated Loading::            Precautions about loading a file twice.
* Named Features::              Loading a library if it isn't already loaded.
* Unloading::			How to ``unload'' a library that was loaded.
* Hooks for Loading::		Providing code to be run when
				  particular libraries are loaded.


File: elisp-ja,  Node: How Programs Do Loading,  Next: Library Search,  Up: Loading

14.1 プログラムからのロード方法
============================================

Emacs Lispには、ロードのためのインターフェイスがいくつかあります。
たとえば、`autoload'は、
ファイルで定義された関数向けに場所を確保するオブジェクトを作成します。
自動ロードする関数を呼び出すと、
ファイルの実際の定義を得るためにファイルをロードします（*note
Autoload::）。
`require'は、ファイルをすでにロードしていなければロードします （*note
Named Features::）。
これらの機構はすべて、最終的には、関数`load'を呼び出して動作します。

 -- Function: load filename &optional missing-ok nomessage nosuffix
          must-suffix
     この関数は、Lispコードのファイルを探してオープンし、
     その中のフォームすべてを評価してから、ファイルをクローズする。

     ファイルを探すために、
     `load'はまず`FILENAME.elc'という名前のファイル、
     つまり、FILENAMEに`.elc'を付加した名前のファイルを探す。
     そのようなファイルが存在すれば、それをロードする。
     そのような名前のファイルがなければ、
     `load'は`FILENAME.el'という名前のファイルを探す。
     そのファイルが存在すれば、それをロードする。
     いずれの名前のファイルもみつからなければ、
     最終的に、`load'は、なにも付加しないFILENAMEという名前のファイルを
     探し、存在すればそれをロードする。
     （関数`load'がFILENAMEを探す手順は賢くない。 `(load
     "foo.el")'を評価すると、
     `foo.el.el'という名前のファイルを探してしまう。）

     省略可能な引数NOSUFFIXが`nil'以外であれば、
     `.elc'と`.el'の接尾辞を試さない。
     この場合、目的のファイルの正確な名前を指定する必要がある。
     正確なファイル名を指定し、かつ、NOSUFFIXに`t'を使えば、
     `foo.el.el'のようなファイル名を探してしまうことを防げる。

     省略可能な引数MUST-SUFFIXが`nil'以外であれば、
     `load'は、ディレクトリ名を明示していない限り、
     ファイル名は`.el'か`.elc'で終るものと仮定する。
     FILENAMEにディレクトリ名が明示してなく、かつ、
     接尾辞も指定してなければ、`load'は接尾辞を必ず付加する。

     FILENAMEが`foo'や`baz/foo.bar'のように
     相対ファイル名であると、`load'は変数`load-path'を使って
     ファイルを探す。
     FILENAMEに`load-path'に指定した各ディレクトリを付加し、
     最初にみつかったファイルをロードする。
     デフォルトディレクトリを表す`nil'が`load-path'に
     指定されている場合に限り、カレントディレクトリを試す。
     `load'は、まず最初のディレクトリで3つの可能な接尾辞を試し、
     続いて2番目のディレクトリで3つの可能な接尾辞を試し、
     というように行う。 *note Library Search::。

     `foo.elc'が`foo.el'より古いという旨の警告を受け取った場合には、
     `foo.el'の再コンパイルを考えるべきである。 *note Byte
     Compilation::。

     （コンパイルしていない）ソースファイルをロードするときには、
     Emacsがファイルを訪問する場合と同様に、
     `load'は文字集合を変換する。 *note Coding Systems::。

     NOMESSAGEが`nil'であると、 ロード中にはエコー領域に `Loading
     foo...'や`Loading foo...done'のメッセージを表示する。

     ファイルをロード中に処理できないエラーに出会うと、ロードを終了する。
     `autoload'によるロードの場合には、
     ロード中に行われた関数定義はすべてもとに戻す。

     `load'がロードすべきファイルをみつけられないと、 普通、（`Cannot
     open load file FILENAME'を伴った） エラー`file-error'を通知する。
     MISSING-OKが`nil'以外であれば、 `load'は`nil'を返すだけである。

     変数`load-read-function'を使って、
     式を読み取るために`read'のかわりに`load'が使う関数を指定できる。
     下記参照。

     ファイルを正しくロードできると`load'は`t'を返す。

 -- コマンド: load-file filename
     このコマンドはファイルFILENAMEをロードする。
     FILENAMEが相対ファイル名であると、
     現在のデフォルトディレクトリを仮定する。
     `load-path'を使わず、接尾辞も付加しない。
     ロードするファイル名を正確に指定したい場合にこのコマンドを使う。

 -- コマンド: load-library library
     このコマンドは、LIBRARYという名前のライブラリをロードする。
     `load'と等価であるが、引数を対話的に読み取る点が異なる。

 -- Variable: load-in-progress
     Emacsがファイルをロード処理中であると、
     この変数は`nil'以外であり、さもなければ`nil'である。

 -- Variable: load-read-function
     この変数は、`load'や`eval-region'が、
     `read'のかわりに使う、式を読み取る関数を指定する。
     その関数は`read'と同様に引数を1つとること。

     通常、この変数の値は`nil'であり、
     これらの関数が`read'を使うことを意味する。

     *注意：*` '
     この変数を使うかわりに、`eval-region'の引数READ-FUNCTIONとして
     関数を渡す新しい別の機能を使ったほうが見通しがよい。 *note Eval::。

   Emacs構築時の`load'の使い方についての情報は、 *Note Building
Emacs::。


File: elisp-ja,  Node: Library Search,  Next: Loading Non-ASCII,  Prev: How Programs Do Loading,  Up: Loading

14.2 ライブラリの探索
=============================

EmacsがLispライブラリをロードするときには、
変数`load-path'で指定したディレクトリ群でライブラリを探します。

 -- User Option: load-path
     この変数の値は、`load'でファイルをロードするときに探索する
     ディレクトリのリストである。
     各要素は、（ディレクトリ名である）文字列か
     （カレント作業ディレクトリを表す）`nil'である。

   `load-path'の値は、環境変数`EMACSLOADPATH'があれば、
それで初期化します。 さもなければ、デフォルト値は、
Emacsを構築したときに`emacs/src/paths.h'で指定したものです。
そして、リスト内のディレクトリのサブディレクトリをリストに追加して
拡張します。

   `EMACSLOADPATH'の構文は`PATH'と同じです。
`:'（オペレーティングシステムによっては`;'）で
ディレクトリ名を区切ります。
デフォルトのカレントディレクトリには`.'を使います。
`csh'の`.login'ファイルで環境変数`EMACSLOADPATH'を
指定する例はつぎのとおりです。

     setenv EMACSLOADPATH .:/user/bil/emacs:/usr/local/share/emacs/20.3/lisp

   `sh'を使っている場合はつぎのようにします。

     export EMACSLOADPATH
     EMACSLOADPATH=.:/user/bil/emacs:/usr/local/share/emacs/20.3/lisp

   `.emacs'ファイルで、
デフォルトの`load-path'の先頭に複数のディレクトリを追加するには、
つぎのようなコードを書きます。

     (setq load-path
           (append (list nil "/user/bil/emacs"
                         "/usr/local/lisplib"
                         "~/emacs")
                   load-path))

この例では、Lispコードを、まずカレント作業ディレクトリで探索し、
続いて、`/user/bil/emacs'ディレクトリ、
`/usr/local/lisplib'ディレクトリ、`~/emacs'ディレクトリ、
さらに、標準のディレクトリで探索します。

   Emacsのダンプには、`load-path'の特別な値を使います。
ダンプ終了時に`load-path'の値が未変更（つまり、同じ特別な値）であれば、
ダンプ版Emacsは起動時に、上に述べたように、普通の`load-path'の値を
使います。 しかし、ダンプ終了時に`load-path'の値が別の値であれば、
ダンプ版Emacsの実行でもその（別の）値を使います。

   したがって、`site-init.el'や`site-load.el'で
少数のライブラリをロードするために
一時的に`load-path'を変更したい場合には、
`load'の呼び出しを`let'で囲んで
`load-path'をローカルに束縛するべきです。

   システムにインストールしたEmacsを実行中は、
`load-path'のデフォルト値には、2つの特別なディレクトリ
（とそれらのサブディレクトリ）が含まれます。

     "/usr/local/share/emacs/VERSION/site-lisp"

と

     "/usr/local/share/emacs/site-lisp"

です。
前者は、Emacsの特定の版向けにローカルにインストールしたパッケージ用です。
後者は、Emacsの任意の版向けにローカルにインストールしたパッケージ用です。

   Emacsのある版向けのパッケージが別の版ではトラブルを引き起こす理由は
いくつかあります。
Emacsの互換性のない変更のために更新を必要とするパッケージもあります。
予告なしに変更される可能性のある明文化していない
Emacsの内部データに依存するものもあります。
Emacsの新しい版では、パッケージの特定の版と一体になっているものもあり、
その版だけで使うべきです。

   Emacsは、起動すると、ディレクトリのサブディレクトリを捜し出して、
それらを`load-path'に追加します。
直下のサブディレクトリも複数レベル下のサブディレクトリも
`load-path'に追加します。

   しかし、サブディレクトリすべてを含むわけではありません。
英数字で始まらない名前のサブディレクトリは除外します。
`RCS'という名前のサブディレクトリも除外します。
また、`.nosearch'という名前のファイルを置いた
サブディレクトリも除外します。
これらの方法を用いれば、`site-lisp'ディレクトリ下の
特定のサブディレクトリの探索を防げます。

   Emacsを構築したディレクトリでEmacsを起動すると、
つまり、正式にインストールしてない実行形式を起動すると、
`load-path'には、普通、2つのディレクトリを追加します。
主構築ディレクトリのサブディレクトリ、`lisp'と`site-lisp'です。
（どちらも、絶対ファイル名で表される。）

 -- コマンド: locate-library library &optional nosuffix path
          interactive-call
     このコマンドは、ライブラリLIBRARYの正確なファイル名を探す。
     `load'と同様にライブラリを探索する。
     引数NOSUFFIXの意味は`load'と同じであり、
     指定した名前LIBRARYに接尾辞`.elc'や`.el'を付加しない。

     PATHが`nil'以外であると、
     それは`load-path'のかわりに使うディレクトリのリストである。

     `locate-library'をプログラムから呼び出した場合、
     文字列でファイル名を返す。
     ユーザーが`locate-library'を対話的に実行した場合、
     引数INTERACTIVE-CALLは`t'であり、これは
     `locate-library'に対してファイル名をエコー領域に表示するように指示する。


File: elisp-ja,  Node: Loading Non-ASCII,  Next: Autoload,  Prev: Library Search,  Up: Loading

14.3 非ASCII文字のロード
===============================

Emacs Lispプログラムが非ASCII文字の文字列定数を含む場合、
Emacs内部では、それらはユニバイト文字列かマルチバイト文字列で表現できます
（*note Text Representations::）。 どちらの表現形式を用いるかは、
どのようにファイルをEmacsに読み込んだかに依存します。
マルチバイト表現へ復号化して読んだ場合には、
Lispプログラムのテキストはマルチバイトテキストになり、
その文字列定数はマルチバイト文字列になります。
（たとえば）Lantin-1文字を含むファイルを復号化せずに読むと、
プログラムテキストはユニバイトテキストになり、
その文字列定数はユニバイト文字列になります。 *Note Coding Systems::。

   結果をより予測可能にするために、
オプション`--unibyte'を指定して起動した場合であっても、
Lispファイルをロードするときには、
Emacsはつねにマルチバイト表現に復号化します。
つまり、非ASCII文字の文字列定数はマルチバイト文字列に変換します。
唯一の例外は、特定のファイルで無変換を指定した場合だけです。

   Emacsをこのように設計したのは、 Emacsの起動方法によらずに、
Lispプログラムが予測可能な結果をもたらすようにするためです。
さらに、こうすることで、ユニバイト動作のEmacsであっても、
マルチバイトテキストを使うことに依存したプログラムが動作します。
もちろん、そのようなプログラムは、
`default-enable-multibyte-characters'を検査して適切に表現を変換して、
ユーザーがユニバイトテキストとマルチバイトテキストのどちらを
好んでいるか調べるように設計すべきです。

   Emacs Lispのほとんどのプログラムでは、
非ASCII文字列はマルチバイト文字列であるということに 気づかないでしょう。
というのは、それらをユニバイトバッファに挿入すると
自動的にユニバイトに変換するからです。
しかしながら、これで違いがでるならば、
Lispファイルの先頭行のコメントに`-*-unibyte: t;-*-'と書くことで、
特定のLispファイルをユニバイトと解釈するように強制できます。
このように指定すると、マルチバイト動作のEmacsであっても、
そのファイルを無条件にユニバイトと解釈します。


File: elisp-ja,  Node: Autoload,  Next: Repeated Loading,  Prev: Loading Non-ASCII,  Up: Loading

14.4 自動ロード
====================

"自動ロード"（autoload）機能により、
関数やマクロを定義しているファイルをロードしていなくても、
関数やマクロをLispに登録できます。 関数を初めて呼び出すと、
適切なファイルを読み込んで実際の定義と関連する他のコードを
インストールしてから、すでにロードしてあったかのように実際の定義を実行します。

   関数を自動的にロードするように設定する方法は2つあります。
`autoload'を呼び出すか、あるいは、
ソース内の実際の定義のまえに特別な『マジック』コメントを書きます。
`autoload'は自動ロードを行う低レベルの基本関数です。
任意のLispプログラムでいつでも`autoload'を呼び出せます。
マジックコメントは、Emacsで使うパッケージ向けに
関数を自動的にロードするように設定するとても便利な方法です。
これらのコメントそのものはなにもしませんが、
コマンド`update-file-autoloads'に対する指針として働きます。
このコマンドは、`autoload'の呼び出しを作成し、
Emacs構築時にそれらを実行するように設定します。

 -- Function: autoload function filename &optional docstring
          interactive type
     この関数は、FUNCTIONという名前の関数（やマクロ）を
     FILENAMEから自動的にロードするように定義する。
     文字列FILENAMEは、FUNCTIONの実際の定義を取得するために
     ロードするファイルを指定する。

     FILENAMEにディレクトリ名や接尾辞`.el'や`.elc'がなければ、
     `autoload'はこれらの接尾辞の1つを必ず付加し、
     接尾辞を付けないFILENAMEという名前のファイルはロードしない。

     引数DOCSTRINGは、関数に対する説明文字列である。
     通常、これは関数定義そのものの説明文字列と同一であること。
     `autoload'の呼び出しにおいて説明文字列を指定しておくことで、
     関数の実際の定義をロードしなくても説明文を見ることが可能になる。

     INTERACTIVEが`nil'以外ならば、
     FUNCTIONを対話的に呼び出せることを意味する。
     つまり、関数の実際の定義をロードしなくても
     `M-x'の補完が動作するのである。 完全な対話指定を指定しない。
     ユーザーがFUNCTIONを実際に呼び出すまでは必要なく、
     呼び出し時点で実際の定義をロードするからである。

     普通の関数と同様に、マクロやキーマップも自動的にロードできる。
     FUNCTIONが実際にはマクロならば、TYPEには`macro'を指定する。
     FUNCTIONが実際にはキーマップならば、 TYPEには`keymap'を指定する。
     Emacsのさまざまな部分では、
     実際の定義をロードせずにこの情報を知る必要がある。

     自動ロードと指定したキーマップは、
     プレフィックスキーのバインディングがシンボルFUNCTIONであるときに、
     キーを探す過程で自動的にロードする。
     キーマップのこれ以外の参照方法では、自動的にロードしない。
     特に、変数名がシンボルFUNCTIONと同じであっても、
     Lispプログラムで変数の値からキーマップを取得して
     `define-key'を呼び出す場合には、自動的にロードしない。

     FUNCTIONが自動ロードオブジェクトではない
     空でない関数定義を有する場合には、
     `autoload'はなにもせずに`nil'を返す。
     FUNCTIONの関数セルが空であったり、
     すでに自動ロードオブジェクトである場合には、
     つぎのような自動ロードオブジェクトとして関数セルを定義する。

          (autoload FILENAME DOCSTRING INTERACTIVE TYPE)

     たとえばつぎのとおり。

          (symbol-function 'run-prolog)
               => (autoload "prolog" 169681 t nil)

     この場合、`"prolog"'はロードすべきファイルの名前であり、
     169681はファイル`emacs/etc/DOC-VERSION' （*note Documentation
     Basics::）内の説明文字列を指す。
     `t'は関数が対話的であることを示し、
     `nil'はマクロでもキーマップでもないことを示す。

   自動ロード対象のファイルでは、通常、他の定義や
複数の機能を提供したり必要としたりします。
（その内容の評価中のエラーなどで）ファイルを完全にロードできないと、
ロード中に行った関数定義や`provide'の呼び出しをもとに戻します。
そのファイルから自動ロードする任意の関数をつぎに呼び出そうとしたときに、
そのファイルを再度ロードすることを保証するためです。
こうしておかないと、
自動ロードをアボートしたファイルで関数が定義されても、
そのファイルのうしろの部分で定義される
その関数に必要なサブルーティンが必ずしもロードされないために
その関数が動作しない可能性があるからです。

   自動ロード対象のファイルで必要なLisp関数やマクロの定義に失敗すると、
`"Autoloading failed to define function FUNCTION-NAME"'を
伴ったエラーを通知します。

   自動ロードを指定するマジックコメントは、
`;;;###autoload'だけを書いた行であり、
自動ロード対象のソースファイル上で実際の関数定義の直前に必要です。
コマンド`M-x update-file-autoloads'は、
対応する`autoload'呼び出しを`loaddefs.el'に書き込みます。
Emacs構築時には`loaddefs.el'をロードするので、
`autoload'を呼び出します。 `M-x
update-directory-autoloads'はもっと強力で、
カレントディレクトリのすべてのファイルに対する自動ロード情報を更新します。

   同じマジックコメントは、任意の種類のフォームを`loaddefs.el'に
コピーできます。 マジックコメントに続くフォームが関数定義でない場合、
そのフォームをそのままコピーします。 構築時にはフォームを実行しても、
ファイルのロード時にはそのフォームを実行しないように
マジックコメントを使うこともできます。
そうするには、マジックコメントと_同じ行に_そのフォームを書きます。
するとそれはコメントなので、ソースファイルをロードするときにはなにもしません。
一方、`M-x update-file-autoloads'はそのフォームを`loaddefs.el'に
コピーするので、Emacs構築時には実行されるのです。

つぎの例は、マジックコメントを使って`doctor'を自動ロードする方法です。

     ;;;###autoload
     (defun doctor ()
       "Switch to *doctor* buffer and start giving psychotherapy."
       (interactive)
       (switch-to-buffer "*doctor*")
       (doctor-mode))

こうすると、`loaddefs.el'ではつぎのようになります。

     (autoload 'doctor "doctor"
       "\
     Switch to *doctor* buffer and start giving psychotherapy."
       t)

ダブルクォートの直後にバックスラッシュや改行を書く慣習は、
`loaddefs.el'などの
あらかじめロードするLispファイルの中だけで使うものです。
これは、`make-docfile'に対して、
説明文字列を`etc/DOC'ファイルに書くように指示します。 *Note Building
Emacs::。


File: elisp-ja,  Node: Repeated Loading,  Next: Named Features,  Prev: Autoload,  Up: Loading

14.5 ロードの繰り返し
=============================

1つのEmacsセッションにおいて、あるファイルを複数回ロードできます。
たとえば、バッファ内の関数定義を編集して、
関数定義を書き直してインストールし直したあとで、
もとの版に戻したいこともあるでしょう。
これには、もとのファイルを再ロードすればよいのです。

   ファイルをロードしたり再ロードするとき、
関数`load'や`load-library'は、 コンパイルしていないファイルではなく、
バイトコンパイル済みのファイルを自動的にロードすることに注意してください。
ファイルを書き直して保存してから再インストールする場合、
新しい版をバイトコンパイルする必要があります。
さもないと、Emacsは、新しいコンパイルしていないファイルではなく、
バイトコンパイル済みの古いファイルをロードしてしまいます。
そのような場合、ファイルをロードすると、 `(compiled; note, source is
newer)'とメッセージを表示して、 再コンパイルするように忠告してきます。

   Lispライブラリファイルにフォームを書くときには、
ファイルを複数回ロードする可能性があることを忘れないでください。
たとえば、ライブラリを再ロードするたびに
各変数を再初期化すべきかどうか考えましょう。
`defvar'は、初期化済みの変数の値を変更しません。 （*note Defining
Variables::。）

   連想リストに要素を追加するもっとも簡単な方法はつぎのとおりです。

     (setq minor-mode-alist
           (cons '(leif-mode " Leif") minor-mode-alist))

しかし、これでは、ライブラリを再ロードすると、
複数の要素を追加してしまいます。 これを避けるにはつぎのようにします。

     (or (assq 'leif-mode minor-mode-alist)
         (setq minor-mode-alist
               (cons '(leif-mode " Leif") minor-mode-alist)))

   リストに要素を1回だけ追加するには、 `add-to-list'（*note Setting
Variables::）も使えます。

ライブラリをすでにロードしたかどうか明示的に調べたいこともあるでしょう。
ライブラリ内で以前ロードされたかどうか検査する方法の1つは、
つぎのとおりです。

     (defvar foo-was-loaded nil)

     (unless foo-was-loaded
       EXECUTE-FIRST-TIME-ONLY
       (setq foo-was-loaded t))

ライブラリで名前付き機能を提供するために`provide'を使っていれば、
ファイルの始めのほうで`featurep'を使って、
`provide'を以前呼び出したかどうか検査できます。 *Note Named Features::。


File: elisp-ja,  Node: Named Features,  Next: Unloading,  Prev: Repeated Loading,  Up: Loading

14.6 機能
===========

`provide'と`require'は、
ファイルを自動的にロードするための`autoload'の代替手段です。
それらは指定した"機能"（features）という考え方で動作します。
自動ロードは特定の関数を呼び出すことで起動しますが、
機能はその名前でプログラムが最初に要求したときにロードします。

   機能名は、関数や変数などの集合を表すシンボルです。
それらを定義するファイルでは、その機能を"提供"（provide）します。
それらを使う別のプログラムでは、 その機能を"要求"（require）することで、
それらが定義されることを確実にします。
こうすると、未ロードであれば定義しているファイルをロードします。

   機能を要求するには、機能名を引数にして`require'を呼び出します。
`require'は、グローバル変数`features'を調べて、
目的の機能がすでに提供されているかどうか調べます。
提供されていなければ、適当なファイルから機能をロードします。
このファイルでは、トップレベルで`provide'を呼び出して、
`features'に機能を追加するべきです。
そうしないと、`require'はエラーを通知します。 

   たとえば、`emacs/lisp/prolog.el' には、
つぎのコードのような`run-prolog'の定義が入っています。

     (defun run-prolog ()
       "Run an inferior Prolog process, with I/O via buffer *prolog*."
       (interactive)
       (require 'comint)
       (switch-to-buffer (make-comint "prolog" prolog-program-name))
       (inferior-prolog-mode))

`(require 'comint)'は、ファイル`comint.el'が未ロードであると、
そのファイルをロードします。
これにより、`make-comint'が定義済みであることを保証します。
普通、機能には、その機能を提供するファイル名からとった名前を付けますから、
`require'にファイル名を指定する必要はありません。

   `comint.el'ファイルには、つぎのトップレベルの式が入っています。

     (provide 'comint)

これにより、グローバル変数`features'のリストに
`comint'が追加されるので、 これ以降に`(require 'comint)'を実行しても、
なにもしないでよいことになります。

   ファイルのトップレベルで`require'を使うと、
そのファイルをロードする場合と同様に、
そのファイルをバイトコンパイルするとき（*note Byte Compilation::）にも
`require'には効果があります。 要求したパッケージに、
バイトコンパイラが知っている必要があるマクロが入っている場合です。

   トップレベルの`require'の呼び出しは、
バイトコンパイル中に評価されますが、 `provide'の呼び出しは評価しません。
したがって、つぎの例のように、
同じ機能に対する`provide'に続けて`require'を書くことで、
バイトコンパイルするまえに定義のファイルをロードすることを確実にできます。

     (provide 'my-feature)  ; バイトコンパイラは無視し、
                            ;   `load'は評価する
     (require 'my-feature)  ; バイトコンパイラは評価する

コンパイラは`provide'を無視し、
続く`require'の処理では当該ファイルをロードします。
ファイルのロード時には`provide'の呼び出しを実行するので、
そのあとの`require'の呼び出しは、
ファイルをロードするときにはなにもしません。

 -- Function: provide feature
     この関数は、機能FEATUREをロードし終えたこと、あるいは、
     ロード中であることを現在のEmacsセッション内で宣言する。
     つまり、FEATUREに関連した機能が他のLispプログラムから利用できることを
     意味する。

     `provide'の呼び出しの直接の効果は、
     FEATUREがリスト`features'に入っていなければ、
     FEATUREをリスト`features'の先頭に入れることである。
     引数FEATUREはシンボルであること。 `provide'はFEATUREを返す。

          features
               => (bar bish)

          (provide 'foo)
               => foo
          features
               => (foo bar bish)

     自動ロードによってファイルをロードしているとき、
     その内容を評価することでエラーになってロードを中止すると、
     ロード中に行われた関数定義や`provide'の呼び出しはもとに戻す。
     *note Autoload::。

 -- Function: require feature &optional filename
     この関数は（`(featurep FEATURE)'を使って）
     現在のEmacsセッション内にFEATUREが存在するかどうか調べる。
     引数FEATUREはシンボルであること。

     機能が存在していなければ、`require'は、
     `load'を使ってFILENAMEをロードする。
     FILENAMEを指定しないと、シンボルFEATUREの名前を
     ロードすべきファイル名の基にする。
     しかしながら、この場合には、`require'は、
     接尾辞を必ず付加してFEATUREを探す。
     FEATUREだけの名前のファイルは探さない。

     FEATUREを提供するファイルのロードに失敗すると、 `require'はエラー
     `Required feature FEATURE was not provided'を通知する。

 -- Function: featurep feature
     この関数は、現在のEmacsセッションでFEATUREが提供されていれば
     （つまり、FEATUREが`features'のメンバであれば） `t'を返す。

 -- Variable: features
     この変数の値は、
     現在のEmacsセッションにロード済みの機能を表すシンボルのリストである。
     各シンボルは、`provide'を呼び出すことでこのリストに追加される。
     リスト`features'内の要素の順番は関係ない。


File: elisp-ja,  Node: Unloading,  Next: Hooks for Loading,  Prev: Named Features,  Up: Loading

14.7 アンロード
====================

ライブラリでロードした関数や変数を捨てさって
他のLispオブジェクト向けにメモリを回収することができます。
そうするには関数`unload-feature'を使います。

 -- コマンド: unload-feature feature &optional force
     このコマンドは、FEATUREを提供するライブラリをアンロードする。
     つまり、当該ライブラリにおいて、`defun'、`defalias'、
     `defsubst'、`defmacro'、`defconst'、`defvar'、
     `defcustom'で定義した関数、マクロ、変数すべてを未定義にする。
     そうして、これらのシンボルに以前設定してあった自動ロードの設定を復元する。
     （ロード時に、これらをシンボルの属性`autoload'に保存している。）

     以前の定義に復元するまえに、`unload-feature'は`remove-hook'を
     実行して、ライブラリ内の関数を特定のフックから取り除く。
     これらのフックは、`-hook'や`-hooks'で終る名前の変数、および、
     `loadhist-special-hooks'に入っているものである。
     これは、重要なフックにおいて存在しない関数を参照することで
     Emacsが動作不能になるのを防ぐ。

     これらの処置でも誤動作防止には不十分であるときには、
     ライブラリで明示的なアンロードフックを定義できる。
     `FEATURE-unload-hook'を定義してあると、
     以前の定義を復元するまえに、 フックを削除する通常の動作の_かわりに_
     このフックをノーマルフックとして実行する。 アンロードフックでは、
     ライブラリをいったんアンロードすると動作不能になるような
     ライブラリで変更したグローバルな状態をすべてアンドゥすべきである。

     通常、`unload-feature'は、他のライブラリが依存している
     ライブラリのアンロードは拒否する。
     （ライブラリAでBを`require'（要求）していると、
     ライブラリAはライブラリBに依存している。）
     省略可能な引数FORCEが`nil'以外であると、
     依存関係を無視し、任意のライブラリをアンロードできる。

   関数`unload-feature'はLispで書いてあり、
その動作は`load-history'に基づきます。

 -- Variable: load-history
     この変数の値は、ライブラリ名をそのライブラリが定義する関数や変数の名前、
     そのライブラリが提供する機能、そのライブラリが要求する機能に対応付ける
     連想リストである。

     各要素はリストであり、1つ1つが1つのライブラリを記述する。
     リストのCARは文字列であり、ライブラリ名である。
     リストの残りは、以下の種類のオブジェクトから成る。

        * このライブラリで定義されたシンボル。

        * `(require . FEATURE)'の形のリストであり、 要求する機能を示す。

        * `(provide . FEATURE)'の形のリストであり、 提供する機能を示す。

     `load-history'の値には、CARが`nil'であるような
     1つの要素があってもよい。
     この要素は、ファイルを訪問してないバッファ内で`eval-buffer'によって
     作られた定義であることを示す。

   コマンド`eval-region'は`load-history'を更新しますが、
訪問先ファイルに対応する要素に、定義されるシンボルを追加するのであって、
要素を置き換えるのではありません。

   あらかじめロード済みのライブラリは、`load-history'に寄与しません。

 -- Variable: loadhist-special-hooks
     この変数は、ライブラリ内で定義された関数を削除するために
     ライブラリをアンロードするまえに走査するフックのリストを保持する。


File: elisp-ja,  Node: Hooks for Loading,  Prev: Unloading,  Up: Loading

14.8 ロード時のフック
=============================

`eval-after-load'を呼び出すと、
特定のライブラリをロードする／してあるときに実行するコードを指定できます。

 -- Function: eval-after-load library form
     この関数は、ライブラリLIBRARYをロードする／してあるときに、
     ライブラリLIBRARYのロードの最後にFORMを評価するように設定する。
     LIBRARYをすでにロードしてあると、
     この関数はFORMをただちに評価する。

     ライブラリ名LIBRARYは`load'の引数に正確に一致する必要がある。
     `load-path'を探索してインストールするライブラリを探したときに
     正しい結果を得るために、LIBRARYにはディレクトリ名を含めないこと。

     FORMでエラーが発生してもロード処理をもとに戻さないが、
     FORMの残りは実行しない。

一般に、よく設計されたLispプログラムはこの機能を使うべきではありません。
Lispライブラリを見通しよくモジュール化して扱うには、
（1）ライブラリの（外部から使うことを意図した）変数を調べて設定し、
（2）ライブラリの関数を呼び出すことです。
（1）を行いたければ、すぐにしてかまいません。
ライブラリをロードするまで待つ必要はありません。
（2）を行うには、ライブラリをロードする必要があります
（`require'で行うことが好ましい）。

   広く使われるプログラムに対する設計基準に合わなくても、
個人のカスタマイズで`eval-after-load'を使うのはかまいません。

 -- Variable: after-load-alist
     特定のライブラリをロードする／してあるときに評価する式の連想リスト。
     各要素はつぎのとおり。

          (FILENAME FORMS...)

     関数`load'は、`eval-after-load'を実現するために
     `after-load-alist'を調べる。


File: elisp-ja,  Node: Byte Compilation,  Next: Advising Functions,  Prev: Loading,  Up: Top

15 バイトコンパイル
***************************

Emacs Lispには、Lispで書いた関数を
より効率よく実行可能な"バイトコード"（byte-code）と呼ばれる
特別な表現に変換する"コンパイラ"（compiler）があります。
コンパイラはLispの関数定義をバイトコードで置き換えます。
バイトコード関数を呼び出すと、 "バイトコードインタープリタ"（byte-code
interpreter）が その定義を評価します。

（真のコンパイル済みコードのように）計算機ハードウェアが直接実行するかわりに、
バイトコードインタープリタがバイトコンパイル済みのコードを評価するので、
バイトコードは、再コンパイルせずに計算機から計算機に移せます。
しかしながら、真のコンパイル済みコードほど速くはありません。

   EmacsバイトコンパイラがLispファイルをコンパイルするときには、
`--unibyte'を指定してEmacsを起動したとしても、
ファイルで特に指定しなければ、
つねにファイルをマルチバイトテキストとして読みます。
コンパイルしても、コンパイルせずに同じファイルを実行した場合と同じ結果を
得るようにするためです。 *Note Loading Non-ASCII::。

一般に、Emacsの任意の版は、それよりまえの版でバイトコンパイルしたコードを
実行できますが、その逆は真ではありません。 Emacs
19.29では互換性のない大きな変更を行いましたから、
それ以降の版でコンパイルしたファイルは、
特別なオプションを指定しない限り、それ以前の版ではまったく動きません。
さらに、Emacs 19.29では、キーボード文字の修飾ビットを変更しました。
その結果、19.29よりまえの版でコンパイルしたファイルは、
修飾ビットを含む文字定数を使っているとそれ以降の版では動作しません。

   バイトコンパイル中に生起するエラーについては、 *Note Compilation
Errors::。

* Menu:

* Speed of Byte-Code::          An example of speedup from byte compilation.
* Compilation Functions::       Byte compilation functions.
* Docs and Compilation::        Dynamic loading of documentation strings.
* Dynamic Loading::             Dynamic loading of individual functions.
* Eval During Compile::  	Code to be evaluated when you compile.
* Byte-Code Objects::		The data type used for byte-compiled functions.
* Disassembly::                 Disassembling byte-code; how to read byte-code.


File: elisp-ja,  Node: Speed of Byte-Code,  Next: Compilation Functions,  Up: Byte Compilation

15.1 バイトコンパイルコードの性能
===============================================

バイトコンパイルした関数は、Cで書いた基本関数ほど効率よくはありませんが、
Lispで書いた版よりはよほど速く動きます。 例を示しましょう。

     (defun silly-loop (n)
       "Return time before and after N iterations of a loop."
       (let ((t1 (current-time-string)))
         (while (> (setq n (1- n))
                   0))
         (list t1 (current-time-string))))
     => silly-loop

     (silly-loop 100000)
     => ("Fri Mar 18 17:25:57 1994"
         "Fri Mar 18 17:26:28 1994")  ; 31秒

     (byte-compile 'silly-loop)
     => [コンパイルしたコードは省略]

     (silly-loop 100000)
     => ("Fri Mar 18 17:26:52 1994"
         "Fri Mar 18 17:26:58 1994")  ; 6秒

   この例では、解釈実行するコードでは実行に31秒必要でしたが、
バイトコンパイルしたコードでは6秒でした。
この結果は代表的なのもですが、実際の結果は大きく変動します。


File: elisp-ja,  Node: Compilation Functions,  Next: Docs and Compilation,  Prev: Speed of Byte-Code,  Up: Byte Compilation

15.2 コンパイル関数
==========================

関数`byte-compile'で、
個々の関数定義やマクロ定義をバイトコンパイルできます。
`byte-compile-file'で1つのファイル全体をコンパイルしたり、
`byte-recompile-directory'や`batch-byte-compile'で
複数個のファイルをコンパイルできます。

   バイトコンパイラは、
各ファイルに対するエラーメッセージや警告メッセージを
`*Compile-Log*'と呼ばれるバッファに出力します。
読者のプログラムに関してここに報告されたことがらは、
問題点を指摘しますが、必ずしもエラーとは限りません。

バイトコンパイルする可能性のあるファイルにマクロ呼び出しを書くときには
注意してください。 マクロ呼び出しはコンパイル時に展開されるので、
正しくコンパイルするためにはマクロは定義済みである必要があります。
詳しくは、*Note Compiling Macros::。

   通常、ファイルをコンパイルしてもファイルの内容を評価したり、
ファイルをロードしません。
しかし、ファイルのトップレベルに書いた`require'は実行します。
コンパイル時に必要なマクロ定義が存在することを保証する1つの方法は、
それらを定義するファイルを要求（`require'）することです （*note Named
Features::）。 コンパイルしたプログラムを_実行する_ときに
マクロ定義ファイルのロードを防ぐには、
`require'の呼び出しの周りに`eval-when-compile'を書きます （*note Eval
During Compile::）。

 -- Function: byte-compile symbol
     この関数は、SYMBOLの関数定義をバイトコンパイルし、
     以前の定義をコンパイルしたもので置き換える。
     SYMBOLの関数定義は、関数の実際のコードであること。
     つまり、コンパイラは、別のシンボルへの間接参照を辿らない。
     `byte-compile'は、SYMBOLのコンパイル済みの新たな定義を返す。

     SYMBOLの定義がバイトコード関数オブジェクトであると、
     `byte-compile'はなにもせずに`nil'を返す。
     Lispはどんなシンボルに対しても関数定義を1つだけ記録するので、
     それがすでにコンパイル済みであると、
     コンパイルまえのコードはどこにもないのである。
     したがって、『同じ定義をコンパイルし直す』方法はない。

          (defun factorial (integer)
            "Compute factorial of INTEGER."
            (if (= 1 integer) 1
              (* integer (factorial (1- integer)))))
          => factorial

          (byte-compile 'factorial)
          =>
          #[(integer)
            "^H\301U\203^H^@\301\207\302^H\303^HS!\"\207"
            [integer 1 * factorial]
            4 "Compute factorial of INTEGER."]

     結果は、バイトコード関数オブジェクトである。
     この文字列には実際のバイトコードが入っている。
     その各文字は、命令や命令のオペランドである。
     ベクトルには、特別な命令に符号化される特定の基本関数を除いて、
     関数が使うすべての定数、変数名、関数名が入っている。

 -- コマンド: compile-defun
     このコマンドはポイントを含む`defun'を読み取り、
     それをコンパイルして、結果を評価する。
     実際に関数定義である`defun'でこのコマンドを使うと、
     その関数をコンパイルしたものをインストールすることになる。

 -- コマンド: byte-compile-file filename
     この関数は、FILENAMEという名前のLispコードのファイルを
     コンパイルしバイトコードのファイルにする。
     出力ファイルの名前は、接頭辞`.el'を`.elc'に換えて作る。
     FILENAMEが`.el'で終っていないときには、
     FILENAMEの末尾に`.elc'を付加する。

     入力ファイルから一度に1つずつフォームを読みながらコンパイルを行う。
     それが関数定義やマクロ定義であると、
     コンパイルした関数定義やマクロ定義を書き出す。
     他のフォームは一塊にして、各塊をコンパイルして書き出し、
     ファイルを読むとコンパイルしたコードが実行されるようにする。
     入力ファイルを読むときにすべてのコメントを捨てる。

     このコマンドは`t'を返す。
     対話的に呼び出すとファイル名を問い合わせる。

          % ls -l push*
          -rw-r--r--  1 lewis     791 Oct  5 20:31 push.el

          (byte-compile-file "~/emacs/push.el")
               => t

          % ls -l push*
          -rw-r--r--  1 lewis     791 Oct  5 20:31 push.el
          -rw-rw-rw-  1 lewis     638 Oct  8 20:25 push.elc

 -- コマンド: byte-recompile-directory directory flag
     この関数は、DIRECTORYにある再コンパイルが必要な
     個々の`.el'ファイルを再コンパイルする。
     ファイルを再コンパイルする必要があるのは、
     `.elc'ファイルが存在しても`.el'ファイルより古い場合である。

     `.el'ファイルに対応する`.elc'ファイルが存在しない場合には、
     FLAGが動作を指示する。
     それが`nil'であると、そのようなファイルは無視する。
     `nil'以外であると、そのような各ファイルをコンパイルするかどうか
     ユーザーに問い合わせる。

     このコマンドの戻り値は予測できない。

 -- Function: batch-byte-compile
     この関数は、コマンド行に指定したファイル群に対して
     `byte-compile-file'を実行する。
     この関数はEmacsをバッチモードで実行しているときにだけ使うこと。
     完了するとEmacsを終了するからである。
     1つのファイルでエラーが発生しても、後続のファイルの処理には影響しないが、
     エラーを起こしたファイルに対する出力ファイルは生成せず、
     Emacsのプロセスは0以外の状態コードで終了する。

          % emacs -batch -f batch-byte-compile *.el

 -- Function: byte-code code-string data-vector max-stack
     この関数はバイトコードを実際に解釈実行する。
     バイトコンパイルした関数は、実際には、
     `byte-code'を呼び出すような本体として定義される。
     この関数を読者自身で呼び出さないこと。
     この関数の正しい呼び出しを生成する方法はバイトコンパイラだけが知っている。

     Emacs 18版では、バイトコードは関数`byte-code'をつねに呼び出すことで
     実行していた。
     現在では、バイトコード関数オブジェクトの一部としてバイトコードを実行するのが
     普通であり、`byte-code'を明示的に呼び出すことは稀である。


File: elisp-ja,  Node: Docs and Compilation,  Next: Dynamic Loading,  Prev: Compilation Functions,  Up: Byte Compilation

15.3 説明文字列とコンパイル
======================================

バイトコンパイルしたファイルからロードした関数や変数では、
それらの説明文字列は、必要に応じてそのファイルを動的に参照します。
これはEmacs内のメモリを節約しロード処理も速くなります。
というのは、ファイルのロード処理で説明文字列を処理する必要がないからです。
説明文字列を実際に参照するのは遅くなりますが、
普通、ユーザーをいらいらさせるほとではありません。

   説明文字列を動的に参照することには欠点があります。

   * コンパイルしたファイルをロード後に削除したり移動したりすると、
     そのファイル内の関数や変数に対する説明文字列をEmacsから参照できなくなる。

   *
     コンパイルしたファイルを（新版をコンパイルするなどして）変更すると、
     それ以降にそのファイルから説明文字列を参照すると、無意味な結果になる。

   読者のサイトでEmacsを通常の手順でインストールした場合には、
これらの問題は普通起こらないはずです。
新版のインストールには別のディレクトリを使いますから、
旧版をインストールしてある限り、そのファイル群は意図した場所に
無変更で残っているはずです。

   しかしながら、読者自身がEmacsを構築して、
構築したディレクトリからEmacsを使う場合、
Lispファイルを編集して再コンパイルすると、
しばしばこの問題を経験するでしょう。
そのような場合には、再コンパイルしたあとでファイルを再ロードすれば
問題を解決できます。

   旧版ではこの機能を使えないので、
Emacsの（19.29以降の）最近の版でバイトコンパイルしたファイルは
旧版ではロードできません。
`byte-compile-dynamic-docstrings'に`nil'を設定すれば、
コンパイル時にこの機能をオフにできます。
Emacsの旧版にロードできるようにファイルをコンパイルできるのです。
すべてのファイルをこのようにコンパイルしたり、あるいは、
この変数をファイルにローカルな束縛に指定して1つのソースファイルだけを
このようにコンパイルしたりもできます。
そのようにする1つの方法は、つぎの文字列をファイルの先頭行に追加することです。

     -*-byte-compile-dynamic-docstrings: nil;-*-

 -- Variable: byte-compile-dynamic-docstrings
     これが`nil'以外であると、
     バイトコンパイラは、説明文字列を動的にロードするように設定した
     コンパイル済みファイルを生成する。

   説明文字列を動的に扱う場合、
コンパイル済みのファイルではLispリーダの特別な構文`#@COUNT'を 使います。
この構文は後続のCOUNT文字を読み飛ばします。
また、`#$'という構文も使います。
これは、『文字列としてのこのファイルの名前』を表します。
Lispのソースファイルでは、これらの構文を使わないのが最良です。
これらは人が読むファイル向けに設計したものではないからです。


File: elisp-ja,  Node: Dynamic Loading,  Next: Eval During Compile,  Prev: Docs and Compilation,  Up: Byte Compilation

15.4 個別関数の動的ロード
===================================

ファイルをコンパイルするとき、 "動的関数ロード"（dynamic function
loading、 "遅延ロード"（lazy loading）ともいう）機能を指定できます。
動的関数ロードでは、ロードするときにファイル内の関数定義をすべて
読むわけではありません。 そのかわりに、各関数定義には、
そのファイルを指す埋め草が入っています。
それぞれの関数を初めて呼び出したときに、
その完全な定義をファイルから読み取り、埋め草を置き換えます。

   動的関数ロードの利点は、ファイルをロードするよりかなり速いことです。
ユーザーが呼び出せる数多くの別々の関数を収めたファイルにおいては、
それらの1つだけを使って残りのものを使わないのであれば、
これは有利なことです。 キーボードコマンドを提供する特別なモードには、
しばしばこのような使い方のパターンがあります。
ユーザーがモードを起動しても、提供するコマンドの一部しか使わないのです。

   動的関数ロードの機能には、ある種の欠点もあります。

   *
     コンパイルしたファイルをロードしたあとにそのファイルを削除したり移動したり
     すると、未ロードの残りの関数定義をEmacsはロードできない。

   *
     コンパイルしたファイルを（新版をコンパイルするなどして）変更すると、
     未ロードの関数をロードすると、無意味な結果になる。

   Emacsのファイル群をインストールした普通の状況では、
このような問題は起きないはずです。
しかし、Lispファイルを読者が変更すると起こりえます。
これらの問題を回避するもっとも簡単な方法は、
再コンパイルするたびに新たにコンパイルしたファイルを
ただちに再ロードすることです。

   バイトコンパイラは、コンパイル時に変数`byte-compile-dynamic'が
`nil'以外であれば、動的関数ロードの機能を使います。
動的ロードは特定のファイルで必要なだけですから、
この変数をグローバルに設定しないでください。
そのかわりにファイルにローカルな変数束縛を使って
特定のソースファイルだけでこの機能をオンにします。
たとえば、ソースファイルの先頭行につぎのテキストを書けば、
そのようにできます。

     -*-byte-compile-dynamic: t;-*-

 -- Variable: byte-compile-dynamic
     これが`nil'以外であると、
     バイトコンパイラは、動的関数ロードを使うように設定した
     コンパイル済みのファイルを生成する。

 -- Function: fetch-bytecode function
     FUNCTIONを完全にロードしていないと、
     バイトコンパイルしたファイルからただちにFUNCTIONの定義をロードする。
     引数FUNCTIONは、バイトコード関数オブジェクトか関数名である。


File: elisp-ja,  Node: Eval During Compile,  Next: Byte-Code Objects,  Prev: Dynamic Loading,  Up: Byte Compilation

15.5 コンパイル時の評価
================================

プログラムのコンパイル時に評価されるようなコードを書くための機能です。

 -- Special Form: eval-and-compile body
     このフォームは、コンパイルしたり実行したり
     （コンパイルしてあってもしてなくても）するときに
     BODYを評価するように印を付ける。

     BODYを別のファイルに収め、そのファイルを`require'で参照しても
     同じ結果を得ることができる。
     BODYが大きい場合には、そのほうが好ましい。

 -- Special Form: eval-when-compile body
     このフォームは、コンパイルしたプログラムをロードするときではなく、
     プログラムのコンパイル時にBODYを評価するように印を付ける。
     コンパイラが評価した結果は、コンパイルしたプログラム内に定数として現れる。
     ソースファイルをコンパイルせずにロードすると、
     BODYを普通どおり評価する。

     *Common Lispに関した注意：*` ' トップレベルでは、 Common
     Lispの`(eval-when (compile eval) ...)'の常套句に似ている。
     それ以外の箇所では、Common Lispの`#.'リーダマクロは
     （解釈実行時ではなければ）`eval-when-compile'が行うことに近い。


File: elisp-ja,  Node: Byte-Code Objects,  Next: Disassembly,  Prev: Eval During Compile,  Up: Byte Compilation

15.6 バイトコード関数オブジェクト
===============================================

バイトコンパイルした関数は、特別なデータ型、
"バイトコード関数オブジェクト"（byte-code function objects）です。

   内部的には、バイトコード関数オブジェクトはベクトルによく似ています。
しかし、評価時にこのデータ型が呼び出すべき関数として現れると、
特別に扱います。
バイトコード関数オブジェクトの表示表現はベクトルに似ていますが、
開き角括弧`['のまえに余分に`#'が付きます。

   バイトコード関数オブジェクトには、少なくとも4つの要素が必要です。
最大個数に制限はありませんが、最初の6つ個の要素にだけ
普通の用途があります。 つぎのとおりです。

żƕÃÂÃ
     引数シンボルのリスト。

ÃÂÃÂÃÃ
     バイトコード命令を収めた文字列。

ŮƕǾ
     バイトコードが参照するLispオブジェクトのベクトル。
     関数名や変数名として使われるシンボルを含む。

ÂÂÃÂÂÂÂ
     この関数に必要なスタックサイズの最大値。

ȪƘƖŭň
     （あれば）説明文字列。 さもなければ`nil'。
     説明文字列がファイルに収めてあれば、値は数かリストである。
     実際の説明文字列を取得するには関数`documentation'を使う （*note
     Accessing Documentation::）。

ůȩƌŮ
     （あれば）対話指定。 これは文字列かLisp式。
     対話的でない関数では`nil'。

   バイトコード関数オブジェクトの例を表示表現でつぎに示します。

     #[(&optional arg)
       "^H\204^F^@\301^P\302^H[!\207"
       [arg 1 forward-sexp]
       2
       254435
       "p"]

   バイトコードオブジェクトを作る基本的な方法は、
`make-byte-code'を使うことです。

 -- Function: make-byte-code &rest elements
     この関数は、ELEMENTSを要素とする
     バイトコード関数オブジェクトを作成し返す。

   バイトコード関数の要素を自分で作ったりしないでください。
それらに整合性がないと、
その関数を呼び出すとEmacsがクラッシュすることもあります。
これらのオブジェクトの作成は、バイトコンパイラに任せるべきです。
バイトコンパイラは整合した要素を作成します（と期待する）。

   バイトコードオブジェクトの要素は`aref'で参照できます。
同じ要素群のベクトルを`vconcat'で作ることもできます。


File: elisp-ja,  Node: Disassembly,  Prev: Byte-Code Objects,  Up: Byte Compilation

15.7 バイトコードの逆アセンブル
============================================

人間はバイトコードを書きません。 それはバイトコンパイラの仕事です。
しかし、好奇心を満たすために逆アセンブラを用意してあります。
逆アセンブラはバイトコンパイルしたコードを人が読める形式に変換します。

バイトコードインタープリタは、単純なスタックマシンとして実装してあります。
値を自前のスタックに積み、計算に使うためにスタックから取り出し、
計算結果そのものはスタックにまた積みます。
バイトコード関数から戻るときには、スタックから値を取り出して
関数値としてその値を返します。

   スタックに加えて、変数とスタックのあいだで値を転送することで、
バイトコード関数は、普通のLisp変数を使ったり、
束縛したり、値を設定できます。

 -- コマンド: disassemble object &optional stream
     この関数はOBJECTの逆アセンブルしたコードを出力する。
     STREAMを指定すると、そこへ出力する。
     さもなければ、逆アセンブルしたコードはストリーム`standard-output'へ
     出力する。 引数OBJECTは関数名かラムダ式である。

     特別な例外として、この関数を対話的に使うと、
     `*Disassemble*'という名前のバッファへ出力する。

   `disassemble'関数の使用例を2つ示します。
バイトコードとLispソースとの対応を取れるように
特別なコメントを追加してありますが、
これらは`disassemble'の出力には現れません。
これらの例は、最適化してないバイトコードです。
現在、バイトコードは、普通、最適化しますが、
目的は果たせるので、例を書き換えてありません。

     (defun factorial (integer)
       "Compute factorial of an integer."
       (if (= 1 integer) 1
         (* integer (factorial (1- integer)))))
          => factorial

     (factorial 4)
          => 24

     (disassemble 'factorial)
          -| byte-code for factorial:
      doc: Compute factorial of an integer.
      args: (integer)

     0   constant 1              ; スタックに1を積む

     1   varref   integer        ; 環境から`integer'の値を取得し、
                                 ; スタックに積む

     2   eqlsign                 ; スタックの先頭から2つの値を
                                 ; 取りさって比較し、
                                 ; 結果をスタックに積む

     3   goto-if-nil 10          ; スタックの先頭から値を取りさり
                                 ; 検査する。`nil'ならば10へ飛び、
                                 ; さもなければつぎへ進む

     6   constant 1              ; スタックに1を積む

     7   goto     17             ; 17へ飛ぶ（この場合、関数は1を返す）

     10  constant *              ; スタックにシンボル`*'を積む

     11  varref   integer        ; スタックに`integer'の値を積む

     12  constant factorial      ; スタックに`factorial'を積む

     13  varref   integer        ; スタックに`integer'の値を積む

     14  sub1                    ; スタックから`integer'を取りさり、
                                 ; 減した新たな値をスタックに積む

                                 ; スタックの現在の内容はつぎのとおり
                                 ; - `integer'を減らした値
                                 ; - `factorial'
                                 ; - `integer'の値
                                 ; - `*'

     15  call     1              ; スタックの最初（先頭）要素を使って
                                 ; 関数`factorial'を呼び出す
                                 ; 戻り値をスタックに積む

                                 ; スタックの現在の内容はつぎのとおり
                                 ; - `factorial'の
                                 ;      再帰呼び出しの結果
                                 ; - `integer'の値
                                 ; - `*'

     16  call     2              ; スタックの最初の要素の2つ
                                 ; （先頭の2つ）を引数として
                                 ; 関数`*'を呼び出し
                                 ; 結果をスタックに積む

     17  return                  ; スタックの先頭要素を返す
          => nil

   関数`silly-loop'は、少々複雑です。

     (defun silly-loop (n)
       "Return time before and after N iterations of a loop."
       (let ((t1 (current-time-string)))
         (while (> (setq n (1- n))
                   0))
         (list t1 (current-time-string))))
          => silly-loop

     (disassemble 'silly-loop)
          -| byte-code for silly-loop:
      doc: Return time before and after N iterations of a loop.
      args: (n)

     0   constant current-time-string  ; `current-time-string'を
                                       ; スタックの先頭に積む

     1   call     0              ; 引数なしで`current-time-string'を
                                 ; 呼び出し、結果をスタックに積む

     2   varbind  t1             ; スタックから値を取りさり、
                                 ; `t1'に束縛する

     3   varref   n              ; 環境から`n'の値を取得し、
                                 ; 値をスタックに積む

     4   sub1                    ; スタックの先頭から1を引く

     5   dup                     ; スタックの先頭の値を複製する
                                 ; つまり、スタックの先頭の値を
                                 ; コピーして、それをスタックに積む

     6   varset   n              ; スタックの先頭から値を取りさり、
                                 ; 値を`n'に束縛する

                                 ; つまり、`dup varset'は
                                 ; スタックの先頭の値を取りさらずに
                                 ; `n'にコピーする

     7   constant 0              ; スタックに0を積む

     8   gtr                     ; スタックから2つの値を取りさり、
                                 ; Nが0より大きいか調べ、
                                 ; 結果をスタックに積む

     9   goto-if-nil-else-pop 17 ; `n' <= 0ならば17へ飛ぶ
                                 ; （whileループから抜ける）
                                 ; さもなければ、スタックの先頭から
                                 ; 値を取りさり、つぎへ進む

     12  constant nil            ; スタックに`nil'を積む
                                 ; （これはループの本体）

     13  discard                 ; ループの本体の結果を捨てる
                                 ; （whileループは副作用のために
                                 ; つねに評価される）

     14  goto     3              ; whileループの先頭へ飛ぶ

     17  discard                 ; スタックの先頭の値を取りさって、
                                 ; whileループの結果を捨てる。
                                 ; これは、9での飛び越しのために
                                 ; 取りさっていない値`nil'

     18  varref   t1             ; `t1'の値をスタックに積む

     19  constant current-time-string  ; `current-time-string'を
                                       ; スタックに積む

     20  call     0              ; ふたたび`current-time-string'を
                                 ; 呼び出す

     21  list2                   ; スタックの先頭から2つの値を取りさり
                                 ; それらのリストを作り、
                                 ; リストをスタックに積む

     22  unbind   1              ; ローカルの環境の`t1'の束縛を解く

     23  return                  ; スタックの先頭の値を返す

          => nil


File: elisp-ja,  Node: Advising Functions,  Next: Debugging,  Prev: Byte Compilation,  Up: Top

16 Emacs Lisp関数のアドバイス _(2003/10/30)_
****************************************************

"アドバイス"（advice）機能により、関数の既存の定義に追加できます。
これは、Emacsの他の部分で定義された関数を
ライブラリにおいてカスタマイズする見通しのよい方法です。
関数全体を再定義するよりも見通しがよいのです。

   各関数は、個別に定義した複数の"アドバイス断片"を持てます。
それぞれのアドバイス断片は、明示的に"有効"にしたり無効にできます。
任意の関数で有効にされたすべてのアドバイス断片が実際にその効果を発揮するのは、
当該関数のアドバイスを"活性にした"ときか
当該関数を定義したり再定義したときです。ここで、アドバイス断片を「有効にする
こと」と「活性にすること」は同じことでないので注意が必要です。

   *使用上の注意：*` '
アドバイスは、既存関数の既存の呼び出しのふるまいを変更するのに有用である。
新たな呼び出しやキーバインドの新たなふるまいが必要な場合には、
既存関数を使う新たな関数（や新たなコマンド）を定義するほうが
見通しがよい。

* Menu:

* Simple Advice::           A simple example to explain the basics of advice.
* Defining Advice::         Detailed description of `defadvice'.
* Around-Advice::           Wrapping advice around a function's definition.
* Computed Advice::         ...is to `defadvice' as `fset' is to `defun'.
* Activation of Advice::    Advice doesn't do anything until you activate it.
* Enabling Advice::         You can enable or disable each piece of advice.
* Preactivation::           Preactivation is a way of speeding up the
                              loading of compiled advice.
* Argument Access in Advice:: How advice can access the function's arguments.
* Subr Arguments::          Accessing arguments when advising a primitive.
* Combined Definition::     How advice is implemented.


File: elisp-ja,  Node: Simple Advice,  Next: Defining Advice,  Up: Advising Functions

16.1 単純なアドバイスの例 _(2003/10/30)_
==================================================

コマンド`next-line'は、ポイントを垂直に複数行移動します。
標準バインドは`C-n'です。 バッファの最終行で使うと、
`next-line-add-newlines'が`nil'以外の場合(デフォルトは`nil')
このコマンドは行を作るために改行を挿入し、その行に移動します。

   同様な機能を`previous-line'に追加したいとします。
つまり、バッファの先頭に新たな行を挿入し、その行へ移動するのです。
どのようにすればよいでしょう？

当該関数を再定義すればできますが、それではモジュール性がよくありません。
アドバイス機能が見通しのよい代替方法を提供します。
既存の関数定義を実際に変更したりその定義を参照することなく、
関数定義に読者のコードを実質的に追加できます。 つぎのように行います。

     (defadvice previous-line (before next-line-at-end (arg))
       "Insert an empty line when moving up from the top line."
       (if (and next-line-add-newlines (= arg 1)
                (save-excursion (beginning-of-line) (bobp)))
           (progn
             (beginning-of-line)
             (newline))))

   この式は、関数`previous-line'に対する"アドバイス断片"を定義します。
このアドバイス断片には`next-line-at-end'という名前が付きます。
シンボル`before'により、
`previous-line'の通常の定義を実行するまえに実行する
"事前アドバイス"（before-advice）であることを意味します。
`(arg)'は、アドバイス断片がどのように関数の引数を参照するかを指定します。

このアドバイス断片が実行されると、必要な場面では新たに行を作りますが、
その行へはポイントを移動しません。
これはアドバイスを書く正しいやりかたです。
というのは、通常の定義がこのあとに実行され、新たに挿入した行へ移動します。

   アドバイスを定義しても関数`previous-line'をただちには変更しません。
つぎのようにアドバイスを"活性にする"と変わります。

     (ad-activate 'previous-line)

これにより、関数`previous-line'に対して定義してある
アドバイスを使い始めます。
これ以降、`C-p'や`M-x'でユーザーが起動したのか
Lispから呼ばれたのかに関わらず、
この関数を起動すると、まずアドバイスを実行してから
関数の通常の定義を実行します。

   この例は、アドバイスの1つの"クラス"である事前アドバイスの例であり、
関数の元定義のまえに実行されます。 他に2つのアドバイスクラスがあります。
元定義のあとに実行される"事後アドバイス"（after-advice）と
元定義の起動を包み込む式を指定する"包囲アドバイス"（around-advice）です。


File: elisp-ja,  Node: Defining Advice,  Next: Around-Advice,  Prev: Simple Advice,  Up: Advising Functions

16.2 アドバイス定義 _(2003/10/30)_
=========================================

アドバイス断片を定義するには、マクロ`defadvice'を使います。
`defadvice'の呼び出しはつぎのような構文です。
`defun'や`defmacro'の構文を基にしていますが、 追加部分があります。

     (defadvice FUNCTION (CLASS NAME
                              [POSITION] [ARGLIST]
                              FLAGS...)
       [DOCUMENTATION-STRING]
       [INTERACTIVE-FORM]
       BODY-FORMS...)

ここで、FUNCTIONはアドバイス対象となる関数
（やマクロやスペシャルフォーム）です。
以後、アドバイスする対象を単に『関数』と書きますが、
これにはつねにマクロやスペシャルフォームを含みます。

   CLASSはアドバイスの"クラス"を指定し、
`before'、`after'、`around'のいずれかです。
事前アドバイス（`before'）は関数そのもののまえに実行されます。
事後アドバイス（`after'）は関数そのもののあとに実行されます。
包囲アドバイス（`around'）は関数自身の実行を包み込みます。
事後アドバイスと包囲アドバイスでは、
`ad-return-value'に設定することで戻り値を変更できます。

 -- Variable: ad-return-value
     アドバイスを実行しているとき、
     関数の元定義の実行を完了したあとでは、この変数はその戻り値を保持する。
     すべてのアドバイスを完了すると、最終的には、この値を呼び出し側へ返す。
     事後アドバイスと包囲アドバイスでは、この変数に別の値を設定することで
     戻り値を変更できる。

   引数NAMEはアドバイスの名前であり、`nil'以外のシンボルです。
アドバイス名は、FUNCTIONの特定クラスのすべてのアドバイス断片から
1つのアドバイス断片を一意に識別します。 名前でアドバイス断片を参照でき、
それを再定義したり有効にしたり無効にできます。

   通常の関数定義の引数リストのかわりに、
アドバイス定義では異なる情報を必要とします。

   省略可能なPOSITIONは、指定したCLASSの
現在のアドバイスリストのどこに新たなアドバイスを置くかを指定します。
`first'、`last'、あるいは、
0から数え始める位置を指定する数である必要があります
（`first'は0と等価）。 位置を指定しないとデフォルトは`first'です。
当該クラスの既存位置の範囲を超えている場合には、
先頭か末尾のどちらか近いほうになります。
既存のアドバイス断片を再定義する場合には、値POSITIONは無視されます。

   省略可能なARGLISTは、
アドバイスが使う引数リストを定義するために使います。
これは、アドバイスを実行するために生成される結合定義 （*note Combined
Definition::）の引数リストになります。 その結果、アドバイスの式では、
引数の値を参照するためにこのリストの引数変数を使えます。

   この引数リストは、関数の実際の呼び出し方を扱えるように、
もとの関数の引数リストと互換性がある必要があります。
2つ以上のアドバイス断片で引数リストを指定している場合、
すべてのアドバイスクラスの中で最初のもの（位置が最小のもの）を使います。

   残りの要素FLAGSは、このアドバイス断片の使い方に関する情報を指定する
シンボルです。 正しいシンボルとそれらの意味はつぎのとおりです。

`activate'
     FUNCTIONに対するアドバイスをただちに活性にする。
     関数のアドバイスに対する変更は、当該関数のアドバイスを活性にすると
     効果を持つようになる。
     このフラグは、FUNCTIONに対するこのアドバイス断片を定義した直後に
     そのようにすることを指示する。

     FUNCTIONが未定義（"未定義のアドバイス"（forward
     advice）と呼ぶ状況）
     であるとこのフラグがすぐに効果を表すことはない。
     というのは、未定義関数のアドバイスは活性にできないからである。
     しかし、FUNCTIONを定義するとそのアドバイスは自動的に活性にされる。

`protect'
     このアドバイス断片をそれよりまえに実行されるコードやアドバイスによる
     非ローカル脱出やエラーに対して保護する。 保護したアドバイス断片は、
     フォーム`unwind-protect'の中に後始末として置かれ、
     それよりまえに実行されるコードでエラーが発生したり`throw'を使っても
     実行される。 *note Cleanups::。

`compile'
     アドバイスの実行に使われる結合定義をコンパイルする。
     `activate'とともに指定しないと、このフラグは無視する。 *note
     Combined Definition::。

`disable'
     このアドバイス断片を当初は無効にしておき、
     のちに明示的に有効にしない限り使われない。 *note Enabling
     Advice::。

`preactivate'
     この`defadvice'をコンパイルしたりマクロ展開したときに、
     FUNCTIONに対するアドバイスを活性にする。
     これにより現在のアドバイスの状態に応じたアドバイス定義をコンパイルし、
     必要に応じて使われるようになる。*Note Preactivation::。

     この`defadvice'をバイトコンパイルする場合にのみ意味を持つ。

   省略可能なDOCUMENTATION-STRINGは、
このアドバイス断片の説明文字列になります。
FUNCTIONに対するアドバイスが活性であると、
（`documentation'が返す）FUNCTIONの説明文は、
関数の元定義の説明文字列とFUNCTIONのアドバイスすべての説明文字列の
合成になります。

   省略可能なINTERACTIVE-FORMは、
元関数の対話的ふるまいを変更するために指定します。
2つ以上のアドバイス断片でINTERACTIVE-FORMを指定している場合、
すべてのアドバイスの中で最初のもの（位置が最小のもの）が優先します。

   空リストでもかまわないBODY-FORMSは、アドバイスの本体です。
アドバイスの本体では、引数、戻り値、束縛環境を参照／変更したり、
いかなる種類の副作用を起こせます。

   *警告：*` ' マクロをアドバイスする場合、
マクロはプログラムのコンパイル時に展開されるのであって、
コンパイルしたプログラムの実行時に展開されるのではないことに注意。
アドバイスが使用するすべてのサブルーティンは、
バイトコンパイラがマクロを展開するときに必要になる。

 -- コマンド: ad-unadvise function
     このコマンドはFUNCTIONからアドバイスを削除する。

 -- コマンド: ad-unadvise-all
     このコマンドはすべての関数からすべてのアドバイス断片を削除する。


File: elisp-ja,  Node: Around-Advice,  Next: Computed Advice,  Prev: Defining Advice,  Up: Advising Functions

16.3 包囲アドバイス _(2003/10/30)_
=========================================

包囲アドバイスにより、関数の元定義を包み込むLisp式を書けます。
関数の元定義を実行する場所を特別なシンボル`ad-do-it'で指定します。
包囲アドバイスの本体に現れたこのシンボルは、
元定義（と内側の包囲アドバイス本体）のフォームを含んだ`progn'で
置き換えられます。 例を示しましょう。

     (defadvice foo (around foo-around)
       "Ignore case in `foo'."
       (let ((case-fold-search t))
         ad-do-it))

これは、`foo'の元定義を実行するときに
大文字小文字を区別しないで探索することを保証します。

 -- Variable: ad-do-it
     これは実際には変数ではないが、包囲アドバイス内では変数のように用いる。
     関数の元定義と『より内側の』包囲アドバイスを実行する場所を指定する。

包囲アドバイスで`ad-do-it'を用いなければ、関数の元定義を実行しません。
これは、元定義を完全に無効にする手段です。
（さらに、内側の包囲アドバイス断片も無効にする）

   もし包囲アドバイスが`ad-do-it'を1つ以上用いていれば、関数の元定義
がそれぞれの場所で実行される。これにより、包囲アドバイスは元の関数(と
その中の関数に含まれる包囲アドバイス断片)を何度も実行できる。このよう
に、元の関数を複数回実行するには、ループの中で`ad-do-it'を用いて
も可能である。


File: elisp-ja,  Node: Computed Advice,  Next: Activation of Advice,  Prev: Around-Advice,  Up: Advising Functions

16.4 計算アドバイス _(2003/10/30)_
=========================================

マクロ`defadvice'は`defun'に似ていて、
アドバイスのコードやアドバイスに関する他のすべての情報を
ソースコードで明示します。 関数`ad-add-advice'を用いると、
その詳細を計算で求めたアドバイスを作成できます。

 -- Function: ad-add-advice function advice class position
     `ad-add-advice'を呼び出すと、
     関数FUNCTIONに対するクラスCLASSのアドバイス断片として
     ADVICEを追加する。 引数ADVICEはつぎの形式である。

          (NAME PROTECTED ENABLED DEFINITION)

     ここで、PROTECTEDとENABLEDはフラグであり、
     DEFINITIONはアドバイスの動作を指定する式である。
     ENABLEDが`nil'であると、 このアドバイス断片は当初は無効になる
     （*note Enabling Advice::）。

     FUNCTIONに指定したクラスCLASSのアドバイス断片がすでにあると、
     POSITIONは新しいアドバイス断片をリストのどこに置くかを指定する。
     POSITIONの値は、`first'、`last'、あるいは、
     （リストの先頭を0から数えた）数である。
     範囲外の数はその範囲の先頭か末尾のどちらか近いほうになる。また、
     POSITIONの値はすでに存在するアドバイス断片を再定義した時には無視
     される。

     FUNCTIONに同じ名前のアドバイス断片ADVICEがすでにあると、
     引数POSITIONは無視され、古いアドバイス断片を新しいもので置き換える。


File: elisp-ja,  Node: Activation of Advice,  Next: Enabling Advice,  Prev: Computed Advice,  Up: Advising Functions

16.5 アドバイスの活性化 _(2003/10/30)_
===============================================

デフォルトでは、アドバイスを定義してもその効果は発揮されません。
アドバイスした関数のアドバイスを"活性"にして始めて効果を発揮します。
`defadvice'でフラグ`activate'を指定すれば、
関数にアドバイスを定義したときに活性にできます。
しかし、普通は、関数`ad-activate'や以下の活性化コマンドを
呼び出すことで、関数のアドバイスを活性にします。

   アドバイスの定義操作と活性化操作を区別することで、
アドバイスを追加するたびに関数を再定義することなる、
関数に複数のアドバイス断片を効率よく追加できます。
さらに重要なことは、関数を実際に定義するまえでも
関数にアドバイスを定義できることです。

   関数のアドバイスを初めて活性にすると、
関数の元定義を保存してから、関数に対する有効なアドバイス断片すべてを
元定義と結合して新たな定義を作り出します。
（現在無効にしてあるアドバイス断片は使用しない。 *note Enabling
Advice::。） この定義をインストールし、
以下に述べる条件に応じてバイトコンパイルする場合もあります。

   アドバイスを活性にするコマンドすべてにおいて、 COMPILEが`t'であると、
アドバイスを実装する結合定義をコンパイルします。

 -- コマンド: ad-activate function &optional compile
     このコマンドはFUNCTIONに対するアドバイスを活性にする。

 -- コマンド: ad-deactivate function
     このコマンドはFUNCTIONのアドバイスを不活性にする。 

 -- コマンド: ad-deactivate-all
     このコマンドはすべての関数に対するアドバイスを不活性にする。

 -- コマンド: ad-update-all &optional compile
     このコマンドは、すでにアドバイスが活性になっているすべて
     の関数のアドバイスを活性化させる。いくつかの関数のアドバイスを変更した
     時に役に立つ。

 -- コマンド: ad-activate-regexp regexp &optional compile
     このコマンドはREGEXPに一致する名前のすべてのアドバイス断片を活性にする。
     より正確には、REGEXPに一致する名前のアドバイス断片を持つ任意の
     関数のすべてのアドバイスを活性にする。

 -- コマンド: ad-deactivate-regexp regexp
     このコマンドはREGEXPに一致する名前の
     すべてのアドバイス断片を不活性にする。
     より正確には、REGEXPに一致する名前のアドバイス断片を持つ任意の
     関数のすべてのアドバイスを不活性にする。

 -- コマンド: ad-update-regexp regexp &optional compile
     このコマンドはREGEXPに一致する名前のアドバイス断片を活性にするが、
     すでにアドバイスが活性になっている関数に対するものだけである。 

     関数に対するアドバイスの再活性化は、
     アドバイスを活性にしたあとに行った当該アドバイスの変更すべて
     （有効にしたり無効にしたアドバイス断片を含む。 *note Enabling
     Advice::）が効果を持つようにするのに便利である。

 -- コマンド: ad-start-advice
     関数を定義したり再定義したときにアドバイスを自動的に活性にする。
     このモードをオンにすると、アドバイスを定義するとただちに効果を持つようになる。

 -- コマンド: ad-stop-advice
     関数を定義したり再定義してもアドバイスを自動的には活性にしない。

 -- User Option: ad-default-compilation-action
     この変数は、関数に対するアドバイスを活性にした結果作られる
     結合定義をコンパイルするかどうか制御します。

     値が`always'であれば、無条件にコンパイルします。`nil'であれば
     常にコンパイルしない。

     値が`maybe'であれば、バイトコンパイラがすでに読み込まれていればコ
     ンパイルを行う。値が`like-original'であれば、アドバイスされる関数
     の元定義がコンパイルされていたり、組み込み関数(built-in
     function)であ れば、コンパイルを行う。

     この変数は`ad-activate'(あるいは他の上記にあげた関数)の
     COMPILE引数が`nil'の場合のみ有効になります。もしその引数が
     `nil'でなければ、そのアドバイスがこの変数の値に関わらずコンパイル
     されます。

   『予約活性』（*note Preactivation::）中にアドバイス定義を作成すると
その定義はすでにコンパイルされているはずです。
というのは、`preactivate'フラグを指定した`defadvice'を
含むファイルをバイトコンパイル中にそれが定義されたはずだからです。


File: elisp-ja,  Node: Enabling Advice,  Next: Preactivation,  Prev: Activation of Advice,  Up: Advising Functions

16.6 アドバイスの有効化と無効化 _(2003/10/30)_
===========================================================

各アドバイス断片には、
それを有効にするか無効にするかを指定するフラグがあります。
アドバイス断片を有効にしたり無効にすることで、
アドバイス断片を未定義にしたり再定義することなくオン／オフできます。
たとえば、関数`foo'に対するアドバイス断片`my-advice'を
無効にするには、つぎのようにします。

     (ad-disable-advice 'foo 'before 'my-advice)

   この関数自身は、アドバイス断片の有効化フラグを変更するだけです。
アドバイスした関数でこの変更の効果を発揮するには、
`foo'のアドバイスを再度活性にする必要があります。

     (ad-activate 'foo)

 -- コマンド: ad-disable-advice function class name
     このコマンドはFUNCTIONに対するクラスCLASS内の
     NAMEで指名したアドバイス断片を無効にする。

 -- コマンド: ad-enable-advice function class name
     このコマンドはFUNCTIONに対するクラスCLASS内の
     NAMEで指名したアドバイス断片を有効にする。

   正規表現を用いて、さまざまな関数に対する
多数のアドバイス断片を一度に無効にすることもできます。
この場合も、当該関数のアドバイスを再度活性にすることで、
その効果が発揮されます。

 -- コマンド: ad-disable-regexp regexp
     このコマンドは、すべての関数のすべてのクラスの
     REGEXPに一致するアドバイス断片すべてを無効にする。

 -- コマンド: ad-enable-regexp regexp
     このコマンドは、すべての関数のすべてのクラスの
     REGEXPに一致するアドバイス断片すべてを有効にする。


File: elisp-ja,  Node: Preactivation,  Next: Argument Access in Advice,  Prev: Enabling Advice,  Up: Advising Functions

16.7 予約活性 _(2003/10/30)_
================================

アドバイスを実行するための結合定義を作成することは、
ある程度手間がかかります。
ライブラリで多数の関数をアドバイスしていると、
ライブラリのロードが遅くなります。
そのような場合、あらかじめ適切な結合定義を作成する
"予約活性"（preactivation）を使えます。

   予約活性を使うには、`defadvice'でアドバイスを定義するときに
フラグ`preactivate'を指定します。 このような`defadvice'の呼び出しでは、
（有効か無効に関わらず）このアドバイス断片と
当該関数に対して現在有効になっている他のアドバイスを元定義
に結合した定義を作成します。
`defadvice'をコンパイルすると、その結合定義もコンパイルします。

   のちに関数のアドバイスを活性にしたとき、
関数に対する有効にしたアドバイスがこの結合定義の作成に
使用したものに一致すると既存の結合定義を使います。
そのため、新たに結合定義を作成する必要がなくなります。
したがって、予約活性はけっしてまちがった結果を生じませんが、
予約活性に用いたアドバイスと活性にした有効なアドバイスが一致しないと
利点はなくなります。

   不一致のために予約活性が正しく動作していない兆候の例を示します。

   * アドバイスした関数の活性に通常より長くかかる。

   * アドバイスした関数を活性にするとバイトコンパイラがロードされる。

   * バイトコンパイラを意図して使っていないのに、
     `features'の値に`byte-compile'が含まれる。

関数自体が定義されるまえであってもコンパイル済みの予約活性したアドバイスは
正しく動作します。
しかし、予約活性したアドバイスを_コンパイル_するときには
関数は定義済みである必要があります。

   予約活性したアドバイスが使われない理由を調べるよい方法はありません。
できることは、 関数のアドバイスを活性にするまえに、
（関数`trace-function-background'で）
関数`ad-cache-id-verification-code'をトレースすることです。
活性にしたあと、当該関数に対して`ad-cache-id-verification-code'が
返した値を調べます。
`verified'ならば予約活性したアドバイスが使われています。
これ以外の値は、アドバイスが不適切と判断された理由に関する情報を
与えます。

   *警告：*` ' 予約活性が失敗する場合が1つ知られている。
現在のアドバイスの状態に一致しなくても、
あらかじめ作成した結合定義を使ってしまう。
これは、同一関数に対する同じクラスの同一名称であるが異なるアドバイス断片を
2つのパッケージで定義している場合に発生する。
このようなことは避けること。


File: elisp-ja,  Node: Argument Access in Advice,  Next: Subr Arguments,  Prev: Preactivation,  Up: Advising Functions

16.8 アドバイスからの引数の参照 _(2003/10/30)_
===========================================================

アドバイス断片の本体からアドバイスする関数の引数を参照する
もっとも簡単な方法は、関数定義で用いているものと同じ名前を使うことです。
これには、元関数の引数の変数名を知る必要があります。

   多くの場合、この単純な方法で十分ですが、欠点もあります。
アドバイス内に引数名を直接書き込むために、堅牢ではありません。
関数の元定義が変更されると、アドバイスは動作しません。

   他の方法は、アドバイスそのものに引数リストを指定することです。
これは関数の元定義の引数名を知る必要はありませんが、制約もあります。
関数に対するすべてのアドバイスで同一の引数リストを使う必要があります。
なぜなら、すべてのアドバイスに実際に使われる引数リストは、
当該関数のアドバイス断片の最初のものだからです。

   より堅牢な方法は、活性にするときに、
つまり、アドバイスを結合した定義を作成するときに
適切なフォームに展開されるマクロを使うことです。
参照用マクロは、関数の引数変数への実引数の分配方法に依存しない
実引数の位置で参照します。 Emacs
Lispにおいては、引数の意味は引数リスト内での位置で決まるため、
これは堅牢です。

 -- Macro: ad-get-arg position
     位置POSITIONにある実引数を返す。

 -- Macro: ad-get-args position
     位置POSITIONから始まる実引数のリストを返す。

 -- Macro: ad-set-arg position value
     位置POSITIONにある実引数の値を設定する。

 -- Macro: ad-set-args position value-list
     位置POSITIONから始まる実引数のリストにVALUE-LISTを設定する。

   例を示します。 関数`foo'の定義はつぎのとおりであり、

     (defun foo (x y &optional z &rest r) ...)

つぎのように呼ばれるとします。

     (foo 0 1 2 3 4 5 6)

そうすると、`foo'の本体では、 Xは0、Yは1、Zは2、Rは`(3 4 5 6)'です。
このとき、`ad-get-arg'や`ad-get-args'は、つぎの値を返します。

     (ad-get-arg 0) => 0
     (ad-get-arg 1) => 1
     (ad-get-arg 2) => 2
     (ad-get-arg 3) => 3
     (ad-get-args 2) => (2 3 4 5 6)
     (ad-get-args 4) => (4 5 6)

   この例では、引数に値を設定できます。

     (ad-set-arg 5 "five")

の効果は、6番目の引数を`"five"'に変更します。
`foo'の本体を実行するまえにこのアドバイスが実行されると、
本体内ではRは`(3 4 "five" 6)'になります。

   つぎは引数リストを変更する例です。

     (ad-set-args 0 '(5 4 3 2 1 0))

`foo'の本体を実行するまえにこのアドバイスが実行されると、
`foo'の本体内では、 Xは5、Yは4、Zは3、Rは`(2 1 0)'になります。

   これらの引数参照は、実際にはLispマクロとしての実装ではありません。
アドバイス機構で特別に実装してあります。


File: elisp-ja,  Node: Subr Arguments,  Next: Combined Definition,  Prev: Argument Access in Advice,  Up: Advising Functions

16.9 subr引数リストの定義 _(2003/10/30)_
================================================

アドバイス機能が結合定義を作成するとき、
元関数の引数リストを知る必要があります。
基本関数に対しては、これはつねに可能とは限りません。
アドバイスが引数リストを決定できないときには、 `(&rest
ad-subr-args)'を使います。 これはつねに動作しますが、
引数値のリストを作成するために効率的ではありません。
`ad-define-subr-args'を使って、
基本関数に対する適当な引数名を宣言できます。

 -- Function: ad-define-subr-args function arglist
     この関数は、関数FUNCTIONの引数リストとして
     ARGLISTを使うことを指定する。

   たとえば、

     (ad-define-subr-args 'fset '(sym newdef))

は、関数`fset'の引数リストを指定します。


File: elisp-ja,  Node: Combined Definition,  Prev: Subr Arguments,  Up: Advising Functions

16.10 結合定義 _(2003/10/30)_
=================================

関数には、N個(0からN-1として数えられる)の事前アドバイス（before-advice）、
M個の包囲アドバイス（around-advice）、
K個の事後アドバイス（after-advice）があるとします。
保護したアドバイス断片はないと仮定すると、
関数のアドバイスを実装するために作成される結合定義は
つぎのようになります。

     (lambda ARGLIST
       [ [ADVISED-DOCSTRING] [(interactive ...)] ]
       (let (ad-return-value)
         before-0-body-form...
              ....
         before-N-1-body-form...
         around-0-body-form...
            around-1-body-form...
                  ....
               around-M-1-body-form...
                  (setq ad-return-value
                        apply original definition to ARGLIST)
               end-of-around-M-1-body-form...
                  ....
            end-of-around-1-body-form...
         end-of-around-0-body-form...
         after-0-body-form...
               ....
         after-K-1-body-form...
         ad-return-value))

   マクロはマクロとして再定義します。
つまり、結合定義の先頭に`macro'を追加します。

   元関数やアドバイス断片のどれかに対話宣言があれば、
対話宣言フォームが入ります。 対話的な基本関数をアドバイスした場合には、
アドバイスは特別な方法を使います。
つまり、基本関数を`call-interactively'で呼び出して、
基本関数自身が引数を読み取るようにします。
この場合、アドバイスからは引数を参照できません。

   各クラスのさまざまなアドバイスの本体フォームは、
それらの指定された順に組み立てられます。 包囲アドバイスL（around-advice
L）のフォーム群は、 包囲アドバイスL - 1（around-advice L - 1）の
フォームの1つに入ります。

   包囲アドバイスのもっとも内側では、

     元定義をARGLISTに適用

しますが、そのフォームは元関数の種類に依存します。
変数`ad-return-value'には、その戻り値が設定されます。
この変数はすべてのアドバイス断片から見えるので、
アドバイスした関数から実際に戻るまえに、 これを参照したり変更できます。

   保護したアドバイス断片を含むアドバイスした関数の構造も同じです。
唯一の違いは、フォーム`unwind-protect'により、
アドバイス断片でエラーを起こしたり非ローカル脱出を行っても、
保護したアドバイスが実行されることを保証します。
包囲アドバイスを1つでも保護していると、その結果として、
包囲アドバイス全体が保護されます。


File: elisp-ja,  Node: Debugging,  Next: Read and Print,  Prev: Advising Functions,  Up: Top

17 Lispプログラムのデバッグ
*************************************

Emacs Lispプログラムの問題点を調べるには、
問題が発生したときにどのようにプログラムを使っているかに依存して、
3つの方法があります。

   * プログラムを実行したときに問題が発生した場合には、
     実行中に何が起こっているかを調べるためにLispデバッガを使える。
     通常のデバッガに加えて、Emacsにはソースレベルデバッガedebugもある。
     本章では両者について述べる。

   * 構文的な問題があるためにLispがプログラムを読み取れないときには、
     EmacsのLisp編集機能を使ってその場所を特定する。

   *
     プログラムをバイトコンパイラでコンパイルするときに問題が発生するときには、
     コンパイラの入力バッファの調べ方を知る必要がある。

* Menu:

* Debugger::            How the Emacs Lisp debugger is implemented.
* Edebug::		A source-level Emacs Lisp debugger.
* Syntax Errors::       How to find syntax errors.
* Compilation Errors::  How to find errors that show up in byte compilation.

   他の有用なデバッグツールは、ドリブルファイルです。
ドリブルファイルをオープンしてあると、
Emacsはすべてのキーボード入力をこのファイルにコピーします。
あとでこのファイルを調べれば、どんな入力があったかわかります。 *Note
Terminal Input::。

   端末設定に関した問題を解決するには、
関数`open-termscript'が有用です。 *Note Terminal Output::。


File: elisp-ja,  Node: Debugger,  Next: Edebug,  Up: Debugging

17.1 Lispデバッガ
=====================

通常の"Lispデバッガ"は、フォームの評価を一時停止する機能を提供します。
評価を一時停止しているあいだ（"ブレーク"（break）と呼ばれる状態）は、
実行時スタックを調べたり、ローカルやグローバル変数の値を調べたり、
それらの値を変更できます。
ブレークは再帰編集なので、Emacsの通常の編集機能すべてを使えます。
デバッガを再帰的に起動するようなプログラムを実行することさえできます。
*Note Recursive Editing::。

* Menu:

* Error Debugging::       Entering the debugger when an error happens.
* Infinite Loops::	  Stopping and debugging a program that doesn't exit.
* Function Debugging::    Entering it when a certain function is called.
* Explicit Debug::        Entering it at a certain point in the program.
* Using Debugger::        What the debugger does; what you see while in it.
* Debugger Commands::     Commands used while in the debugger.
* Invoking the Debugger:: How to call the function `debug'.
* Internals of Debugger:: Subroutines of the debugger, and global variables.


File: elisp-ja,  Node: Error Debugging,  Next: Infinite Loops,  Up: Debugger

17.1.1 エラーによるデバッガの起動
----------------------------------------------

デバッガへ入るもっとも重要な時期は、Lispエラーが発生したときです。
これにより、エラーの直接原因を調べることができます。

   しかし、デバッガに入るのは、エラーの通常の帰結ではありません。
多くのコマンドは
（バッファの末尾で`C-f'を使うなどの）不適切に起動されると
しばしばLispエラーを生じますが、
通常の編集ではそのたびにデバッガに入ったのではとても不便です。
そのため、エラーによってデバッガに入りたい場合には、
変数`debug-on-error'に`nil'以外を設定します。
（コマンド`toggle-debug-on-error'はこれを簡単に行う。）

 -- User Option: debug-on-error
     この変数は、エラーが通知され処理されないときに
     デバッガを呼び出すかどうか決定する。
     `debug-on-error'が`t'であると、
     すべての種類のエラー（`debug-ignored-errors'に指定したものを除く）
     はデバッガを呼び出す。 `nil'であるとデバッガを呼び出さない。

     その値はデバッガを呼び出すエラー条件のリストでもよい。
     たとえば、リスト`(void-variable)'にすると、
     「値を持たない変数に関したエラー」のみがデバッガを起動する。

     この変数が`nil'以外であると、
     Emacsはプロセスのフィルタ関数や番兵に対してエラーハンドラを作成しない。
     したがって、これらの関数でのエラーもデバッガを起動する。 *note
     Processes::。

 -- User Option: debug-ignored-errors
     この変数は、デバッガに入らないエラーの種類を指定する。
     その値はエラー条件シンボルや正規表現のリストである。
     エラーにこれらの条件シンボルが含まれるか
     エラーメッセージが正規表現の1つに一致する場合には、
     `debug-on-error'の値に関わらず 当該エラーではデバッガに入らない。

     この変数の通常の値は、
     編集ではしばしば発生するが、Lispプログラムのバグではほとんど発生しないような
     エラー群のリストである。
     しかし、『ほとんど』は『けっして』ではない。
     このリストに一致するようなエラーで読者のプログラムが失敗する場合、
     エラーをデバッグするにはこのリストを変更する必要がある。
     もっとも簡単な方法は、`debug-ignored-errors'に`nil'を
     設定することである。

 -- User Option: debug-on-signal
     通常、`condition-case'で捕捉したエラーは、
     たとえ`debug-on-error'が`nil'以外であっても、
     けっしてデバッガを起動しない。
     いいかえれば、デバッガを起動するまえに、
     `condition-case'はエラー処理の機会を得るのである。

     `debug-on-signal'に`nil'以外の値を設定すると、
     各エラーごとにデバッガがまず機会を得る。
     `debug-on-error'と`debug-ignored-errors'の値で指定される
     条件に一致すれば、`condition-case'に関わらず
     エラーはデバッガを起動する。

     *警告：*` ' この変数は強力な処方である！` '
     Emacsのさまざまな部分では通常の動作としてエラーを処理し、
     読者にはエラーが発生したことさえわからない。
     `debug-on-signal'に`nil'以外の値を設定すると
     それらのエラーでデバッガに入る。

     *警告：*` ' `debug-on-error'が`nil'であると、
     `debug-on-signal'は意味を持たない。

   ファイル`.emacs'をロード中に発生するエラーをデバッグするには、
オプション`--debug-init'を使います。
これにより、`.emacs'のロード中は`debug-on-error'を`t'に束縛し、
初期化ファイルでのエラーを捕捉する`condition-case'を迂回します。

   読者のファイル`.emacs'で`debug-on-error'を設定しても、
その効果は`.emacs'のロードを終ると持続しません。
（これはコマンド行オプション`--debug-init'の実装における
好ましくない特性である。）
`.emacs'で`debug-on-error'を恒久的に設定する最良の方法は、
つぎのように、`after-init-hook'を用いることです。

     (add-hook 'after-init-hook
               '(lambda () (setq debug-on-error t)))


File: elisp-ja,  Node: Infinite Loops,  Next: Function Debugging,  Prev: Error Debugging,  Up: Debugger

17.1.2 無限ループのデバッグ
-------------------------------------

プログラムが無限にループし戻ってこないときには、
まず、ループを停止する必要があります。
ほとんどのオペレーティングシステムでは、 中断を意味する`C-g'を使います。

   普通に中断したのでは、
プログラムが無限ループした理由に関する情報は得られません。
より詳しい情報を得るには、 変数`debug-on-quit'に`nil'以外を設定します。
`C-g'による中断はエラーとは扱わないため、
`C-g'の処理に関して`debug-on-error'はなんの効果もありません。
同様に、`debug-on-quit'はエラーに関してなんの効果もありません。

   無限ループの途中でデバッガを起動できれば、
デバッガでステップ実行コマンドを使って先へ進めます。
ループひとまわりをステップ実行すれば、
問題を解決するに十分な情報を得られるはずです。

 -- User Option: debug-on-quit
     この変数は、`quit'が通知され処理されなかった場合に、
     デバッガを呼び出すかどうかを決定する。
     `debug-on-quit'が`nil'以外である場合、
     （`C-g'を打って）中断するとデバッガを呼び出す。
     `debug-on-quit'が`nil'であると、 中断してもデバッガを呼び出さない。
     *note Quitting::。


File: elisp-ja,  Node: Function Debugging,  Next: Explicit Debug,  Prev: Infinite Loops,  Up: Debugger

17.1.3 関数呼び出し時のデバッガの起動
----------------------------------------------------

プログラムの途中で発生する問題点を調べるための1つの有用な技法は、
ある関数を呼び出すたびにデバッガに入ることです。
問題を生じる関数に対してこのようにしておき、
当該関数をステップ実行するか、あるいは、
問題が発生する直前に呼ばれる関数に対してこのようにしておき、
その関数の呼び出しを終えてから、呼び出し側をステップ実行します。

 -- コマンド: debug-on-entry function-name
     この関数は、FUNCTION-NAMEが呼び出されるたびに
     デバッガを起動するようにする。 当該関数の定義の最初のフォームとして
     フォーム`(debug 'debug)'を挿入することでこれを行う。

     Lispコードで定義した任意の関数は、
     解釈実行コードであろうとコンパイル済みのコードであろうと、
     関数に入るときにブレークするようにできる。
     関数がコマンドであると、Lispから呼ばれたときや
     対話的に呼ばれたときに（引数を読み取ってから）デバッガに入る。
     （Cで書いた）基本関数は、この方法ではデバッグできない。

     `debug-on-entry'を対話的に呼び出すと、
     ミニバッファでFUNCTION-NAMEを問い合わせる。
     その関数がすでに呼び出し時にデバッガを起動するようになっていると、
     `debug-on-entry'はなにもしない。
     `debug-on-entry'はつねにFUNCTION-NAMEを返す。

     *注意：*` ' `debug-on-entry'を使ったあとに当該関数を再定義すると、
     デバッガに入るためのコードがなくなる。
     実質的には、関数を再定義すると呼び出し時にブレークする機能を
     取り消すことになる。

          (defun fact (n)
            (if (zerop n) 1
                (* n (fact (1- n)))))
               => fact
          (debug-on-entry 'fact)
               => fact
          (fact 3)

          ------ Buffer: *Backtrace* ------
          Entering:
          * fact(3)
            eval-region(4870 4878 t)
            byte-code("...")
            eval-last-sexp(nil)
            (let ...)
            eval-insert-last-sexp(nil)
          * call-interactively(eval-insert-last-sexp)
          ------ Buffer: *Backtrace* ------

          (symbol-function 'fact)
               => (lambda (n)
                    (debug (quote debug))
                    (if (zerop n) 1 (* n (fact (1- n)))))

 -- コマンド: cancel-debug-on-entry function-name
     この関数は、FUNCTION-NAMEに対する`debug-on-entry'の効果
     （呼び出し時にブレークする）を取り消す。 対話的に呼び出すと、
     ミニバッファでFUNCTION-NAMEを問い合わせる。
     FUNCTION-NAMEが`nil'であったり空文字列であると、
     すべての関数について、呼び出し時にブレークすることを取り消す。

     呼び出し時にブレークする設定をしていない関数に対して
     `cancel-debug-on-entry'を呼び出してもなにもしない。
     つねにFUNCTION-NAMEを返す。


File: elisp-ja,  Node: Explicit Debug,  Next: Using Debugger,  Prev: Function Debugging,  Up: Debugger

17.1.4 デバッガの明示的な起動
----------------------------------------

読者のプログラムに式`(debug)'を書くと、
その箇所でデバッガを呼び出すことができます。
つまり、ソースファイルを訪問して適当な箇所にテキスト`(debug)'を挿入し、
`C-M-x'と打ちます。 *警告：*` '
一時的なデバッグ目的でこれを行う場合には、
ファイルを保存するまえにこの挿入箇所をもとに戻すこと！

   `(debug)'を挿入する箇所は、
余分なフォームを評価してもその値を無視できる場所でなければなりません。
（`(debug)'の値が無視されないと、 プログラムの実行を変えてしまう！）
もっとも適した一般的な場所は`progn'や暗黙の`progn'の内側です （*note
Sequencing::）。


File: elisp-ja,  Node: Using Debugger,  Next: Debugger Commands,  Prev: Explicit Debug,  Up: Debugger

17.1.5 デバッガの使い方
-------------------------------

デバッガに入ると、それまで選択していたバッファをあるウィンドウに、
`*Backtrace*'という名前のバッファを別のウィンドウに表示します。
バックトレースバッファでは、各行は現在実行中のLisp関数の各レベルです。
このバッファの先頭には、デバッガを起動するに至った理由
（エラーで起動されたときにはエラーメッセージと関連データ）
を表すメッセージがあります。

   バックトレースバッファは読み出し専用であり、
各文字をデバッガコマンドであると定義した
特別なメジャーモード、debuggerモードを使います。
Emacsの通常の編集コマンドも使えます。
したがって、エラー発生時に編集していたバッファを調べるためにウィンドウを
切り替えたり、バッファを切り替えたり、ファイルを訪れたり、
その他のどんな編集でもできます。
しかし、デバッガは再帰編集レベル（*note Recursive
Editing::）であるので、
デバッグを終えるときには、バックトレースバッファに戻ってから
デバッガを（コマンド`q'で）終了するのが賢い方法です。
デバッガを終了すると、再帰編集から抜けバックトレースバッファを削除します。

   バックトレースバッファでは、実行中の関数とその引数の値を表示します。
また、スタックフレームを記述する行へポイントを移動することで
スタックフレームを指定できます。
（スタックフレームとは、Lispインタープリタが関数の起動に関する情報を
記録しておく場所である。）
ポイントがある行に対応するフレームを"カレントフレーム"（current
frame）と 呼びます。
デバッガのある種のコマンドはカレントフレームに作用します。

   デバッガ自身はバイトコンパイルしたものを実行する必要があります。
というのは、デバッガ自身が使用するスタックフレームのサイズを
仮定しているからです。 解釈実行だとこの仮定が成り立ちません。


File: elisp-ja,  Node: Debugger Commands,  Next: Invoking the Debugger,  Prev: Using Debugger,  Up: Debugger

17.1.6 デバッガコマンド
-------------------------------

デバッガ内（debuggerモード）では、
通常のカーソル移動コマンドに加えて以下の特別なコマンドを使えます。
（ウィンドウやバッファの切り替えなどのEmacsの通常の機能も使えることに留意。）

   デバッガコマンドのもっとも重要な使い方はステップ実行であり、
これにより制御の流れを調べることです。
デバッガは、解釈実行版の関数の制御構造をステップ実行できますが、
バイトコンパイルした関数ではできません。
バイトコンパイルした関数をステップ実行したい場合には、
同じ関数を解釈実行版の定義に置き換える必要があります。
（これには、関数のソースを訪れて、その定義内で`C-M-x'と打つ。）

   debuggerモードのコマンド一覧を以下に示します。

`c'
     デバッガを終了し実行を継続する。 継続可能であれば、
     （デバッガ内で行った変数値やデータ構造に対する変更などの副作用を除いて）
     デバッガを起動しなかったかのようにプログラムの実行を再開する。

     継続が可能なのは、
     関数呼び出し時や終了時、明示的な起動、中断によりデバッガに入った場合である。
     エラーが原因でデバッガが起動されたときには継続できない。

`d'
     実行を継続するが、任意のLisp関数を呼び出すとデバッガに入る。
     これにより、式の部分式をステップ実行して
     部分式が計算する値やその動作を調べることができる。

     このようにしてデバッガを起動した関数呼び出しのスタックフレームには
     自動的に印が付き、そのスタックから抜けるとデバッガがふたたび呼び出される。
     この印を消すにはコマンド`u'を使う。

`b'
     フレームから抜けるとデバッガに入るようにカレントフレームに印を付ける。
     このように印を付けたフレームには、バックトレースバッファでは星印が付く。

`u'
     カレントフレームから抜けるときにデバッガに入らない。
     これは、当該フレームに対するコマンド`b'を取り消す。
     視覚的にはバックトレースバッファの当該行から星印が取られる。

`e'
     ミニバッファでLisp式を読み取り、それを評価し、その値をエコー領域に表示する。
     この操作の一環として、デバッガは重要なある種の変数や
     カレントバッファを変更する。
     `e'はそれらの値をデバッガの外側の値に一時的に復元するので、
     それらを調べたり変更したりできる。
     これによりデバッガは透過的になる。
     対照的に、`M-:'はデバッガ内で特別なことは行わない。
     デバッガ内での変数値を表示する。

`R'
     `e'と同様であるが、
     バッファ`*Debugger-record*'での評価結果も保存する。

`q'
     デバッグ中のプログラムを終了する。
     Emacsのトップレベルのコマンド実行へ戻る。

     `C-g'でデバッガへ入ったが、
     実際には中断したいのであってデバッグはしたくない場合には
     コマンド`q'を使う。

`r'
     デバッガから値を指定して戻る。
     その値は、ミニバッファで式を読み取り、それを評価して得る。

     （`b'で指定したり`d'でフレームに入ることで）
     Lispの呼び出しフレームから抜けでたためにデバッガが起動された場合に、
     コマンド`r'は有用である。
     コマンド`r'で指定した値は、当該フレームの値として使われる。
     このコマンドは、`debug'を呼び出してその戻り値を使う場合にも有用である。
     さもなければ、`r'は`c'と同じ効果であり、指定した戻り値は関係ない。

     エラーでデバッガに入った場合には`r'は使えない。


File: elisp-ja,  Node: Invoking the Debugger,  Next: Internals of Debugger,  Prev: Debugger Commands,  Up: Debugger

17.1.7 デバッガの起動
----------------------------

ここでは、デバッガを起動するために使われる関数`debug'の詳細を述べます。

 -- Function: debug &rest debugger-args
     この関数はデバッガに入る。
     `*Backtrace*'（あるいはデバッガの第2レベルに再帰的に入ると
     `*Backtrace*<2>'など）という名前のバッファに切り替え、
     Lisp関数の呼び出しスタックに関する情報でこのバッファを満たす。
     そして再帰編集に入りdebuggerモードのバックトレースバッファを表示する。

     debuggerモードのコマンド`c'や`r'で再帰編集から抜けだし、
     `debug'はそれ以前のバッファに切り替え
     `debug'を呼び出したところへ戻る。
     これは、関数`debug'が呼び出し側へ戻る唯一の手段である。

     DEBUGGER-ARGSの使い途は、
     `debug'が引数の残りをバッファ`*Backtrace*'の先頭に表示し、
     ユーザーが読めるようにすることである。
     以下に述べる場合を除いて、これがこれらの引数の_唯一_の用途である。

     `debug'の第1引数が特定の値を持つ場合、特別な意味がある。
     （通常、これらの値はEmacs内部で用いるだけであり、
     プログラマが`debug'を呼ぶときには使わない。）
     以下にこれらの特別な値を示す。

    `lambda'
          第1引数が`lambda'であると、
          `debug-on-next-call'が`nil'以外であるために
          関数に入るときに`debug'を呼び出したことを意味する。
          デバッガはバッファの先頭にテキスト行`Entering:'を表示する。

    `debug'
          第1引数が`debug'であると、
          関数に入るときにデバッガを起動するようになっていたために
          `debug'を呼び出したことを示す。
          デバッガは、`lambda'の場合と同様に、`Entering:'を表示する。
          さらに、当該関数のスタックフレームに関数から
          戻るときにデバッガを起動するように印を付ける。

    `t'
          第1引数が`t'であると、
          `debug-on-next-call'が`nil'以外であるときに
          フォームの並びを評価したために `debug'を呼び出したことを示す。
          デバッガはバッファの先頭行につぎの行を表示する。

               Beginning evaluation of function call form:

    `exit'
          第1引数が`exit'であると、
          スタックフレームから抜けるときにデバッガを呼び出すように印を
          付けたスタックフレームから抜けたことを示す。
          この場合、`debug'の第2引数はフレームからの戻り値である。
          デバッガはバッファの先頭行に`Return
          value:'に続けて戻り値を表示する。

    `error'
          第1引数が`error'であると、
          エラーや`quit'が通知されたが処理されないためにデバッガに入ったことを示し、
          `Signaling:'に続けて通知されたエラーと`signal'の引数を表示する。
          たとえばつぎのとおり。

               (let ((debug-on-error t))
                 (/ 1 0))

               ------ Buffer: *Backtrace* ------
               Signaling: (arith-error)
                 /(1 0)
               ...
               ------ Buffer: *Backtrace* ------

          エラーが通知されたときには、
          変数`debug-on-error'は`nil'以外であるはずである。
          `quit'が通知されたときには、
          変数`debug-on-quit'は`nil'以外であるはずである。

    `nil'
          明示的にデバッガに入るときには、
          DEBUGGER-ARGSの先頭として`nil'を使う。
          DEBUGGER-ARGSの残りはバッファの先頭行に表示される。
          この機能を用いてメッセージを表示でき、
          たとえば、`debug'を呼び出した条件の覚え書きにする。


File: elisp-ja,  Node: Internals of Debugger,  Prev: Invoking the Debugger,  Up: Debugger

17.1.8 デバッガの内部
----------------------------

本節では、デバッガが内部的に使用する関数や変数について述べます。

 -- Variable: debugger
     この変数の値は、デバッガを起動するために呼び出す関数である。
     その値は、可変個数の引数を取る関数（あるいは典型的には関数名）であること。
     その関数でなんらかのデバッガに入ると仮定する。
     この変数のデフォルト値は`debug'。

     Lispが関数に渡す最初の引数で、呼び出した理由を表す。
     引数の規約は`debug'に記述してある。

 -- コマンド: backtrace
     この関数は、現在活性なLisp関数呼び出しのトレースを表示する。
     これは、`debug'がバッファ`*Backtrace*'を
     満たすために用いる関数である。 どの関数呼び出しが活性であるかを
     判断するためにスタックを参照する必要があるためCで書いてある。
     戻り値はつねに`nil'。

     以下の例では、Lisp式で明示的に`backtrace'を呼び出す。
     これにより、バックトレースをストリーム`standard-output'に出力する。
     ここではバッファ`backtrace-output'に出力する。
     バックトレースの各行は、1つの関数呼び出しを表す。
     関数の引数値すべてが判ればそれらを行に表示する。
     それらが計算途中であれば、その旨を行に表示する。
     スペシャルフォームの引数は省略する。

          (with-output-to-temp-buffer "backtrace-output"
            (let ((var 1))
              (save-excursion
                (setq var (eval '(progn
                                   (1+ var)
                                   (list 'testing (backtrace))))))))

               => nil

          ----------- Buffer: backtrace-output ------------
            backtrace()
            (list ...computing arguments...)
            (progn ...)
            eval((progn (1+ var) (list (quote testing) (backtrace))))
            (setq ...)
            (save-excursion ...)
            (let ...)
            (with-output-to-temp-buffer ...)
            eval-region(1973 2142 #<buffer *scratch*>)
            byte-code("...  for eval-print-last-sexp ...")
            eval-print-last-sexp(nil)
          * call-interactively(eval-print-last-sexp)
          ----------- Buffer: backtrace-output ------------

     文字`*'は、
     抜け出るときにデバッガを起動する印が付いているフレームを表す。

 -- Variable: debug-on-next-call
     この変数が`nil'以外であると、
     つぎに`eval'、`apply'、`funcall'を呼び出すまえに
     デバッガを呼び出すことを指定する。
     デバッガに入ると`debug-on-next-call'を`nil'に設定する。

     デバッガのコマンド`d'は、この変数を設定することで動作する。

 -- Function: backtrace-debug level flag
     この関数は、LEVELの深さのスタックフレームに
     値FLAGに応じてフレームから抜け出るときのデバッガ呼び出しの印を付ける。
     FLAGが`nil'以外であると、
     のちに当該フレームから抜けるとデバッガに入る。
     非ローカルな脱出で当該フレームから抜けるときにもデバッガに入る。

     この関数はデバッガのみが使用する。

 -- Variable: command-debug-status
     この変数は、現在の対話的コマンドのデバッグ状況を記録する。
     コマンドが対話的に呼び出されるたびに、
     この変数は`nil'に束縛される。 デバッガはこの変数に設定することで、
     同じコマンドの起動中にデバッガが将来起動された場合に備えて
     情報を残すことができる。

     デバッガにとっては、通常のグローバル変数ではなくこの変数を使う利点は、
     以降のコマンド起動にデータが繰り越さないことである。

 -- Function: backtrace-frame frame-number
     関数`backtrace-frame'は、Lispデバッガで使うことを意図している。
     深さFRAME-NUMBERのスタックフレームで進行中の計算に関する情報を返す。

     当該フレームで引数の評価を完了していなければ（あるいはスペシャルフォーム）、
     値は`(nil FUNCTION ARG-FORMS...)'。

     当該フレームで引数の評価を完了し関数を呼び出していれば、 値は`(t
     FUNCTION ARG-VALUES...)'。

     戻り値において、FUNCTIONは評価したリストのCARであるか、
     マクロ呼び出しでは`lambda'式である。
     関数に引数`&rest'があれば、リストARG-VALUESの残りで表現される。

     FRAME-NUMBERが範囲外であると、`backtrace-frame'は`nil'を返す。


File: elisp-ja,  Node: Edebug,  Next: Syntax Errors,  Prev: Debugger,  Up: Debugging

17.2 edebug
===========

edebugはEmacs Lispプログラムのソースレベルデバッガであり、
つぎのことを行えます。

   * 各式の前後で停止して評価をステップ実行する。

   * 条件付きブレークポイント、無条件ブレークポイントを設定する。

   * 指定した条件が真の場合に停止する（グローバルブレークイベント）。

   * 各停止位置や各ブレークポイントで停止し低速／高速トレースする。

   * edebugの外側であるかのように、式の結果を表示したり式を評価する。

   * edebugが表示を更新するたびに、
     自動的に式の並びを再評価しその結果を表示する。

   * 関数の出入りに関するトレース情報を出力する。

   * エラーが発生すると停止する。

   * edebug自身のフレームを省いて、バックトレースを表示する。

   * マクロや定義フォームに対して引数の評価を指定する。

   * 基本的なカバレッジテストや頻度数計測を行う。

   以下の最初の3つの節では、edebugを使うのに十分な情報を与えます。

* Menu:

* Using Edebug::		Introduction to use of Edebug.
* Instrumenting::		You must instrument your code
				  in order to debug it with Edebug.
* Modes: Edebug Execution Modes. Execution modes, stopping more or less often.
* Jumping::			Commands to jump to a specified place.
* Misc: Edebug Misc.		Miscellaneous commands.
* Breakpoints::			Setting breakpoints to make the program stop.
* Trapping Errors::		trapping errors with Edebug.
* Views: Edebug Views.		Views inside and outside of Edebug.
* Eval: Edebug Eval.			Evaluating expressions within Edebug.
* Eval List::			Expressions whose values are displayed
				  each time you enter Edebug.
* Printing in Edebug::		Customization of printing.
* Trace Buffer::		How to produce trace output in a buffer.
* Coverage Testing::		How to test evaluation coverage.
* The Outside Context::		Data that Edebug saves and restores.
* Instrumenting Macro Calls::	Specifying how to handle macro calls.
* Options: Edebug Options.	Option variables for customizing Edebug.


File: elisp-ja,  Node: Using Edebug,  Next: Instrumenting,  Up: Edebug

17.2.1 edebugの使い方
-------------------------

edebugでLispプログラムをデバッグするには、
デバッグしたいLispコードをまず"処置"（instrument）しておく必要があります。
これを行う簡単な方法は、関数やマクロの定義にポイントを移動してから、
`C-u C-M-x'（前置引数を指定した`eval-defun'）を実行します。
コードを処置する別の方法については、*Note Instrumenting::。

関数をいったん処置しておけば、当該関数を呼び出すとedebugを活性にします。
edebugが活性になると実行を停止し、
読者が選択したedebugの実行モードに応じて、
関数をステップ実行したりデバッグコマンドを検査しながら
表示を更新しつつ実行を継続します。
デフォルトの実行モードはステップ実行であり、 いったん実行を停止します。
*Note Edebug Execution Modes::。

   edebugでは、デバッグ中のLispコードのソースを
表示したEmacsバッファを読者は見ます。
このバッファを"ソースコードバッファ"と呼びます。
このバッファは一時的に読み出し専用です。

   左端の矢印は、関数の実行中の行を表します。
ポイントの初期位置は関数の実行中の行にありますが、
読者自身がポイントを移動すると変わります。

   （以下の）`fac'の定義を処置してから`(fac 3)'を実行したとすると、
つぎのようになります。 ポイントは`if'のまえの開き括弧にあります。

     (defun fac (n)
     =>-!-(if (< 0 n)
           (* n (fac (1- n)))
         1))

   edebugが関数内で実行を停止できる箇所を"停止位置"（stop
point）と呼びます。
これらは、リストである各部分式の前後と各変数参照のうしろにあります。
関数`fac'の中にある停止位置をピリオドで示します。

     (defun fac (n)
       .(if .(< 0 n.).
           .(* n. .(fac (1- n.).).).
         1).)

   ソースコードバッファでは、Emacsのlispモードのコマンドに加えて
edebugの特別なコマンドを使えます。
たとえば、つぎの停止位置まで実行するには edebugコマンド<SPC>を打ちます。
`fac'に入ったあとで<SPC>を1回打つと、 つぎのような表示になります。

     (defun fac (n)
     =>(if -!-(< 0 n)
           (* n (fac (1- n)))
         1))

   式のうしろでedebugが実行を停止すると、
式の値をエコー領域に値を表示します。

   多用される他のコマンドには、
停止位置にブレークポイントを設定する`b'、
ブレークポイントに達するまで実行する`g'、
edebugを終了してトップレベルのコマンドループへ戻る`q'があります。
edebugのコマンド一覧を表示するには`?'を打ちます。


File: elisp-ja,  Node: Instrumenting,  Next: Edebug Execution Modes,  Prev: Using Edebug,  Up: Edebug

17.2.2 edebug向けの処置
----------------------------

Lispコードのデバッグにedebugを使うためには、
コードをまず"処置"する必要があります。
コードを処置すると、適当な箇所でedebugを起動する追加のコードを挿入します。

   いったんedebugをロードすると、
コマンド`C-M-x'（`eval-defun'）は再定義されます。
定義内で前置引数を指定して起動すると
定義を評価するまえに処置するようになります。
（ソースコード自体は変更しない。）
変数`edebug-all-defs'が`nil'以外であると、 前置引数の意味を逆にします。
つまり、前置引数を指定し_ない限り_、 `C-M-x'は関数定義を処置します。
変数`edebug-all-defs'のデフォルト値は`nil'です。 コマンド`M-x
edebug-all-defs'は変数`edebug-all-defs'の値を トグルします。

   `edebug-all-defs'が`nil'以外であると、
コマンド`eval-region'、`eval-current-buffer'、`eval-buffer'も
それらが評価する定義を処置します。 同様に、`edebug-all-forms'は、
定義以外のフォームであっても`eval-region'が
_任意_のフォームを処置するかどうか制御します。
これは、ミニバッファでのロードや評価には適用されません。 コマンド`M-x
edebug-all-forms'はこのオプションをトグルします。

   別のコマンド`M-x edebug-eval-top-level-form'は、
`edebug-all-defs'と`edebug-all-forms'の値に関わらず
任意のトップレベルのフォームを処置するために使えます。

   edebugが動作中は、 コマンド`I'（`edebug-instrument-callee'）で、
ポイントのうしろのフォームから呼ばれる関数やマクロの定義を
処置済みでなければ処置できます。
これは、edebugが当該関数のソースを探せる場合にのみ可能です。
edebugをロード後には、 `eval-region'は、処置していないものも含めて、
評価した各定義の位置を記録しています。
関数を処置後に呼び出してステップ実行する コマンド`i'（*note
Jumping::）も参照してください。

   edebugは、標準のスペシャルフォームすべて、
式を引数とする`interactive'フォーム、
無名ラムダ式、他の定義フォームをどのように処置するかわかっています。
edebugは、マクロ呼び出しを引数に持つユーザー定義マクロをどのように
処置すべきかわかりませんから、読者がそれを指示する必要があります。
詳しくは、*Note Instrumenting Macro Calls::。

   edebugは、あるセッションで初めてコードを処置する場合、
フック`edebug-setup-hook'を実行してから それに`nil'を設定します。
これを利用すると、読者が使用するパッケージに対応した
edebug用仕様（*note Instrumenting Macro Calls::）を
edebugを使用する場合にのみロードするようにできます。

   定義から処置を取り除くには、
処置しないような方法でその定義を単に再評価するだけです。
けっして処置せずにフォームを評価する方法は2つあります。
ファイルを`load'するか、
ミニバッファで`eval-expression'（`M-:'）を使います。

   edebugが処置中に構文エラーを検出すると、
コードのエラー箇所にポイントを置いて、
エラー`invalid-read-syntax'を通知します。

   edebugの内側で使える他の評価関数については*Note Edebug Eval::。


File: elisp-ja,  Node: Edebug Execution Modes,  Next: Jumping,  Prev: Instrumenting,  Up: Edebug

17.2.3 edebugの実行モード
-------------------------------

edebugには読者がデバッグしているプログラムを実行するための
実行モードが複数あります。 これらを"edebugの実行モード"と呼びます。
これらをメジャーモードやマイナモードと混同しないでください。
edebugの実行モードは、停止するまでにどの程度edebugが実行を継続するか、
たとえば、各停止位置で停止するのかつぎのブレークポイントまで継続するのか、
また、停止するまでに評価の進行状況をどの程度edebugが表示するのかを
決定します。

   通常、あるモードにおいて、
プログラムを継続するコマンドを打つことでedebugの実行モードを指定します。
以下にそれらのコマンドの一覧を示します。 `S'を除くすべてのコマンドは、
少なくともある程度プログラムの実行を再開します。

`S'
     停止：` 'プログラムをいっさい実行せずに、
     edebugコマンドの入力を待つ（`edebug-stop'）。

`<SPC>'
     ステップ実行：`
     'つぎに出会う停止位置で止まる（`edebug-step-mode'）。

`n'
     つぎ：` '式のうしろでつぎに出会う停止位置で止まる
     （`edebug-next-mode'）。 *note Edebug
     Misc::の`edebug-forward-sexp'も参照。

`t'
     トレース：` 'edebugの各停止位置で1秒間休止する
     （`edebug-trace-mode'）。

`T'
     高速トレース：` '各停止位置で表示を更新するが休止しない
     （`edebug-Trace-fast-mode'）。

`g'
     実行：` 'つぎのブレークポイントまで実行する （`edebug-go-mode'）。
     *note Breakpoints::。

`c'
     継続：` '各ブレークポイントで1秒間休止してから継続する
     （`edebug-continue-mode'）。

`C'
     高速継続：` '各ブレークポイントへポイントを移動するが休止しない
     （`edebug-Continue-fast-mode'）。

`G'
     非停止実行：` 'ブレークポイントを無視する
     （`edebug-Go-nonstop-mode'）。
     `S'や編集コマンドを打てば停止できる。

   一般に、上記一覧の上にある実行モードほど下にあるものに比べると
プログラムをゆっくり実行、つまり、早く停止します。

実行中やトレース中には、edebugコマンドをなにか打てば実行に割り込めます。
edebugはつぎの停止位置でプログラムを止め、
読者が打ったコマンドを実行します。
たとえば、実行中に`t'を打てば、つぎの停止位置でトレースモードに
切り替わります。 単に実行を停止するには`S'を使います。

   読者の関数が入力を読み取る場合、実行に割り込むつもりで打った文字を
関数が読み取ってしまうかもしれません。
読者のプログラムがいつ入力するかに注意していれば、
このような意図しない結果を避けることができます。

   本節で述べたコマンドを含むキーボードマクロは動作しません。
つまり、プログラムを再開するためにedebugから抜けると
キーボードマクロの制御を失ってしまいます。
これを修正するのは簡単ではありません。
また、edebugの外側でキーボードマクロを定義したり実行しても、
edebug内のコマンドにはなんの影響もありません。 これは普通は利点です。
しかし、オプション`edebug-continue-kbd-macro' （*note Edebug
Options::）も参照してください。

   edebugの新たなレベルに入ると、変数`edebug-initial-mode'の値を
実行モードの初期値とします。
デフォルトでは、これはステップ実行モードを指定します。
処置した関数を1つのコマンドから複数回呼び出すなどして
edebugの同一レベルに再度入ることができることに注意してください。


File: elisp-ja,  Node: Jumping,  Next: Edebug Misc,  Prev: Edebug Execution Modes,  Up: Edebug

17.2.4 ジャンプ
-------------------

本節で述べるコマンドは、指定した位置に達するまで実行します。
`i'を除くすべてのものは、停止する場所に一時的なブレークポイントを
設定してから実行モードに移行します。
意図したブレークポイントより先に別のブレークポイントに達しても
実行を停止します。 ブレークポイントについて詳しくは*Note Breakpoints::。

   非ローカル脱出は、読者が意図したプログラムの停止すべき
一時的なブレークポイントを迂回するため、
これらのコマンドは非ローカル脱出があると意図したように動作しません。

`h'
     ポイント位置付近の停止位置まで進む（`edebug-goto-here'）。

`f'
     プログラムの式1つ分先へ進む（`edebug-forward-sexp'）。

`o'
     囲んでいるS式の終りまでプログラムを実行する。

`i'
     ポイントのあとのフォームから呼ばれる関数やマクロへ進む。

   コマンド`h'は、一時的なブレークポイントを使って、
ポイント位置付近の停止位置まで進みます。
ブレークポイントについて詳しくは*Note Breakpoints::。

   コマンド`f'は、プログラムの式1つ分先へ進みます。
より正確には、`C-M-f'による移動箇所へ一時的なブレークポイントを設定し、
プログラムがブレークポイントで停止するような実行モードで実行します。

   前置引数Nを指定すると、
ポイント位置からN個先のS式に一時的なブレークポイントを設定します。
囲んでいるリストの残り要素数がNより少なければ、
囲んでいる式の末尾で停止します。

   `C-M-f'の移動先はプログラムが実際に停止するであろう箇所です。
これが正しくない場合もあり、たとえば、`cond'では正しくありません。

   コマンド`f'は、柔軟性のために、
停止位置ではなくポイント位置で`forward-sexp'を使います。
_現在の停止位置から_式1つだけ実行したい場合には、
まず`w'と打ってポイントを停止位置に移動してから`f'を打ちます。

   コマンド`o'は式から『出る』まで実行します。
ポイントを含むS式の末尾に一時的なブレークポイントを置きます。
このS式が関数定義そのものである場合には、
`o'は定義の最後のS式の手前まで実行します。
現在この箇所にいた場合には、関数から戻ってから停止します。
いいかえれば、最後のS式のあとに位置していない限り、
このコマンドは現在実行中の関数から抜けません。

   コマンド`i'は、
ポイント位置のあとにあるリストフォームから呼ばれる関数やマクロへ進み、
最初に出会った停止位置で止まります。
そのフォームはこれから評価されるフォームである必要はありません。
しかし、評価されるフォームが関数呼び出しである場合には、
引数を評価するまえにこのコマンドを使うことを覚えておいてください。
さもないとこのコマンドを使う時期が遅すぎます。

   コマンド`i'は、呼び出す関数やマクロが処置されていないと
それらを処置します。
これは便利ですが、それらの関数やマクロは、明示的に処置を取り除かない限り、
処置したままになります。


File: elisp-ja,  Node: Edebug Misc,  Next: Breakpoints,  Prev: Jumping,  Up: Edebug

17.2.5 edebugのその他のコマンド
----------------------------------------

edebugの他のコマンドを以下に示します。

`?'
     edebugのヘルプメッセージを表示する（`edebug-help'）。

`C-]'
     1つまえのレベルのコマンドレベルへ戻る（`abort-recursive-edit'）。

`q'
     エディタのトップレベルのコマンドループへ戻る（`top-level'）。
     edebugのすべての動作中のレベルを含めて、すべての再帰編集レベルから抜ける。
     しかし、フォーム`unwind-protect'や`condition-case'で保護した
     処置済みのコードがあるとデバッガを再開する。

`Q'
     `q'と同様であるが保護したコードでも停止しない
     （`top-level-nonstop'）。

`r'
     もっとも最近の式の既知の結果をエコー領域に再表示する
     （`edebug-previous-result'）。

`d'
     わかりやすいようにedebug自体の関数を除外してバックトレースを表示する
     （`edebug-backtrace'）。

     edebugのバックトレースバッファでは、
     標準のデバッガのようにはデバッガのコマンドを使えない。

     実行を継続するとバックトレースバッファは自動的に削除される。

edebugの再帰編集から、edebugを再帰的に活性にするコマンドを起動できます。
edebugが活性であるときにはいつでも`q'でトップレベルへ戻るか、
`C-]'で1つの再帰編集レベルを抜けることができます。
保留している評価すべてのバックトレースは`d'で表示できます。


File: elisp-ja,  Node: Breakpoints,  Next: Trapping Errors,  Prev: Edebug Misc,  Up: Edebug

17.2.6 ブレークポイント
-------------------------------

edebugのステップ実行モードは、つぎの停止位置に達すると実行を停止します。
edebugが実行を止める方法は3つあります。
ブレークポイント、グローバルブレーク条件、ソースのブレークポイントです。

   edebugを使用中には、読者がテスト中のプログラムに"ブレークポイント"
（breakpoint）、つまり、実行を停止すべき箇所を設定できます。 *note
Using Edebug::で定義した任意の停止位置にブレークポイントを設定できます。
ブレークポイントの設定や解除において対象となる停止位置は、
ソースコードバッファのポイント位置かそのあとにある停止位置です。
ブレークポイントに関するedebugコマンドはつぎのとおりです。

`b'
     ポイント位置かそのうしろにある停止位置にブレークポイントを設定する
     （`edebug-set-breakpoint'）。
     前置引数を指定すると、一時的なブレークポイントになる
     （そこでプログラムが停止すると解除される）。

`u'
     ポイント位置かそのうしろにある停止位置の（あれば）ブレークポイントを解除する
     （`edebug-unset-breakpoint'）。

`x CONDITION <RET>'
     CONDITIONが`nil'以外の値に評価される場合にのみ
     プログラムを停止する条件付きブレークポイントを設定する
     （`edebug-set-conditional-breakpoint'）。
     前置引数を指定すると、一時的なブレークポイントになる。

`B'
     現在の定義内にあるつぎのブレークポイントにポイント位置を移動する
     （`edebug-next-breakpoint'）。

   edebug内では、`b'でブレークポイントを設定し、 `u'で解除できます。
まず目的のedegugの停止位置にポイント位置を移動し、
`b'を打ってその箇所にブレークポイントを設定したり、
`u'を打ってその箇所のブレークポイントを解除します。
設定されていないブレークポイントを解除しても、なにも起こりません。

定義を再評価したり再処置すると、その中のブレークポイントすべてを解除します。

   "条件付きブレークポイント"（conditional breakpoint）は、
プログラムがこの箇所に達するたびに条件を検査します。
条件を評価中に発生するどんなエラーも無視し、 `nil'として扱います。
条件付きブレークポイントを設定するには`x'を使い、
条件式はミニバッファで指定します。
すでに条件付きブレークポイントを設定してある停止位置に
条件付きブレークポイントを設定し直すと、
それまでの条件式がミニバッファに入るので編集できます。

   ブレークポイントを設定するコマンドに前置引数を指定すると、
条件付き／無条件ブレークポイントを"一時的"なものにできます。
一時的ブレークポイントでプログラムが停止すると、
そのブレークポイントは自動的に解除されます。

   edebugのモードが非停止実行でなければ、
edebugはブレークポイントでつねに停止するか休止します。
非停止実行モードでは、ブレークポイントを完全に無視します。

   ブレークポイントの場所を確認するには、コマンド`B'を使います。
同じ関数内のポイント箇所のうしろにあるブレークポイントか、
後続のものがなければ最初のブレークポイントにポイント位置を移動します。
このコマンドは実行を継続しません。
バッファ内で単にポイントを移動するだけです。

* Menu:

* Global Break Condition::	Breaking on an event.
* Source Breakpoints::  	Embedding breakpoints in source code.


File: elisp-ja,  Node: Global Break Condition,  Next: Source Breakpoints,  Up: Breakpoints

17.2.6.1 グローバルブレーク条件
..........................................

"グローバルブレーク条件"（global break condition）は、
指定した条件が満たされると、その場所に関わらず、実行を停止させます。
edebugは各停止位置においてグローバルブレーク条件を評価します。
これが`nil'以外の値であると、 ブレークポイントに達したかのように、
実行モードに依存して実行を停止するか休止します。
条件の評価中にエラーが発生しても実行は停止しません。

   条件式は`edebug-global-break-condition'に保存されます。
コマンド`X'で新たな条件式を指定できます
（`edebug-set-global-break-condition'）。

   グローバルブレーク条件は、読者のコードのどこでイベントが発生するかを
調べるもっとも簡単な方法ですが、コードの実行速度をかなり遅くします。
ですから、使用しない場合には条件を`nil'に再設定すべきです。


File: elisp-ja,  Node: Source Breakpoints,  Prev: Global Break Condition,  Up: Breakpoints

17.2.6.2 ソース上のブレークポイント
................................................

定義内のすべてのブレークポイントは、定義を処置し直すたびに失われます。
ブレークポイントを失いたくない場合には、
"ソース上のブレークポイント"（source breakpoint）を指定できます。
これはソースコード上で関数`edebug'を呼び出すだけです。
もちろん、条件付けして呼び出せます。
たとえば、関数`fac'において、引数がゼロの場合に停止するには、
以下に示すように最初の行を挿入します。

     (defun fac (n)
       (if (= n 0) (edebug))
       (if (< 0 n)
           (* n (fac (1- n)))
         1))

   関数`fac'を処置してこの関数を呼び出すと、
`edebug'の呼び出しはブレークポイントのように動作します。
実行モードに応じて、edebugはその箇所で停止するか休止します。

   `edebug'を呼び出したコードが処置済みでなければ、
この関数は`debug'を呼び出します。


File: elisp-ja,  Node: Trapping Errors,  Next: Edebug Views,  Prev: Breakpoints,  Up: Edebug

17.2.7 エラーの捕捉
-------------------------

Emacsは、通常、エラーが通知されても`condition-case'で処理されなかった
場合、エラーメッセージを表示します。
edebugが活性であり処置済みのコードを実行していると、
edebugは処理されなかったエラーすべてに反応します。
この動作を`edebug-on-error'と`edebug-on-quit'で カスタマイズできます。
*Note Edebug Options::。

   edebugがエラーに反応すると、
エラーを起こすまえ出会った最後の停止位置を表示します。
この位置は、実際にエラーを起こした処置してない関数の呼び出し位置である
場合もあります。 未束縛な変数のエラーでは、最後の停止位置は、
当該変数の参照位置からかなり離れている場合があります。
そのような場合には、完全なバックトレースを表示したいでしょう （*note
Edebug Misc::）。

   edebugが活性なときに`debug-on-error'や`debug-on-quit'を変更しても、
edebugが不活性になったときにそれらの変更を取り消してしまいます。
さらに、edebugの再帰編集中は、これらの変数はedebugの外側での値に
束縛されます。


File: elisp-ja,  Node: Edebug Views,  Next: Edebug Eval,  Prev: Trapping Errors,  Up: Edebug

17.2.8 edebugのビュー
-------------------------

これらのedebugのコマンドは、edebugに入るまえのバッファやウィンドウの
状態を調べるものです。
外部ウィンドウ構成は、edebugの外側でのウィンドウの集まりや内容に
関するものです。

`v'
     外部ウィンドウ構成を一時的に見る （`edebug-view-outside'）。

`p'
     edebugの外側でのカレントバッファと外側でのポイント位置を
     一時的に表示する（`edebug-bounce-point'）。
     前置引数Nは、かわりに休止秒数を指定する。

`w'
     ソースコードバッファで現在の停止位置にポイント位置を戻す
     （`edebug-where'）。

     同じバッファを表示している別のウィンドウでこのコマンドを使うと、
     それ以後、そのウィンドウに現在の定義が表示されるようになる。

`W'
     edebugが外部ウィンドウ構成を保存／復元するかどうかをトグルする
     （`edebug-toggle-save-windows'）。

     前置引数を指定すると選択したウィンドウだけの保存／復元をトグルする。
     ソースコードバッファを表示していないウィンドウを指定するには、
     グローバルキーマップの`C-x X W'を使う必要がある。

   `v'で外部ウィンドウ構成を見ることができます。
あるいは、（edebugの外側での）カレントバッファが表示されていなくても
`p'でカレントバッファのポイント位置を見ることができます。
ポイント位置を移動したら、
`w'でソースコードバッファの停止位置へ戻れます。

   外部ウィンドウ構成を保存_しない_ように`W'を使うたびに、
edebugは保存しておいた外部ウィンドウ構成を破棄します。
そのため、保存_する_ように戻しても、
（プログラムを続行することで）edebugを抜けると、
現在のウィンドウ構成は変更されません。
しかし、`*edebug*'と`*edebug-trace*'の自動再表示は、
十分なウィンドウが開いてないと、
読者が見たいバッファと衝突するかもしれません。


File: elisp-ja,  Node: Edebug Eval,  Next: Eval List,  Prev: Edebug Views,  Up: Edebug

17.2.9 評価
-------------

edebugの内側では、edebugが動作していないがごとく式を評価できます。
edebugは、式の評価と表示に対して見えないようにします。
edebugが明示的に保存／復元する場合を除いて、
副作用を持つ式の評価も期待どおり動作します。
この処理に関して詳しくは*Note The Outside Context::。

`e EXP <RET>'
     edebugの外側の文脈で式EXPを評価する （`edebug-eval-expression'）。
     つまり、edebugは評価への干渉を最小限にとどめようとする。

`M-: EXP <RET>'
     edebug自身の文脈で式EXPを評価する。

`C-x C-e'
     edebugの外側の文脈でポイント位置のまえの式を評価する
     （`edebug-eval-last-sexp'）。

   edebugは`cl.el'（版2.03以降）内の構文
`lexical-let'、`macrolet'、`symbol-macrolet'で
作成されるレキシカル（テキスト上の）束縛を参照する式の評価を扱えます。


File: elisp-ja,  Node: Eval List,  Next: Printing in Edebug,  Prev: Edebug Eval,  Up: Edebug

17.2.10 評価リストバッファ
-----------------------------------

`*edebug*'と呼ばれる"評価リストバッファ"を使って、
式を対話的に評価できます。
さらに、edebugが表示を更新するたびに自動的に評価される
式の"評価リスト"を設定することもできます。

`E'
     評価リストバッファ`*edebug*'へ切り替える
     （`edebug-visit-eval-list'）。

   バッファ`*edebug*'では、以下の特別なコマンドに加えて lisp対話モード
（*note lisp対話バッファ: (emacs)Lisp Interaction.）
のコマンドも使えます。

`C-j'
     外側の文脈でポイント位置のまえの式を評価し、
     その値をバッファに挿入する （`edebug-eval-print-last-sexp'）。

`C-x C-e'
     edebugの外側の文脈でポイント位置のまえの式を評価する
     （`edebug-eval-last-sexp'）。

`C-c C-u'
     バッファの内容から新たな評価リストを構築する
     （`edebug-update-eval-list'）。

`C-c C-d'
     ポイント位置にある評価リストグループを削除する
     （`edebug-delete-eval-item'）。

`C-c C-w'
     ソースコードバッファに切り替え現在の停止位置に戻る
     （`edebug-where'）。

   `*scratch*'で行うのと同様に、 評価リストウィンドウでは`C-j'や`C-x
C-e'で式を評価できますが、 それらはedebugの外側の文脈で評価されます。

   実行を継続すると、対話的に入力した式（やその結果）は破棄されますが、
実行を停止するたびに評価される式から成る"評価リスト"（evaluation list）
を設定できます。

   これを行うには、評価リストバッファにて、
1つ以上の"評価リストグループ"（evaluation list group）を書きます。
評価リストグループは、1つ以上のLisp式から成ります。
グループはコメント行で区切ります。

   コマンド`C-c C-u'（`edebug-update-eval-list'）は、
バッファを走査して各グループの最初の式を使って
評価リストを再構築します。
（各グループの2番目の式は計算結果を表示した値とみなす。）

   edebugに入るたびに、各式に続けてその現在値をバッファに挿入することで
評価リストを再表示します。
このとき、各式がそれぞれグループになるようにコメント行も挿入します。
したがって、バッファのテキストを変更せずに再度`C-c C-u'と打つと、
評価リストは実質的には変更されません。

   評価リストの評価中にエラーが発生すると、
エラーメッセージを評価結果とみなして文字列で表示します。
したがって、現在の文脈では不正な変数を式に使っても
読者のデバッグを遮ることはありません。

評価リストウィンドウに数個の式を追加したときのようすを以下に示します。

     (current-buffer)
     #<buffer *scratch*>
     ;---------------------------------------------------------------
     (selected-window)
     #<window 16 on *scratch*>
     ;---------------------------------------------------------------
     (point)
     196
     ;---------------------------------------------------------------
     bad-var
     "Symbol's value as variable is void: bad-var"
     ;---------------------------------------------------------------
     (recursion-depth)
     0
     ;---------------------------------------------------------------
     this-command
     eval-last-sexp
     ;---------------------------------------------------------------

   グループを削除するには、そこへポイントを移動して`C-c C-d'と打ちます。
あるいは、グループのテキストを単に削除してから`C-c C-u'で
評価リストを更新します。 評価リストに新たに式を追加するには、
適切な位置に式を挿入し、新たなコメント行を挿入します。
（コメント行にマイナス記号を挿入する必要はない。
コメントの内容は関係ない。） そして、`C-c C-u'と打ちます

   `*edebug*'を選択したあとは、 `C-c
C-w'でソースコードバッファへ戻れます。
読者が実行を継続するとバッファ`*edebug*'は削除され、
つぎに必要なときに再度作成されます。


File: elisp-ja,  Node: Printing in Edebug,  Next: Trace Buffer,  Prev: Eval List,  Up: Edebug

17.2.11 edebugでの出力
--------------------------

読者のプログラムの式が循環したリスト構造を含む値を作り出す場合、
edebugがそれを出力しようとするとエラーになります。

   循環構造を扱う1つの方法は、出力を切り詰めるために
`print-length'や`print-level'を設定することです。
edebugが読者のためにこれを行います。 それらが`nil'であると、
edebugは`print-length'と`print-level'を50に束縛します。
（実際は、edebugが使う値は
`e-debug-print-length'と`e-debug-print-level'が指定する。） *Note
Output Variables::。

 -- User Option: edebug-print-length
     `nil'以外であると、edebugが結果を出力するときには、
     これを`print-length'に束縛する。 デフォルト値は`50'。

 -- User Option: edebug-print-level
     `nil'以外であると、edebugが結果を出力するときには、
     これを`print-level'に束縛する。 デフォルト値は`50'。

   パッケージ`cust-print'を使えば、
循環構造や要素を共有する構造をより的確に出力することもできます。

`cust-print'をロードしてedebugでのみこの特別な出力を使うようにするには、
単にコマンド`M-x edebug-install-custom-print'を使うだけです。
標準の出力関数に戻すには、`M-x
edebug-uninstall-custom-print'を使います。

   循環構造を作るコードの例を示します。

     (setq a '(x y))
     (setcar a a)

特別な出力ではこれを`Result: #1=(#1# y)'と出力します。
`#1='の記法は、これに続く構造に`1'というラベルを付けます。
また、`#1#'の記法はすでにラベル付けした構造を参照します。
この記法は、リストやベクトルの任意の共有された要素に使われます。

 -- User Option: edebug-print-circle
     `nil'以外であると、edebugが結果を出力するときには、
     これを`print-circle'に束縛する。 デフォルト値は`nil'。

   他のプログラムでもこの特別な出力を使えます。
詳しくは、`cust-print.el'を参照してください。


File: elisp-ja,  Node: Trace Buffer,  Next: Coverage Testing,  Prev: Printing in Edebug,  Up: Edebug

17.2.12 トレースバッファ
--------------------------------

edebugは、実行トレースを`*edebug-trace*'というバッファに保存することで
それらを記録できます。 これは、関数名とそれらの引数、戻り値から成る
関数呼び出しとその戻りの記録です。 トレース記録を有効にするには、
`edebug-trace'に`nil'以外の値を設定します。

   トレースバッファを作成することとトレース実行モードとは
同じではありません（*note Edebug Execution Modes::）。

   トレース記録を有効にしていると、
各関数へ入るときと出るときに、トレースバッファに行が追加されます。
関数へ入るときの記録は、`::::{'に関数名と引数値が続きます。
関数から出るときの記録は、`::::}'に関数名とその結果が続きます。

   入るときの`:'の個数は、再帰の深さを表します。
関数呼び出しの対応する開始や対応する終了を探すために
トレースバッファでは中括弧を使えます。

   関数`edebug-print-trace-before'と`edebug-print-trace-after'を
再定義すれば、関数へ入ったときと出るときのトレース記録をカスタマイズできます。

 -- Macro: edebug-tracing string body...
     このマクロはフォームBODYの周りにトレース情報を追加する。
     引数STRINGは、トレースバッファに入れるテキストを指定する。
     すべての引数を評価する。
     `edebug-tracing'はBODYの最後のフォームの値を返す。

 -- Function: edebug-trace format-string &rest format-args
     この関数はトレースバッファにテキストを挿入する。 テキストは`(apply
     'format FORMAT-STRING FORMAT-ARGS)'で 計算する。
     区切りとして改行も挿入する。

   `edebug-tracing'と`edebug-trace'は、
edebugが活性でない場合であっても呼ばれるとトレースバッファに行を挿入します。
トレースバッファにテキストを挿入するとき、
挿入した最後の行が見えるようにウィンドウをスクロールします。


File: elisp-ja,  Node: Coverage Testing,  Next: The Outside Context,  Prev: Trace Buffer,  Up: Edebug

17.2.13 カバレッジテスト
--------------------------------

edebugでは、初歩的なカバレッジテストや実行頻度を表示できます。

   カバレッジテストでは、各式の結果を以前の結果と比較します。
現在のEmacsセッションでカバレッジテストを始めて以降、
プログラムの各フォームが異なる2つの値を返せば、
当該フォームを『カバーした』とみなします。
したがって、読者のプログラムについてカバレッジテストを行うには、
さまざまな条件でそれを実行して正しく動作しているか注意します。
読者が各フォームが異なる2つの値を返すように試行し終れば、
edebugはそのように通知します。

   カバレッジテストは実行速度を遅くするので、
`edebug-test-coverage'が`nil'以外の場合にのみテストします。
すべての処置済み関数の実行に関する頻度数計測は、
非停止実行モードであってもカバレッジテストのオン／オフに関わらず行います。

   ある定義に関するカバレッジテストと頻度数計測を表示するには `M-x
edebug-display-freq-count'を使います。

 -- コマンド: edebug-display-freq-count
     このコマンドは、現在の定義の各行について頻度数データを表示する。

     頻度数は、コードの各行のあとにコメント行として表示され、
     コマンド`undo'でそれらのコメント行の挿入をアンドゥできる。
     頻度数は、式のまえの`('や式のうしろの`)'の直下、
     あるいは、変数の最後の文字に表示される。
     表示を簡素にするために、頻度数が同じ行のまえのほうの式の頻度数と同じであると
     表示しない。

     式の頻度数に続く文字`='は、
     その式を評価するたびに同じ値を返したことを意味する。
     いいかえれば、カバレッジテストとしては、
     その式はまだ『カバーして』いないことになる。

     ある定義に関する頻度数計測とカバレッジデータをクリアするには、
     `eval-defun'で単に再処置すればよい。

   たとえば、`edebug-test-coverage'を`t'とし、
ソース上のブレークポイントを設定して`(fac 5)'を評価すると、
ブレークポイントに達したときの頻度数データはつぎのようになります。

     (defun fac (n)
       (if (= n 0) (edebug))
     ;#6           1      0 =5
       (if (< 0 n)
     ;#5         =
           (* n (fac (1- n)))
     ;#    5               0
         1))
     ;#   0

   コメント行は、`fac'が6回呼ばれたことを表します。
最初の`if'文は、5回とも同じ結果を返したのです。
2番目の`if'についても同じです。
`fac'の再帰呼び出しは1度も戻っていません。


File: elisp-ja,  Node: The Outside Context,  Next: Instrumenting Macro Calls,  Prev: Coverage Testing,  Up: Edebug

17.2.14 外側の文脈
-----------------------

edebugは、読者がデバッグ中のプログラムに対しては透過であるように努めますが、
完全にうまくいくとは限りません。
また、`e'で読者が式を評価するときや評価リストバッファでも、
外側の文脈を一時的に復元して透過であるように努めます。
本節では、edebugが復元する文脈について正確に説明し、
edebugが透過にならない場合についても説明します。

* Menu:

* Checking Whether to Stop::	When Edebug decides what to do.
* Edebug Display Update::	When Edebug updates the display.
* Edebug Recursive Edit::	When Edebug stops execution.


File: elisp-ja,  Node: Checking Whether to Stop,  Next: Edebug Display Update,  Up: The Outside Context

17.2.14.1 停止すべきかどうかの検査
..............................................

edebugに入ると、トレース情報を作るのかプログラムを停止するのかを
決定するまえであってもある種のデータを保存／復元する必要が
つねにあります。

   * edebugがスタックに与える影響を軽減するために、
     `max-lisp-eval-depth'と`max-specpdl-size'を一度増加する。
     しかし、こうしてもedebugを使うときにスタックを使い切ってしまうことがある。

   * キーボードマクロの実行状態を保存し復元する。
     edebugが活性であると、`executing-macro'は
     `edebug-continue-kbd-macro'に束縛される。



File: elisp-ja,  Node: Edebug Display Update,  Next: Edebug Recursive Edit,  Prev: Checking Whether to Stop,  Up: The Outside Context

17.2.14.2 edebugの表示の更新
..................................

edebugが（トレースモードなどで）なにかを表示する必要があると、
edebugの『外側』の現在のウィンドウ構成を保存します （*note Window
Configurations::）。 （プログラムを続行して）edebugを抜けるときには、
以前のウィンドウ構成を復元します

   Emacsは休止するときにのみ表示を更新します。
通常、プログラムを続行しても、休止したり入力を読むことなく
ブレークポイントやステップ実行によりedebugへ戻ります。
そのような場合、Emacsには（edebugの）『外側』のようすを再表示する
機会が与えられません。
見かけ上、ウィンドウの表示は直前にedebugが活性であったときと同じになります。

なにかを表示するためにedebugに入っても以下のデータを保存／復元しますが、
エラーや中断が起こると、故意に復元しないものもあります。

   * カレントであるバッファと、そのバッファ内のポイントとマークは
     保存／復元される。

   * `edebug-save-windows'が`nil'以外ならば、
     外側でのウィンドウ構成を保存／復元する （*note Edebug Display
     Update::）。

     エラーや中断が起こるとウィンドウ構成は復元されない。
     しかし、`save-excursion'を使っていれば、 エラーや中断が起こっても、
     外側で選択していたウィンドウは選択_される_。
     `edebug-save-windows'の値がリストであると、
     リストに指定したウィンドウのみを保存／復元する。

     ソースコードバッファのウィンドウ開始位置やスクロールは復元しないが、
     これは、edebug内での表示が統一されるようにするためである。

   * `edebug-save-displayed-buffer-points'が`nil'以外であれば、
     表示されている各バッファのポイント位置の値を保存／復元する。

   * 変数`overlay-arrow-position'と`overlay-arrow-string'は、
     保存／復元される。
     そのため、同じバッファで再帰編集からedebugを起動しても安全である。

   * カーソルがウィンドウに表示されるように、
     `cursor-in-echo-area'は`nil'にローカルに束縛する。


File: elisp-ja,  Node: Edebug Recursive Edit,  Prev: Edebug Display Update,  Up: The Outside Context

17.2.14.3 edebugの再帰編集
...............................

edebugに入ってユーザーコマンドを読み取るとき、
以下のデータを保存し（のちに復元し）ます。

   * カレントマッチデータ。 *note Match Data::。

   * `last-command'、`this-command'、`last-command-char'、
     `last-input-char'、`last-input-event'、
     `last-command-event'、`last-event-frame'、
     `last-nonmenu-event'、`track-mouse'。
     edebug内で使ったコマンドは、edebugの外側でのこれらの変数には影響しない。

     `this-command-keys'が返すキー列は
     edebug内でコマンドを実行すると変更されてしまい、
     Lispからキー列を設定し直す方法はない。

     edebugは`unread-command-events'の値を保存／復元できない。
     この変数に変な値が入っているときにedebugに入ると、
     読者がデバッグするプログラムの実行に干渉することがある。

   * edebug内で実行された複雑なコマンドは
     変数`command-history'に追加される。
     これにより実行結果を変更することはほとんどない。

   * edebug内での再帰の深さは、edebugの外側での深さより1だけ深い。
     自動的に更新される評価リストウィンドウではそうではない。

   * `recursive-edit'は
     `standard-output'と`standard-input'を`nil'に束縛するが、
     edebugは評価中にはそれらを一時的に復元する。

   * キーボードマクロ定義の状態は保存／復元する。
     edebuが活性であると、`defining-kbd-macro'は
     `edebug-continue-kbd-macro'に束縛される。


File: elisp-ja,  Node: Instrumenting Macro Calls,  Next: Edebug Options,  Prev: The Outside Context,  Up: Edebug

17.2.15 マクロ呼び出しの処置
--------------------------------------

edebugがLispマクロを呼び出す式を処置するとき、
それを正しく行うにはマクロに関する余分な情報を必要とします。
マクロ呼び出しのどの部分式が評価されるフォームであるかを
明確に判定する方法がないからです。 （マクロ本体で明示的に評価されるか、
結果の展開形が評価されるときか、あるいは、さらにあと）

   したがって、edebugが出会う各マクロについて、
当該マクロの呼び出し形式を記述するedebug用仕様を定義する必要があります。
これには、`def-edebug-spec'を使います。

 -- マクロ: def-edebug-spec macro specification
     マクロMACROの呼び出しのどの式が評価されるかを指定する。
     単純なマクロでは、SPECIFICATIONは
     マクロ定義の仮引数リストに似ているが、
     その指定はマクロ引数よりも汎用性がある。

     引数MACROはマクロ名だけでなく任意のシンボルでよい。

   例題マクロ`for'（*note Argument Evaluation::）の
edebug用仕様の等価な定義例2つを示します。

     (def-edebug-spec for
       (symbolp "from" form "to" form "do" &rest form))

     (def-edebug-spec for
       (symbolp ['from form] ['to form] ['do body]))

   SPECIFICATIONに指定するものとその引数の処理方法は次表のとおりです。

`t'
     すべての引数を評価するように処置する。

`0'
     引数はいっさい処置しない。

シンボル
     edebug用仕様を持つシンボルをかわりに使う。
     この間接参照は別の種類の仕様を得るまで繰り返す。
     これにより、別のマクロから仕様を継承できる。

リスト
     リストの各要素は、呼び出しフォームの引数の型を記述する。
     仕様リストの各要素については次節で述べる。

* Menu:

* Specification List::		How to specify complex patterns of evaluation.
* Backtracking::		What Edebug does when matching fails.
* Specification Examples::	To help understand specifications.


File: elisp-ja,  Node: Specification List,  Next: Backtracking,  Up: Instrumenting Macro Calls

17.2.15.1 仕様リスト
.........................

マクロ呼び出しの引数のあるものは評価し別のものは評価しない場合には、
edebug用仕様に"仕様リスト"（specification list）が必要になります。
複数の引数に一致する仕様リストの要素もありますが、
後続の要素の処理を修飾する要素もあります。
後者は"仕様キーワード"（specification keyword）と呼ばれ、
（`&optional'のように）`&'で始まるシンボルです。

   仕様リストには、それ自体がリストである引数に一致する部分リストや
グループ化に使うベクトルを含んでもかまいません。
部分リストやグループは仕様リストを階層に分けます。
仕様キーワードはそれらを含む部分リストやグループの残りに適用されます。

   仕様リストに選択肢や繰り返しが含まれる場合、
実際のマクロ呼び出しに一致させるにはバックトラックが必要な場合もあります。
詳しくは*Note Backtracking::。

   edebug用仕様では、正規表現による一致と文脈自由文法の構文を使えます。
対応した括弧に囲まれた部分リスト、フォームの再帰的処理、
間接仕様による再帰です。

   仕様リストの要素に指定できるものとそれらの意味を以下に示します。

`sexp'
     処置しない評価しない1つのLispオブジェクト。

`form'
     処置した評価する1つの式。

`place'
     Common Lispの`setf'構文のように値を格納する場所。

`body'
     `&rest form'の省略形。 以下の`&rest'を参照。

`function-form'
     関数フォーム。 クォートした関数シンボル、クォートしたラムダ式、
     あるいは、（関数シンボルやラムダ式に評価される）フォーム。
     これは、ラムダ式である引数が、
     `function'ではなく`quote'でクォートされるときに有用である。
     というのは、ラムダ式の本体をいずれかの方法で処置するからである。

`lambda-expr'
     クォートしていないラムダ式。

`&optional'
     この仕様リスト内の後続の要素すべては省略可能。
     一致しないと、edebugはただちにこのレベルの一致を止める。

     数個の省略可能な要素に省略不可な要素を続けるには、 `[&optional
     SPECS...]'を使う。
     数個の要素がすべて一致するかまったく一致しないことを指定するには、
     `&optional [SPECS...]'を使う。 以下の`defun'の例を参照。

`&rest'
     この仕様リスト内の後続の要素すべてを0回以上繰り返す。
     最後の繰り返しでは、仕様リストの要素すべてに一致するまえに
     式を使い尽くしても問題にはならない。

     数個の要素のみを繰り返すには`[&rest SPECS...]'を使う。
     各繰り返しですべてが一致するような数個の要素を指定するには、
     `&rest [SPECS...]'を使う。

`&or'
     仕様リスト内の後続の各リストは選択肢を表す。
     選択肢の1つに一致しなければ、仕様`&or'は失敗。

     `&or'に続く各要素は1つの選択肢を表す。
     複数の要素を1つの選択肢としてグループにまとめるには、
     それらを`[...]'で囲む。

`&not'
     `&or'を使ったかように後続の要素を選択肢として一致させるが、
     どれかが一致すると仕様は失敗。
     どれにも一致しなければ、仕様`&not'は成功。

`&define'
     仕様は定義フォームに対するものであることを表す。
     定義フォームそのものは処置しない
     （つまり、edbugは定義フォームの前後で停止しない）が、
     この内側にあるフォームは典型的には処置される。
     キーワード`&define'はリスト仕様の最初の要素である必要がある。

`nil'
     現在の引数リストのレベルにおいて一致する引数がなければ成功する。
     さもなければ失敗。 部分リスト仕様と以下のバッククォートの例を参照。

`gate'
     いかなる引数とも一致しないが、このゲートを通ると、
     このレベルの仕様の残りの部分と一致を調べる際には
     バックトラックを禁止する。
     これは主により詳しい構文エラーメッセージを生成するために使う。
     詳しくは*note Backtracking::を参照。
     例については以下の`let'を参照。

`ÁÁĻÁÂÃÃÃ'
     仕様リストのその他のシンボルは述語であるか間接仕様である。

     シンボルにedebug用仕様があれば、
     この"間接仕様"は、シンボルのかわりに使われる仕様リストであるか、
     引数を処理するために呼び出される関数であること。
     仕様は、マクロ向けに`def-edebug-spec'で定義した仕様であってもよい。
     以下の`defun'の例を参照。

     さもなければ、シンボルは述語であること。
     述語は引数で呼び出され、述語が`nil'を返すと仕様は失敗する。
     いずれの場合でも、当該引数は処置されない。

     適当な述語には、`symbolp'、`integerp'、
     `stringp'、`vectorp'、`atom'がある。

`[ELEMENTS...]'
     要素のベクトルは要素群を単一の"グループ仕様"にまとめる。
     この意味はベクトルの意味とは関係ない。

`"STRING"'
     引数はSTRINGという名前のシンボルであること。
     この仕様は、SYMBOLの名前がSTRINGである
     クォートとしたシンボル`'SYMBOL'と等価であるが、
     文字列のほうが望ましい。

`(vector ELEMENTS...)'
     引数は、仕様内のELEMENTSに一致するものを要素とするベクトルであること。
     以下のバッククォートの例を参照。

`(ELEMENTS...)'
     その他のリストは"部分リスト仕様"であり、
     引数は仕様ELEMENTSに一致するものを要素とするリストであること。

     部分リスト仕様はドット対リストでもよく、その場合、
     対応するリスト引数はドット対リストである。
     あるいは、ドット対リスト仕様の最後のCDRは （`(spec .  [(more
     specs...)])'などの グループや間接仕様を介した）
     別の部分リスト仕様であってもよいが、
     それらの要素はドット対ではないリスト引数に一致する。
     これは、以下のバッククォートの例のような再帰仕様に有用である。
     このような再帰を終らせるうえの仕様`nil'も参照。

     `(specs .  nil)'や `(specs .
     (sublist-elements...))'のような部分リスト仕様は `(specs
     sublist-elements...)'と等価であることに注意。

   `&define'のうしろに追加できる仕様の一覧を以下に示します。
以下の`defun'の例を参照してください。

`name'
     引数はシンボルであり、定義フォームの名前である。

     定義フォームには単一の名前フィールドがある必要はなく、
     複数の名前フィールドを持っていてもよい。

`:name'
     この構造は引数には実際には一致しない。
     `:name'に続く要素はシンボルであること。
     定義に対する追加の名前要素として使う。
     定義の名前に一意で静的な要素を追加するために使う。
     複数あってもよい。

`arg'
     引数はシンボルであり、定義フォームの引数の名前である。
     しかし、ラムダリストキーワード（`&'で始まるシンボル）は許されない。

`lambda-list'
     ラムダリスト、すなわち、ラムダ式の引数リストに一致する。

`def-body'
     引数は、定義内のコード本体である。
     これは、上に述べた`body'に似ているが、
     定義本体は定義に関連した情報を調べる異なるedebug呼び出しで処置する必要がある。
     定義内のフォームの最上位レベルのリストには`def-body'を使う。

`def-form'
     引数は、定義内の単一の最上位レベルのフォームである。
     これは`def-body'に似ているが、
     フォームのリストではなく単一のフォームに一致するものに使う。
     特別な場合として、`def-form'は
     フォームを実行したときにトレース情報を出力しないことを意味する。
     以下の`interactive'の例を参照。


File: elisp-ja,  Node: Backtracking,  Next: Specification Examples,  Prev: Specification List,  Up: Instrumenting Macro Calls

17.2.15.2 仕様内でのバックトラック
..............................................

仕様の一致がある箇所で失敗しても、
必ずしも構文エラーが通知されるとは限りません。
そのかわりに、選択肢すべてを試し尽くすまで"バックトラック"します。
最終的に、引数リストの各要素は仕様内のいずれかの要素に一致する必要があり、
仕様内の各必須要素はいずれかの引数に一致する必要があります。

構文エラーを検出しても、より高いレベルの選択肢を使い切るまでは報告されず、
実際のエラー箇所から離れた箇所にポイントが置かれます。
しかし、エラー発生時にバックトラックが禁止されていれば、
ただちにエラーが報告されます。
さまざまな状況でバックトラックが自動的に再許可されることに注意してください。
`&optional'や`&rest'や`&or'で新たに選択肢が指定されたり、
部分リストやグループや間接仕様を処理し始めると、
自動的に再許可されます。 バックトラックの許可／禁止の効果は、
現在処理しているレベルやそれより低いレベルに限定されます。

   任意のフォーム仕様（つまり、`form'、`body'、`def-form'、
`def-body'）の一致処理中には、バックトラックを禁止します。
これらの仕様は任意のフォームに一致するので、
エラーはより上のレベルではなくフォーム自身にあるはずです。

   また、クォートしたシンボルや文字列の仕様に一致すると
バックトラックを禁止します。
というのは、通常、これは構造を認識したことを意味するからです。
しかし、すべてが同一シンボルで始まる選択肢を指定する場合には、 `["foo"
&or [first case] [second case] ...]'のように、
そのシンボルを選択肢から括り出せばバックトラックするようにできます。

多くの場合では、バックトラックを自動的に禁止するこれらの2つの方法で十分ですが、
仕様`gate'を使ってバックトラックを明示的に禁止すると有用な場合もあります。
上位の選択肢が適用できないとわかっている場合に有用です。
仕様`let'の例を参照してください。


File: elisp-ja,  Node: Specification Examples,  Prev: Backtracking,  Up: Instrumenting Macro Calls

17.2.15.3 仕様の例
......................

以下の例を参考にするとedebug用仕様を理解しやすいでしょう。

   スペシャルフォーム`let'には束縛と本体の並びがあります。
各束縛は、シンボル、あるいは、シンボルと省略可能な式から成る部分リストです。
以下のedebug用仕様では、部分リストの内側にある`gate'で、
部分リストを一度みつけるとバックトラックを禁止していることに
注意してください。

     (def-edebug-spec let
       ((&rest
         &or symbolp (gate symbolp &optional form))
        body))

   edebugは、`defun'と`defmacro'、
および、対応する引数リストと仕様`interactive'に対しては、
以下のedebug用仕様を使います。
式の引数は実際には関数本体の外側で評価されるので、
対話宣言フォームを特別扱いする必要があります。

     (def-edebug-spec defmacro defun) ; 仕様`defun'の間接参照
     (def-edebug-spec defun
       (&define name lambda-list
                [&optional stringp]   ; あれば、説明文字列に一致する
                [&optional ("interactive" interactive)]
                def-body))

     (def-edebug-spec lambda-list
       (([&rest arg]
         [&optional ["&optional" arg &rest arg]]
         &optional ["&rest" arg]
         )))

     (def-edebug-spec interactive
       (&optional &or stringp def-form))    ; `def-form'を参照

   以下のバッククォートに対する仕様は、
ドット対リストの一致の仕方と再帰を終らせる`nil'の使い方を示します。
また、ベクトルの要素の一致の仕方も示します。
（edebugが実際に定義している仕様では、
失敗の可能性がある非常に深い再帰をもたらすためドット対リストを扱わない。）

     (def-edebug-spec ` (backquote-form))   ; わかりやすいように別名を付ける

     (def-edebug-spec backquote-form
       (&or ([&or "," ",@"] &or ("quote" backquote-form) form)
            (backquote-form . [&or nil backquote-form])
            (vector &rest backquote-form)
            sexp))


File: elisp-ja,  Node: Edebug Options,  Prev: Instrumenting Macro Calls,  Up: Edebug

17.2.16 edebugのオプション
--------------------------------

以下のオプションはedebugの動作に影響します。

 -- User Option: edebug-setup-hook
     edebugを使うまえに呼び出す関数群。
     新たな値に設定されるたびに、edebugはこれらの関数を呼び出し、
     そのあとで`edebug-setup-hook'を`nil'に再設定する。
     これを用いて、edebugを使用する場合にのみ、
     使用するパッケージに対応するedebug用仕様をロードできる。 *note
     Instrumenting::。

 -- User Option: edebug-all-defs
     これが`nil'以外であると、
     `defun'や`defmacro'のような定義フォームを普通に評価すると、
     edebug用にそれらを処置する。
     これは、`eval-defun'、`eval-region'、`eval-buffer'、
     `eval-current-buffer'にも適用される。

     このオプションの値をトグルするにはコマンド`M-x
     edebug-all-defs'を使う。 *note Instrumenting::。

 -- User Option: edebug-all-forms
     これがcodenil以外であると、コマンド`eval-defun'、
     `eval-region'、`eval-buffer'、`eval-current-buffer'は、
     定義しないフォームの場合であってもすべてのフォームを処置する。
     これは、ロードやミニバッファでの評価には適用されない。

     このオプションの値をトグルするにはコマンド`M-x
     edebug-all-forms'を使う。 *note Instrumenting::。

 -- User Option: edebug-save-windows
     これが`nil'以外であると、edebugはウィンドウ構成を保存／復元する。
     これには時間がかかるので、読者のプログラムがウィンドウ構成に
     依存しないのならば、この変数は`nil'に設定しておくほうがよい。

     値がリストであると、リスト内のウィンドウのみを保存／復元する。

     edebugのコマンド`W'を使ってこの変数を対話的に変更できる。 *note
     Edebug Display Update::。

 -- User Option: edebug-save-displayed-buffer-points
     これが`nil'以外であると、edebugは表示されているすべてのバッファの
     ポイントを保存／復元する。

     選択していないウィンドウに表示されたバッファのポイントを変更する
     コードをデバッグ中には、別のバッファのポイントを保存／復元する必要がある。
     edebugやユーザーが当該ウィンドウを選択すると、
     そのバッファのポイントはウィンドウのポイント位置に移動する。

     すべてのバッファでポイントを保存／復元するには
     各ウィンドウを2度選択する必要があるため手間がかかる。
     そのため、必要な場合にのみこの機能を有効にする。 *note Edebug
     Display Update::。

 -- User Option: edebug-initial-mode
     この変数が`nil'以外であれば、
     edebugが初めて動作するときの初期の動作モードを指定する。
     可能な値は、 `step'、`next'、`go'、`Go-nonstop', `trace'、
     `Trace-fast'、`continue'、`Continue-fast'。

     デフォルト値は`step'。 *note Edebug Execution Modes::。

 -- User Option: edebug-trace
     `nil'以外であると、関数へ入るときと出るときのトレースを表示することを
     意味する。 トレース出力は、`*edebug-trace*'という名前のバッファに、
     関数へ入るときと出るときを各行に再帰の深さで字下げして表示する。

     デフォルト値は`nil'。

     *note Trace Buffer::の`edebug-tracing'も参照。

 -- User Option: edebug-test-coverage
     `nil'以外であれば、edebugはデバッグ対象のすべての式のカバレッジ
     テストを行う。 *note Coverage Testing::。

 -- User Option: edebug-continue-kbd-macro
     `nil'以外であれば、
     edebugの外側で実行するキーボードマクロを定義したり実行する。
     デバッグしないので注意してこのオプションを使うこと。

 -- User Option: edebug-on-error
     `debug-on-error'の以前の値が`nil'であると、
     edebugは`debug-on-error'にこの値を束縛する。 *note Trapping
     Errors::。

 -- User Option: edebug-on-quit
     `debug-on-quit'の以前の値が`nil'であると、
     edebugは`debug-on-quit'にこの値を束縛する。 *note Trapping
     Errors::。

   edebugが動作中に`edebug-on-error'や`edebug-on-quit'の値を
変更しても、新たなコマンドでedebugを_つぎに_起動するまでは
これらの値は使用されない。

 -- User Option: edebug-global-break-condition
     `nil'以外であると、各停止位置で検査される式である。
     結果が`nil'以外であるとブレークする。 エラーは無視する。 *note
     Global Break Condition::。


File: elisp-ja,  Node: Syntax Errors,  Next: Compilation Errors,  Prev: Edebug,  Up: Debugging

17.3 不正なLisp構文のデバッグ
=======================================

Lispリーダは不正な構文を報告しますが、どこに問題があるかは報告できません。
たとえば、式を評価中のエラー『End of file during parsing』
（構文解析中にファイルの終り）は、開き括弧（あるいは開き角括弧）が
多すぎることを表します。
Lispリーダは括弧が対応していないことをファイルの末尾で検出しますが、
どこに閉じ括弧があるべきかは判断できません。 同様に、『Invalid read
syntax: ")"』（不正な構文：")"）は
閉じ括弧が多すぎるか開き括弧が足りないことを表しますが、
どこに括弧が足りないかは判断できません。
それでは、どこを変更すべきかどのように調べるのでしょう？

   問題が単純な括弧の非対応でなければ、
各関数定義の先頭で`C-M-e'を試し、
関数定義の末尾に移動するかどうかをみるのは有用な技法です。
正しく移動しなければ、その関数に問題があります。

   Lispによくある構文エラーは括弧の非対応なので、
これらの場面について詳しい助言を述べておきます。
（さらに、対応括弧表示モードをオンにしてポイントを移動すると非対応を
探しやすい。）

* Menu:

* Excess Open::     How to find a spurious open paren or missing close.
* Excess Close::    How to find a spurious close paren or missing open.


File: elisp-ja,  Node: Excess Open,  Next: Excess Close,  Up: Syntax Errors

17.3.1 開き括弧の過剰
----------------------------

最初の手順は、括弧が対応していない関数定義を探すことです。
開き括弧が過剰であれば、ファイルの末尾に閉じ括弧を挿入し
`C-M-b'（`backward-sexp'）を打ちます。
こうすると、括弧が対応していない関数定義の先頭へ移動します。
（そうしたら、`C-<SPC> C-_ C-u C-<SPC>'と打って、
当該箇所にマークを設定してから閉じ括弧の挿入を取り消し、
最終的にマークへ戻る。）

   つぎの手順は、なにが悪いか正確に判断することです。
プログラムを調べる以外にこれを確実に行う方法はありませんが、
しばしば、既存の字下げが括弧のありかたを予想する鍵になります。
これを利用するもっとも簡単な方法は`C-M-q'で字下げし直し、
どのようになるか見ることです。 *まだやらないでください！*` '
まず読み進んてください。

これを行うまえに、関数定義に充分な数の閉じ括弧があることを確認してください。
さもないと、`C-M-q'がエラーになったり、
ファイルの末尾までを字下げし直してしまいます。
ですから、関数定義の末尾へ移動して閉じ括弧を挿入しておきます。
`C-M-e'を使って移動しないでください。
というのは、関数定義の括弧の対応が取れていないと失敗するからです。

   関数定義の先頭へ移動して`C-M-q'を打ちます。
通常、ある場所から関数の末尾までの行が右へずれます。
その場所の近くで、閉じ括弧が足りなかったり開き括弧が多すぎるのです。
（しかし、これが正しいと仮定してはならない。
コードを調べて確認すること。） 不具合箇所がみつかったならば、
意図した括弧に対しては古い字下げが適しているでしょうから
`C-_'で`C-M-q'をアンドゥします。

   問題を解決できたと思ったら、再度`C-M-q'を使います。
古い字下げが意図した括弧の入れ子に対応していて、
必要な括弧を挿入できているならば、 `C-M-q'はなにも変えないはずです。


File: elisp-ja,  Node: Excess Close,  Prev: Excess Open,  Up: Syntax Errors

17.3.2 閉じ括弧の過剰
----------------------------

過剰な閉じ括弧に対処するには、まず、ファイルの先頭に開き括弧を挿入し、
その括弧のまえで`C-M-f'を打って、
括弧が対応していない関数定義の末尾を探します。 （そして、`C-<SPC> C-_
C-u C-<SPC>'と打って、
当該箇所にマークを設定して開き括弧の挿入をアンドゥし、
最終的にマークへ戻る。）

   その関数定義の先頭で`C-M-f'と打って、
実際に対応している閉じ括弧を探します。
これにより、関数定義が終るべき場所より手前の箇所に移動するはずです。
この付近に余分な閉じ括弧がみつかることもあるでしょう。

   その場所に問題がなければ、つぎにすべきことは、
関数定義の先頭で`C-M-q'と打つことです。
ある範囲の行が左にずれるでしょう。
もしそうならば、開き括弧が足りないか余分な閉じ括弧は、
そのような行の先頭付近にあるでしょう。
（しかし、これが正しいと仮定してはならない。
コードを調べて確認すること。） 不具合箇所がみつかったならば、
意図した括弧に対しては古い字下げが適しているでしょうから
`C-_'で`C-M-q'をアンドゥします。

   問題を解決できたと思ったら、再度`C-M-q'を使います。
古い字下げが意図した括弧の入れ子に対応していて、
必要な括弧を挿入できているならば、 `C-M-q'はなにも変えないはずです。


File: elisp-ja,  Node: Compilation Errors,  Prev: Syntax Errors,  Up: Debugging

17.4 コンパイル時の問題のデバッグ
===============================================

バイトコンパイル時にエラーが発生したときは、
通常、読者がコンパイルしているプログラムの不正な構文に原因があります。
コンパイラはバッファ`*Compile-Log*'に適切なエラーメッセージを
表示してから停止します。
メッセージにはエラーとなった関数の名前があったりなかったりします。
いずれにしても、つぎのようにしてファイルのどこでエラーが生じたかを調べます。

   まず、バッファ` *Compiler Input*'に切り替えます。
（バッファ名が空白で始まり、そのため、 `M-x
list-buffers'では表示されないことに注意。）
このバッファにはコンパイルしたプログラムが入っていて、
ポイント位置はバイトコンパイラがどこまで読み取ったかを表します。

   エラーの原因が不正なLisp構文であるならば、
ポイント位置が不正構文を_検出した_箇所を正確に表します。
エラー原因が近くにあるとは限りません！` '
エラーを探すために前節の方法を使ってください。

   正しく読み取ったフォームのコンパイル中にエラーを検出したときには、
ポイントはそのフォームの末尾に位置しています。
この場合、この方法ではエラー箇所を正確に判別できませんが、
どの関数を確認すべきかを示しています。


File: elisp-ja,  Node: Read and Print,  Next: Minibuffers,  Prev: Debugging,  Up: Top

18 Lispオブジェクトの読み取りと表示
*************************************************

"表示"（printing）とは
Lispオブジェクトをテキスト表現へ変換する操作であり、
"読み取り"（reading）は逆の変換操作です。 これには、*note Lisp Data
Types::で述べた表示表現と入力構文を用います。

   本章では、読み取りや表示を行うLisp関数について述べます。
また、（読み取るときに）テキストをどこから得たり、
（表示するときに）どこへ出すかを指定する
"ストリーム"（stream）についても述べます。

* Menu:

* Streams Intro::     Overview of streams, reading and printing.
* Input Streams::     Various data types that can be used as input streams.
* Input Functions::   Functions to read Lisp objects from text.
* Output Streams::    Various data types that can be used as output streams.
* Output Functions::  Functions to print Lisp objects as text.
* Output Variables::  Variables that control what the printing functions do.


File: elisp-ja,  Node: Streams Intro,  Next: Input Streams,  Up: Read and Print

18.1 読み取りと表示の概要
===================================

Lispオブジェクトの"読み取り"とは、
テキスト表現のLisp式を解析して対応するLispオブジェクトを生成することを
意味します。
これにより、プログラムはLispコードのファイルからLispへ取り込まれます。
テキストをオブジェクトの"入力構文"（read syntax）と呼びます。
たとえば、テキスト`(a . 5)'は、
CARが`a'でありCDRが数5であるコンスセルの入力構文です。

   Lispオブジェクトの"表示"とは、
オブジェクトを表現するテキストを生成することを意味します。
つまり、オブジェクトをその"表示表現" （*note Printed
Representation::）に変換します。
上に述べたコンスセルを表示するとテキスト`(a . 5)'を生成します。

   読み取りと表示は、多かれ少なかれ、逆操作です。
与えられたテキスト断片を読み取ることで得られたオブジェクトを表示すると、
しばしば、同じテキストを生成します。
オブジェクトを表示することによって得られたテキストを読み取ると、
通常、似たようなオブジェクトを生成します。
たとえば、シンボル`foo'を表示するとテキスト`foo'を生成し、
そのテキストを読み取るとシンボル`foo'が返されます。
要素が`a'と`b'であるリストを表示すると テキスト`(a b)'を生成し、
そのテキストを読み取ると
要素が`a'と`b'である（もとと同じではないが）リストを生成します。

   しかし、これら2つの操作は厳密には逆操作ではありません。
3種類の例外があります。

   * 表示では、読み取れないテキストを生成することがある。
     たとえば、バッファ、ウィンドウ、フレーム、サブプロセス、マーカは、
     `#'で始まるテキストとして表示されるが、
     これを読み取ろうとするとエラーになる。
     これらのデータ型を読み取る方法は存在しない。

   * 1つのオブジェクトには複数のテキスト表現がありえる。
     たとえば、`1'と`01'は同じ整数を表し、 `(a b)'と`(a .
     (b))'は同じリストを表す。 読み取りではいずれの表現も受け付けるが、
     表示では1つの表現を選ぶ。

   * オブジェクトを読み取る途中にコメントが現れてもよく、
     しかも読み取り結果にはまったく影響しない。


File: elisp-ja,  Node: Input Streams,  Next: Input Functions,  Prev: Streams Intro,  Up: Read and Print

18.2 入力ストリーム
==========================

テキストを読み取るほとんどのLisp関数は、
"ストリーム"（stream）を引数として受け付けます。
入力ストリームは、読み取るべきテキストの文字をどこからどのように得るのかを
指定します。 入力ストリームとして使える型は以下のとおりです。

BUFFER
     入力文字はバッファBUFFERのポイント直後の文字から読み取られる。
     1文字読むごとにポイントを進める。

MARKER
     入力文字は、マーカMARKERがあるバッファの
     マーカ直後の文字から読み取られる。
     1文字読むごとにマーカ位置を進める。
     ストリームがマーカであるときには、バッファのポイント位置は影響しない。

STRING
     入力文字は文字列STRINGの先頭文字から必要な文字数だけ読み取られる。

FUNCTION
     入力文字は関数FUNCTIONが生成する。
     この関数は2種類の呼び出し方を扱える必要がある。

        * 引数なしで呼ばれると、つぎの文字を返す。

        * 1つの（つねに文字である）引数で呼ばれると、
          FUNCTIONは引数を保存し、
          つぎに呼ばれたときにそれを返すように準備する。
          これを文字の"読み戻し"（unreading）と呼ぶ。
          これは、Lispリーダが1文字多く読みすぎたので『読み取った場所へ戻し』たいときに
          発生する。 このとき、FUNCTIONが返す値はなんでもよい。

`t'
     ストリームとして`t'を使うと、ミニバッファから読み取ることを意味する。
     実際には、ミニバッファを表示しユーザーが指定したテキストから成る文字列を作り、
     それを入力ストリームとして使う。

`nil'
     入力ストリームとして`nil'を指定すると、
     `standard-input'の値をかわりに使うことを意味する。
     その値は"デフォルト入力ストリーム"であり、
     `nil'以外の入力ストリームであること。

SYMBOL
     入力ストリームとしてのシンボルは、
     そのシンボルの（あれば）関数定義と等価である。

   バッファであるストリームからの読み取りの例を
読み取り前後のポイント位置を含めて示します。

     ---------- Buffer: foo ----------
     This-!- is the contents of foo.
     ---------- Buffer: foo ----------

     (read (get-buffer "foo"))
          => is
     (read (get-buffer "foo"))
          => the

     ---------- Buffer: foo ----------
     This is the-!- contents of foo.
     ---------- Buffer: foo ----------

最初の読み取りでは空白を読み飛ばしていることに注意してください。
読み取りでは、意味あるテキストのまえにある白文字はいくつでも読み飛ばします。

   つぎは、マーカをストリームとして読み取る例です。
マーカの初期位置は下に示したバッファの先頭にあります。
読み取った値はシンボル`This'です。


     ---------- Buffer: foo ----------
     This is the contents of foo.
     ---------- Buffer: foo ----------

     (setq m (set-marker (make-marker) 1 (get-buffer "foo")))
          => #<marker at 1 in foo>
     (read m)
          => This
     m
          => #<marker at 5 in foo>   ;; 最初の空白の直前

   つぎは文字列の内容から読み取ります。

     (read "(When in) the course")
          => (When in)

   以下の例は、ミニバッファから読み取ります。
プロンプトは`Lisp expression: 'です。
（ストリーム`t'から読むとつねにこのプロンプトが使われる。）
ユーザーの入力はプロンプトに続けて示してあります。

     (read t)
          => 23
     ---------- Buffer: Minibuffer ----------
     Lisp expression: 23 <RET>
     ---------- Buffer: Minibuffer ----------

   最後は、`useless-stream'という名前の関数をストリームにした例です。
このストリームを使うまえに、
変数`useless-list'を文字のリストで初期化します。
そうすると、関数`useless-stream'を呼び出すたびに
リスト内のつぎの文字を返すか、
リストの先頭に追加して文字を読み戻します。

     (setq useless-list (append "XY()" nil))
          => (88 89 40 41)

     (defun useless-stream (&optional unread)
       (if unread
           (setq useless-list (cons unread useless-list))
         (prog1 (car useless-list)
                (setq useless-list (cdr useless-list)))))
          => useless-stream

つぎのようにしてストリームを使って読み取ります。

     (read 'useless-stream)
          => XY

     useless-list
          => (40 41)

リストには開き括弧と閉じ括弧が残っていることに注意してください。
Lispリーダが開き括弧に出会うとこれで入力を終えると決定し、
それを読み戻すのです。 この時点で読み取りを試みると、
`()'を読み取って`nil'を返します。

 -- Function: get-file-char
     この関数は、関数`load'で開いた入力ファイルから読み取るための
     入力ストリームとして内部的に使われる。
     読者はこの関数を使ってはならない。


File: elisp-ja,  Node: Input Functions,  Next: Output Streams,  Prev: Input Streams,  Up: Read and Print

18.3 入力関数
=================

本節では読み取りに関係するLisp関数や変数について述べます。

   以下の関数では、STREAMは入力ストリーム（前節参照）を表します。
STREAMが`nil'であったり省略すると、
`standard-input'の値をデフォルトにします。

   読み取り中に閉じていないリストやベクトル、文字列に出会うと、
エラー`end-of-file'を通知します。

 -- Function: read &optional stream
     この関数はSTREAMから1つのLisp式のテキスト表現を読み取り、
     それをLispオブジェクトとして返す。
     これは基本的なLisp入力関数である。

 -- Function: read-from-string string &optional start end
     この関数はSTRINGのテキストから先頭のLisp式のテキスト表現を読み取る。
     読み取った式をCAR、文字列に残っているつぎの文字
     （つまり読み取っていない最初の文字）の位置を表す整数をCDR
     とするコンスセルを返す。

     STARTが指定してあると、文字列のSTARTで添字付け
     （先頭文字の添字は0）されるところから読み始める。
     ENDを指定すると、その添字位置の直前で読み取りを終らせ、
     文字列には残りの文字がないかのように扱う。

     例：

          (read-from-string "(setq x 55) (setq y 5)")
               => ((setq x 55) . 11)
          (read-from-string "\"A short string\"")
               => ("A short string" . 16)

          ;; 最初の文字から読み始める
          (read-from-string "(list 112)" 0)
               => ((list 112) . 10)
          ;; 2番目の文字から読み始める
          (read-from-string "(list 112)" 1)
               => (list . 5)
          ;; 7番目の文字から読み始め、9番目の文字で読み終える
          (read-from-string "(list 112)" 6 8)
               => (11 . 8)

 -- Variable: standard-input
     この変数はデフォルトの入力ストリーム、
     つまり、引数STREAMが`nil'である場合に`read'が使う
     ストリームを保持する。


File: elisp-ja,  Node: Output Streams,  Next: Output Functions,  Prev: Input Functions,  Up: Read and Print

18.4 出力ストリーム
==========================

出力ストリームは表示で生成した文字群をどのように扱うかを指定します。
ほとんどの表示関数は省略可能な引数として出力ストリームを受け付けます。
出力ストリームとして使える型は以下のとおりです。

BUFFER
     出力文字はバッファBUFFERのポイント位置に挿入される。
     文字が挿入されるたびにポイント位置は進められる。

MARKER
     出力文字はマーカMARKERがあるバッファのマーカ位置に挿入される。
     文字を挿入するたびにマーカ位置は進められる。
     ストリームがマーカであるときには、バッファのポイント位置は影響せず、
     この種の表示ではポイントを移動しない。

FUNCTION
     出力文字は関数FUNCTIONに渡され、この関数が文字の保存に責任を持つ。
     1つの文字を引数として出力する文字数の回数だけ呼び出され、
     読者の望む場所に文字を保存する責任を持つ。

`t'
     出力文字はエコー領域に表示される。

`nil'
     出力ストリームとして`nil'を指定すると、
     `standard-output'の値をかわりに使うことを意味する。
     その値は"デフォルト出力ストリーム"であり、 `nil'以外であること。

SYMBOL
     出力ストリームとしてのシンボルは、
     そのシンボルの（あれば）関数定義と等価である。

   正当な出力ストリームの多くは、入力ストリームとしても正当です。
入力ストリームと出力ストリームの違いは、
オブジェクト型の違いというよりは、
読者がLispオブジェクトをどのように使うかです。

   バッファを出力ストリームとして使った例を示します。
ポイントの初期位置は以下に示すように`the'の`h'の直前にあります。
終了後でも、ポイントは同じ`h'の直前に位置しています。

     ---------- Buffer: foo ----------
     This is t-!-he contents of foo.
     ---------- Buffer: foo ----------

     (print "This is the output" (get-buffer "foo"))
          => "This is the output"

     ---------- Buffer: foo ----------
     This is t
     "This is the output"
     -!-he contents of foo.
     ---------- Buffer: foo ----------

   つぎは、マーカを出力ストリームとして用いた例です。
バッファ`foo'のマーカの初期位置は、
単語`the'の`t'と`h'のあいだにあります。
終了後には、マーカは挿入したテキストを越えて同じ`h'の直前に位置します。
ポイント位置はなんの影響もないことに注意してください。

     ---------- Buffer: foo ----------
     This is the -!-output
     ---------- Buffer: foo ----------

     (setq m (copy-marker 10))
          => #<marker at 10 in foo>

     (print "More output for foo." m)
          => "More output for foo."

     ---------- Buffer: foo ----------
     This is t
     "More output for foo."
     he -!-output
     ---------- Buffer: foo ----------

     m
          => #<marker at 34 in foo>

   つぎは、エコー領域への出力の例です。

     (print "Echo Area output" t)
          => "Echo Area output"
     ---------- Echo Area ----------
     "Echo Area output"
     ---------- Echo Area ----------

   最後は、関数を出力ストリームとして使った例を示します。
関数`eat-output'は与えられた文字を受け取り、
それをリスト`last-output'の先頭にコンスします （*note Building
Lists::）。
終了後には、リストがすべての出力文字を保持していますが逆順です。

     (setq last-output nil)
          => nil

     (defun eat-output (c)
       (setq last-output (cons c last-output)))
          => eat-output

     (print "This is the output" 'eat-output)
          => "This is the output"

     last-output
          => (10 34 116 117 112 116 117 111 32 101 104
         116 32 115 105 32 115 105 104 84 34 10)

リストの順番を逆にすれば正しい順序の出力になります。

     (concat (nreverse last-output))
          => "
     \"This is the output\"
     "

`concat'を呼び出してリストを文字列に変換し、
内容を読みやすいようにしました。


File: elisp-ja,  Node: Output Functions,  Next: Output Variables,  Prev: Output Streams,  Up: Read and Print

18.5 出力関数
=================

本節ではLispオブジェクトを表示する、
つまり、オブジェクトを表示表現に変換するLisp関数について述べます。

   Emacsの表示関数のなかには、正しく読み取れるように
クォート文字を出力に追加するものがあります。
使用されるクォート文字は`"'と`\'です。
これらは、文字列とシンボルを区別したり、
文字列やシンボル内の句読点文字を読み取るときに区切り文字として扱うこと
を防ぎます。 詳しくは*Note Printed Representation::。
出力関数を選べば、クォートのありなしを指定できます。

   テキストをLispシステムへ読み取る意図がある場合には、
曖昧さを避けるためにクォート文字付きで表示するべきです。
Lispプログラマに対してLispオブジェクトを明確に記述する場合も同様です。
しかし、人間向けの見やすい出力が目的であれば、
クォートせずに表示するのが普通はよいでしょう。

   Lispオブジェクトはそれ自身を参照できます。
自己参照しているオブジェクトを普通の方法で表示するには
無限のテキストが必要であり、 そのような試みは無限再帰をもたらします。
Emacsはそのような再帰を検出し、
すでに表示したオブジェクトを再帰的に表示するかわりに
`#LEVEL'を表示します。
たとえば、`#0'は、現在の表示操作においてレベル0のオブジェクトを
再帰的に参照することを示します。

     (setq foo (list nil))
          => (nil)
     (setcar foo foo)
          => (#0)

   以下の関数では、STREAMは出力ストリームを表します。
（出力ストリームについては前節を参照。）
STREAMが`nil'であったり省略すると、
`standard-output'の値をデフォルトにします。

 -- Function: print object &optional stream
     関数`print'は便利な表示方法である。 オブジェクトOBJECTの表示表現を
     ストリームSTREAMに出力し、 OBJECTの前後に改行を1つずつ表示する。
     クォート文字を使う。 `print'はOBJECTを返す。 たとえばつぎのとおり。

          (progn (print 'The\ cat\ in)
                 (print "the hat")
                 (print " came back"))
               -|
               -| The\ cat\ in
               -|
               -| "the hat"
               -|
               -| " came back"
               -|
               => " came back"

 -- Function: prin1 object &optional stream
     この関数はオブジェクトOBJECTの表示表現を
     ストリームSTREAMに出力する。
     `print'のようには出力を区切る改行を表示しないが、
     `print'と同様にクォート文字を用いる。 OBJECTを返す。

          (progn (prin1 'The\ cat\ in)
                 (prin1 "the hat")
                 (prin1 " came back"))
               -| The\ cat\ in"the hat"" came back"
               => " came back"

 -- Function: princ object &optional stream
     この関数はオブジェクトOBJECTの表示表現を
     ストリームSTREAMに出力する。 OBJECTを返す。

     この関数は、`read'ではなく人が読みやすい出力を意図しており、
     クォート文字を挿入せず、文字列を囲むダブルクォートも出力しない。
     空白も追加しない。

          (progn
            (princ 'The\ cat)
            (princ " in the \"hat\""))
               -| The cat in the "hat"
               => " in the \"hat\""

 -- Function: terpri &optional stream
     この関数はストリームSTREAMに改行を出力する。 関数名は『terminate
     print』の略。

 -- Function: write-char character &optional stream
     この関数は文字CHARACTERをストリームSTREAMへ出力する。
     CHARACTERを返す。

 -- Function: prin1-to-string object &optional noescape
     この関数は同じ引数に対して`prin1'が表示するであろう
     テキストから成る文字列を返す。

          (prin1-to-string 'foo)
               => "foo"
          (prin1-to-string (mark-marker))
               => "#<marker at 2773 in strings.texi>"

     NOESCAPEが`nil'以外であると、 出力にはクォート文字を使わない。
     （この引数は、Emacs 19版以降で使える。）

          (prin1-to-string "foo")
               => "\"foo\""
          (prin1-to-string "foo" t)
               => "foo"

     文字列としてのLispオブジェクトの表示表現を得るための別の方法については、
     *note String Conversion::の`format'を参照。

 -- Macro: with-output-to-string body...
     このマクロは、`standard-output'を文字列への出力と設定して
     フォームBODYを実行する。 そして、その文字列を返す。

     たとえば、カレントバッファの名前が`foo'であると

          (with-output-to-string
            (princ "The buffer is ")
            (princ (buffer-name)))

     は`"The buffer is foo"'を返す。


File: elisp-ja,  Node: Output Variables,  Prev: Output Functions,  Up: Read and Print

18.6 出力に影響する変数
================================

 -- Variable: standard-output
     この変数の値はデフォルトの出力ストリーム、つまり、
     引数STREAMが`nil'の場合に表示関数が用いるストリーム。

 -- Variable: print-escape-newlines
     この変数が`nil'以外であると、
     文字列内の改行文字を`\n'、ページ送り文字を`\f'と表示する。
     通常、これらの文字は実際の改行やページ送りとして表示される。

     この変数は、クォート付きで表示する表示関数`prin1'や
     `print'に影響を与える。 `princ'には影響しない。
     `prin1'を用いた例を示す。

          (prin1 "a\nb")
               -| "a
               -| b"
               => "a
          b"

          (let ((print-escape-newlines t))
            (prin1 "a\nb"))
               -| "a\nb"
               => "a
          b"

     2番目の式では、`prin1'の呼び出し中には
     `print-escape-newlines'のローカル束縛が有効であるが、
     結果を表示するときには有効ではない。

 -- Variable: print-escape-nonascii
     この変数が`nil'以外であると、
     クォート付きで表示する出力関数`prin1'や`print'は、
     文字列内のユニバイト非ASCII文字を無条件で
     バックスラッシュ列として表示する。

     これらの関数は、出力ストリームがマルチバイトバッファや
     マルチバイトバッファのマーク位置であると、
     この変数の値に関係なくユニバイト非ASCII文字に対して
     バックスラッシュ列を用いる。

 -- Variable: print-escape-multibyte
     この変数が`nil'以外であると、
     クォート付きで表示する表示関数`prin1'や`print'は、
     文字列内のマルチバイト非ASCII文字を無条件で
     バックスラッシュ列として表示する。

     これらの関数は、出力ストリームがユニバイトバッファや
     ユニバイトバッファのマーク位置であると、
     この変数の値に関係なくマルチバイト非ASCII文字に対して
     バックスラッシュ列を用いる。

 -- Variable: print-length
     この変数の値は、任意のリスト、ベクトル、ブールベクトルを表示するときの
     最大要素数である。
     表示するオブジェクトがこれより多くの要素を持つと、
     「…」で省略する。

     値が`nil'（デフォルト）であると無制限。

          (setq print-length 2)
               => 2
          (print '(1 2 3 4 5))
               -| (1 2 ...)
               => (1 2 ...)

 -- Variable: print-level
     この変数の値は、表示するときの括弧や角括弧の入れ子の最大の深さ。
     この制限を越える任意のリストやベクトルは「…」で省略する。
     値が`nil'（デフォルト）であると無制限。



File: elisp-ja,  Node: Minibuffers,  Next: Command Loop,  Prev: Read and Print,  Up: Top

19 ミニバッファ
*********************

"ミニバッファ"（minibuffer）は、単純な数値前置引数ではなく、
より複雑な引数を読み取るためにEmacsのコマンドが使う特別なバッファです。
これらの引数には、ファイル名、バッファ名、
（`M-x'での）コマンド名があります。
ミニバッファは、エコー領域と同様に、フレームの最下行に表示されますが、
引数を読み取るときにのみ表示されます。

* Menu:

* Intro to Minibuffers::      Basic information about minibuffers.
* Text from Minibuffer::      How to read a straight text string.
* Object from Minibuffer::    How to read a Lisp object or expression.
* Minibuffer History::	      Recording previous minibuffer inputs
				so the user can reuse them.
* Completion::                How to invoke and customize completion.
* Yes-or-No Queries::         Asking a question with a simple answer.
* Multiple Queries::	      Asking a series of similar questions.
* Reading a Password::	      Reading a password from the terminal.
* Minibuffer Misc::           Various customization hooks and variables.


File: elisp-ja,  Node: Intro to Minibuffers,  Next: Text from Minibuffer,  Up: Minibuffers

19.1 ミニバッファの紹介
================================

ほとんどの意味において、ミニバッファはEmacsの普通のバッファです。
編集コマンドなどのバッファ_内_でのほとんどの操作は、
ミニバッファでも普通に動作します。
しかし、バッファを操作するコマンドの多くは、
ミニバッファには適用できません。
ミニバッファの名前はつねに`*Minibuf-NUMBER'という形式であって、
変更できません。
ミニバッファはミニバッファ専用の特別なウィンドウだけに表示されます。
これらのウィンドウはつねにフレームの最下行に現れます。
（ミニバッファを持たないフレームや、
ミニバッファ用ウィンドウのみの特殊なフレームもある。 *note Minibuffers
and Frames::を参照。）

   ミニバッファ用のウィンドウは通常は1行だけです。
ウィンドウサイズを変更するコマンドで一時的に大きさを変えられますが、
ミニバッファから抜けると通常サイズに戻ります。
ミニバッファ用ウィンドウのサイズを恒久的に変更するには、
ミニバッファを使っていないときに、フレームの別のウィンドウにおいて
ウィンドウサイズを変更するコマンドを使います。
ミニバッファだけを持つフレームの場合、
フレームのサイズを変更すればミニバッファのサイズを変更できます。

すでにミニバッファが活性であるときにコマンドがミニバッファを使用することを
"再帰ミニバッファ"と呼びます。
最初のミニバッファの名前は` *Minibuf-0*'です。
再帰ミニバッファは、名前の最後の数を増やして命名します。
（名前は空白で始まるため、通常のバッファの一覧には表示されない。）
再帰ミニバッファの中で、もっとも内側の（つまりもっとも再帰が深い）ものが
活性なミニバッファです。 これを単にミニバッファと呼びます。
変数`enable-recursive-minibuffers'を設定すれば、
再帰ミニバッファを許可したり禁止できます。
あるいは、コマンドシンボルにこの名前の属性を入れます （*note Minibuffer
Misc::）。

   他のバッファと同様に、ミニバッファは 複数のローカルキーマップ（*note
Keymaps::）を使うことがあります。
これらには、さまざまな終了コマンドや補完コマンド（*note Completion::）
が含まれます。

   * `minibuffer-local-map'は（補完なしの）普通の入力用。

   * `minibuffer-local-ns-map'も同様だが、 <RET>と同様に<SPC>で抜ける。
     これは主にMocklisp互換用に使われる。

   * `minibuffer-local-completion-map'は弱い補完用。

   * `minibuffer-local-completion-map'は強い補完や慎重な補完用。


File: elisp-ja,  Node: Text from Minibuffer,  Next: Object from Minibuffer,  Prev: Intro to Minibuffers,  Up: Minibuffers

19.2 ミニバッファでのテキスト文字列の読み取り
=================================================================

多くの場合、テキストを文字列として読み取るためにミニバッファを使います。
Lispオブジェクトのテキスト表現を読み取るためにも使えます。
ミニバッファでの入力のもっとも基本的な関数は
`read-from-minibuffer'であり、どちらの目的にも使えます。

多くの場合、Lisp関数の途中でミニバッファの入力関数を呼ぶべきではありません。
そのかわりに、`interactive'の指定で、
コマンドの引数を読み取る操作の一部として
すべてのミニバッファ入力を行います。 *Note Defining Commands::。

 -- Function: read-from-minibuffer prompt-string &optional
          initial-contents keymap read hist default inherit-input-method
     この関数は、ミニバッファから入力を得るもっとも汎用の方法である。
     デフォルトでは、任意のテキストを受け取り文字列として返す。
     しかし、READが`nil'以外であれば、 `read'を用いてテキストを
     Lispオブジェクトへ変換する（*note Input Functions::）。

     この関数がまず行うことは、ミニバッファを活性にし、
     プロンプトPROMPT-STRINGとともに表示することである。
     PROMPT-STRINGは文字列であること。
     これで、ユーザーはミニバッファでテキストを編集できるようになる。

     ユーザーがミニバッファを抜けるコマンドを打つと、
     `read-from-minibuffer'は
     ミニバッファ内のテキストから戻り値を構築する。
     通常、当該テキストを含む文字列を返す。
     しかし、READが`nil'以外であると、
     `read-from-minibuffer'はテキストを読み取った結果である
     Lispオブジェクトを評価せずに返す。 （読み取りについては*note Input
     Functions::。）

     引数DEFAULTは、履歴コマンドで使うデフォルト値を指定する。
     これは文字列か`nil'であること。 READが`nil'以外である場合、
     ユーザーの入力が空であるときには、
     `read'への入力としてもDEFAULTを用いる。
     しかし、（READが`nil'である）通常の場合、
     ユーザーの入力が空のとき、`read-from-minibuffer'は
     DEFAULTを返さずに空文字列`""'を返す。
     この意味において、この関数は本章の他のミニバッファ用入力関数と異なる。

     KEYMAPが`nil'以外であると、
     ミニバッファのローカルキーマップとして用いる。
     KEYMAPを省略したり`nil'であると、
     `minibuffer-local-map'の値をキーマップとして用いる。
     キーマップを指定することは、
     補完などのさまざまな応用向けにミニバッファをカスタマイズする
     もっとも重要な方法である。

     引数HISTは、ミニバッファでの入力を保存し履歴コマンドを使用可能に
     するために用いる履歴リスト変数を指定する。
     デフォルトは`minibuffer-history'である。 *note Minibuffer
     History::。

     変数`minibuffer-allow-text-properties'が`nil'以外であると、
     返される文字列には、ミニバッファで指定されたテキスト属性が含まれる。
     さもなければ、値を返すときにすべてのテキスト属性を取り除く。

     引数INHERIT-INPUT-METHODが`nil'以外であると、
     ミニバッファに入るまえにどのバッファにいたかに関わらず、
     そのバッファから現在の入力方式（*note Input Methods::）と
     `enable-multibyte-characters'（*note Text
     Representations::）の設定を 継承する。

     INITIAL-CONTENTSが文字列であれば、 `read-from-minibuffer'は、
     ユーザーがテキスト編集を始めるまえに、
     この文字列をミニバッファに挿入しその末尾にポイントを置く。
     この文字列を初期内容とするミニバッファが現れる。

     あるいは、INITIAL-CONTENTSは、 `(STRING .
     POSITION)'という形式のコンスセルでもよい。
     これは、文字列STRINGをミニバッファに挿入し、
     ポイントは末尾にではなく
     先頭からPOSITION番目の文字に置くことを意味する。

     *使用上の注意：*` ' 引数INITIAL-CONTENTSとDEFAULTは、
     多かれ少なかれ同じことを行う代替方法を提供する。
     `read-from-minibuffer'の1つの呼び出しにおいて、
     両者の機能を同時に使うことに意味はない。
     一般には、DEFAULTを使うことを勧める。
     というのは、ユーザーがデフォルト値を望む場合にはデフォルト値を挿入でき、
     それ以外の場合にはデフォルト値を削除しなくてもよいからである。

 -- Function: read-string prompt &optional initial history default
          inherit-input-method
     この関数はミニバッファから文字列を読み取り、それを返す。
     引数PROMPTとINITIALは、 `read-from-minibuffer'と同様に使われる。
     使用するキーマップは`minibuffer-local-map'である。

     省略可能な引数HISTORYは、`nil'以外であると、
     履歴リストと（省略可能な）リスト内での初期位置を指定する。
     省略可能な引数DEFAULTは、
     ユーザー入力が空の場合に返されるデフォルト値であり、文字列であること。
     省略可能な引数INHERIT-INPUT-METHODは、
     カレントバッファの入力方式を継承するかどうかを指定する。

     この関数は関数`read-from-minibuffer'の
     インターフェイスを単純化したものである。

          (read-string PROMPT INITIAL HISTORY DEFAULT INHERIT)
          ==
          (let ((value
                 (read-from-minibuffer PROMPT INITIAL nil nil
                                       HISTORY DEFAULT INHERIT)))
            (if (equal value "")
                DEFAULT
              value))

 -- Variable: minibuffer-allow-text-properties
     この変数が`nil'であると、
     `read-from-minibuffer'はミニバッファで指定されたすべての
     テキスト属性を返すまえに取り除く。
     すべてのミニバッファが`read-from-minibuffer'を使うので、
     この変数はすべてのミニバッファ入力に適用される。

     この変数の値に関わらず、
     補完関数は無条件にテキスト属性を廃棄することに注意。

 -- Variable: minibuffer-local-map
     ミニバッファから読み取るときのデフォルトのローカルキーマップ。
     デフォルトでは、以下のバインディングである。

    `C-j'
          `exit-minibuffer'

    <RET>
          `exit-minibuffer'

    `C-g'
          `abort-recursive-edit'

    `M-n'
          `next-history-element'

    `M-p'
          `previous-history-element'

    `M-r'
          `next-matching-history-element'

    `M-s'
          `previous-matching-history-element'

 -- Function: read-no-blanks-input prompt &optional initial
          inherit-input-method
     この関数はミニバッファから文字列を読み取るが、
     入力には白文字を許さず、白文字は入力を終らせる。
     引数PROMPT、INITIAL、INHERIT-INPUT-METHODは、
     `read-from-minibuffer'と同様に使われる。

     これは関数`read-from-minibuffer'の
     インターフェイスを単純化したものであり、
     引数KEYMAPとして`minibuffer-local-ns-map'の値を渡す。
     キーマップ`minibuffer-local-ns-map'では
     `C-q'を再バインドしないため、
     クォートすれば空白を文字列に含めることが_できる_。

          (read-no-blanks-input PROMPT INITIAL)
          ==
          (read-from-minibuffer PROMPT INITIAL minibuffer-local-ns-map)

 -- Variable: minibuffer-local-ns-map
     この組み込み変数は、関数`read-no-blanks-input'が
     ミニバッファ用のローカルキーマップとして使うキーマップである。
     デフォルトでは、`minibuffer-local-map'のバインディングに加えて
     以下のバインディングである。

    <SPC>
          `exit-minibuffer'

    <TAB>
          `exit-minibuffer'

    `?'
          `self-insert-and-exit'


File: elisp-ja,  Node: Object from Minibuffer,  Next: Minibuffer History,  Prev: Text from Minibuffer,  Up: Minibuffers

19.3 ミニバッファでのLispオブジェクトの読み取り
==================================================================

本節では、ミニバッファでLispオブジェクトを読み取る関数について述べます。

 -- Function: read-minibuffer prompt &optional initial
     この関数はミニバッファを用いてLispオブジェクトを読み取り、
     それを評価せずに返す。 引数PROMPTとINITIALは、
     `read-from-minibuffer'と同様に使われる。

     これは関数`read-from-minibuffer'の
     インターフェイスを単純化したものである。

          (read-minibuffer PROMPT INITIAL)
          ==
          (read-from-minibuffer PROMPT INITIAL nil t)

     初期入力として文字列`"(testing)"'を与えた例を示す。

          (read-minibuffer
           "Enter an expression: " (format "%s" '(testing)))

          ;; 以下のようにミニバッファが表示される

          ---------- Buffer: Minibuffer ----------
          Enter an expression: (testing)-!-
          ---------- Buffer: Minibuffer ----------

     デフォルトとして初期入力を使うには、ユーザーはただちに<RET>を打てばよい。
     あるいは、入力を編集する。

 -- Function: eval-minibuffer prompt &optional initial
     この関数はミニバッファを用いてLisp式を読み取り、
     それを評価してその結果を返す。 引数PROMPTとINITIALは、
     `read-from-minibuffer'と同様に使われる。

     この関数は`read-from-minibuffer'の
     インターフェイスを単純化したものである。

          (eval-minibuffer PROMPT INITIAL)
          ==
          (eval (read-minibuffer PROMPT INITIAL))

 -- Function: edit-and-eval-command prompt form
     この関数はミニバッファを用いてLisp式を読み取り、それを評価する。
     このコマンドと`eval-minibuffer'との違いは、
     初期フォームFORMを省略できないことであり、
     このフォームをテキスト文字列としではなく表示表現に
     変換するLispオブジェクトとして扱うことである。
     `prin1'を用いて表示するので、
     これが文字列であると初期テキストにはダブルクォート文字（`"'）が現れる。
     *note Output Functions::。

     `edit-and-eval-command'はまず、PROMPTをプロンプトとして
     ミニバッファを活性にする。
     続いて、ミニバッファにFORMの表示表現を挿入し、ユーザーに編集させる。
     ユーザーがミニバッファから抜けると、
     編集後のテキストを`read'で読み取り評価する。
     評価結果が`edit-and-eval-command'の値になる。

     以下の例では、すでに正しいフォームである
     初期テキストの式をユーザーに提示する。

          (edit-and-eval-command "Please edit: " '(forward-word 1))

          ;; 上の式を評価後には、ミニバッファは以下のようになる

          ---------- Buffer: Minibuffer ----------
          Please edit: (forward-word 1)-!-
          ---------- Buffer: Minibuffer ----------

     ただちに<RET>を打つと、 ミニバッファから抜けて式を評価するので、
     ポイントを1単語分先へ進めることになる。
     この例では、`edit-and-eval-command'は`nil'を返す。


File: elisp-ja,  Node: Minibuffer History,  Next: Completion,  Prev: Object from Minibuffer,  Up: Minibuffers

19.4 ミニバッファの履歴
================================

"ミニバッファ履歴リスト"（minibuffer history list）は
ミニバッファでの以前の入力を記録し、
ユーザーがそれらを手軽に再利用できるようにします。
履歴リストは実際にはシンボルでありリストではありません。
最新のものが先頭にある（以前の入力の）文字列のリストを値とする変数です。

   異なる種類の入力に用いる多くの別々の履歴リストがあります。
ミニバッファを利用するたびに適した履歴リストを指定するのは、
Lispプログラマの責任です。

   基本的なミニバッファ入力関数
`read-from-minibuffer'と`completing-read'の両者は、
読者が指定する履歴リストを省略可能な引数HISTとして受け付けます。
指定可能な値はつぎのとおりです。

VARIABLE
     変数VARIABLE（シンボル）を履歴リストとして用いる。

(VARIABLE . STARTPOS)
     変数VARIABLE（シンボル）を履歴リストとして用い、
     初期履歴位置をSTARTPOS
     （履歴リストの最新要素を0とする整数）と仮定する。

     STARTPOSを指定した場合、整合性を保つために、
     履歴リストの当該要素をミニバッファの初期内容にも指定すること。

   HISTを指定しなければ、
デフォルトの履歴リスト`minibuffer-history'を用いる。
その他の標準的な履歴リストについては以下を参照。
読者が独自の履歴リスト変数を作成してもよい。
初めて使用するまえに単に`nil'で初期化しておく。

   `read-from-minibuffer'と`completing-read'の両者は
履歴リストに新たな要素を自動的に追加し、
リスト上の要素を再利用するためのコマンドをユーザーに提供する。
履歴リストを使うために読者のプログラムで行うべきことは、
履歴リストを初期化し必要なときにその名前を入力関数に渡すだけである。
ミニバッファ入力関数が履歴リストを使用していないときには、
履歴リストを変更しても安全である。

   標準的なミニバッファ履歴リスト変数を以下にあげておく。

 -- Variable: minibuffer-history
     ミニバッファの履歴入力用のデフォルトの履歴リスト。

 -- Variable: query-replace-history
     `query-replace'（および同様のコマンド）の引数用の履歴リスト。

 -- Variable: file-name-history
     ファイル名引数用の履歴リスト。

 -- Variable: buffer-name-history
     バッファ名引数用の履歴リスト。

 -- Variable: regexp-history
     正規表現引数用の履歴リスト。

 -- Variable: extended-command-history
     拡張コマンド名である引数用の履歴リスト。

 -- Variable: shell-command-history
     シェルコマンドである引数用の履歴リスト。

 -- Variable: read-expression-history
     Lisp式として評価する引数用の履歴リスト。


File: elisp-ja,  Node: Completion,  Next: Yes-or-No Queries,  Prev: Minibuffer History,  Up: Minibuffers

19.5 補完
===========

"補完"（completion）とは、
名前の省略から始まる名前の残り部分を補充する機能です。
ユーザー入力を正しい名前のリストと比較し、
すでにユーザーが入力したものに名前が
どの程度一致するかを決定することで補完します。 たとえば、`C-x
b'（`switch-to-buffer'）と打って、
切り替えたいバッファ名の始めの数文字を打って
<TAB>（`minibuffer-complete'）を打つと、
Emacsは可能な限りその名前を補充します。

   Emacsの標準のコマンドは、
シンボル、ファイル、バッファ、プロセスの名前を補完できます。
本節の関数を用いれば、その他の種類の名前の補完も実装できます。

   関数`try-completion'は補完のための基本関数です。
与えられた文字列の集まりから
初期文字列にもっとも適合する最長のものを返します。

   関数`completing-read'は補完のための上位レベルの
インターフェイスを提供します。 `completing-read'の呼び出しには、
正しい名前のリストを決定する方法を指定します。
この関数は、補完に有用なコマンドを数個のキーにバインドした
ローカルキーマップを使うミニバッファを活性にします。
その他の関数は、特定の種類の名前を補完して読み取るために
単純化したインターフェイスを提供します。

* Menu:

* Basic Completion::       Low-level functions for completing strings.
                             (These are too low level to use the minibuffer.)
* Minibuffer Completion::  Invoking the minibuffer with completion.
* Completion Commands::    Minibuffer commands that do completion.
* High-Level Completion::  Convenient special cases of completion
                             (reading buffer name, file name, etc.)
* Reading File Names::     Using completion to read file names.
* Programmed Completion::  Finding the completions for a given file name.


File: elisp-ja,  Node: Basic Completion,  Next: Minibuffer Completion,  Up: Completion

19.5.1 基本補完関数
-------------------------

2つの関数`try-completion'と`all-completions'は、
それ自身ではミニバッファを使いません。 これらについて本章で述べるのは、
ミニバッファを使う上位レベルの補完機能と同列にしておくためです。

 -- Function: try-completion string collection &optional predicate
     この関数は、COLLECTIONにあるSTRINGを補完する
     共通の最長な部分文字列を返す。
     COLLECTIONの値は、連想リスト、オブジェクト配列、あるいは、
     実質的な文字列の集まりを返す関数（下記参照）であること。

     補完では、COLLECTIONで指定した各補完候補と STRINGを比較する。
     補完候補の先頭部分がSTRINGに等しければ、
     その補完候補は一致するという。
     一致する補完候補がなければ、`try-completion'は`nil'を返す。
     たった1つの補完候補に一致し、かつ、完全に一致すれば、
     `try-completion'は`t'を返す。
     さもなければ、一致する補完候補すべてに共通する最長の文字列を値とする。

     COLLECTIONが連想リスト（*note Association Lists::）であると、
     連想リストの要素のCAR群が補完候補の集まりになる。

     COLLECTIONがオブジェクト配列（*note Creating Symbols::）であると、
     オブジェクト配列内のすべてのシンボルの名前が補完候補の集まりになる。
     グローバル変数`obarray'は、インターンしたすべてのLispシンボルの
     名前を収めたオブジェクト配列を保持する。

     新たなオブジェクト配列を作成する唯一の正しい方法は、
     まず空で作成してから`intern'で1つ1つシンボルを追加することである
     ことに注意。
     なお、1つのシンボルを複数のオブジェクト配列にはインターンできない。

     引数PREDICATEが`nil'以外である場合、 それは1引数の関数であること。
     その関数は一致する補完候補の検査に使われ、
     PREDICATEが`nil'以外を返す場合にのみ一致した候補とみなす。
     PREDICATEに渡す引数は、
     （CARが文字列である）連想リストのコンスセルであるか、
     オブジェクト配列からの（シンボル名では_ない_）シンボルである。

     COLLECTIONには、関数であるシンボルを使うこともできる。
     その関数には補完処理を完遂する責任がある。
     `try-completion'はその関数が返したものを返す。
     その関数は3引数、つまり、 STRING、PREDICATE、`nil'で呼ばれる。
     （第3引数がある理由は、 `all-completions'でも同じ関数を使い、
     いずれの場合にも適切に動作できるようにするため。） *note
     Programmed Completion::。

     以下の最初の例では、 文字列`foo'は連想リストの3つのCARに一致する。
     すべての一致は`fooba'で始まるため、これが結果になる。
     2番目の例では、たった1つの一致があり、しかも、完全に一致するので、
     値は`t'である。

          (try-completion
           "foo"
           '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4)))
               => "fooba"

          (try-completion "foo" '(("barfoo" 2) ("foo" 3)))
               => t

     つぎの例では、`forw'で始まるシンボルが多数あり、
     それらはすべて単語`forward'で始まる。
     ほとんどのシンボルでは、これに`-'が続くが、
     すべてがそうではないので、`forward'までしか補完できない。

          (try-completion "forw" obarray)
               => "forward"

     最後の例は、述語`test'の検査に通るのは3つの一致のうち2つだけである
     （文字列`foobaz'は短すぎる）。 両者は文字列`foobar'で始まる。

          (defun test (s)
            (> (length (car s)) 6))
               => test
          (try-completion
           "foo"
           '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
           'test)
               => "foobar"

 -- Function: all-completions string collection &optional predicate
          nospace
     この関数はSTRINGの補完すべてのリストを返す。
     この関数の引数は、`try-completion'のものと同じである。

     COLLECTIONが関数であると、
     STRING、PREDICATE、`t'の3引数で呼ばれる。
     `all-completions'はこの関数が返す値を返す。 *note Programmed
     Completion::。

     NOSPACEが`nil'以外であると、
     STRINGが空白で始まらない限り、空白で始まる補完は無視する。

     `try-completion'の例に示した関数`test'を用いた例を示す。

          (defun test (s)
            (> (length (car s)) 6))
               => test

          (all-completions
           "foo"
           '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
           'test)
               => ("foobar1" "foobar2")

 -- Variable: completion-ignore-case
     この変数の値が`nil'以外であると、
     Emacsは補完において大文字小文字を区別しない。


File: elisp-ja,  Node: Minibuffer Completion,  Next: Completion Commands,  Prev: Basic Completion,  Up: Completion

19.5.2 補完とミニバッファ
----------------------------------

本節ではミニバッファからの補完による読み取り用の
基本インターフェイスについて述べます。

 -- Function: completing-read prompt collection &optional predicate
          require-match initial hist default inherit-input-method
     この関数は、与えられた補完でユーザーを補佐して
     ミニバッファで文字列を読み取る。
     文字列であるプロンプトPROMPTでミニバッファを活性にする。

     実際の補完は、COLLECTIONとPREDICATEを
     関数`try-completion'に渡して行う。
     これは、補完を用いるローカルキーマップでバインドされたコマンドで行われる。

     REQUIRE-MATCHが`nil'であると、 ミニバッファでの入力に関わらず
     ミニバッファから抜けるコマンドは動作する。
     REQUIRE-MATCHが`t'であると、
     ミニバッファでの入力がCOLLECTIONの1つの要素に補完できない限り、
     ミニバッファから抜ける通常のコマンドは動作しない。
     REQUIRE-MATCHが`nil'でも`t'でもないと、
     ミニバッファでの入力がCOLLECTIONの1つの要素に一致しない限り、
     ミニバッファから抜けるコマンドは動作しない。

     しかし、REQUIRE-MATCHの値に関わらず、 空の入力はつねに許される。
     その場合、`completing-read'はDEFAULTを返す。
     DEFAULTの値は（`nil'でなければ）履歴コマンドを介しても
     ユーザーが使える。

     ミニバッファが空の状態で<RET>を打つと、
     ユーザーは空入力で抜けることができる。
     そうすると、`completing-read'は`""'を返す。
     これにより、読み取った値に対してコマンドが使うどんなデフォルトでも指定できる。
     REQUIRE-MATCHの値、および、COLLECTIONに空文字列が
     含まれるかどうかに関わらず、ユーザーはこのようにして<RET>で戻れる。

     関数`completing-read'は`read-minibuffer'を呼び出すことで動作する。
     REQUIRE-MATCHが`nil'であると、
     キーマップとして`minibuffer-local-completion-map'を使い、
     `nil'以外であると`minibuffer-local-must-match-map'を使う。 *note
     Completion Commands::。

     引数HISTは、入力を保存しミニバッファ履歴コマンドで
     使う履歴リスト変数を指定する。
     デフォルトは`minibuffer-history'である。 *note Minibuffer
     History::。

     INITIALが`nil'以外であると、
     `completing-read'はこれを入力の一部としてミニバッファに挿入する。
     これにより、ユーザーは補完コマンドとともに入力を編集できる。
     ほとんどの場合、INITIALではなくDEFAULTを使うことを勧める。

     引数INHERIT-INPUT-METHODが`nil'以外であると、
     ミニバッファに入るまえのカレントバッファがなんであれ、
     カレントバッファから現在の入力方式（*note Input Methods::）と
     `enable-multibyte-characters'（*note Text Representations::）
     の設定を継承する。

     組み込み変数`completion-ignore-case'が`nil'以外であると、
     大文字小文字を区別せずに候補に対して入力を比較する。 *note Basic
     Completion::。

     `completing-read'を用いた例を以下に示す。

          (completing-read
           "Complete a foo: "
           '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
           nil t "fo")

          ;; 上の式を評価するとミニバッファはつぎのようになる

          ---------- Buffer: Minibuffer ----------
          Complete a foo: fo-!-
          ---------- Buffer: Minibuffer ----------

     ユーザーが`<DEL> <DEL> b <RET>'を打つと、
     `completing-read'は`barfoo'を返す。

     関数`completing-read'は、
     補完を実際に行うコマンドに情報を渡すために3つの変数を束縛する。
     3つの変数とは、`minibuffer-completion-table'、
     `minibuffer-completion-predicate'、
     `minibuffer-completion-confirm'である。
     これらについて詳しくは、*note Completion Commands::を参照。


File: elisp-ja,  Node: Completion Commands,  Next: High-Level Completion,  Prev: Minibuffer Completion,  Up: Completion

19.5.3 補完を行うミニバッファコマンド
----------------------------------------------------

本節では、補完を行うためにミニバッファで用いられるキーマップ、
コマンド、ユーザーオプションについて述べます。

 -- Variable: minibuffer-local-completion-map
     `completing-read'は、 補完候補の1つと完全に一致しなくてもよい場合に
     ローカルキーマップとしてこの値を使う。
     デフォルトでは、このキーマップのバインディングはつぎのとおり。

    `?'
          `minibuffer-completion-help'

    <SPC>
          `minibuffer-complete-word'

    <TAB>
          `minibuffer-complete'

     他の文字は`minibuffer-local-map' （*note Text from
     Minibuffer::）と同様にバインドされる。

 -- Variable: minibuffer-local-must-match-map
     `completing-read'は、 補完候補の1つと完全に一致する必要がある場合に
     ローカルキーマップとしてこの値を使う。
     そのため、ミニバッファから無条件に抜けるコマンド`exit-minibuffer'に
     バインドしたキーはない。
     デフォルトでは、このキーマップのバインディングはつぎのとおり。

    `?'
          `minibuffer-completion-help'

    <SPC>
          `minibuffer-complete-word'

    <TAB>
          `minibuffer-complete'

    `C-j'
          `minibuffer-complete-and-exit'

    <RET>
          `minibuffer-complete-and-exit'

     他の文字は`minibuffer-local-map'と同様にバインドされる。

 -- Variable: minibuffer-completion-table
     この変数の値は、ミニバッファでの補完に用いられる
     連想リストやオブジェクト配列である。
     これは、`completing-read'が`try-completion'に渡すものを
     保持したグローバル変数である。 `minibuffer-complete-word'などの
     ミニバッファ補完コマンドで使用される。

 -- Variable: minibuffer-completion-predicate
     この変数の値は、`completing-read'が
     `try-completion'へ渡す述語である。
     この変数は、他のミニバッファ補完関数でも使われる。

 -- コマンド: minibuffer-complete-word
     この関数は、ミニバッファの内容を多くても1単語分補完する。
     ミニバッファの内容に対応する補完がたった1つであっても、
     単語構成文字ではない文字以降は補充しない。 *note Syntax Tables::。

 -- コマンド: minibuffer-complete
     この関数は、ミニバッファの内容を可能な限り補完する。

 -- コマンド: minibuffer-complete-and-exit
     この関数は、確認が必要でないとき、つまり、
     `minibuffer-completion-confirm'が`nil'であるときには、
     ミニバッファの内容を補完後に抜ける。 確認が必要_である_ときには、
     このコマンドをただちに繰り返すことで確認をとる。
     このコマンドは、連続して2回呼ばれると、
     確認しないようにプログラムしてある。

 -- Variable: minibuffer-completion-confirm
     この変数の値が`nil'以外の場合、
     Emacsはミニバッファから抜けるまえに補完を確認してくる。
     関数`minibuffer-complete-and-exit'は、
     抜けるまえにこの変数の値を検査する。

 -- コマンド: minibuffer-completion-help
     この関数は、ミニバッファの現在の内容に対する補完のリストを作る。
     引数COLLECTIONとして変数`minibuffer-completion-table'の値を、
     引数PREDICATEとして`minibuffer-completion-predicate'の値を
     用いて`all-completions'を呼び出すことで動作する。
     補完のリストは、`*Completions*'という名前のバッファに
     テキストとして表示される。

 -- Function: display-completion-list completions
     この関数は、通常はバッファであるストリーム`standard-output'に
     COMPLETIONSを表示する。 （ストリームについては詳しくは*note Read
     and Print::。） 引数COMPLETIONSは、普通は、`all-completions'が
     返した補完のリストであるが、そうでなくてもよい。
     各要素は、シンボルか文字列であり、その場合、そのまま表示される。
     各要素が2つの文字列から成るリストである場合、
     文字列を連結したものを表示する。

     この関数は、`minibuffer-completion-help'から呼ばれる。
     以下のように、`with-output-to-temp-buffer'とともに
     用いるのがもっとも一般的である。

          (with-output-to-temp-buffer "*Completions*"
            (display-completion-list
              (all-completions (buffer-string) my-alist)))

 -- User Option: completion-auto-help
     この変数が`nil'以外であると、
     つぎの補充文字が一意に決まらない場合には、
     自動的に補完のリストを表示する。


File: elisp-ja,  Node: High-Level Completion,  Next: Reading File Names,  Prev: Completion Commands,  Up: Completion

19.5.4 高レベルの補完関数
----------------------------------

本節では、特定の種類の名前を補完付きで読み取るための
高レベルの便利な関数について述べます。

   多くの場合、これらの関数をLisp関数の途中では呼び出さないでください。
可能な場合には、`interactive'の指定で、
コマンドの引数を読み取る操作の一部としてすべてのミニバッファ入力を
行ってください。 *Note Defining Commands::。

 -- Function: read-buffer prompt &optional default existing
     この関数はバッファ名を読み取り、文字列として返す。
     引数DEFAULTはデフォルトの名前を表し、
     ユーザーがミニバッファから空で抜け出したときに返される値である。
     `nil'以外であるときには、文字列かバッファであること。
     これはプロンプトとして現れるが、
     ミニバッファには初期入力として挿入されない。

     EXISTINGが`nil'以外であると、
     指定した名前は既存のバッファ名であること。
     テキストが正しくないとミニバッファから抜ける通常のコマンドは動作せず、
     <RET>は正しい名前を探すため補完を行う。
     （しかし、DEFAULTが正しいかどうかは検査しない。
     ユーザーがミニバッファを空で抜ければ、
     なんであろうとDEFAULTが返される。）

     以下の例では、ユーザーは`minibuffer.t'と入力してから<RET>を打つ。
     引数EXISTINGは`t'であり、
     入力した名前で始まる唯一のバッファ名は`minibuffer.texi'であるので、
     この名前が値になる。

          (read-buffer "Buffer name? " "foo" t)
          ;; 上の式を評価すると、ミニバッファは空で
          ;; つぎのようなプロンプトが表示される

          ---------- Buffer: Minibuffer ----------
          Buffer name? (default foo) -!-
          ---------- Buffer: Minibuffer ----------

          ;; ユーザーは`minibuffer.t <RET>'と打つ
               => "minibuffer.texi"

 -- Variable: read-buffer-function
     この変数は、バッファ名の読み取り方を指定する。
     たとえば、この変数に`iswitchb-read-buffer'を設定すると、
     バッファ名を読み取るために`read-buffer'を呼び出す
     すべてのEmacsコマンドは、
     バッファ名を読むためにパッケージ`iswitchb'を使うようになる。

 -- Function: read-command prompt &optional default
     この関数はコマンド名を読み取り、Lispシンボルとして返す。
     引数PROMPTは、`read-from-minibuffer'と同様に使われる。
     なんであっても`commandp'が`t'を返せばコマンドであり、
     `commandp'が`t'を返すシンボルはコマンド名であることに注意。 *note
     Interactive Call::。

     引数DEFAULTは、ユーザー入力が空だった場合に返したい値を指定する。
     これは、シンボルか文字列であること。
     文字列であると、`read-command'は、これを返すまえにインターンする。
     DEFAULTが`nil'であると、デフォルトを指定しないことを意味し、
     ユーザー入力が空であると戻り値は`nil'である。

          (read-command "Command name? ")

          ;; 上の式を評価後には、ミニバッファは空で
          ;; つぎのようなプロンプトが表示される

          ---------- Buffer: Minibuffer ----------
          Command name?
          ---------- Buffer: Minibuffer ----------

     ユーザーが`forward-c <RET>'と打つと、
     この関数は`forward-char'を返す。

     関数`read-command'は`completing-read'のインターフェイスを
     単純化したものである。
     既存のLispシンボルの集まりから補完するために変数`obarray'を使い、
     コマンド名のみを対象とするために述語`commandp'を使う。

          (read-command PROMPT)
          ==
          (intern (completing-read PROMPT obarray
                                   'commandp t nil))

 -- Function: read-variable prompt &optional default
     この関数はユーザー変数の名前を読み取り、シンボルとして返す。

     引数DEFAULTは、ユーザー入力が空だった場合に返したい値を指定する。
     これは、シンボルか文字列であること。
     文字列であると、`read-variable'は、これを返すまえにインターンする。
     DEFAULTが`nil'であると、デフォルトを指定しないことを意味し、
     ユーザー入力が空であると戻り値は`nil'である。

          (read-variable "Variable name? ")

          ;; 上の式を評価後には、ミニバッファは空で
          ;; つぎのようなプロンプトが表示される

          ---------- Buffer: Minibuffer ----------
          Variable name? -!-
          ---------- Buffer: Minibuffer ----------

     ユーザーが`fill-p <RET>'と打つと、
     `read-variable'は`fill-prefix'を返す。

     この関数は`read-command'に似ているが、
     `commandp'のかわりに述語`user-variable-p'を使う。

          (read-variable PROMPT)
          ==
          (intern
           (completing-read PROMPT obarray
                            'user-variable-p t nil))

   *note User-Chosen Coding Systems::の関数`read-coding-system'や
`read-non-nil-coding-system'も参照してください。


File: elisp-ja,  Node: Reading File Names,  Next: Programmed Completion,  Prev: High-Level Completion,  Up: Completion

19.5.5 ファイル名の読み取り
-------------------------------------

ここでは、ファイル名を読み取るように設計された高レベルの
別の補完関数について述べます。
デフォルトディレクトリの自動挿入などの特別な機能を提供します。

 -- Function: read-file-name prompt &optional directory default
          existing initial
     この関数は、PROMPTをプロンプトとし、
     補完を行ってミニバッファでファイル名を読み取る。
     DEFAULTが`nil'以外であると、
     ユーザーが単に<RET>を打つと、この関数はDEFAULTを返す。
     DEFAULTが正しいかどうかは検査せず、
     それがなんであれ、ユーザーがミニバッファを空で抜けるとそれを返す。

     EXISTINGが`nil'以外であると、
     ユーザーは既存ファイルの名前を指定する必要がある。
     <RET>は、可能ならば正しい名前に補完を行うが、
     それが正しくない場合には抜けない。
     EXISTINGの値が`nil'でも`t'でもないと、
     <RET>は補完後の確認を必要とする。 EXISTINGが`nil'であると、
     存在しないファイルの名前も許す。

     引数DIRECTORYは、相対ファイル名の補完に用いるディレクトリを指定する。
     `insert-default-directory'が`nil'以外であると、
     初期入力としてDIRECTORYをミニバッファに挿入する。
     カレントバッファの`default-directory'の値がデフォルトになる。

     INITIALを指定すると、 （DIRECTORYがあればそれを挿入後に）バッファに
     挿入される初期ファイル名になる。
     この場合、ポイントはINITIALの先頭に置かれる。
     INITIALのデフォルトは`nil'であり、 いかなるファイル名も挿入しない。
     INITIALの動作を見るには、コマンド`C-x C-v'を試してほしい。
     *注意：*` '
     ほとんどの場合、INITIALではなくDEFAULTを使うことを勧める。

     例を示す。

          (read-file-name "The file is ")

          ;; 上の式を評価後には、ミニバッファはつぎのようになる

          ---------- Buffer: Minibuffer ----------
          The file is /gp/gnu/elisp/-!-
          ---------- Buffer: Minibuffer ----------

     `manual <TAB>'を打つと、つぎのようになる。

          ---------- Buffer: Minibuffer ----------
          The file is /gp/gnu/elisp/manual.texi-!-
          ---------- Buffer: Minibuffer ----------

     ユーザーが<RET>と打つと、 `read-file-name'は
     ファイル名を文字列`"/gp/gnu/elisp/manual.texi"'として返す。

 -- User Option: insert-default-directory
     この変数は`read-file-name'が使う。 その値は、`read-file-name'が、
     デフォルトディレクトリの名前と（あれば）初期ファイル名を
     ミニバッファに入れて動作を開始するかどうかを制御する。
     この変数の値が`nil'であると、 `read-file-name'は
     （引数INITIALで初期入力を指定しない限り）
     ミニバッファに初期入力を入れない。
     その場合でも、相対ファイル名の補完には
     デフォルトディレクトリを使うが表示はしない。

     例を示す。

          ;; デフォルトディレクトリを入れて始める
          (let ((insert-default-directory t))
            (read-file-name "The file is "))

          ---------- Buffer: Minibuffer ----------
          The file is ~lewis/manual/-!-
          ---------- Buffer: Minibuffer ----------

          ;; ミニバッファは空であり、プロンプトのみ
          (let ((insert-default-directory nil))
            (read-file-name "The file is "))

          ---------- Buffer: Minibuffer ----------
          The file is -!-
          ---------- Buffer: Minibuffer ----------


File: elisp-ja,  Node: Programmed Completion,  Prev: Reading File Names,  Up: Completion

19.5.6 プログラム補完
----------------------------

意図した補完候補を持った連想リストやオブジェクト配列を
作成することが困難な場合もあります。
そのような場合、与えられた文字列に対する補完を計算する
独自の関数を与えることができます。 これを"プログラム補完"（programmed
completion）と呼びます。

   この機能を使うには、`completing-read'の引数COLLECTIONに
関数定義を持つシンボルを渡します。 関数`completing-read'は、
`try-completion'や`all-completions'に
読者の補完関数を渡すようにして、読者の関数にすべてを任せます。

   補完関数はつぎの3つの引数を受け取ります。

   * 補完すべき文字列。

   * 補完候補を選別する述語関数、あるいは、選別しないのならば`nil'。
     読者の関数では、各補完候補についてこの述語を呼び出し、
     `nil'が返されたら当該候補を無視する。

   * 操作の型を示すフラグ。

   3つの操作型に対応してフラグの値は3つあります。

   * `nil'は`try-completion'を指定する。
     補完関数は、指定された文字列の補完を返すこと。
     あるいは、文字列が一意に完全に一致する場合には`t'を返し、
     文字列の補完がまったくなければ`nil'を返す。

     文字列が一意に完全に一致する場合であっても、
     より長い候補に一致する場合には、
     この関数は`t'ではなく文字列を返すこと。

   * `t'は`all-completions'を指定する。
     補完関数は、指定された文字列に対する補完のリストを返すこと。

   * `lambda'は、完全な一致を指定する。
     補完関数は、指定された文字列が候補に完全に一致する場合には`t'を返し、
     さもなければ`nil'を返すこと。

   補完関数COLLECTIONには関数シンボルに加えて、
ラムダ式（関数であるリスト）も許すほうが
一貫性があって見通しがよいはずですが、それは不可能です。
リストには補完候補表としての意味がすでにあり、連想リストがそれです。
関数としての可能性もある通常の連想リストの扱いに失敗するようでは、
信頼性がなくなります。 そのため、読者が補完に使用したい関数は、
シンボルに入れておく必要があるのです。

   Emacsは、ファイル名の補完にはプログラム補完を用います。 *Note File
Name Completion::。


File: elisp-ja,  Node: Yes-or-No Queries,  Next: Multiple Queries,  Prev: Completion,  Up: Minibuffers

19.6 Yes/Noの問い合わせ
=============================

本節ではユーザーにyes/noを問い合わせるための関数について述べます。
関数`y-or-n-p'には、1文字で答えます。
誤った答えでも重大な問題に至らないような問い合わせに便利です。
`yes-or-no-p'には3文字か4文字で答える必要があるため、
より重要な問い合わせに適しています。

   これらの関数がマウスを使って起動されたコマンドから呼ばれると、
より正確には、`last-nonmenu-event'（*note Command Loop Info::）が
`nil'かリストであると、
関数は問い合わせのための対話ボックスやポップアップメニューを使います。
さもなければ、キーボード入力を使います。
呼び出しにおいて`last-nonmenu-event'に適切な値を束縛することで
マウスかキーボード入力の使用を強制できます。

   厳密にいえば、`yes-or-no-p'はミニバッファを使いますが、
`y-or-n-p'は使いません。 ですが、両者をここで説明しておきます。

 -- Function: y-or-n-p prompt
     この関数はユーザーに問い合わせ、エコー領域で入力を待ちます。
     ユーザーが`y'を打てば`t'を返し、 `n'を打てば`nil'を返します。
     さらに、<SPC>を「y」、<DEL>を「n」ともみなします。
     `C-]'を`C-g'のように『中断』ともみなします。
     というのは、問い合わせはミニバッファを使っているようにみえるので、
     これから抜けるためにユーザーが`C-]'を使いそうだからである。
     応答は1文字であり、<RET>で終える必要はない。
     大文字と小文字は同じ意味である。

     『問い合わせ』では、エコー領域にPROMPTを表示し、
     文字列`(y or n) 'が続きます。 入力が正しい応答（`y'、`n'、`<SPC>'、
     `<DEL>'、中断など）でないと、 関数は`Please answer y or
     n.'を表示して 問い合わせるを繰り返す。

     応答は編集できないので、この関数は実際にはミニバッファを使わない。
     ミニバッファが使うのと同じ画面領域を使う エコー領域（*note The
     Echo Area::）を実際には使う。
     問い合わせ中は、カーソルはエコー領域に移動する。

     応答とその意味は、
     たとえ`y'や`n'であっても組み込まれているわけではない。
     キーマップ`query-replace-map'がそれらを指定する。 *note Search and
     Replace::。

     以下の例では、ユーザーはまず`q'を打つが、これは正しくない。
     つぎのプロンプトに対して、ユーザーは`y'を打つ。

          (y-or-n-p "Do you need a lift? ")

          ;; 上の式を評価後には、エコー領域には
          ;; つぎのプロンプトが表示される

          ---------- Echo area ----------
          Do you need a lift? (y or n)
          ---------- Echo area ----------

          ;; ユーザーが`q'を打つと、つぎのようになる

          ---------- Echo area ----------
          Please answer y or n.  Do you need a lift? (y or n)
          ---------- Echo area ----------

          ;; ユーザーが正しい応答を打つと
          ;; 問い合わせのうしろに表示される

          ---------- Echo area ----------
          Do you need a lift? (y or n) y
          ---------- Echo area ----------

     ここでは、エコー領域のメッセージを複数行示したが、
     実際には、1度に1つのメッセージだけが表示される。

 -- Function: y-or-n-p-with-timeout prompt seconds default-value
     `y-or-n-p'と同様だが、ユーザーがSECONDS秒以内に答えないと、
     入力を待たずにDEFAULT-VALUEを返す。 これにはタイマを使う。 *note
     Timers::を参照。 引数SECONDSは整数でも浮動小数点でもよい。

 -- Function: yes-or-no-p prompt
     この関数はユーザーに問い合わせ、ミニバッファでの入力を仮定する。
     ユーザーが`yes'を入力すると`t'を返し、
     `no'を入力すると`nil'を返す。
     応答を終えるためにユーザーは<RET>を打つ必要がある。
     大文字と小文字は同じ意味である。

     `yes-or-no-p'は、まず、PROMPTに続けて
     `(yes or no) 'をエコー領域に表示する。
     ユーザーは正しい応答の1つを入力する必要がある。
     さもないと、この関数は`Please answer yes or no.'を2秒ほど
     表示してから問い合わせを繰り返す。

     `yes-or-no-p'は`y-or-n-p'よりもユーザーの手間を必要とし、
     より重要な決定に適している。

     例を示す。

          (yes-or-no-p "Do you really want to remove everything? ")

          ;; 上の式を評価後には、つぎのプロンプトが
          ;; 空のミニバッファとともに表示される

          ---------- Buffer: minibuffer ----------
          Do you really want to remove everything? (yes or no)
          ---------- Buffer: minibuffer ----------

     ユーザーは、まず`y <RET>'を打つが、
     この関数は完全な単語`yes'を要求するので正しくない。
     以下のプロンプトを少し時間をおいて表示する。

          ---------- Buffer: minibuffer ----------
          Please answer yes or no.
          Do you really want to remove everything? (yes or no)
          ---------- Buffer: minibuffer ----------


File: elisp-ja,  Node: Multiple Queries,  Next: Reading a Password,  Prev: Yes-or-No Queries,  Up: Minibuffers

19.7 複数のY/Nの問い合わせ
===================================

各バッファについて『バッファを保存するか』などの
一連の単純な問い合わせをする場合には、 個々に問い合わせるかわりに
`map-y-or-n-p'を用いてまとめて問い合わせるべきです。

 -- Function: map-y-or-n-p prompter actor list &optional help
          action-alist
     この関数は、各問について1文字の応答をエコー領域から読み取ることで、
     ユーザーに一連の問い合わせを行う。

     LISTの値は、問い合わせ対象のオブジェクトを指定する。
     オブジェクトのリストであるか、生成関数であること。
     関数である場合、それは引数なしで呼ばれ、
     つぎの問い合わせ対象のオブジェクトを返すか、
     問い合わせの終了を意味する`nil'を返す。

     引数PROMPTERは、各問い合わせをどのように問うかを指定する。
     PROMPTERが文字列であると、問い合わせ文はつぎのように計算される。

          (format PROMPTER OBJECT)

     ここで、OBJECTは（LISTから得た）
     問い合わせ対象のオブジェクトである。

     文字列でなければ、PROMPTERは
     1引数（問い合わせ対象のオブジェクト）の関数であり、
     問い合わせ文を返す。
     値が文字列であれば、それがユーザーへの問い合わせ文になる。
     関数は、（ユーザーに問い合わせずに）
     当該オブジェクトを処理することを意味する`t'か、
     （ユーザーに問い合わせずに）当該オブジェクトを無視することを意味する
     `nil'を返してもよい。

     引数ACTORは、ユーザーの応答に対してどのように動作するかを指定する。
     これは1引数の関数であり、ユーザーが「はい」と答えたオブジェクトで
     呼ばれる。 引数は、つねにLISTから得たオブジェクトである。

     引数HELPを指定する場合、つぎの形のリストであること。

          (SINGULAR PLURAL ACTION)

     ここで、 SINGULARは操作対象のオブジェクトを
     記述する単数形の名詞を含んだ文字列であり、
     PLURALは対応する複数形の名詞であり、
     ACTIONは動作を記述する他動詞であること。

     HELPを指定しないと、デフォルトは `("object" "objects" "act
     on")'である。

     各問い合わせでは、ユーザーは当該対象オブジェクトに対する操作に
     `y'、`Y'、`SPC'で答える。
     `n'、`N'、<DEL>は、そのオブジェクトを無視する。
     `!'はそのオブジェクトを含めて後続のものも処理する。
     <ESC>や`q'は（後続のオブジェクトをすべて無視して）抜ける。
     `.'（ピリオド）は現在の対象オブジェクトを処理してから抜ける。
     `C-h'はヘルプメッセージを表示する。
     これらは、`query-replace'が受け付ける応答と同じである。
     キーマップ`query-replace-map'が、 `query-replace'と同様に
     `map-y-or-n-p'に対する（応答の）意味を定義する。 *note Search and
     Replace::を参照。

     ACTION-ALISTを使って、
     可能な応答とそれらの意味を追加指定することもできる。
     これは、`(CHAR FUNCTION HELP)'の形の要素から成る
     連想リストであり、それぞれが1つの追加応答を定義する。
     この要素の中で、 CHARは（応答である）1つの文字、
     FUNCTIONは1引数（LISTからのオブジェクト）の関数、
     HELPは文字列である。

     ユーザーがCHARで答えると、 `map-y-or-n-p'はFUNCTIONを呼び出す。
     これが`nil'以外を返せば、当該オブジェクトを『処理』したとみなして、
     `map-y-or-n-p'はLISTのつぎのオブジェクトに移る。
     `nil'であると、同じオブジェクトについてプロンプトを繰り返す。

     `map-y-or-n-p'がマウスを使って起動されたコマンドから呼ばれると、
     より正確には、`last-nonmenu-event'（*note Command Loop Info::）が、
     `nil'かリストであると、
     関数は問い合わせのための対話ボックスやポップアップメニューを使う。
     その場合、キーボード入力やエコー領域は使わない。
     呼び出しにおいて`last-nonmenu-event'に適切な値を束縛することで
     マウスかキーボード入力の使用を強制できる。

     `map-y-or-n-p'の戻り値は、処理したオブジェクトの個数である。


File: elisp-ja,  Node: Reading a Password,  Next: Minibuffer Misc,  Prev: Multiple Queries,  Up: Minibuffers

19.8 パスワードの読み取り
===================================

別のプログラムへ渡すパスワードを読み取るには、
関数`read-passwd'を使います。

 -- Function: read-passwd prompt &optional confirm default
     この関数は、プロンプトPROMPTを表示してパスワードを読み取る。
     ユーザーが入力するパスワードは表示せず、
     そのかわりにパスワードの各文字ごとに`.'を表示する。

     省略可能な引数CONFIRMが`nil'以外であると、
     パスワードを2回読み取り、両者が同一である必要がある。
     同一でないと、連続して2回同じパスワードを打つまで
     ユーザーは何度でも繰り返す必要がある。

     省略可能な引数DEFAULTは、ユーザーが空のパスワードを
     入力したときに返すデフォルトのパスワードを指定する。
     DEFAULTが`nil'であると、
     `read-passwd'はそのような場面では空文字列を返す。


File: elisp-ja,  Node: Minibuffer Misc,  Prev: Reading a Password,  Up: Minibuffers

19.9 ミニバッファに関するその他
============================================

本節では、ミニバッファに関係する他の基本関数や変数について述べます。

 -- コマンド: exit-minibuffer
     このコマンドは活性なミニバッファから抜ける。
     通常、ミニバッファのローカルキーマップでキーにバインドされる。

 -- コマンド: self-insert-and-exit
     このコマンドは（*note Command Loop
     Info::の`last-command-char'にある）
     最新のキーボード入力文字を活性なミニバッファに挿入してから抜ける。

 -- コマンド: previous-history-element n
     このコマンドは、ミニバッファの内容を
     N番目まえの（古い）履歴要素の値で置き換える。

 -- コマンド: next-history-element n
     このコマンドは、ミニバッファの内容を
     N番目先のより新しい履歴要素の値で置き換える。

 -- コマンド: previous-matching-history-element pattern
     このコマンドは、ミニバッファの内容を
     PATTERN（正規表現）に一致するまえの（古い）履歴要素の値で置き換える。

 -- コマンド: next-matching-history-element pattern
     このコマンドは、ミニバッファの内容を
     PATTERN（正規表現）に一致するつぎの（新しい）履歴要素の値で置き換える。

 -- Function: minibuffer-prompt
     この関数は、現在活性なミニバッファのプロンプト文字列を返す。
     活性なミニバッファがなければ`nil'を返す。

 -- Function: minibuffer-prompt-width
     この関数は、現在活性なミニバッファのプロンプト文字列の表示幅を返す。
     活性なミニバッファがなければ0を返す。

 -- Variable: minibuffer-setup-hook
     ミニバッファに入るたびに実行されるノーマルフック。 *note Hooks::。

 -- Variable: minibuffer-exit-hook
     ミニバッファから抜けるたびに実行されるノーマルフック。 *note
     Hooks::。

 -- Variable: minibuffer-help-form
     この変数の現在値は、
     ミニバッファの内側で`help-form'のローカルな束縛に使われる。
     （*note Help Functions::）。

 -- Function: active-minibuffer-window
     この関数は、現在活性なミニバッファのウィンドウを返す。
     あるいは、活性なミニバッファがなければ`nil'を返す。

 -- Function: minibuffer-window &optional frame
     この関数は、フレームFRAMEで使われるミニバッファ用ウィンドウを返す。
     FRAMEが`nil'であると、カレントフレームを意味する。
     フレームで使うミニバッファ用ウィンドウは、
     そのフレームの一部である必要はない。
     ミニバッファを持たないフレームでは、
     他のフレームのミニバッファ用ウィンドウを使う。

 -- Function: window-minibuffer-p window
     この関数は、WINDOWがミニバッファ用ウィンドウであると
     `nil'以外を返す。

   与えられたウィンドウがミニバッファ用であるかどうかを調べるために、
`(minibuffer-window)'の戻り値と比較するのは正しくありません。
というのは、フレームが複数個あると
複数のミニバッファ用ウィンドウがあるからです。

 -- Function: minibuffer-window-active-p window
     この関数は、ミニバッファ用ウィンドウWINDOWが活性であると
     `nil'以外を返す。

 -- Variable: minibuffer-scroll-window
     この変数の値が`nil'以外であると、
     値はウィンドウオブジェクトであること。
     ミニバッファで関数`scroll-other-window'が呼ばれると、
     `scroll-other-window'はこのウィンドウをスクロールする。

   最後に、再帰ミニバッファ（*note Recursive Editing::）を扱う
関数と変数について述べます。

 -- Function: minibuffer-depth
     この関数は、活性なミニバッファの現在の深さを非負整数で返す。
     活性なミニバッファがなければ0を返す。

 -- User Option: enable-recursive-minibuffers
     この変数が`nil'以外であると、
     ミニバッファ用ウィンドウが活性であっても、
     （`find-file'などの）ミニバッファを使うコマンドを起動できる。
     そのような起動では、新たなミニバッファに対する再帰編集レベルが作られる。
     内側の（深い）ミニバッファを編集中には、
     外側の（浅い）レベルのミニバッファは見えない。

     この変数が`nil'であると、
     ミニバッファ用ウィンドウが活性なときには、
     別のウィンドウに切り替えたとしてもミニバッファコマンドは使えない。

   コマンド名に`nil'以外の 属性`enable-recursive-minibuffers'があると、
当該コマンドをミニバッファから起動したときでさえ、
当該コマンドはミニバッファを使って引数を読み取れます。
ミニバッファコマンド`next-matching-history-element'
（ミニバッファでは通常`M-s'）は、この機能を使っています。


File: elisp-ja,  Node: Command Loop,  Next: Keymaps,  Prev: Minibuffers,  Up: Top

20 コマンドループ
************************

読者がEmacsを起動すると、Emacsはほぼただちに"エディタコマンドループ"
（editor command loop）に入ります。
このループは、キー列を読み取り、それらの定義を実行し、結果を表示します。
本章では、これがどのように行われるのか、および、
Lispプログラムからこれを行うためのサブルーティンについて述べます。

* Menu:

* Command Overview::    How the command loop reads commands.
* Defining Commands::   Specifying how a function should read arguments.
* Interactive Call::    Calling a command, so that it will read arguments.
* Command Loop Info::   Variables set by the command loop for you to examine.
* Input Events::	What input looks like when you read it.
* Reading Input::       How to read input events from the keyboard or mouse.
* Special Events::      Events processed immediately and individually.
* Waiting::             Waiting for user input or elapsed time.
* Quitting::            How C-g works.  How to catch or defer quitting.
* Prefix Command Arguments::    How the commands to set prefix args work.
* Recursive Editing::   Entering a recursive edit,
                          and why you usually shouldn't.
* Disabling Commands::  How the command loop handles disabled commands.
* Command History::     How the command history is set up, and how accessed.
* Keyboard Macros::     How keyboard macros are implemented.


File: elisp-ja,  Node: Command Overview,  Next: Defining Commands,  Up: Command Loop

20.1 コマンドループの概要
===================================

コマンドループがまず始めに行うことはキー列、
つまり、コマンドへ変換されるイベント列を読むことです。
これには関数`read-key-sequence'を呼び出します。
読者のLispコードでもこの関数を呼び出せます（*note Key Sequence
Input::）。 Lispプログラムでは、`read-event'（*note Reading One
Event::）で 低レベルの入力を行ったり、 `discard-input'（*note Event
Input Misc::）で 処理待ち中の入力を破棄できます。

   キー列は現在活性なキーマップを介してコマンドに変換されます。
この処理方法については*Note Key Lookup::。
この結果は、キーボードマクロであるか、
対話的に呼び出し可能な関数であるはずです。
キーが`M-x'であると、別のコマンドの名前を読み取り、
そのコマンドを呼び出します。
これはコマンド`execute-extended-command'（*note Interactive Call::）で
処理されます。

   コマンドを実行するには、まず、その引数を読む必要があります。
これは、`command-execute'（*note Interactive Call::）を呼び出して
行います。 Lispで書かれたコマンドでは、
`interactive'指定が引数の読み方を指示します。 前置引数（*note Prefix
Command Arguments::）を使ったり、
プロンプトを表示してミニバッファ（*note Minibuffers::）から読みます。
たとえば、コマンド`find-file'には、
ミニバッファからファイル名を読むことを指示した
`interactive'指定があります。
コマンドの関数本体ではミニバッファを使いません。
このコマンドをLispコードから関数として呼び出す場合、
通常のLisp関数の引数としてファイル名文字列を指定する必要があります。

   コマンドが文字列やベクトル（つまり、キーボードマクロ）である場合、
`execute-kbd-macro'を用いてそれらを実行します。
読者自身がこの関数を呼び出してもかまいません（*note Keyboard
Macros::）。

   動作中のコマンドの実行を止めるには、`C-g'を打ちます。
この文字は"中断"（quitting）を引き起こします（*note Quitting::）。

 -- Variable: pre-command-hook
     エディタコマンドループは、各コマンドのまえにこのノーマルフックを実行する。
     その際、`this-command'にはこれから実行するコマンドが保持され、
     `last-command'には直前のコマンドがある。 *note Hooks::。

 -- Variable: post-command-hook
     エディタコマンドループは、
     （中断やエラーのために完了しなかったコマンドを含めて）
     各コマンドのあとにこのノーマルフックを実行する。
     初めてコマンドループに入ったときにも実行する。
     その際、`this-command'には実行し終えたばかりのコマンドがあり、
     `last-command'にはその前のコマンドがある。 *note Hooks::。

   `pre-command-hook'や`post-command-hook'の実行中は、
中断を禁止します。 これらのフックの1つを実行中にエラーが起きると、
エラーの無限ループを防ぐために、
フックの実行を終了しフック変数を`nil'にします。


File: elisp-ja,  Node: Defining Commands,  Next: Interactive Call,  Prev: Command Overview,  Up: Command Loop

20.2 コマンドの定義
==========================

Lisp関数の本体に、スペシャルフォーム`interactive'を呼び出す
フォームがトップレベルにあると、Lisp関数はコマンドになります。
このフォームは実際に呼び出されてもなにもしませんが、
このフォームがあることで、対話的に呼び出せることを表します。
その引数が、対話的呼び出しにおける引数の読み方を制御します。

* Menu:

* Using Interactive::     General rules for `interactive'.
* Interactive Codes::     The standard letter-codes for reading arguments
                             in various ways.
* Interactive Examples::  Examples of how to read interactive arguments.


File: elisp-ja,  Node: Using Interactive,  Next: Interactive Codes,  Up: Defining Commands

20.2.1 `interactive'の使い方
--------------------------------

本節では、Lisp関数を対話的に呼び出し可能なコマンドにするフォーム
`interactive'の書き方について述べます。

 -- Special Form: interactive arg-descriptor
     このスペシャルフォームは、これを含む関数がコマンドであり、
     （`M-x'や当該関数にバインドしたキー列を入力することで）
     対話的に呼び出せることを宣言する。
     引数ARG-DESCRIPTORは、コマンドを対話的に呼び出したときに
     コマンドに対する引数の計算方法を宣言する。

     他の関数と同様に、コマンドはLispプログラムからも呼び出せるが、
     その場合、呼び出し側が引数を渡し、ARG-DESCRIPTORにはなんの効果もない。

     フォーム`interactive'が効果を発揮するのは、
     コマンドループ（実際にはサブルーティン`call-interactively'）が
     関数を呼び出すまえに関数定義を走査してこのフォームを探すからである。
     関数が呼び出されると、フォーム`interactive'を含めて
     その本体のフォームが実行されるが、そのとき、
     `interactive'は引数を評価せずに単に`nil'を返す。

   引数ARG-DESCRIPTORには3つの可能性があります。

   * 省略するか`nil'。 この場合、コマンドは引数なしで呼ばれる。
     コマンドが1つ以上の引数を必要とする場合、これはただちにエラーになる。

   * 文字列ではないLisp式。 この場合、それはフォームであり、
     コマンドに渡す引数リストを得るために評価される。 

     この式が（ミニバッファを使うことを含めて）キーボード入力を読む場合には、
     入力を読むまえのポイントの整数値やマークは、
     入力を読んだあとでは正しくない可能性があることに留意すること。
     カレントバッファがサブプロセスの出力を受け取る可能性があるからである。
     コマンドが入力を待っているあいだにサブプロセスの出力が到着すると、
     ポイントやマークを再配置する可能性がある。

     しては_いけない_ことの例を示す。

          (interactive
           (list (region-beginning) (region-end)
                 (read-string "Foo: " nil 'my-history)))

     キーボード入力を読み終えてからポイントやマークを調べることで、
     問題を回避する。

          (interactive
           (let ((string (read-string "Foo: " nil 'my-history)))
             (list (region-beginning) (region-end) string)))

   * 文字列。 この場合、その内容は、コード文字とそれに続く
     （コード文字によっては使ったり無視する）プロンプトから成ること。
     プロンプトは、文字列の終りか改行で終る。 簡単な例を示す。

          (interactive "bFrobnicate buffer: ")

     コード文字`b'は、補完を用いて既存のバッファ名を読むことを指示する。
     バッファ名は、コマンドに渡される唯一の引数である。
     文字列の残りはプロンプトである。

     文字列内に改行文字があると、それはプロンプトを終える。
     その部分で文字列が終らないときには、
     文字列の残りの部分には、別の引数を指定するコード文字やプロンプトがある。
     このようにして、何個の引数でも指定できる。

     プロンプトの文字列では、プロンプト内の（第1引数から始まる）
     まえの引数値を含めるために`%'を使える。 これは`format'（*note
     Formatting Strings::）を用いて行う。
     たとえば、既存バッファの名前を読み、
     続けてそのバッファに与える新たな名前を読むにはつぎのようにする。

          (interactive "bBuffer to rename: \nsRename buffer %s to: ")

     文字列の最初の文字が`*'である場合、
     バッファが読み出し専用であるとエラーを通知する。

     文字列の最初の文字が`@'であり、
     コマンドを起動したキー列にマウスイベントが含まれる場合、
     コマンドを実行するまえに
     それらのイベントの最初のものに関連したウィンドウを選択する。

     `*'と`@'は同時に使え、その順序は関係ない。
     引数の実際の読み取りはプロンプトの
     （`*'でも`@'でもない最初の文字で始まる）残りの部分で制御される。


File: elisp-ja,  Node: Interactive Codes,  Next: Interactive Examples,  Prev: Using Interactive,  Up: Defining Commands

20.2.2 `interactive'のコード文字
--------------------------------------

以下に述べるコード文字の説明では、
つぎに定義するいくつかのキーワードを含みます。

「補完」
     補完を使える。 `completing-read'を使って引数を読むため、
     <TAB>、<SPC>、<RET>は名前を補完する （*note Completion::）。
     `?'は補完候補のリストを表示する。

「既存」
     既存オブジェクトの名前を必要とする。 不正な名前は受け付けない。
     現在の入力が正しくないとミニバッファから抜けるコマンドは動作しない。

「デフォルト」
     ミニバッファにユーザーがなにもテキストを入力しないときに
     使われるなんらかのデフォルト値。 デフォルトはコード文字に依存する。

「入出力なし」
     このコード文字は、入力をまったく読まずに引数を計算する。
     したがって、プロンプト文字列を使わず、
     読者が指定したプロンプト文字列は無視する。

     コード文字はプロンプト文字列を使わないが、
     この文字が文字列の最後の文字でない場合には改行を続けること。

「プロンプト」
     コード文字の直後にプロンプトが続く。
     プロンプトは文字列の終りか改行で終る。

「スペシャル」
     このコード文字は、対話指定文字列の先頭でのみ意味を持ち、
     プロンプトや改行を必要としない。 これは1つの孤立した文字である。

   以下に、`interactive'に使うコード文字を説明します。

`*'
     カレントバッファが読み出し専用であるとエラーを通知する。
     「スペシャル」。

`@'
     このコマンドを起動したキー列の最初のマウスイベントが表すウィンドウを選択する。
     「スペシャル」。

`a'
     関数名（つまり、`fboundp'を満たすシンボル）。
     「既存」、「補完」、「プロンプト」。

`b'
     既存バッファの名前。 デフォルトでは、カレントバッファ（*note
     Buffers::）の名前を使う。
     「既存」、「補完」、「デフォルト」、「プロンプト」。

`B'
     バッファ名。 バッファが既存である必要はない。
     デフォルトでは、カレントバッファ以外の最近使ったバッファの名前を使う。
     「補完」、「デフォルト」、「プロンプト」。

`c'
     文字。 カーソルはエコー領域には移動しない。 「プロンプト」。

`C'
     コマンド名（つまり、`commandp'を満たすシンボル）。
     「既存」、「補完」、「プロンプト」。

`d'
     整数としてのポイント位置（*note Point::）。 「入出力なし」。

`D'
     ディレクトリ名。
     デフォルトは、カレントバッファのカレントデフォルトディレクトリ
     `default-directory'（*note System Environment::）。
     「既存」、「補完」、「デフォルト」、「プロンプト」。

`e'
     コマンドを起動したキー列の最初やつぎのマウスイベント。
     より正確には、`e'はリストであるイベントを取得するので、
     読者はリスト内のデータを調べられる。 *note Input Events::。
     「入出力なし」。

     1つのコマンドの対話指定で複数回`e'を使える。
     コマンドを起動したキー列がN個のリストであるイベントである場合、
     N番目の`e'は、N番目のそのようなイベントを与える。 `e'では、
     ファンクションキーやASCII文字などのリストでないイベントは数えない。

`f'
     既存ファイルの名前（*note File Names::）。
     デフォルトディレクトリは`default-directory'。
     「既存」、「補完」、「デフォルト」、「プロンプト」。

`F'
     ファイル名。 ファイルが既存である必要はない。
     「補完」、「デフォルト」、「プロンプト」。

`i'
     無関係な引数。 このコードは、引数の値につねに`nil'を与える。
     「入出力なし」。

`k'
     キー列（*note Keymap Terminology::）。
     現在のキーマップにおいてコマンドがみつかる（あるいは未定義コマンド）まで
     イベントを読み続ける。
     キー列引数は、文字列かベクトルとして表現される。
     カーソルはエコー領域には移動しない。 「プロンプト」。

     この種の入力は、`describe-key'や`global-set-key'などの
     コマンドで使われる。

`K'
     キー列であり、読者がその定義を変更することを意図している。
     これは`k'と同様に動作するが、
     キー列の最後の入力イベントに対しては、
     未定義キーを定義済みのものに変換するために（必要なときに）普通使われる
     変換処理を抑制する。

`m'
     整数としてのマーク位置。 「入出力なし」。

`M'
     カレントバッファの入力方式を用いてミニバッファで読んだ任意のテキスト。
     文字列として返す （*note 入力方式: (emacs)Input Methods.）。
     「プロンプト」。

`n'
     ミニバッファで読んだ数。 入力が数でないと、ユーザーに再入力を促す。
     もし前置引数があってもそれは使わない。 「プロンプト」。

`N'
     数値前置引数。 前置引数がなければ、`n'で数を読む。 数を必要とする。
     *note Prefix Command Arguments::。 「プロンプト」。

`p'
     数値前置引数。 （この`p'は小文字。） 「入出力なし」。

`P'
     生の前置引数。 （この`P'は大文字。） 「入出力なし」。

`r'
     2つの数値引数としてのポイントとマーク。 小さいほうが先にくる。
     これは、1つではなく2つの連続した引数を指定する唯一のコード文字。
     「入出力なし」。

`s'
     ミニバッファで読んだ任意のテキスト。 文字列として返す（*note Text
     from Minibuffer::）。 `C-j'か<RET>で入力を終える。
     （これらの文字を入力に含めるには`C-q'を使う。） 「プロンプト」。

`S'
     ミニバッファで読んだ名前をインターンしたシンボル。
     白文字で入力を終える。 （文字列に白文字を含めるには`C-q'を使う。）
     （丸括弧や角括弧などの）通常はシンボルを終える他の文字は、
     ここではシンボルを終端しない。 「プロンプト」。

`v'
     ユーザーオプションと宣言された変数
     （つまり、述語`user-variable-p'を満たす）。 *note High-Level
     Completion::。 「既存」、「補完」、「プロンプト」。

`x'
     入力構文で表されたLispオブジェクト。 `C-j'か<RET>で終える。
     オブジェクトは評価しない。 *note Object from Minibuffer::。
     「プロンプト」。

`X'
     `x'のようにLispフォームを読むが、評価しその値がコマンドの引数になる。
     「プロンプト」。

`z'
     コーディングシステム名（シンボル）。
     ユーザーの入力が空であると、引数の値は`nil'。 *note Coding
     Systems::。 「補完」、「既存」、「プロンプト」。

`Z'
     このコマンドに前置引数を指定した場合にのみ、
     コーディングシステム名（シンボル）。
     前置引数がないと、`Z'は引数の値に`nil'を与える。
     「補完」、「既存」、「プロンプト」。


File: elisp-ja,  Node: Interactive Examples,  Prev: Interactive Codes,  Up: Defining Commands

20.2.3 `interactive'の使用例
--------------------------------

ここでは`interactive'の例を示します。

     (defun foo1 ()              ; `foo1'は引数なし
         (interactive)           ; 2単語分先へ進める
         (forward-word 2))
          => foo1

     (defun foo2 (n)             ; `foo2'は1引数
         (interactive "p")       ; 数値前置引数
         (forward-word (* 2 n)))
          => foo2

     (defun foo3 (n)             ; `foo3'は1引数
         (interactive "nCount:") ; ミニバッファで読む
         (forward-word (* 2 n)))
          => foo3

     (defun three-b (b1 b2 b3)
       "Select three existing buffers.
     Put them into three windows, selecting the last one."
         (interactive "bBuffer1:\nbBuffer2:\nbBuffer3:")
         (delete-other-windows)
         (split-window (selected-window) 8)
         (switch-to-buffer b1)
         (other-window 1)
         (split-window (selected-window) 8)
         (switch-to-buffer b2)
         (other-window 1)
         (switch-to-buffer b3))
          => three-b
     (three-b "*scratch*" "declarations.texi" "*mail*")
          => nil


File: elisp-ja,  Node: Interactive Call,  Next: Command Loop Info,  Prev: Defining Commands,  Up: Command Loop

20.3 対話的呼び出し
==========================

コマンドループでは、キー列をコマンドへ変換し終えると、
関数`command-execute'を用いてそのコマンドを起動します。
コマンドが関数であれば、`command-execute'は引数を読み取り、
コマンドを呼び出す`call-interactively'を呼びます。
読者自身がこれらの関数を呼び出してもかまいません。

 -- Function: commandp object
     OBJECTが対話的呼び出しに適していれば、
     つまり、OBJECTがコマンドであれば`t'を返す。
     さもなければ`nil'を返す。

     対話的呼び出しが可能なオブジェクトには、
     （キーボードマクロとして扱われる）文字列やベクトル、
     トップレベルで`interactive'を呼び出しているラムダ式、
     そのようなラムダ式をコンパイルしたバイトコード関数オブジェクト、
     対話的（`autoload'の4番目の引数が`nil'以外）
     と宣言された自動ロードオブジェクト、 一部の基本関数が含まれる。

     シンボルの関数定義が`commandp'を満たせば、
     シンボルも`commandp'を満たす。

     キーやキーマップはコマンドではない。
     それらはコマンドを探すために使われる（*note Keymaps::）。

     `commandp'の実用的な使用例については、 *note Accessing
     Documentation::の`documentation'を参照。

 -- Function: call-interactively command &optional record-flag keys
     この関数は、対話的呼び出し可能な関数COMMANDを
     その対話指定に従って引数を読み取り呼び出す。
     COMMANDが関数でなかったり、
     対話的に呼び出せない（つまり、コマンドでない）場合には、
     エラーを通知する。
     キーボードマクロ（文字列やベクトル）はコマンドとみなすが、
     それらは関数でないため、この関数はキーボードマクロを受け付けない。

     RECORD-FLAGが`nil'以外であると、
     コマンドとその引数を無条件にリスト`command-history'に追加する。
     さもなければ、引数を読むために
     コマンドがミニバッファを使った場合にのみ追加する。 *note Command
     History::。

     もし引数KEYSを指定すると、コマンドがそれを起動したイベントを
     問い合わせたときに与えるイベント列を指定する。

 -- Function: command-execute command &optional record-flag keys
     この関数はCOMMANDを実行する。 引数COMMANDは`commandp'を満たすこと。
     つまり、対話的呼び出し可能な関数かキーボードマクロであること。

     `command'が文字列やベクトルであると、
     `execute-kbd-macro'で実行される。
     関数であると、省略可能なRECORD-FLAGとともに関数を
     `call-interactively'に渡す。

     シンボルは、その関数定義を使って処理する。
     `autoload'で定義されたシンボルは、
     対話的呼び出し可能な関数と宣言されていればコマンドとみなす。
     そのような定義では、指定されたライブラリをロードしてから
     シンボルの定義を再検査して処理する。

     もし引数KEYSを指定すると、コマンドがそれを起動したイベントを
     問い合わせたときに与えるイベント列を指定する。

 -- コマンド: execute-extended-command prefix-argument
     この関数は`completing-read'（*note Completion::）を使って
     ミニバッファでコマンド名を読む。
     そして`command-execute'を使って指定されたコマンドを実行する。
     コマンドが返した値が`execute-extended-command'の値になる。

     コマンドが前置引数を必要とする場合、PREFIX-ARGUMENTの値を受け取る。
     `execute-extended-command'が対話的に呼ばれた場合、
     現在の生の前置引数がPREFIX-ARGUMENTとして使われ、
     それが実行するコマンドへ渡される。

     `execute-extended-command'は通常`M-x'に定義付けられ、
     そのため、プロンプトとして文字列`M-x 'を使う。
     （`execute-extended-command'を起動するために使われた
     イベントをプロンプトにするべきであるが、
     それを実装するのは手間がかかる。）
     もし前置引数を指定すると、その内容もプロンプトの一部になる。

          (execute-extended-command 1)
          ---------- Buffer: Minibuffer ----------
          1 M-x forward-word RET
          ---------- Buffer: Minibuffer ----------
               => t

 -- Function: interactive-p
     この関数は、これ（`interactive-p'の呼び出し）を含んだ関数が
     `call-interactively'で対話的に呼び出されると`t'を返す。
     （Lispから`call-interactively'が呼び出されても、
     エディタコマンドループが直接呼び出しても違いはない。）
     これを含んだ関数がLispの評価（あるいは`apply'や`funcall'）で
     呼び出された場合は、対話的呼び出しではない。

   `interactive-p'のもっとも一般的な用途は、
情報メッセージを表示するかどうか決めることです。
特別な例外として、キーボードマクロを実行中にはいつでも、
`interactive-p'は`nil'を返します。
これは情報メッセージを省いてマクロの実行を速くするためです。

   つぎのように使います。

     (defun foo ()
       (interactive)
       (when (interactive-p)
         (message "foo")))
          => foo

     (defun bar ()
       (interactive)
       (setq foobar (list (foo) (interactive-p))))
          => bar

     ;; `M-x foo'と打つ
          -| foo

     ;; `M-x bar'と打つ
     ;; これはなにも表示しない

     foobar
          => (nil t)

   この種のことを行う別の方法は、コマンドを
対話的呼び出しでは`nil'以外の値になる引数`print-message'を
取るようにし、その引数が`nil'以外になるような`interactive'指定を
使うことです。 つぎのようにします。

     (defun foo (&optional print-message)
       (interactive "p")
       (when print-message
         (message "foo")))

   `p'で与えられる数値前置引数はけっして`nil'になりません。


File: elisp-ja,  Node: Command Loop Info,  Next: Input Events,  Prev: Interactive Call,  Up: Command Loop

20.4 コマンドループからの情報
=========================================

エディタコマンドループは、自身や実行中のコマンドのために
状態記録を数個のLisp変数に設定します。

 -- Variable: last-command
     この変数は、コマンドループが（現在のコマンドの）まえに実行したコマンドの
     名前を記録する。
     通常、この値は関数定義を持つシンボルであるが、保証はしない。

     コマンドが後続のコマンドに対する前置引数を指定する場合を除いて、
     コマンドからコマンドループへ戻ると`this-command'から値をコピーする。

     この変数は現在の端末に対してつねにローカルであり、
     バッファに対してローカルにはならない。 *note Multiple Displays::。

 -- Variable: real-last-command
     `last-command'と同様にEmacsがこの変数に設定するが、
     Lispプログラムではけっして変更しない。

 -- Variable: this-command
     この変数は、エディタコマンドループが
     いま実行しているコマンドの名前を記録する。
     `last-command'と同様に、通常は関数定義を持つシンボルである。

     コマンドループは、コマンドを実行する直前にこの変数に設定し、
     コマンドが終了すると（コマンドが後続のコマンドに対する
     前置引数を指定する場合を除いて）
     この値を`last-command'にコピーする。

     後続のコマンドに対するフラグとして
     実行中にこの変数に設定するコマンドもある。
     特に、テキストをキルする関数群は`this-command'に`kill-region'を
     設定して、直後に続くキルコマンドでは
     キルしたテキストをまえのキルに追加するようにする。

   特定のコマンドがエラーを起こした場合に
直前のコマンドとは認識されたくない場合には、
読者はそのコマンドがそれを防ぐように書く必要があります。
1つの方法は、以下に示すように、
コマンドの始めで`this-command'に`t'を設定し、
コマンドの終りで`this-command'に正しい値を戻します。

     (defun foo (args...)
       (interactive ...)
       (let ((old-this-command this-command))
         (setq this-command t)
         ...do the work...
         (setq this-command old-this-command)))

`let'で`this-command'を束縛しません。
というのは、エラーがあると`let'は古い値を復元するからです。
これこそがここでは避けたい`let'の機能です。

 -- Function: this-command-keys
     この関数は、現在のコマンドに対して直前のコマンドが生成した前置引数を含めて、
     現在のコマンドを起動したキー列を含んだ文字列かベクトルを返す。
     すべてのイベントが文字であれば、値は文字列である。 *note Input
     Events::。

          (this-command-keys)
          ;; `C-u C-x C-e'を使ってこの式を評価する
               => "^U^X^E"

 -- Function: this-command-keys-vector
     `this-command-keys'と同様だが、つねにベクトルでイベントを返すため、
     文字列に入力イベントを保持する際の複雑さを扱う必要がない （*note
     Strings of Events::）。

 -- Variable: last-nonmenu-event
     この変数は、マウスメニューによるイベントを考慮せずに、
     キー列として読んだ最後の入力イベントを保持する。

     この変数の1つの用途は、
     メニューをポップアップする位置を`x-popup-menu'に指示することである。
     `y-or-n-p'（*note Yes-or-No Queries::）も内部的に使っている。

 -- Variable: last-command-event
 -- Variable: last-command-char
     この変数には、コマンドの一部としてコマンドループが
     読んだ最後の入力イベントが設定される。
     この変数の主な用途は、どの文字を挿入すべきかを決定するために
     `self-insert-command'が使うことである。

          last-command-event
          ;; `C-u C-x C-e'を使ってこの式を評価する
               => 5

     `C-e'のASCIIコードは5なので、値は5である。

     Emacs 18版との互換性のために別名`last-command-char'がある。

 -- Variable: last-event-frame
     この変数は、最後の入力イベントを振り向けたフレームを記録する。
     通常これは、イベントが生成されたときに選択されていたフレームであるが、
     そのフレームが入力フォーカスを別のフレームに振り向けていると、
     この値はイベントを振り向けた先のフレームである。 *note Input
     Focus::。


File: elisp-ja,  Node: Input Events,  Next: Reading Input,  Prev: Command Loop Info,  Up: Command Loop

20.5 入力イベント
=======================

Emacsのコマンドループは、キーボードやマウスのユーザーの操作を表す
"入力イベント"（input event）列を読みます。
キーボード操作に対するイベントは、文字かシンボルです。
マウスイベントはつねにリストです。
本節では、入力イベントの表現方法やその意味を詳しく説明します。

 -- Function: eventp object
     この関数は、OBJECTが入力イベントであるかイベント型であると
     `nil'以外を返す。

     任意のシンボルがイベントやイベント型として使われることに注意。
     `eventp'は、Lispのプログラムコードがシンボルを
     イベントとして使うかどうか区別できない。
     そのかわりに、シンボルが、Emacsの現在のセッションにおいて入力として読まれた
     イベントに使われたことがあるかどうかを区別する。
     シンボルがそのように使われたことがなければ、
     `eventp'は`nil'を返す。

* Menu:

* Keyboard Events::		Ordinary characters--keys with symbols on them.
* Function Keys::		Function keys--keys with names, not symbols.
* Mouse Events::                Overview of mouse events.
* Click Events::		Pushing and releasing a mouse button.
* Drag Events::			Moving the mouse before releasing the button.
* Button-Down Events::		A button was pushed and not yet released.
* Repeat Events::               Double and triple click (or drag, or down).
* Motion Events::		Just moving the mouse, not pushing a button.
* Focus Events::		Moving the mouse between frames.
* Misc Events::                 Other events window systems can generate.
* Event Examples::		Examples of the lists for mouse events.
* Classifying Events::		Finding the modifier keys in an event symbol.
				Event types.
* Accessing Events::		Functions to extract info from events.
* Strings of Events::           Special considerations for putting
				  keyboard character events in a string.


File: elisp-ja,  Node: Keyboard Events,  Next: Function Keys,  Up: Input Events

20.5.1 キーボードイベント
----------------------------------

キーボードからは2種類の入力があります。
普通のキーとファンクションキーです。 普通のキーは文字に対応します。
それらが生成するイベントは、Lispでは文字として表現されます。
文字イベントのイベント型は文字自身（整数）です。 *note Classifying
Events::を参照してください。

   入力文字イベントは、0から524287までの"基本コード"（basic code）と
以下の"修飾ビット"（modifier bit）の任意の組み合わせです。

meta
     文字コードのビット 2**27
     は、メタキーを押し下げながら文字を打ったことを表す。

control
     文字コードのビット 2**26 は非ASCII文字のコントロール文字を表す。

     `C-a'などのASCIIコントロール文字には
     独自の特別な基本コードがあるため、
     Emacsはそれを表すための特別なビットを必要としない。
     つまり、`C-a'のコードは単に1である。

     しかし、コントロールキーを使った`%'などの
     ASCIIにないコントロールとの組み合わせを打った場合、
     得られる数値は`%'のコードに 2**26 を加えたものである
     （端末で非ASCIIのコントロール文字を扱えるとして）。

shift
     文字コードのビット 2**25 は、シフトキーを押し下げながら
     ASCIIコントロール文字を打ったことを表す。

     英文字では、基本コードそのものが大文字か小文字かを表す。
     数字文字と区切り文字では、
     シフトキーは異なる基本コードのまったく異なる文字を選ぶ。
     可能な限りASCII文字集合ですませるために、
     これらの文字に対しては、Emacsはビット 2**25 を使わない。

     しかし、ASCIIでは`C-A'と`C-a'を区別できないため、
     Emacsは、`C-A'ではビット 2**25
     を使うが、`C-a'ではこのビットを使わない。

hyper
     文字コードのビット 2**24
     は、ハイパーキーを押し下げながら文字を打ったことを表す。

super
     文字コードのビット 2**23
     は、スーパーキーを押し下げながら文字を打ったことを表す。

alt
     文字コードのビット 2**22
     は、アルトキーを押し下げながら文字を打ったことを表す。
     （<ALT>とラベルされたキーが実際にはメタキーである端末も存在する。）

   読者のプログラム内では、
特定の修飾ビットの値を明示することは避けるのが最良です。
文字の修飾ビットを検査するには、 関数`event-modifiers'（*note
Classifying Events::）を使います。 キーバインディングを作るときには、
（`\C-'、`\M-'などの）修飾ビットを伴う文字の 入力表現を使います。
`define-key'でキーバインディングを作るときには、
文字の指定には`(control hyper ?x)'のようなリストを使います （*note
Changing Key Bindings::）。
関数`event-convert-list'は、そのようなリストを
イベント型に変換します（*note Classifying Events::）。


File: elisp-ja,  Node: Function Keys,  Next: Mouse Events,  Prev: Keyboard Events,  Up: Input Events

20.5.2 ファンクションキー
----------------------------------

ほとんどのキーボードには、"ファンクションキー"（function key）、
つまり、文字ではない名前や記号のキーがあります。 Emacs
Lispでは、ファンクションキーはシンボルで表現されます。
シンボルの（小文字の）名前がファンクションキーのラベルです。
たとえば、<F1>というラベルのキーを押すと、
入力ストリームにはシンボル`f1'が置かれます。

ファンクションキーイベントのイベント型は、イベントシンボルそれ自身です。
*Note Classifying Events::。

   ファンクションキーに対するシンボル命名慣習の特例を以下に示します。

`backspace', `tab', `newline', `return', `delete'
     これらのキーは、ほとんどのキーボードにある特別なキーを持つ
     一般的なASCIIコントロール文字に対応する。

     ASCIIでは、`C-i'と<TAB>は同じ文字である。
     これらを区別できる端末では、前者を整数9、後者をシンボル`tab'と
     表現することで、EmacsはLispプログラムに区別を伝える。

     ほとんどの場面では、これら2つを区別しても有用ではない。
     そのため、通常、`function-key-map'（*note Translating Input::）は、
     `tab'を9に対応付けるようには設定してある。
     したがって、文字コード9（文字`C-i'）に対するキーバインディングは
     `tab'にも適用される。 この種の他のシンボルについても同様である。
     関数`read-char'も同様にこれらのイベントを文字に変換する。

     ASCIIでは、<BS>は実際には`C-h'である。
     しかし、`backspace'は文字コード127（<DEL>）に変換され、
     文字コード8（<BS>）には変換されない。
     ほとんどのユーザーはこれを好む。

`left', `up', `right', `down'
     カーソル矢印キー

`kp-add', `kp-decimal', `kp-divide', ...
     （普通のキーボードの右側にある）キーパッドのキー。

`kp-0', `kp-1', ...
     キーパッドの数字キー。

`kp-f1', `kp-f2', `kp-f3', `kp-f4'
     キーパッドのPFキー

`kp-home', `kp-left', `kp-up', `kp-right', `kp-down'
     キーパッドの矢印キー。
     Emacsは、通常、これらを対応するキーパッドのものではない
     `home'、`left'、...のキーに変換する。

`kp-prior', `kp-next', `kp-end', `kp-begin', `kp-insert', `kp-delete'
     普通のキーに対応するキーパッドのキー。
     Emacsは、通常、同じ名前のキーパッドのものではないキーに変換する。

   ファンクションキーにも<ALT>、<CTRL>、<HYPER>、
<META>、<SHIFT>、<SUPER>の修飾キーを使えます。
それらを表現するには、シンボル名に接頭辞を付けます。

`A-'
     アルト修飾。

`C-'
     コントロール修飾。

`H-'
     ハイパー修飾。

`M-'
     メタ修飾。

`S-'
     シフト修飾。

`s-'
     スーパー修飾。

   したがって、<META>を押し下げた<F3>キーのシンボルは`M-f3'です。
複数の接頭辞を使うときには、アルファベット順に書くことを勧めますが、
キーバインディングの探索関数や修飾関数の引数では関係ありません。


File: elisp-ja,  Node: Mouse Events,  Next: Click Events,  Prev: Function Keys,  Up: Input Events

20.5.3 マウスイベント
----------------------------

Emacsでは4種類のマウスイベント、つまり、クリックイベント、ドラッグイベント、
ボタン押し下げイベント、モーションイベントを扱えます。
すべてのマウスイベントは、リストで表現します。
リストのCARはイベント型であり、
どの修飾キーとともにどのマウスボタンを使ったかを表します。
イベント型では、ダブル（連続2回）／トリプル（連続3回）の
押し下げも区別できます（*note Repeat Events::）。
リストの残りの要素は、位置情報と時間情報です。

   キーの探索では、イベント型のみが意味を持ちます。
型が同じであれば、異なるイベントでも同じコマンドを実行します。
コマンドでは、対話指定コード`e'を用いてイベントの完全な値を参照できます。
*Note Interactive Codes::。

マウスイベントで始まるキー列は、カレントバッファのキーマップではなく、
マウスが入っているウィンドウのバッファのキーマップを用いて読まれます。
つまり、あるウィンドウ内でクリックしても、
当該ウィンドウやバッファを選択するとは限らず、
その動作はキー列のコマンドバインディングで完全に制御されます。


File: elisp-ja,  Node: Click Events,  Next: Drag Events,  Prev: Mouse Events,  Up: Input Events

20.5.4 クリックイベント
-------------------------------

ユーザーがマウスのボタンを同じ場所で押し下げてから離すと、
"クリック"（click）イベントが生成されます。
マウスクリックイベントはつぎの形式です。

     (EVENT-TYPE
      (WINDOW BUFFER-POS (X . Y) TIMESTAMP)
      CLICK-COUNT)

   通常の各要素の意味はつぎのとおりです。

EVENT-TYPE
     どのマウスボタンが使われたかを表すシンボル。
     ボタンを左から右へ番号を付けて、
     シンボル`mouse-1'、`mouse-2'、...の1つである。

     ファンクションキーの場合と同様に、
     アルト、コントロール、ハイパー、メタ、シフト、スーパーの
     修飾キーを表す接頭辞`A-'、`C-'、`H-'、`M-'、 `S-'、`s-'も使える。

     このシンボルはイベントのイベント型としての役割も果たす。
     キーバインディングはイベント型でイベントを指定する。
     したがって、`mouse-1'に対するキーバインディングは、
     イベント型EVENT-TYPEが`mouse-1'であるすべてのイベントに適用される。

WINDOW
     クリックを行ったウィンドウ。

X, Y
     ウィンドウWINDOWの左上端を`(0 . 0)'とした
     クリック位置のピクセル単位の座標。

BUFFER-POS
     クリックした文字のバッファ内位置。

TIMESTAMP
     イベントが発生したときのミリ秒単位の時刻。 （この値は、Emacs
     Lispの整数の範囲では約5時間で一周するので、
     時間的に近傍のイベントを関連付ける場合にのみ有用である。）

CLICK-COUNT
     同じマウスボタンを素早く押し下げた繰り返し回数。 *note Repeat
     Events::。

モード行やスクロールバーなどのスクリーンの特別な部分で発生したイベントでは、
BUFFER-POS、XとYの意味は少々異なります。

   スクロールバーの内側でのクリックでは、
BUFFER-POSはシンボル`vertical-scroll-bar'か
`horizontal-scroll-bar'であり、 `(X . Y)'は`(PORTION . WHOLE)'に
置き換えられます。
ここで、PORTIONはスクロールバーの先頭や左端からのクリック位置、
WHOLEはスクロールバー全体の長さです。

   モード行やウィンドウWINDOWを右隣のものと区切る
縦方向の区切り行の内側では、
BUFFER-POSはシンボル`mode-line'か`vertical-line'です。
モード行では、Yは意味のあるデータではありません。
縦方向の区切り行では、Xは意味のあるデータではありません。

   1つの特別な場面では、
BUFFER-POSは単一のシンボルではなく（上に述べた1つの）シンボルを
含んだリストになります。
イベントに対する仮想的なプレフィックスキーを入力ストリームに挿入すると
このようになります。 *Note Key Sequence Input::。


File: elisp-ja,  Node: Drag Events,  Next: Button-Down Events,  Prev: Click Events,  Up: Input Events

20.5.5 ドラッグイベント
-------------------------------

Emacsには、ドラッグイベントがあります。
ユーザーがマウスボタンを押し下げてから、
ボタンを離すまえに別の文字位置へマウスを動かすと
"ドラッグ"（drag）イベントが発生します。
マウスのすべてのイベントのように、Lispではドラッグイベントは
リストとして表現されます。
つぎのように、リストは開始マウス位置と終了位置を記録しています。

     (EVENT-TYPE
      (WINDOW1 BUFFER-POS1 (X1 . Y1) TIMESTAMP1)
      (WINDOW2 BUFFER-POS2 (X2 . Y2) TIMESTAMP2)
      CLICK-COUNT)

   ドラッグイベントでは、シンボルEVENT-TYPEの名前には
接頭辞`drag-'が付きます。
たとえば、ボタン2を押し下げてマウスをドラッグすると
イベント`drag-mouse-2'が生成されます。
イベントの2番目と3番目の要素は、ドラッグの開始位置と終了位置を与えます。
なお、データにはクリックイベントと同じ意味があります（*note Click
Events::）。 ドラッグイベントかどうかを区別せずに、
マウスの任意のイベントの2番目の要素は同じ方法で参照できます。

   接頭辞`drag-'は、 `C-'や`M-'のような修飾キー接頭辞に続きます。

   `read-key-sequence'が、
キーバインディングを持たないドラッグイベントを受け取り、かつ、
それに対応するクリックイベントにはバインディングがある場合、
ドラッグイベントの開始位置をクリック位置とするクリックイベントに変換します。
つまり、望まなければ、読者はクリックイベントとドラッグイベントを区別する
必要がありません。


File: elisp-ja,  Node: Button-Down Events,  Next: Repeat Events,  Prev: Drag Events,  Up: Input Events

20.5.6 ボタン押し下げイベント
----------------------------------------

クリックイベントとドラッグイベントは、
ユーザーがマウスボタンを離したときに発生します。
ボタンを離すまではクリックとドラッグを区別する方法がないため、
ボタンを離すまで発生しえません。

   ボタンを押し下げたらただちに動作を始めたい場合には、
読者は"ボタン押し下げ"（button-down）イベントを処理する必要があります。
(1) ボタンを押し下げるとただちに発生します。
それらは、シンボルEVENT-TYPEの名前に 接頭辞`down-'があることを除けば、
クリックイベント（*note Click
Events::）とまったく同じリストで表現されます。
接頭辞`down-'は、`C-'や`M-'のような修飾キー接頭辞に続きます。

   関数`read-key-sequence'は、
コマンドバインディングを持たないボタン押し下げイベントを無視します。
したがって、Emacsのコマンドループもそれらを無視します。
つまり、読者がボタン押し下げイベントでなにかをしたいのでなければ、
読者はボタン押し下げイベントを定義する必要はありません。
ボタン押し下げイベントを定義する理由は、
ボタンが離されるまで（モーションイベントを読んで）マウスの動きを
追跡するためです。 *Note Motion Events::。

   ---------- Footnotes ----------

   (1) 「ボタン押し下げ」は、「ドラッグ」の対句。


File: elisp-ja,  Node: Repeat Events,  Next: Motion Events,  Prev: Button-Down Events,  Up: Input Events

20.5.7 繰り返しイベント
-------------------------------

マウスを動かさずに同一のマウスボタンを素早く連続して押し下げると、
Emacsは2回目以降の押し下げに対して
特別な"繰り返し"（repeat）マウスイベントを生成します。

   もっとも一般的な繰り返しイベントは"ダブルクリック"（double-click）
イベントです。
ボタンを2回クリックすると、Emcasはダブルクリックイベントを生成します。
（他のすべてのクリックイベントのように）読者がボタンを離したときに
イベントが生成されます。

   ダブルクリックイベントのイベント型には、接頭辞`double-'が含まれます。
したがって、<meta>を押し下げて2番目のボタンをダブルクリックすると、
Lispプログラムには`M-double-mouse-2'が送られます。
ダブルクリックイベントにバインディングがなければ、
対応する普通のクリックイベントを用いて実行します。
したがって、実際に利用したくない限りは、
読者はダブルクリック機能に注意する必要はありません。

ユーザーがダブルクリックすると、Emacsはまず普通のクリックイベントを生成し、
つぎにダブルクリックイベントを生成します。
したがって、ダブルクリックイベントのコマンドバインディングでは、
すでに普通のクリックコマンドが動作済みであると仮定して設計する必要があります。
普通のクリックの結果をもとに望みのダブルクリックの結果を得るようにします。

   普通のクリックの意味にダブルクリックの意味を
『追加』するようにすると便利です。
ダブルクリックのユーザーインターフェイスはこのようにすることを勧めます。

ボタンをクリックして、ふたたびボタンを押し下げてそのままマウスを動かすと、
最終的にボタンを離した時点で、"ダブルドラッグ"（double-drag）イベントが
生成されます。
そのイベント型には`drag'のかわりに`double-drag'が含まれます。
ダブルドラッグイベントにバインディングがなければ、
Emacsは普通のドラッグイベントとしてバインディングを探します。

   ダブルクリックイベントやダブルドラッグイベントを生成するまえに、
ユーザーがボタンを2回目に押し下げたとき、
Emacsは"ダブルダウン"（double-down）イベントを生成します。
このイベント型には`down'のかわりに`double-down'が含まれます。
ダブルダウンイベントにバインディングがなければ、
Emacsは普通のボタン押し下げイベントとしてバインディングを探します。
どちらでもバインディングがみつからなければ、ダブルダウンイベントは無視します。

   まとめると、ボタンをクリックしてただちに再度ボタンを押し下げると、
Emacsは、はじめのクリックに対してボタン押し下げイベントと
クリックイベントを生成し、
再度ボタンを押し下げるとダブルダウンイベントを生成し、
最後にダブルクリックイベントかダブルドラッグイベントを生成します。

   ボタンを2回クリックしてから再度押し下げる操作を素早く行うと、
Emacsは、"トリプルダウン"（triple-down）イベントに続けて
"トリプルクリック"（triple-click）イベントか
"トリプルドラッグ"（triple-drag）イベントを生成します。
これらのイベント型には`double'のかわりに`triple'が含まれます。
トリプルのイベントにバインディングがなければ、
Emacsは対応するダブルのイベントを使います。

   ボタンを3回以上クリックしてから再度押し下げると、
3回目以降の押し下げに対するイベントはすべてトリプルのイベントです。
Emacsは、クアドラプル（4回）、クインタプル（5回）、…などの
イベントは生成しません。
しかし、イベントリストを調べれば、ボタンを何回押したか正確にわかります。

 -- Function: event-click-count event
     この関数は、イベントEVENTにおいてボタンが連続して押された回数を返す。
     EVENTが、ダブルダウンイベント、ダブルクリックイベント、
     ダブルドラッグイベントであると、値は2である。
     EVENTがトリプルのイベントであると、値は3かそれ以上である。
     EVENTが（繰り返しイベントではない）普通のマウスイベントであると、
     値は1である。

 -- Variable: double-click-time
     繰り返しイベントが生成されるためには、
     同じスクリーン位置において連続してマウスボタンを押し下げ、しかも、
     各押し下げの間隔は`double-click-time'の値未満（ミリ秒）である必要がある。
     `double-click-time'に`nil'を設定すると、
     連続したクリックの検出を禁止する。
     `t'を設定すると時間制限をなくし、
     Emacsは連続したクリックの検出を位置だけで行う。


File: elisp-ja,  Node: Motion Events,  Next: Focus Events,  Prev: Repeat Events,  Up: Input Events

20.5.8 モーションイベント
----------------------------------

Emacsは、ボタン操作を伴わないマウスの移動を表す
"マウスモーション"（mouse motion）イベントを生成することがあります。
マウスモーションイベントはつぎのようなリストで表現されます。

     (mouse-movement (WINDOW BUFFER-POS (X . Y) TIMESTAMP))

   リストの2番目の要素は、クリックイベント（*note Click
Events::）と同様に、 マウスの現在位置を表します。

   スペシャルフォーム`track-mouse'により、
その本体の内側ではモーションイベントの生成を可能にできます。
フォーム`track-mouse'の外側では、
Emacsはマウスの移動のみに対するイベントを生成しないので、
それらのイベントは現れません。 *Note Mouse Tracking::。


File: elisp-ja,  Node: Focus Events,  Next: Misc Events,  Prev: Motion Events,  Up: Input Events

20.5.9 フォーカスイベント
----------------------------------

ウィンドウシステムは、どのウィンドウにキーボード入力を与えるかを
ユーザーが制御するための一般的な方法を提供します。
ウィンドウを選ぶことを"フォーカス"（focus）と呼びます。
ユーザーがEmacsのフレームを切り替える操作を行うと、
"フォーカスイベント"（focus event）が生成されます。
グローバルキーマップにあるフォーカスイベントの普通の定義は、
Emcasの新たなフレームを選択するようになっていて、
これはユーザーが期待することです。 *Note Input Focus::。

   Lispでは、フォーカスイベントはつぎのようなリストで表現されます。

     (switch-frame NEW-FRAME)

ここで、NEW-FRAMEは切り替え先のフレームです。

   Xのほとんどのウィンドウマネージャは、
マウスをウィンドウへ入れるだけで当該ウィンドウにフォーカスが設定される
ようになっています。
フレームにマウスが入るとカーソルの形状を変更するので、
Emacsでもそのようにします。 しかし、Lispプログラムにとっては、
なんらかの入力が到着するまではフォーカスの変更について知る必要がありません。
そのため、ユーザーが実際にキーボードのキーを打つか
新たなフレームでマウスボタンを押し下げたときだけ、
Emacsはフォーカスイベントを生成します。
フレーム間でマウスを動かしただけでは、フォーカスイベントは生成されません。

   キー列の途中にフォーカスイベントが現れると、キー列を乱します。
そのため、Emacsはキー列の途中にはフォーカスイベントを生成しません。
ユーザーがキー列の途中で、つまり、
プレフィックスキーのあとでフォーカスを変更すると、
複数イベントのキー列のまえかうしろにフォーカスイベントを移動し、
途中には現れないようにEmacsはイベントの順序を並び替えます。


File: elisp-ja,  Node: Misc Events,  Next: Event Examples,  Prev: Focus Events,  Up: Input Events

20.5.10 ウィンドウシステムのその他のイベント
--------------------------------------------------------------

ウィンドウシステム内で起きたことを表す他のイベントもあります。

`(delete-frame (FRAME))'
     この種のイベントは、
     Emacsのフレームであるウィンドウを削除するコマンドを
     ユーザーがウィンドウマネージャに与えたことを表す。

     イベント`delete-frame'の標準定義はフレームFRAMEの削除である。

`(iconify-frame (FRAME))'
     この種のイベントは、
     ウィンドウマネージャを用いてユーザーがフレームFRAMEを
     アイコン化したことを表す。 これに対する標準定義は`ignore'である。
     というのは、フレームはすでにアイコンになっているので、
     Emacsが行うことはなにもないからである。 このイベント型の目的は、
     必要ならばその種のイベントを読者が追跡できるようにしておくことである。

`(make-frame-visible (FRAME))'
     この種のイベントは、
     ウィンドウマネージャを用いてユーザーがアイコン化したフレームFRAMEを
     開いたことを表す。 これに対する標準定義は`ignore'である。
     というのは、フレームはすでに見えるようになっているので、
     Emacsが行うことはなにもないからである。

`(mouse-wheel POSITION DELTA)'
     この種のイベントは、
     （MSインテリマウスなどの）マウスのホイールを動かすと生成される。
     その典型的な効果はスクロールやズーミングである。

     要素DELTAはホイールの回転方向と回転量である。
     その絶対値はホイールを回すごとに増加する数である。
     負のDELTAは、逆転、つまり、ユーザーへ近付く方向への回転を表し、
     正のDELTAは、順転、つまり、ユーザーから遠ざかる方向への回転を表す。

     要素POSITIONはイベントの発生位置を表し、
     マウスクリックイベントで使われる形式と同じである。

     この種のイベントは、ある種のシステムでのみ生成される。

`(drag-n-drop POSITION FILES)'
     この種のイベントは、
     Emacsの外側のアプリケーションで一群のファイルを選択し、
     それらをEmacsのフレームにドラッグ＆ドロップしたときに生成される。

     要素POSITIONはイベントの発生位置を表し、
     マウスクリックイベントで使われる形式と同じであり、
     要素FILESはドラッグ＆ドロップされたファイル名のリストである。
     このイベントを扱う通常の処理は、それらのファイルを訪問することである。

     現状では、この種のイベントは、ある種のシステムでのみ生成される。

   これらのイベントがキー列の途中、つまり、
プレフィックスキーのうしろに現れると、
複数イベントのキー列のまえかうしろに当該イベントを移動し、
途中には現れないようにEmacsはイベントの順序を並び替えます。


File: elisp-ja,  Node: Event Examples,  Next: Classifying Events,  Prev: Misc Events,  Up: Input Events

20.5.11 イベントの例
--------------------------

ユーザーが同じ場所でマウスの左ボタンを押し下げてから離すと、
つぎのようなイベント列が生成されます。

     (down-mouse-1 (#<window 18 on NEWS> 2613 (0 . 38) -864320))
     (mouse-1      (#<window 18 on NEWS> 2613 (0 . 38) -864180))

   コントロールキーを押し下げた状態で、
ユーザーがマウスの2番目のボタンを押し下げ、
マウスをつぎの行へドラッグすると、つぎのような2つのイベントが生成されます。

     (C-down-mouse-2 (#<window 18 on NEWS> 3440 (0 . 27) -731219))
     (C-drag-mouse-2 (#<window 18 on NEWS> 3440 (0 . 27) -731219)
                     (#<window 18 on NEWS> 3510 (0 . 28) -729648))

   メタキーとシフトキーを押し下げた状態で、
ユーザーがマウスの2番目のボタンをウィンドウのモード行で押し下げ、
マウスを別のウィンドウへドラッグすると、
つぎのような2つのイベントが生成されます。

     (M-S-down-mouse-2 (#<window 18 on NEWS> mode-line (33 . 31) -457844))
     (M-S-drag-mouse-2 (#<window 18 on NEWS> mode-line (33 . 31) -457844)
                       (#<window 20 on carlton-sanskrit.tex> 161 (33 . 3)
                        -453816))


File: elisp-ja,  Node: Classifying Events,  Next: Accessing Events,  Prev: Event Examples,  Up: Input Events

20.5.12 イベントの分類
-----------------------------

各イベントには"イベント型"（event type）があって、
キーバインディング処理のためにイベントを分類します。
キーボードイベントでは、イベント型はイベントの値に等しいです。
したがって、文字に対するイベント型は文字であり、
ファンクションキーに対するイベント型はシンボルそのものです。
リストであるイベントでは、イベント型はリストのCARにあるシンボルです。
したがって、イベント型はつねにシンボルか文字です。

イベント型が同じであるイベントは、キーバインディングに関する限り同じです。
つまり、それらは同じコマンドを実行します。
しかし、これは、それらが必ずしも同じことを行うという意味ではありません。
イベント全体を調べてなにを行うかを決定するコマンドもあります。
たとえば、マウスイベントの生起位置を使って、
バッファのどの部分を処理するかを決めるコマンドもあります。

   イベントをおおまかに分類すると有用な場合もあります。
たとえば、他の修飾キーやマウスボタンには関係なしに、
<META>キーが使われているイベントかどうか調べたいことがあるでしょう。

   関数`event-modifiers'や`event-basic-type'は、
そのような情報を便利に与えるためのものです。

 -- Function: event-modifiers event
     この関数は、EVENTにある修飾子のリストを返す。
     修飾子はシンボルであり、`shift'、`control'、
     `meta'、`alt'、`hyper'、`super'である。
     さらに、マウスイベントシンボルの修飾子リストには、
     必ず、`click'、`drag'、`down'の1つが含まれる。

     引数EVENTは、イベントオブジェクト全体であるか、単なるイベント型である。

     例を示す。

          (event-modifiers ?a)
               => nil
          (event-modifiers ?\C-a)
               => (control)
          (event-modifiers ?\C-%)
               => (control)
          (event-modifiers ?\C-\S-a)
               => (control shift)
          (event-modifiers 'f5)
               => nil
          (event-modifiers 's-f5)
               => (super)
          (event-modifiers 'M-S-f5)
               => (meta shift)
          (event-modifiers 'mouse-1)
               => (click)
          (event-modifiers 'down-mouse-1)
               => (down)

     クリックイベントに対する修飾子リストには`click'が明示的に含まれるが、
     イベントシンボルの名前自体には`click'は含まれない。

 -- Function: event-basic-type event
     この関数は、EVENTにあるキーやマウスボタンを返す。
     たとえばつぎのとおり。

          (event-basic-type ?a)
               => 97
          (event-basic-type ?A)
               => 97
          (event-basic-type ?\C-a)
               => 97
          (event-basic-type ?\C-\S-a)
               => 97
          (event-basic-type 'f5)
               => f5
          (event-basic-type 's-f5)
               => f5
          (event-basic-type 'M-S-f5)
               => f5
          (event-basic-type 'down-mouse-1)
               => mouse-1

 -- Function: mouse-movement-p object
     この関数は、OBJECTがマウス移動のイベントならば`nil'以外を返す。

 -- Function: event-convert-list list
     この関数は、修飾子名と基本イベント型のリストを
     それらが示すイベント型に変換する。 たとえばつぎのとおり。

          (event-convert-list '(control ?a))
               => 1
          (event-convert-list '(control meta ?a))
               => -134217727
          (event-convert-list '(control super f1))
               => C-s-f1


File: elisp-ja,  Node: Accessing Events,  Next: Strings of Events,  Prev: Classifying Events,  Up: Input Events

20.5.13 イベントの参照
-----------------------------

本節では、マウスボタンイベントやモーションイベント内のデータを
参照するための便利な関数について述べます。

   つぎの2つの関数は、以下の形式のリストであるマウスボタンイベントの
開始位置や終了位置を返します。

     (WINDOW BUFFER-POSITION (X . Y) TIMESTAMP)

 -- Function: event-start event
     イベントEVENTの開始位置を返す。

     EVENTがクリックイベントやボタン押し下げイベントであると、
     イベントの位置を返す。
     EVENTがドラッグイベントであると、ドラッグの開始位置を返す。

 -- Function: event-end event
     イベントEVENTの終了位置を返す。

     EVENTがドラッグイベントであると、
     ユーザーがマウスボタンを離したときの位置を返す。
     EVENTがクリックイベントかボタン押し下げイベントであると、
     実際の値は開始位置であり、
     その種のイベントにある唯一の位置情報である。

   つぎの5つの関数は、上に述べた位置情報のリストを引数として、
そのさまざまな部分を返す。

 -- Function: posn-window position
     POSITION内のウィンドウを返す。

 -- Function: posn-point position
     POSITIONのバッファ内位置を返す。 これは整数である。

 -- Function: posn-x-y position
     POSITION内のピクセル単位のxy座標を コンスセル`(X . Y)'として返す。

 -- Function: posn-col-row position
     POSITIONの（文字単位の）行（row）とコラム（col）の座標を
     コンスセル`(COL . ROW)'として返す。
     これらは実際にはPOSITION内のXとYの値から計算される。

 -- Function: posn-timestamp position
     POSITION内の時刻情報を返す。

   つぎの関数はスクロールバーでのイベントを解読するのに便利です。

 -- Function: scroll-bar-event-ratio event
     スクロールバー内でのイベントから、スクロールバーに対する縦方向の位置を返す。
     その値は2つの整数を含むコンスセル`(PORTION . WHOLE)'であり、
     その比は位置の割合を表す。

 -- Function: scroll-bar-scale ratio total
     この関数は（実質的には）RATIOにTOTALを掛け、 結果を整数に丸める。
     引数RATIOは数ではなく`(NUM . DENOM)'であり、
     典型的には`scroll-bar-event-ratio'が返す値である。

     この関数はスクロールバー内での位置を
     バッファ内での位置へ換算するのに便利である。 つぎのように行う。

          (+ (point-min)
             (scroll-bar-scale
                (posn-x-y (event-start event))
                (- (point-max) (point-min))))

     スクロールバー内でのイベントには、
     xy座標のかわりに比を表す2つの整数があることに注意。


File: elisp-ja,  Node: Strings of Events,  Prev: Accessing Events,  Up: Input Events

20.5.14 キーボードイベントを文字列で保持する
--------------------------------------------------------------

文字列が使われるほとんどの場面では、 文字列にはテキスト文字、つまり、
バッファやファイルにある文字と同じ種類のものが入っていると考えています。
文字列にはキーボード文字が入っているとみなして使うLispプログラムもあります。
たとえば、文字列には、キー列やキーボードマクロの定義が入っているのです。
しかし、キーボード文字を文字列に保持するのは複雑であり、
それは歴史的な互換性を保つためにするのであり、
また、つねに可能とは限りません。

   新しいプログラムでは、キーボードイベントを文字列に保持しないで、
このような複雑さを避けるように推奨します。 つぎのようにします。

   * キー列に対しては、それらを`lookup-key'や`define-key'に対する
     引数以外にも使うつもりならば、文字列のかわりにベクトルを使う。
     たとえば、`read-key-sequence'のかわりに`read-key-sequence-vector'を
     `this-command-keys'のかわりに`this-command-keys-vector'を使う。

   * メタ文字を含むキー列は、
     それらを`define-key'に直接渡す場合であっても、ベクトルで書く。

   * 文字列である可能性があるキー列の内容を調べるときには、
     `listify-key-sequence'（*note Event Input Misc::）を使って、
     それをリストに変換しておく。

   複雑さの原因は、キーボード入力に含まれる修飾ビットにあります。
メタ修飾子以外の修飾ビットを文字列に入れることは不可能であり、
メタ修飾子は特別な場合として唯一許されているのです。

   初期のGNU
Emacsでは、メタ文字を128から255の範囲のコードで表現していました。
その当時、基本文字コードは0から127でしたから、
キーボード文字のすべてのコードは文字列に収まったのです。
多くのLispプログラムでメタ文字を表すために文字列定数内で`\M-'を使い、
特に、`define-key'や類似の関数に対する引数に使われ、
キー列やイベント列はつねに文字列で表現されていました。

127を超える大きな基本文字コードと追加の修飾ビットを扱えるようにしたとき、
メタ文字の表現方法を変更せざるをえませんでした。
現在、メタ修飾子を表す文字内のビットは 2**27
であり、そのような数を文字列に入れることはできません。

   文字列定数で`\M-'を使っているプログラムを扱えるように、
文字列にメタ文字を入れるための特別な規則があります。
以下は、文字列を入力文字の列として解釈するための規則です。

   * キーボード文字の値が0から127の範囲にあれば、
     無変更で文字列に入れる。

   * コードが 2**27 から 2**27+127,
     の範囲にあるこれらの文字のメタ変種は文字列に入れられるが、
     それらの数値を変更する必要がある。 ビット 2**27 のかわりに 2**7
     ビットに変更し、 128から255の範囲の値にする。
     ユニバイト文字列だけにこれらのコードを入れられる。

   * 256以上の非ASCII文字はマルチバイト文字列だけに入れられる。

   * その他のキーボード文字イベントは文字列に収められない。
     これには、128から255の範囲のキーボードイベントも含む。

   キーボード入力文字の文字列を作る`read-key-sequence'などの関数は
つぎの規則に従います。
つまり、文字列に収まらないイベントであるときには、
文字列のかわりにベクトルを作ります。

   読者が文字列で`\M-'の入力構文を使うと、
それらは128から255の範囲のコードになります。
対応するキーボードイベントを文字列に保存するように変更したときに得られる
コードと同じです。
したがって、文字列内のメタイベントは、それらがどのように文字列に
収められたかに関わらず、整合性のある動作をします。

しかし、本節のはじめに述べた推奨方法に従ってこれらのことがらを避けるほうが、
ほとんどのプログラムはよりよく動作するでしょう。


File: elisp-ja,  Node: Reading Input,  Next: Special Events,  Prev: Input Events,  Up: Command Loop

20.6 入力の読み取り
==========================

エディタコマンドループは、
関数`read-key-sequence'を使ってキー列を読み取ります。
なお、関数`read-key-sequence'は関数`read-event'を使います。
これらやイベント入力を扱う他の関数は、Lispプログラムからも使えます。
*note Temporary Displays::の`momentary-string-display'、 および、*note
Waiting::の`sit-for'を参照してください。
端末の入力モードの制御や端末入力のデバッグに関する関数や変数については、
*Note Terminal Input::。
入力イベントを読むときにそれらを変換したり修正する機能については、
*Note Translating Input::。

   上位レベルの入力機能については、*note
Minibuffers::を参照してください。

* Menu:

* Key Sequence Input::		How to read one key sequence.
* Reading One Event::		How to read just one event.
* Quoted Character Input::	Asking the user to specify a character.
* Event Input Misc::    	How to reread or throw away input events.


File: elisp-ja,  Node: Key Sequence Input,  Next: Reading One Event,  Up: Reading Input

20.6.1 キー列の入力
-------------------------

コマンドループは、`read-key-sequence'を呼ぶことで
キー列の入力を読み取ります。
Lispプログラムからこの関数を呼び出してもよく、
たとえば、`describe-key'は、
説明対象とするキーを読むためにこの関数を使います。

 -- Function: read-key-sequence prompt
     この関数は、キー列を読み取り文字列かベクトルとして返す。
     完全なキー列を収集し終えるまで、
     つまり、現在活性なキーマップにおいて、非プレフィックスコマンドを
     指定するのに十分になるまで、イベントを読み続ける。

     イベントがすべて文字であり、かつ、それらが文字列に収まるならば、
     `read-key-sequence'は文字列（*note Strings of Events::）を返す。
     さもなければ、ベクトルを返す。
     ベクトルならば、任意の種類のイベント、つまり、
     文字、シンボル、リストを保持できるからである。
     文字列やベクトルの要素は、キー列のイベントである。

     引数PROMPTは、プロンプトとしてエコー領域に表示する文字列であるか、
     あるいは、プロンプトを表示しないことを意味する`nil'である。

     以下の例では、プロンプト`?'がエコー領域に表示され、 ユーザーは`C-x
     C-f'と打つ。

          (read-key-sequence "?")

          ---------- Echo Area ----------
          ?C-x C-f
          ---------- Echo Area ----------

               => "^X^F"

     関数`read-key-sequence'は中断を抑止する。
     この関数が動作中に`C-g'を打っても、他の文字と同様に扱い、
     `quit-flag'を設定しない。 *note Quitting::。

 -- Function: read-key-sequence-vector prompt
     これは`read-key-sequence'と同様であるが、
     つねにベクトルとしてキー列を返し、文字列としてはけっして返さない。
     *note Strings of Events::。

   入力文字が大文字であって、それらにキーバインディングがないとき、
対応する小文字にキーバインディングがあれば、
`read-key-sequence'は文字を小文字に変換します。
`lookup-key'はこのような変換を行わないことに注意してください。

   関数`read-key-sequence'は、ある種のマウスイベントも変換します。
バインディングのないドラッグイベントをクリックイベントに変換したり、
バインディングのないボタン押し下げイベントを完全に無視します。
さらに、フォーカスイベントとその他のウィンドウイベントを並び替えて、
それらが他のイベントのキー列の途中に現れないようにします。

マウスイベントが、モード行やスクロールバーなどのウィンドウの特別な部分で
生起しても、特別なイベント型はなく、マウスボタンや修飾キーの
組み合わせを普通どおりに表したシンボルです。
ウィンドウのどの部分かに関する情報は、
イベント内の別の部分、つまり、座標に入っています。
しかし、`read-key-sequence'は、その情報を
シンボル`mode-line'、`vertical-line'、`horizontal-scroll-bar'、
`vertical-scroll-bar'を用いた仮想的な『プレフィックスキー』に変換します。
ウィンドウの特別な部分におけるマウスクリックの意味は、
これらの仮想的なプレフィックスキーを用いてキー列を定義することで
定義できます。

   たとえば、`read-key-sequence'を呼び出してから、
ウィンドウのモード行でクリックすると、
つぎのような2つのイベントを得ます。

     (read-key-sequence "Click on the mode line: ")
          => [mode-line
              (mouse-1
               (#<window 6 on NEWS> mode-line
                (40 . 63) 5959987))]

 -- Variable: num-input-keys
     この変数の値は、現在のEmacsセッションにおいて、
     これまでに処理されたキー列の個数である。
     これには、端末から読み取ったキー列、および、
     実行したキーボードマクロから読み取ったキー列が含まれる。

 -- Variable: num-nonmacro-input-events
     この変数は、端末からこれまでに受け取った入力イベントの総個数を保持する。
     キーボードマクロで生成されたものは含まない。


File: elisp-ja,  Node: Reading One Event,  Next: Quoted Character Input,  Prev: Key Sequence Input,  Up: Reading Input

20.6.2 単一イベントの読み取り
----------------------------------------

コマンド入力用の最低レベルの関数は、単一イベントを読み取る関数です。

 -- Function: read-event &optional prompt suppress-input-method
     この関数は、必要ならばイベントの到着を待って、
     コマンド入力のつぎのイベントを読み取って返す。
     イベントは、ユーザーか（実行中の）キーボードマクロから直接得る。

     PROMPTが`nil'以外であると、
     これはプロンプトとしてエコー領域に表示される文字列であること。
     さもなければ、`read-event'は
     入力待ちであることを示すメッセージを表示せずに、
     そのかわりに、現在のコマンドを実行するに至ったイベントや
     現在のコマンドが読み取ったイベントをプロンプトとして表示する。
     *note The Echo Area::。

     SUPPRESS-INPUT-METHODが`nil'以外であると、
     このイベントの読み取りに関しては現在の入力方式を使わない。
     入力方式の処理をせずにイベントを読みたいときには、
     つねにこのようにすること。
     `input-method-function'を束縛してはならない（下記参照）。

     変数`cursor-in-echo-area'が`nil'以外であると、
     `read-event'は、エコー領域に表示されたメッセージの末尾に
     カーソルを一時的に移動する。
     さもなければ、`read-event'はカーソルを移動しない。

     `read-event'がヘルプ文字と定義されたイベントを受け取ると、
     それを返さずに`read-event'がイベントを直接処理してしまう場合がある。
     *note Help Functions::。 "特殊イベント"（special
     event）と呼ばれる他のイベントも `read-event'が直接処理する（*note
     Special Events::）。

     `read-event'を呼んで右矢印のファンクションキーを押すとつぎのようになる。

          (read-event)
               => right

 -- Function: read-char
     この関数はコマンド入力の文字を読み取りそれを返す。
     文字を得るまで、文字以外のイベントはすべて破棄する。

     最初の例では、ユーザーは文字`1'（ASCIIコード49）を打つ。
     2番目の例は、`eval-expression'を使って
     ミニバッファから`read-char'を呼び出すキーボードマクロの定義である。
     `read-char'はキーボードマクロの直後の文字、つまり、`1'を読む。
     そして、`eval-expression'はその戻り値をエコー領域に表示する。

          (read-char)
               => 49

          ;; これを評価するために読者は`M-:'を使うと仮定する
          (symbol-function 'foo)
               => "^[:(read-char)^M1"
          (execute-kbd-macro 'foo)
               -| 49
               => nil

   `read-event'は、あれば現在の入力方式も起動します。
`input-method-function'が`nil'以外であれば、 それは関数であるはずです。
`read-event'が修飾ビットのない（<SPC>を含む）印字文字を読み取ると、
引数としてイベントを渡してその関数を呼び出します。

 -- Variable: input-method-function
     これが`nil'以外であると、その値は現在の入力方式関数を指定する。

     *注意：*` ' この変数を`let'で束縛しないこと。
     この変数はしばしばバッファローカルであり、
     入力を読む周囲で束縛すると（読者がこれをもっとも束縛_しそうな_ところ）、
     Emacsが入力を待っているときにバッファが非同期に切り替わると、
     誤ったバッファに値を復元してしまうことがある。

   入力方式関数は、入力として使われるイベントのリストを返すべきです。
（リストが`nil'であると入力がなかったことを意味し、
`read-event'は別のイベントを待つ。） これらのイベントは、
`unread-command-events'内のイベントよりまえに処理されます。
入力方式関数が返したイベントは、それらが修飾ビットがない印字文字であっても、
入力方式関数に再度渡されることはありません。

   入力方式関数が`read-event'や`read-key-sequence'を呼び出すときには、
`input-method-function'を`nil'に束縛して 再帰呼び出しを防ぐべきです。

キー列の2番目以降のイベントを読むときには、入力方式関数を呼び出しません。
したがって、それらの文字は、入力方式処理の対象ではありません。
入力方式の処理では、
`overriding-local-map'と`overriding-terminal-local-map'の値を
検査するのがよいです。 これらの変数のいずれかが`nil'以外であるときには、
入力方式ではその引数をリストに入れ、
それ以上処理せずにそのリストを返すべきです。


File: elisp-ja,  Node: Quoted Character Input,  Next: Event Input Misc,  Prev: Reading One Event,  Up: Reading Input

20.6.3 クォートした文字の入力
----------------------------------------

ユーザーに文字入力を促して、コントロール文字やメタ文字を
文字そのものや文字の8進数コードで手軽に入力できるようにするには、
関数`read-quoted-char'を使います。
コマンド`quoted-insert'は、この関数を使っています。

 -- Function: read-quoted-char &optional prompt
     この関数は`read-char'に似ているが、
     最初に読んだ文字が8進数字文字（0-7）であると、
     任意個数の8進数字文字を読み取り（8進数字文字以外が現れると止める）、
     その数値の文字コードが表す文字を返す。

     最初の文字を読むと中断を抑制するので、
     ユーザーは`C-g'を入力できる。 *note Quitting::。

     PROMPTを与えると、それはユーザーへのプロンプトを表す文字列を指定する。
     プロンプト文字列はつねにエコー領域に表示され、あとに`-'が続く。

     つぎの例では、ユーザーは8進数177（10進数では127）を打つ。

          (read-quoted-char "What character")

          ---------- Echo Area ----------
          What character-177
          ---------- Echo Area ----------

               => 127


File: elisp-ja,  Node: Event Input Misc,  Prev: Quoted Character Input,  Up: Reading Input

20.6.4 その他のイベント入力機能
-------------------------------------------

本節では、イベントを処理せずに『まえもって覗き見』する方法、
処理待ちの入力の有無の検査方法、処理待ちの入力の破棄方法について述べます。
関数`read-passwd'も参照してください（*note Reading a Password::）。

 -- Variable: unread-command-events
     この変数は、コマンド入力として読まれることを
     待っているイベントのリストを保持する。
     イベントはリストに現れる順に使われ、使われると1つ1つ取り除かれる。

     関数でイベントを読んだあとにそれを使わない場面があるため、
     この変数が必要になる。 この変数にイベントを保存すると、
     コマンドループやコマンド入力を読む関数によって通常どおり処理される。

     たとえば、数値前置引数を実現する関数は、任意個数の数字文字を読み取る。
     数字文字でないイベントをみつけたら、そのイベントを読み戻して、
     コマンドループが通常どおりに読めるようにする必要がある。
     同様に、インクリメンタルサーチでは、この機能を使って
     探索においては意味を持たないイベントを読み戻す。
     なぜなら、そのようなイベントは探索を終了させ、
     通常どおり実行される必要があるからである。

     `unread-command-events'に入れられるように
     キー列からイベントを確実に簡単に取り出す方法は
     `listify-key-sequence'を使うことである（*note Strings of
     Events::）。

     もっとも最近に読み戻したイベントが最初に再度読まれるように、
     普通はこのリストの先頭にイベントを追加する。

 -- Function: listify-key-sequence key
     この関数は、文字列やベクトルであるKEYを個々のイベントのリストに変換する。
     この結果は`unread-command-events'に入れられる。

 -- Variable: unread-command-char
     この変数は、コマンド入力として読まれる文字を保持する。
     値「-1」は、『空』を意味する。

     この変数はほとんど廃れており、
     かわりに`unread-command-events'を使うべきである。 Emacs
     18版以前向けに書かれたプログラムを扱うためだけに存在する。

 -- Function: input-pending-p
     この関数は、現在、コマンド入力があるかどうかを調べる。
     ただちに返るが、入力があれば値`t'を、 さもなければ`nil'を返す。
     入力がないのに`t'を返すことが稀にある。

 -- Variable: last-input-event
 -- Variable: last-input-char
     この変数は、コマンドの一部として、あるいは、Lispプログラムが明示的に
     読み取った最後の端末入力イベントを記録する。

     以下の例で、Lispプログラムは文字`1'（ASCIIコード49）を読む。
     それが`last-input-event'の値になるが、
     （この式を評価するコマンドは`C-x C-e'と仮定するので）
     `last-command-event'の値は`C-e'のままである。

          (progn (print (read-char))
                 (print last-command-event)
                 last-input-event)
               -| 49
               -| 5
               => 49

     Emacs 18版との互換性のために、別名`last-input-char'が存在する。

 -- Function: discard-input
     この関数は端末入力バッファの内容を廃棄し、
     定義中のキーボードマクロを取り消す。 これは`nil'を返す。

     以下の例で、フォームを評価しはじめてから、ユーザーは何文字か打つ。
     `sleep-for'が待機を終えると、
     `discard-input'は待機中に打たれた文字をすべて破棄する。

          (progn (sleep-for 2)
                 (discard-input))
               => nil


File: elisp-ja,  Node: Special Events,  Next: Waiting,  Prev: Reading Input,  Up: Command Loop

20.7 特殊イベント
=======================

特殊イベントは、読まれるとただちに非常に低レベルで処理されます。
関数`read-event'はこれらのイベントをそれ自身で処理してしまい、
それらを返すことはありません。

   このように処理されるイベントは表示されることはなく、
キー列に組み込まれることもなく、
`last-command-event'や`(this-command-keys)'の値に
現れることもありません。 特殊イベントが数値引数を破棄することはなく、
`unread-command-events'で読み戻すことはできません。
特殊イベントがキーボードマクロに現れることはなく、
読者がキーボードマクロを定義しているときに、
特殊イベントがキーボードマクロに記録されることはありません。

   しかし、それらのイベントは、
読まれた直後には`last-input-event'に現れますから、
これからイベントの定義で実際のイベントを見ることができます。

   `iconify-frame'、`make-frame-visible'、`delete-frame'の
イベント型は、通常このように処理されます。
特殊イベントをどのように処理するか、
どのイベントが特殊イベントであるかを定義する
キーマップは変数`special-event-map'にあります（*note Active
Keymaps::）。


File: elisp-ja,  Node: Waiting,  Next: Quitting,  Prev: Special Events,  Up: Command Loop

20.8 時間待ちと入力待ち
================================

待機関数は、指定時間経過するか入力がくるまで待つように設計してあります。
たとえば、ユーザーに表示を眺める時間を与えるために
計算途中で休止したいでしょう。 `sit-for'は、休止してスクリーンを更新し、
入力がくるとただちに戻ります。
一方、`sleep-for'はスクリーンを更新せずに休止します。

 -- Function: sit-for seconds &optional millisec nodisp
     この関数は（処理待ちのユーザーからの入力がなければ）再表示を行い、
     SECONDS秒休止するか、入力がくるまで待つ。 入力がこずに（*note
     Event Input Misc::の`input-pending-p'を参照）
     指定時間だけ休止した場合は、戻り値は`t'である。
     さもなければ、戻り値は`nil'である。

     引数SECONDSは整数である必要はない。
     それが浮動小数点数であると、`sit-for'は秒の小数も待つ。
     秒単位しか扱えないシステムもあり、
     そのようなシステムではSECONDSを秒に切り下げる。

     省略可能な引数MILLISECは、ミリ秒単位の追加待ち時間を指定する。
     これはSECONDSで指定した時間に加えられる。
     秒未満を扱えないシステムでは、
     MILLISECに0以外を指定するとエラーになる。

     入力がくると再表示をつねに取り止め、
     再表示開始まえに入力がくると、いっさい再表示しない。
     したがって、処理待ちの入力があると、再表示を強制する方法はない。
     しかし、処理待ちの入力がなければ、`(sit-for
     0)'で再表示を強制できる。

     NODISPが`nil'以外であると、 `sit-for'は再表示はしないが、
     入力がくるとただちに（あるいは指定時間だけ経過すると）戻る。

     フレームをアイコンにしたりアイコンにしたフレームを開くと
     イベントが生成されるため、`sit-for'は戻る。 *note Misc Events::。

     `sit-for'の普通の目的は、
     読者が表示したテキストを読む時間をユーザーに与えることである。

 -- Function: sleep-for seconds &optional millisec
     この関数は表示を更新せずに単にSECONDS秒だけ休止する。
     入力にはいっさい注意を払わない。 `nil'を返す。

     引数SECONDSは整数である必要はない。
     それが浮動小数点数であると、`sleep-for'は秒の小数も待つ。
     秒単位しか扱えないシステムもあり、
     そのようなシステムではSECONDSを秒に切り下げる。

     省略可能な引数MILLISECは、ミリ秒単位の追加待ち時間を指定する。
     これはSECONDSで指定した時間に加えられる。
     秒未満を扱えないシステムでは、
     MILLISECに0以外を指定するとエラーになる。

     遅延を保証したい場合に`sleep-for'を使う。

   現在時刻を取得する関数については*Note Time of Day::。


File: elisp-ja,  Node: Quitting,  Next: Prefix Command Arguments,  Prev: Waiting,  Up: Command Loop

20.9 中断
===========

Lisp関数が動作中に`C-g'を打つと、
Emacsがなにを行っていても"中断"を引き起こします。
つまり、もっとも内側の活性なコマンドループに制御が戻ります。

   コマンドループがキーボード入力を待っているときに`C-g'を打っても、
中断を引き起こさずに、普通の入力文字として動作します。
もっとも単純な場合、`C-g'はコマンド`keyboard-quit'を実行しますが、
その効果は中断を引き起こすことですから、読者には区別できないはずです。
しかし、プレフィックスキーに続けて`C-g'を打つと、
それらは組み合わされて未定義キーになります。
その効果は、前置引数を含めてプレフィックスキーを取り消します。

   ミニバッファでは、`C-g'には別の定義があって、
ミニバッファを強制終了させます。
つまり、ミニバッファから抜け出て中断します。
（単に中断したのでは、ミニバッファ_内で_
コマンドループに戻るだけである。）
コマンドループで入力を読んでいるときに`C-g'で直接中断しない理由は、
このようにミニバッファでその意味を再定義できるようにするためです。
ミニバッファでは、プレフィックスキーに続く`C-g'は再定義してなく、
プレフィックスキーと前置引数を取り消すという通常の効果を持ちます。
`C-g'がつねに直接中断するのでは、このようにすることさえ不可能です。

   `C-g'が直接に中断するときには、 変数`quit-flag'に`t'を設定します。
Emacsはこの変数を適切なときに検査し`nil'でないと中断します。
したがって、`quit-flag'に`nil'以外を設定すると 中断を引き起こします。

   Cのコードのレベルでは、どこでも中断できるわけではありません。
`quit-flag'を検査している特別な箇所だけです。
このようにするのは、それ以外の箇所で中断すると
Emacsの内部状態に矛盾をきたす可能性があるからです。
中断は安全な場所まで延期されるので、
中断によってEmcasがクラッシュすることはありません。

   `read-key-sequence'や`read-quoted-char'などのある種の関数は、
入力を待っている場合であっても中断を完全に抑制します。
中断するかわりに、`C-g'は入力として働きます。
`read-key-sequence'の場合、コマンドループにおいて
`C-g'の特別なふるまいをもたらします。 `read-quoted-char'の場合、
`C-q'で`C-g'をクォートできるようになります。

   変数`inhibit-quit'に`nil'以外の値を束縛することで
Lisp関数のある部分において中断を抑制できます。
そうすると、`C-g'はそれでもいつもどおり `quit-flag'を`t'にしますが、
その通常の結果である中断は抑制されます。
最終的にフォーム`let'の終りで束縛が解除されるなどして
`inhibit-quit'が再度`nil'になります。
その時点でも`quit-flag'が`nil'以外であると
要求した中断がただちに起こります。
このふるまいは、プログラムの『臨界領域』では
中断が起こらないことを保証する理想的なものです。

   （`read-quoted-char'などの）ある種の関数では、
`C-g'は特別に処理され中断を引き起こしません。
`inhibit-quit'に`t'を束縛して入力を読み取り、
`inhibit-quit'が再度`nil'になるまえに
`quit-flag'を`nil'にすることでそのようにします。
これを`read-quoted-char'の定義の以下の抜粋で示しましょう。
最初の入力文字のあとで通常の中断を許す方法も示しています。

     (defun read-quoted-char (&optional prompt)
       "...DOCUMENTATION..."
       (let ((message-log-max nil) done (first t) (code 0) char)
         (while (not done)
           (let ((inhibit-quit first)
                 ...)
     	(and prompt (message "%s-" prompt))
     	(setq char (read-event))
     	(if inhibit-quit (setq quit-flag nil)))
           ...変数`code'に設定する...)
         code))

 -- Variable: quit-flag
     `inhibit-quit'が`nil'であれば、
     この変数が`nil'以外であるとEmacsはただちに中断する。
     `C-g'は、`inhibit-quit'に関わらず、
     通常、`quit-flag'に`nil'以外を設定する。

 -- Variable: inhibit-quit
     この変数は、`quit-flag'が`nil'以外の値に設定されたときに
     Emacsが中断すべきかどうかを決定する。
     `inhibit-quit'が`nil'以外であると、 `quit-flag'に特別な意味はない。

 -- コマンド: keyboard-quit
     この関数は`(signal 'quit nil)'で`quit'条件を通知する。
     これは中断と同じことを行う。 （*note Errors::の`signal'を参照。）

   中断として使う`C-g'以外の特殊文字を使えます。 *note Terminal
Input::の関数`set-input-mode'を参照してください。


File: elisp-ja,  Node: Prefix Command Arguments,  Next: Recursive Editing,  Prev: Quitting,  Up: Command Loop

20.10 前置コマンド引数
==============================

Emacsのほとんどのコマンドは、"前置引数"（prefix argument）、
つまりコマンド自身のまえに指定された数を利用できます。
（前置引数とプレフィックスキーを混同しないこと。）
前置引数はつねに値で表現され、
`nil'であると現在は前置引数がないことを表します。
各コマンドは、前置引数を使ってもよいし、無視してもかまいません。

   前置引数には2つの表現方法があります。
"生"（raw）と"数値"（numeric）です。
エディタコマンドループでは、内部的には生の表現を使い、
その情報を保持するLisp変数もそのようにしますが、
コマンドではどちらの表現を要求してもかまいません。

   生の前置引数の値にはつぎの可能性があります。

   * 前置引数がないことを意味する`nil'。 その数値としての値は1であるが、
     多くのコマンドでは`nil'と整数1を区別する。

   * それ自身が表す整数。

   * 整数を要素とする1要素のリスト。
     この形式の前置引数は、数字文字なしの1個以上の`C-u'の結果である。
     リスト内の数値は整数であるが、そのようなリストと整数のみを区別する
     コマンドもある。

   * シンボル`-'。 数字文字なしに`M--'や`C-u -'を打ったことを表す。
     これに等価な数値は-1であるが、
     整数-1とシンボル`-'を区別するコマンドもある。

   いろいろな前置引数でつぎの関数を呼び出す例を示します。

     (defun display-prefix (arg)
       "Display the value of the raw prefix arg."
       (interactive "P")
       (message "%s" arg))

以下は、生の前置引数で`display-prefix'を呼び出した結果です。

             M-x display-prefix  -| nil

     C-u     M-x display-prefix  -| (4)

     C-u C-u M-x display-prefix  -| (16)

     C-u 3   M-x display-prefix  -| 3

     M-3     M-x display-prefix  -| 3      ; （`C-u 3'と同じ）

     C-u -   M-x display-prefix  -| -

     M--     M-x display-prefix  -| -      ; （`C-u -'と同じ）

     C-u - 7 M-x display-prefix  -| -7

     M-- 7   M-x display-prefix  -| -7     ; （`C-u -7'と同じ）

   Emacsは、前置引数を保持するために2つの変数、
`prefix-arg'と`current-prefix-arg'を使います。
他のコマンド向けに前置引数を設定する`universal-argument'などの
コマンドは、前置引数を`prefix-arg'に保持します。
対照的に、`current-prefix-arg'には
現在のコマンドに対して前置引数を運ぶ役割があり、
この変数に設定しても以後のコマンドに対する前置引数には
なんの効果もありません。

   通常、コマンドは、`interactive'宣言により、
「生」か「数値」のいずれの表現の前置引数を使うか指定します。 （*Note
Using Interactive::。）
あるいは、変数`current-prefix-arg'にある前置引数の値を
関数から直接見てもかまいませんが、
これは見通しのよい方法ではありません。

 -- Function: prefix-numeric-value arg
     この関数は、有効な生の前置引数の値ARGからそれに等価な数値を返す。
     引数は、シンボル、数、リストのいずれかである。
     それが`nil'であると、戻り値は1である。
     `-'であると、戻り値は-1である。 数であると、その数を返す。
     リストであると、リストの（数であるはずの）CARを返す。

 -- Variable: current-prefix-arg
     この変数は、_現在の_コマンドに対する生の前置引数を保持する。
     コマンドが直接この変数を調べてもよいが、
     前置引数を参照する普通の方法は`(interactive "P")'を使うことである。

 -- Variable: prefix-arg
     この変数の値は、_つぎの_編集コマンド向けの生の前置引数である。
     後続のコマンド向けの前置引数を指定する`universal-argument'などの
     コマンドは、この変数に設定することで動作する。

 -- Variable: last-prefix-arg
     まえのコマンドで使われた生の前置引数の値。

つぎのコマンドは、後続のコマンド向けの前置引数を設定するためのものです。
それ以外の目的には呼ばないでください。

 -- コマンド: universal-argument
     このコマンドは入力を読み取り、後続のコマンド向けの前置引数を指定する。
     なにをしているか理解していない限り、読者自身でこのコマンドを呼ばないこと。

 -- コマンド: digit-argument arg
     このコマンドは、後続のコマンド向けの前置引数に追加する。
     引数ARGは、このコマンドが呼び出されるまえの生の前置引数であり、
     前置引数を更新する計算に使われる。
     なにをしているか理解していない限り、読者自身でこのコマンドを呼ばないこと。

 -- コマンド: negative-argument arg
     このコマンドは、後続のコマンド向けの数値前置引数に追加する。
     引数ARGは、このコマンドが呼び出されるまえの生の前置引数であり、
     その値の符号を変えて新たな前置引数とする。
     なにをしているか理解していない限り、読者自身でこのコマンドを呼ばないこと。


File: elisp-ja,  Node: Recursive Editing,  Next: Disabling Commands,  Prev: Prefix Command Arguments,  Up: Command Loop

20.11 再帰編集
==================

Emacsが動作を始めると、Emacsのコマンドループに自動的に入ります。
このトップレベルのコマンドループからはけっして抜けることはなく、
Emacsが動いている限り動作し続けます。
Lispプログラムからコマンドループを起動することもできます。
そうすると、活性なコマンドループが複数作られることになるので、
それを"再帰編集"（recursive editing）と呼びます。
再帰編集レベルには、それを起動したコマンドを一時休止させ、
当該コマンドを再開するまでユーザーにどんな編集でも許す効果があります。

   再帰編集中に利用可能なコマンドは、トップレベルのコマンドループと
同じものでありキーマップで定義されます。
再帰編集を抜けるための数個の特別なコマンドがあり、
完了すると再帰編集レベルから抜ける別のコマンドもあります。
（再帰編集を抜けるコマンドはつねに利用可能であるが、
再帰編集中でないとなにも行わない。）

   再帰編集を含むすべてのコマンドループでは、
コマンドループから実行したコマンドのエラーによって
コマンドループから抜け出さないように汎用目的のエラーハンドラを設定します。

   ミニバッファでの入力は、特別な種類の再帰編集です。
これには、ミニバッファやミニバッファ用ウィンドウを表示するなどの特別な
処理がありますが、読者が考えるよりは少ないのです。
ミニバッファでは特別なふるまいをするキーもありますが、
それらはミニバッファのローカルマップによるものです。
ウィンドウを切り替えると、Emacsの普通のコマンドを使えます。

   再帰編集レベルを起動するには、関数`recursive-edit'を呼び出します。
この関数にはコマンドループが含まれています。
さらに、`exit'を伴った`catch'の呼び出しもあり、
これにより、`exit'へ投げることで
再帰編集レベルから抜け出せるようになっています （*note Catch and
Throw::）。 `t'以外の値を投げると、`recursive-edit'は、
呼び出し側の関数へ普通に戻ります。
コマンド`C-M-c'（`exit-recursive-edit'）は、これを行います。
値`t'を投げると`recursive-edit'に中断を引き起こし、
1つ上のレベルのコマンドループへ制御を戻します。
これを"強制終了"（aborting）と呼び、
`C-]'（`abort-recursive-edit'）で行えます。

   ミニバッファを使う場合を除いて、ほとんどのアプリケーションでは
再帰編集を使うべきではありません。 カレントバッファのメジャーモードを
一時的な特別なメジャーモードに変更するほうが、
一般にはユーザーにとってより便利です。 ただし、当該メジャーモードには、
まえのモードに戻るコマンドを用意しておきます。
（rmailのコマンド`e'は、この方式を使っている。）
あるいは、『再帰的に』編集する別のテキストをユーザーに与えたい場合には、
特別なモードの新たなバッファを作成してそれを選択します。
当該モードには、処理を終えてまえのバッファに戻るコマンドを
定義しておきます。 （rmailのコマンド`m'は、このようにする。）

   再帰編集はデバッグに便利です。 ブレークポイントの一種として関数定義に
`debug'の呼び出しを挿入しておくと、
その箇所に達したときにいろいろと調べられます。
`debug'は再帰編集を起動しますが、デバッガとしての機能も提供します。

   `query-replace'で`C-r'を打ったり、 `C-x
q'（`kbd-macro-query'）を使ったときにも 再帰編集レベルが使われます。

 -- Function: recursive-edit
     この関数はエディタコマンドループを起動する。
     Emacsの初期化過程で自動的に呼び出され、ユーザーが編集できるようにする。
     Lispプログラムから呼ばれると、再帰編集レベルに入る。

     以下の例では、関数`simple-rec'は、まず1単語分ポイントを進め、
     エコー領域にメッセージを表示して再帰編集に入る。
     そうすると、ユーザーは望むことはなんでもできるようになり、
     （再帰編集を）抜けるために`C-M-c'を打つと、
     `simple-rec'の実行を継続する。

          (defun simple-rec ()
            (forward-word 1)
            (message "Recursive edit in progress")
            (recursive-edit)
            (forward-word 1))
               => simple-rec
          (simple-rec)
               => nil

 -- コマンド: exit-recursive-edit
     この関数は、（ミニバッファでの入力を含む）もっとも内側の再帰編集から抜ける。
     その関数定義は実質的には`(throw 'exit nil)'である。

 -- コマンド: abort-recursive-edit
     この関数は、再帰編集から抜けたあとで`quit'を通知することで、
     （ミニバッファでの入力を含む）もっとも内側の再帰編集を
     要請したコマンドを強制終了する。 その関数定義は実質的には`(throw
     'exit t)'である。 *note Quitting::。

 -- コマンド: top-level
     この関数は、すべての再帰編集を抜ける。
     すべての計算を抜け出てメインのコマンドループへ直接戻るため、値は返さない。

 -- Function: recursion-depth
     この関数は再帰編集の現在の深さを返す。
     活性な再帰編集がなければ0を返す。


File: elisp-ja,  Node: Disabling Commands,  Next: Command History,  Prev: Recursive Editing,  Up: Command Loop

20.12 コマンドを禁止する
=================================

"コマンドを禁止する"とは、
コマンドを実行するまえにユーザーの確認を必要とするように
コマンドに印を付けることです。 コマンドを禁止するのは、
初心者に混乱をもたらす可能性のあるコマンドに対してや、
コマンドの誤用を防ぐためです。

   コマンドを禁止する低レベルの機構は、
コマンドのLispシンボルに`nil'以外の属性`disabled'を入れることです。
これらの属性は、通常、ユーザーの`.emacs'ファイルにて
つぎのようなLisp式で設定します。

     (put 'upcase-region 'disabled t)

数個のコマンドにはデフォルトでこれらの属性がありますから、
`.emacs'ファイルで属性を取り除きます。

   属性`disabled'の値は文字列であり、
コマンドを禁止したことを表すメッセージです。 たとえばつぎのとおりです。

     (put 'delete-region 'disabled
          "Text deleted this way cannot be yanked back!\n")

   禁止したコマンドを対話的に起動するとどうなるかについて 詳しくは*Note
使用禁止コマンド: (emacs)Disabling。
コマンドを禁止しても、Lispプログラムから関数として呼び出すことには
なんの影響もありません。

 -- コマンド: enable-command command
     これ以降、特別な確認なしにCOMMANDを実行可能にする。
     さらに（ユーザーが了承すれば）ユーザーの`.emacs'ファイルを変更して、
     将来のセッションでもそのようにする。

 -- コマンド: disable-command command
     これ以降、COMMANDの実行には特別な確認を必要とするようにする。
     さらに（ユーザーが了承すれば）ユーザーの`.emacs'ファイルを変更して、
     将来のセッションでもそのようにする。

 -- Variable: disabled-command-hook
     禁止したコマンドをユーザーが対話的に起動したとき、
     禁止したコマンドのかわりにこのノーマルフックを実行する。
     フック関数では、`this-command-keys'を使って
     コマンドを実行するためにユーザーがなにを入力したかを調べ、
     コマンドそのものを探し出せる。 *note Hooks::。

     デフォルトでは、`disabled-command-hook'には、
     ユーザーに処理を進めるかどうかを問い合わせる関数が入っている。


File: elisp-ja,  Node: Command History,  Next: Keyboard Macros,  Prev: Disabling Commands,  Up: Command Loop

20.13 コマンド履歴
========================

コマンドループでは、実行した複雑なコマンドの履歴を管理していて、
それらのコマンドを簡単に繰り返せるようにしています。
"複雑なコマンド"とは、ミニバッファを使って引数を読むコマンドです。
これには、任意の`M-x'コマンド、任意の`M-:'コマンド、
ミニバッファから引数を読み取る`interactive'指定を持つ任意のコマンドが
含まれます。 コマンド自身の実行中に明示的にミニバッファを使っても、
複雑なコマンドとはみなしません。

 -- Variable: command-history
     この変数の値は、最近使った複雑なコマンドのリストであり、
     各要素は評価すべきフォームを表す。
     編集セッション中は、すべての複雑なコマンドを集積するが、
     （変数`history-length'で指定される）最大サイズに達すると
     新しい要素を追加するたびに古い要素を削除する。

          command-history
          => ((switch-to-buffer "chistory.texi")
              (describe-key "^X^[")
              (visit-tags-table "~/emacs/src/")
              (find-tag "repeat-complex-command"))

   この履歴リストは、実際にはミニバッファ履歴（*note Minibuffer
History::） の特別な場合です。 要素は文字列ではなく式なのです。

まえのコマンドを編集したり取り出すための専用コマンドがたくさんあります。
コマンド`repeat-complex-command'と`list-command-history'は、
ユーザーマニュアル （*note ミニバッファコマンドの繰り返し:
(emacs)Repetition.）に説明してあります。
ミニバッファ内では、通常のミニバッファ履歴コマンドを使えます。


File: elisp-ja,  Node: Keyboard Macros,  Prev: Command History,  Up: Command Loop

20.14 キーボードマクロ
==============================

"キーボードマクロ"は、
コマンドとみなせる入力イベントのまとまった列であり、
キーの定義から構成されます。 Lispにおけるキーボードマクロの表現は、
イベントを含んだ文字列やベクトルです。
キーボードマクロとLispマクロ（*note Macros::）を混同しないでください。

 -- Function: execute-kbd-macro kbdmacro &optional count
     この関数はキーボードマクロKBDMACROをイベント列として実行する。
     KBDMACROが文字列かベクトルであると、
     その中のイベントをユーザーが入力した場合とまったく同様に実行する。
     列は単一のキーイベントである必要は_ない_。
     通常、キーボードマクロの定義は、複数のキー列を連結したものである。

     KBDMACROがシンボルであると、
     KBDMACROのかわりにその関数定義を用いる。
     それがさらに別のシンボルであると、この処理を繰り返す。
     最終的な結果は、文字列かベクトルであること。
     結果がシンボルでも文字列でもベクトルでもないと、 エラーを通知する。

     引数COUNTは繰り返し回数であり、 KBDMACROをその回数だけ実行する。
     COUNTを省略するか`nil'であると、KBDMACROを1回実行する。
     COUNTが0であると、
     KBDMACROの実行をエラーに出会うか探索に失敗するまで繰り返す。

     `execute-kbd-macro'を使った例については*note Reading One Event::。

 -- Variable: executing-macro
     この変数は、現在実行中のキーボードマクロの定義である
     文字列やベクトルを保持する。
     これが`nil'であると、現在実行中のマクロはない。
     コマンドでこの変数を検査することで、
     マクロ実行で起動されたときのふるまいを変更できる。
     読者自身はこの変数に設定しないこと。

 -- Variable: defining-kbd-macro
     この変数は、キーボードマクロを定義中かどうかを表す。
     コマンドでこの変数を検査することで、マクロ定義中のふるまいを変更できる。
     コマンド`start-kbd-macro'と`end-kbd-macro'がこの変数に設定する。
     読者自身は設定しないこと。

     この変数は現在の端末に対してつねにローカルであり、
     バッファに対してローカルにはならない。 *note Multiple Displays::。

 -- Variable: last-kbd-macro
     この変数は、もっとも最近に定義されたキーボードマクロの定義である。
     その値は、文字列かベクトル、あるいは、`nil'である。

     この変数は現在の端末に対してつねにローカルであり、
     バッファに対してローカルにはならない。 *note Multiple Displays::。


File: elisp-ja,  Node: Keymaps,  Next: Modes,  Prev: Command Loop,  Up: Top

21 キーマップ
******************

入力イベントとコマンドとのバインディング（対応）は、
"キーマップ"（keymap）と呼ばれるデータ構造に記録されています。
キーマップの各バインディング（あるいは"バインド"（bind））は、
個々のイベント型を別のキーマップかコマンドに対応付けます。
イベント型のバインディングがキーマップであると、
後続の入力イベントを探すためにそのキーマップを使います。
コマンドがみつかるまで、これを繰り返します。
この処理全体を"キー探索"（key lookup）と呼びます。

* Menu:

* Keymap Terminology::        	Definitions of terms pertaining to keymaps.
* Format of Keymaps::		What a keymap looks like as a Lisp object.
* Creating Keymaps:: 		Functions to create and copy keymaps.
* Inheritance and Keymaps::	How one keymap can inherit the bindings
				   of another keymap.
* Prefix Keys::                 Defining a key with a keymap as its definition.
* Active Keymaps::	        Each buffer has a local keymap
                                   to override the standard (global) bindings.
				   A minor mode can also override them.
* Key Lookup::                  How extracting elements from keymaps works.
* Functions for Key Lookup::    How to request key lookup.
* Changing Key Bindings::       Redefining a key in a keymap.
* Key Binding Commands::        Interactive interfaces for redefining keys.
* Scanning Keymaps::            Looking through all keymaps, for printing help.
* Menu Keymaps::		Defining a menu as a keymap.


File: elisp-ja,  Node: Keymap Terminology,  Next: Format of Keymaps,  Up: Keymaps

21.1 キーマップの用語
=============================

"キーマップ"（keymap）は、イベント型を定義に対応させる表です。
（この定義は任意のLispオブジェクトであるが、
コマンドループによる実行においては、特定の型のみが意味を持つ）。
与えられたイベント（あるいはイベント型）とキーマップから、
Emacsはイベントの定義を得ることができます。
イベントは、文字、ファンクションキー、マウス操作です （*note Input
Events::）。

   ある単位を構成する入力イベントの列を"キー列"（key sequence）、
あるいは、略して"キー"（key）と呼びます。
単一イベントから成る列はつねにキー列であり、複数イベント列もキー列です。

   キーマップは、任意のキー列に対するバインディング、
つまり、定義を決定します。 キー列が単一イベントから成るとき、
そのバインディングはキーマップ内の当該イベントの定義です。
複数のイベントから成るキー列のバインディングは、
繰り返し処理で探します。
つまり、最初のイベントのバインディングを探すと、
それはキーマップであるはずです。
続いて、そのキーマップから2番目のイベントのバインディングを探します。
これをキー列のすべてのイベントを使い尽くすまで行います

   キー列のバインディングがキーマップであると、
そのキー列を"プレフィックスキー"（prefix key）と呼びます。
さもなければ、（追加できるイベントがないので） "完全なキー"（complete
key）と呼びます。
バインディングが`nil'であると、キーは"未定義"であるといいます。
プレフィックスキーの例は、`C-c'、`C-x'、`C-x 4'です。
定義されている完全なキーの例は、`X'、<RET>、`C-x 4 C-f'です。
未定義な完全なキーの例は、`C-x C-g'と`C-c 3'です。 詳しくは、*Note
Prefix Keys::。

   キー列のバインディングを探す際の規則では、
（最後のイベントのまえまでにみつかる）途中のバインディングは
すべてキーマップであると仮定します。
これが満たされないと、イベントの列があるまとまりを構成せず、
1つのキー列になりません。
いいかえれば、有効なキー列の末尾からいくつかのイベントを取りさると、
つねにプレフィックスキーになる必要があります。 たとえば、`C-f
C-n'はキー列ではありません。 `C-f'はプレフィックスキーではないので、
`C-f'で始まる列はキー列ではありません。

   複数イベントから成るキー列の候補は、
プレフィックスキーのバインディングに依存します。
したがって、キーマップが異なればそれらは異なり、
バインディングを変更するとそれらは変わります。
しかし、単一イベントから成る列は、プレフィックスに依存しないので、
つねにキー列です。

   ある時点には、複数個の主キーマップが活性です。
つまり、キーバインディングの探索に使われます。 それらは、
すべてのバッファが共有する"グローバルマップ"（global map）、
特定のメジャーモードに関連付けられた"ローカルマップ"（local keymap）、
現在オンにしてあるマイナモードに属する "マイナモードキーマップ"（minor
mode keymaps）です。
（すべてのマイナモードにキーマップがあるわけではない。）
ローカルキーマップのバインディングは、
対応するグローバルなバインディングを隠します（つまり優先する）。
マイナモードキーマップは、ローカルとグローバルの両方のキーマップを隠します。
詳しくは*Note Active Keymaps::。


File: elisp-ja,  Node: Format of Keymaps,  Next: Creating Keymaps,  Prev: Keymap Terminology,  Up: Keymaps

21.2 キーマップの形式
=============================

キーマップは、そのCARがシンボル`keymap'であるリストです。
リストの残りの要素がキーマップのキーバインディングを定義します。
オブジェクトがキーマップであるかどうか検査するには、
関数`keymapp'（下記参照）を使います。

   キーマップでは、シンボル`keymap'のうしろに、
さまざまな種類の要素が現れます。

`(TYPE . BINDING)'
     イベント型TYPEに対する1つのバインディングを指定する。
     普通の各バインディングは、文字やシンボルである特定の"イベント型"に
     適用される。 *note Classifying Events::。

`(t . BINDING)'
     "デフォルトのキーバインディング"を指定する。
     キーマップの他の要素に一致しない任意のイベントには、
     そのバインディングとして指定したBINDINGを与える。
     デフォルトのバインディングにより、
     すべてを列挙せずに可能なすべてのイベントにバインドできる。
     デフォルトのバインディングを有するキーマップは、
     任意の低優先順位のキーマップを隠してしまう。

`VECTOR'
     キーマップの要素がベクトルであると、
     当該ベクトルをASCII文字全体、つまり、コード0から127に対する
     バインディングとみなす。
     ベクトルのN番目の要素は、コードNの文字に対する
     バインディングである。
     これは、多くのバインディングを記録するコンパクトな方法である。
     このようなベクトルのキーマップを"完全なキーマップ"（full
     keymap）と呼ぶ。 それ以外のキーマップを"疎なキーマップ"（sparse
     keymaps）と呼ぶ。

     キーマップにベクトルがあると、ベクトルの要素が`nil'であっても
     ベクトルが各ASCII文字のバインディングをつねに定義する。
     そのような`nil'のバインディングは、 ASCII文字に対しては
     キーマップのデフォルトのキーバインディングを無効にする。
     しかし、ASCII文字以外のイベントに対しては、
     デフォルトのバインディングが意味を持つ。 `nil'のバインディングが
     低優先順位のキーマップを隠すことは_ない_。
     つまり、ローカルマップが`nil'のバインディングを与えると、
     Emacsはグローバルマップのバインディングを使う。

`STRING'
     バインディングに加えて、
     キーマップでは、要素として文字列を持つこともできる。
     これを"全面プロンプト文字列"（overall prompt string）と呼び、
     キーマップをメニューとして使うことを可能にする。 *note Menu
     Keymaps::。

キーマップは、メタ文字に対するバインディングを直接には記録していません。
そのかわりに、キー探索においては、メタ文字は2文字から成る列とみなし、
先頭文字は<ESC>（あるいは、`meta-prefix-char'の現在値）です。
つまり、キー`M-a'は実際には`<ESC> a'と表現され、
そのグローバルなバインディングは `esc-map'の`a'でみつかります（*note
Prefix Keys::）。

   Lispモードに対するローカルキーマップの例を示します。
これは疎なキーマップです。 <DEL>、<TAB>、`C-c
C-l'、`M-C-q'、`M-C-x'に対する バインディングを定義しています。

     lisp-mode-map
     =>
     (keymap
      ;; <TAB>
      (9 . lisp-indent-line)
      ;; <DEL>
      (127 . backward-delete-char-untabify)
      (3 keymap
         ;; C-c C-l
         (12 . run-lisp))
      (27 keymap
          ;; `M-C-q'は`<ESC> C-q'とみなされる
          (17 . indent-sexp)
          ;; `M-C-x'は`<ESC> C-x'とみなされる
          (24 . lisp-send-defun)))

 -- Function: keymapp object
     この関数は、OBJECTがキーマップであれば`t'を返し、
     さもなければ`nil'を返す。 より正確には、この関数は、
     そのCARが`keymap'であるリストかどうかを検査する。

          (keymapp '(keymap))
              => t
          (keymapp (current-global-map))
              => t


File: elisp-ja,  Node: Creating Keymaps,  Next: Inheritance and Keymaps,  Prev: Format of Keymaps,  Up: Keymaps

21.3 キーマップの作成
=============================

ここでは、キーマップを作成するための関数について述べます。

 -- Function: make-keymap &optional prompt
     この関数は新たに完全なキーマップ
     （つまり、すべてのASCII文字に対する定義を収めた
     長さ128のベクトル）を作成しそれを返す。
     新たなキーマップでは、すべてのASCII文字に対するバインディングは
     `nil'であり、それ以外の種類のイベントに対するバインディングはない。

          (make-keymap)
              => (keymap [nil nil nil ... nil nil])

     PROMPTを指定すると、
     それはキーマップに対する全面プロンプト文字列になる。
     全面プロンプト文字列はメニューキーマップ （*note Menu
     Keymaps::）に有用である。

 -- Function: make-sparse-keymap &optional prompt
     この関数は、新たに空の疎なキーマップを作成しそれを返す。
     新たなキーマップにはイベントに対するバインディングはいっさいない。
     引数PROMPTは、`make-keymap'の場合同様、
     プロンプト文字列を指定する。

          (make-sparse-keymap)
              => (keymap)

 -- Function: copy-keymap keymap
     この関数はKEYMAPのコピーを返す。
     KEYMAPにバインディングとして直接現れる任意のキーマップも
     任意のレベルまで再帰的にコピーされる。
     しかし、文字に対する定義が、その関数定義がキーマップであるような
     シンボルに出会うと再帰的なコピーを行わないため、
     同じシンボルが新たなコピーにも現れる。

          (setq map (copy-keymap (current-local-map)))
          => (keymap
               ;; (これはメタ文字を意味する)
               (27 keymap
                   (83 . center-paragraph)
                   (115 . center-line))
               (9 . tab-to-tab-stop))

          (eq map (current-local-map))
              => nil
          (equal map (current-local-map))
              => t


File: elisp-ja,  Node: Inheritance and Keymaps,  Next: Prefix Keys,  Prev: Creating Keymaps,  Up: Keymaps

21.4 継承とキーマップ
=============================

キーマップでは、"親キーマップ"（parent keymap）と呼ぶ別のキーマップの
バインディングを継承できます。
そのようなキーマップはつぎのようになります。

     (keymap BINDINGS... . PARENT-KEYMAP)

このキーマップは、キーを探索する時点において
PARENT-KEYMAPが有するすべてのバインディングを継承しますが、
それらにはBINDINGSが追加されたり優先します。

   `define-key'や他のキーバインディング関数でPARENT-KEYMAPの
バインディングを変更すると、それらの変更は、
BINDINGSで隠されない限り継承側のキーマップからも見えます。
その逆は真ではありません。
`define-key'で継承側のキーマップを修正すると、
それはBINDINGSに影響するだけでPARENT-KEYMAPには影響しません。

   親キーマップを用いたキーマップを作成する正しい方法は、
`set-keymap-parent'を使うことです。
親キーマップを用いたキーマップを直接作成するようなコードがある場合には、
`set-keymap-parent'を用いるようにプログラムを変更してください。

 -- Function: keymap-parent keymap
     この関数は、キーマップKEYMAPの親キーマップを返す。
     KEYMAPに親がなければ`keymap-parent'は`nil'を返す。

 -- Function: set-keymap-parent keymap parent
     キーマップKEYMAPの親キーマップとしてPARENTを設定し、 PARENTを返す。
     PARENTが`nil'であると、
     この関数はKEYMAPに親キーマップをいっさい与えない。

     KEYMAPに（プレフィックスキー用のバインディングである）
     サブマップがあれば、それらもPARENTが指定するプレフィックスキーを
     反映する新たな親マップを受け取る。

   `text-mode-map'からキーマップを継承する方法を示します。

     (let ((map (make-sparse-keymap)))
       (set-keymap-parent map text-mode-map)
       map)


File: elisp-ja,  Node: Prefix Keys,  Next: Active Keymaps,  Prev: Inheritance and Keymaps,  Up: Keymaps

21.5 プレフィックスキー
================================

"プレフィックス"（prefix key）とは、
そのバインディングがキーマップであるキー列のことです。
そのキーマップが、プレフィックスキー以降のキーでなにをするかを定義します。
たとえば、`C-x'はプレフィックスキーであり、
変数`ctl-x-map'に保持されたキーマップを使います。
このキーマップは、`C-x'で始まるキー列に対するバインディングを定義します。

   Emacsの標準プレフィックスキーのなかには、
Lisp変数にも保持されたキーマップを使うものがあります。

   * `esc-map'は、プレフィックスキー<ESC>用のグローバルマップである。
     したがって、すべてのメタ文字のグローバルな定義はここにある。
     このキーマップは`ESC-prefix'の関数定義でもある。

   * `help-map'は、プレフィックスキー`C-h'に対する
     グローバルキーマップである。

   * `mode-specific-map'は、プレフィックスキー`C-c'に対する
     グローバルキーマップである。
     このキーマップは実際にはグローバルでありモード固有ではないが、
     その名前は、`C-h b'（`display-bindings'）の出力において
     `C-c'に関する有用な情報を与える。
     というのは、このプレフィックスキーの主な用途は、
     モード固有のバインディングのためだからである。

   * `ctl-x-map'は、プレフィックスキー`C-x'に対して使われる
     グローバルキーマップである。
     このキーマップは、シンボル`Control-X-prefix'の関数セルに現れる。

   * `mule-keymap'は、プレフィックスキー`C-x <RET>'に対して使われる
     グローバルキーマップである。

   * `ctl-x-4-map'は、プレフィックスキー`C-x 4'に対して使われる
     グローバルキーマップである。

   * `ctl-x-5-map'は、プレフィックスキー`C-x 5'に対して使われる
     グローバルキーマップである。

   * `2C-mode-map'は、プレフィックスキー`C-x 6'に対して使われる
     グローバルキーマップである。

   * `vc-prefix-map'は、プレフィックスキー`C-x v'に対して使われる
     グローバルキーマップである。

   * `facemenu-keymap'は、プレフィックスキー`M-g'に対して使われる
     グローバルキーマップである。

   * Emacsには、他にも、`C-x @'、`C-x a i'、`C-x <ESC>'、 `<ESC>
     <ESC>'のプレフィックスキーがある。
     これらは、特別な名前を持たないキーマップを使う。

   プレフィックスキーのキーマップバインディングは、
当該プレフィックスキーに続くイベントを探すために使われます。
（その関数定義がキーマップであるシンボルでもよい。
効果は同じであるが、シンボルはプレフィックスキーに対する名前として働く。）
したがって、`C-x'のバインディングは シンボル`Control-X-prefix'であり、
その関数セルがコマンド`C-x'用のキーマップを保持している。
（`ctl-x-map'の値も同じキーマップである。）

プレフィックスキーの定義は、任意の活性なキーマップにあってかまいません。
プレフィックスキーとしての`C-c'、`C-x'、`C-h'、<ESC>の
定義はグローバルマップにあるので、これらのプレフィックスキーは
つねに利用できます。 メジャーモードやマイナモードでは、
プレフィックスキーの定義をローカルキーマップや
マイナモードキーマップに入れることで、
キーをプレフィックスとして再定義できます。 *Note Active Keymaps::。

複数の活性なキーマップにおいて、キーがプレフィックスと定義されていると、
さまざまな定義は実質的には併合されます。
マイナモードキーマップで定義されたコマンドが最優先で、
つぎにローカルマップのプレフィックス定義、
そしてグローバルマップのプレフィックス定義が続きます。

   以下の例では、ローカルキーマップにおいて、
`C-p'を`C-x'に等価なプレフィックスキーにします。 続いて`C-p
C-f'のバインディングを `C-x C-f'のように関数`find-file'にします。
キー列`C-p 6'はどの活性なキーマップでもみつかりません。

     (use-local-map (make-sparse-keymap))
         => nil
     (local-set-key "\C-p" ctl-x-map)
         => nil
     (key-binding "\C-p\C-f")
         => find-file

     (key-binding "\C-p6")
         => nil

 -- Function: define-prefix-command symbol
     この関数は、SYMBOLをプレフィックスキーの
     バインディングとして使えるように準備する。
     つまり、完全なキーマップを作成し、
     SYMBOLの関数定義にそのキーマップを保存する。
     以後、SYMBOLにキー列をバインドすると、
     当該キー列をプレフィックスキーに入る。

     この関数は、変数としてのSYMBOLにも値としてキーマップを設定する。
     SYMBOLを返す。



File: elisp-ja,  Node: Active Keymaps,  Next: Key Lookup,  Prev: Prefix Keys,  Up: Keymaps

21.6 活性なキーマップ
=============================

Emacsには、通常、たくさんのキーマップがあります。
ある時点では、それらの数個が"活性"になっていて、
ユーザー入力の解釈に関与します。
それらは、グローバルキーマップ、カレントバッファのローカルキーマップ、
オンになっているマイナモードのキーマップです。

   "グローバルキーマップ"（global keymap）は、
`C-f'のようなカレントバッファに依存せずに
定義されたキーのバインディングを保持します。
変数`global-map'はこのキーマップを保持していて、
このキーマップはつねに活性です。

   各バッファには別のキーマップ、つまり、
バッファの"ローカルキーマップ"（local keymap）があり、
キーに対する新しい定義や無効にする定義を保持しています。
カレントバッファのローカルキーマップは、
`overriding-local-map'で無効にしない限り、つねに活性です。
テキスト属性により、バッファの特定部分に対する
代替ローカルマップを指定できます。 *note Special
Properties::を参照してください。

   各マイナモードもキーマップを持てます。
その場合、マイナモードがオンであると当該キーマップは活性です。

   変数`overriding-local-map'が`nil'以外であると、
バッファのローカルキーマップとそのすべてのマイナモードキーマップに
取ってかわるローカルキーマップを指定します。

   キーが入力されるとどのコマンドを実行するかを決定するために、
すべての活性なキーマップを一緒に使います。
Emacsは、キーマップの1つでバインディングがみつかるまで、
優先順位が高いほうからこれらのキーマップを1つ1つ探索します。
1つのキーマップで探索する処理のことを "キー探索"（key
lookup）といいます。 *note Key Lookup::を参照してください。

   通常、Emacsはまず`minor-mode-map-alist'で指定される順に
マイナモードキーマップでキーを探します。
キーに対するバインディングがなければ、
Emacsはローカルキーマップで探します。 そこにもバインディングがなければ、
Emacsはグローバルキーマップで探します。
しかし、`overriding-local-map'が`nil'以外であれば、
Emacsはまずそのキーマップで探してから、 グローバルキーマップで探します。

   同じメジャーモードを使う各バッファは、通常、同じローカルキーマップを
使うので、キーマップはモードにローカルであると考えることができます。
（たとえば`local-set-key'を使って）バッファのローカルキーマップを
修正すると、当該キーマップを共有している別のバッファでも
その修正が見えます。

   Lispモードや他の数個のメジャーモードで使われるローカルキーマップは、
それらのモードがまだ使われていなくても存在します。
そのようなローカルキーマップは、`lisp-mode-map'などの変数の値です。
使用頻度の低いほとんどのメジャーモードでは、
セッションで始めてそのモードを使ったときに
ローカルキーマップを作成します。

   ミニバッファにもローカルキーマップがあります。
それにはさまざまな補完コマンドや脱出コマンドが含まれます。 *Note Intro
to Minibuffers::。

   Emacsには、別の用途のキーマップもあります。
`read-key-sequence'でイベントを変換するためのものです。 *Note
Translating Input::。

   標準的なキーマップの一覧については*Note Standard Keymaps::。

 -- Variable: global-map
     この変数は、Emacsがキーボード入力をコマンドに対応させるための
     デフォルトのグローバルキーマップを保持する。
     グローバルキーマップは、通常、このキーマップである。
     デフォルトのグローバルキーマップは、
     すべての印字文字に`self-insert-command'をバインドする
     完全なキーマップである。

     グローバルマップのバインディングを修正することは実用的ですが、
     この変数には、動作開始時のキーマップ以外の値は設定しないこと。

 -- Function: current-global-map
     この関数は、現在のグローバルキーマップを返す。
     `global-map'を変更していなければ、
     これは`global-map'の値と同じである。

          (current-global-map)
          => (keymap [set-mark-command beginning-of-line ...
                      delete-backward-char])

 -- Function: current-local-map
     この関数は、カレントバッファのローカルキーマップを返す。
     なければ`nil'を返す。
     つぎの例では、（lisp対話モードを使っている）バッファ`*scratch*'の
     キーマップは疎なキーマップであり、
     ASCIIコード27の<ESC>に対する指定も別の疎なキーマップである。

          (current-local-map)
          => (keymap
              (10 . eval-print-last-sexp)
              (9 . lisp-indent-line)
              (127 . backward-delete-char-untabify)
              (27 keymap
                  (24 . eval-defun)
                  (17 . indent-sexp)))

 -- Function: current-minor-mode-maps
     この関数は、現在オンになっているマイナモードのキーマップのリストを返す。

 -- Function: use-global-map keymap
     この関数は、キーマップKEYMAPを新たな現在のグローバルキーマップとする。
     これは`nil'を返す。

     グローバルキーマップを変更することは、とうてい普通のことではない。

 -- Function: use-local-map keymap
     この関数は、キーマップKEYMAPをカレントバッファの
     新たなローカルキーマップとする。 KEYMAPが`nil'であると、
     バッファにはローカルキーマップがなくなる。
     `use-local-map'は`nil'を返す。
     ほとんどのメジャーモードコマンドは、この関数を使う。

 -- Variable: minor-mode-map-alist
     この変数は、変数の値に応じて活性になっている／いないキーマップを
     記述する連想リストである。 その要素はつぎの形である。

          (VARIABLE . KEYMAP)

     変数VARIABLEの値が`nil'以外であれば、
     キーマップKEYMAPは活性である。
     典型的には、VARIABLEはマイナモードをオン／オフする変数である。
     *note Keymaps and Minor Modes::。

     `minor-mode-map-alist'の要素と`minor-mode-alist'の要素とは、
     異なる構造であることに注意してほしい。
     キーマップは要素のCDRである必要があり、
     要素のCADRがキーマップであるようなリストではだめである。
     CADRは、（リストの）キーマップであるか、
     関数定義がキーマップであるシンボルである。

     複数のマイナモードキーマップが活性な場合、
     それらの優先順位は、`minor-mode-map-alist'での順番である。
     読者は、互いに干渉しないようにマイナモードを設計する必要がある。
     正しくできていれば、順序は関係ないはずである。

     マイナモードについて詳しくは*note Keymaps and Minor Modes::を参照。
     `minor-mode-key-binding'（*note Functions for Key
     Lookup::）も参照のこと。

 -- Variable: minor-mode-overriding-map-alist
     この変数は、メジャーモードから特定のマイナモード向けのキーバインディングを
     無効にするためのものである。
     この連想リストの要素は、`minor-mode-map-alist'の要素と同じ形で、
     `(VARIABLE . KEYMAP)'である。

     `minor-mode-overriding-map-alist'の要素として変数が現れると、
     当該要素が指定するキーマップで、
     `minor-mode-map-alist'内の同じ変数で指定したキーマップを
     完全に置き換える。

     `minor-mode-overriding-map-alist'は、すべてのバッファにおいて、
     自動的にバッファにローカルになる。

 -- Variable: overriding-local-map
     `nil'以外の値であると、この変数は、
     バッファのローカルキーマップ、ならびに、すべてのマイナモードキーマップの
     かわりに用いるキーマップを保持する。
     このキーマップは、現在のグローバルキーマップを除く、
     他のすべての活性なキーマップを無効にする。

 -- Variable: overriding-terminal-local-map
     `nil'以外であると、この変数は、
     `overriding-local-map'、および、バッファのローカルキーマップと
     すべてのマイナモードキーマップのかわりに用いるキーマップを保持する。

     この変数はつねに現在の端末に対してローカルであり、
     バッファに対してローカルにはならない。 *note Multiple Displays::。
     これはインクリメンタルサーチモードの実装に使われている。

 -- Variable: overriding-local-map-menu-flag
     この変数が`nil'以外であれば、
     `overriding-local-map'や`overriding-terminal-local-map'の値は、
     メニューバーの表示に影響する。 デフォルト値は`nil'であり、
     そのため、それらのマップはメニューバーには影響しない。

     これら2つのキーマップ変数は、メニューバーの表示に影響しないときであっても、
     メニューバーを用いて入力したキー列の実行には影響することに注意してほしい。
     そのため、メニューバーのキー列が到着したら、
     そのキー列を探索し実行するまえに、これらの変数をクリアすべきである。
     これらの変数を使うモードでは、典型的にはつぎのようにする。
     つまり、モードで処理できないイベントは『読み戻し』てモードから抜ける。

 -- Variable: special-event-map
     この変数は特殊イベント用のキーマップを保持する。
     イベント型のバインディングがこのキーマップにあれば、
     そのイベントは特殊イベントであり、
     `read-event'が当該イベントのバインディングを直接実行する。 *note
     Special Events::。


File: elisp-ja,  Node: Key Lookup,  Next: Functions for Key Lookup,  Prev: Active Keymaps,  Up: Keymaps

21.7 キー探索
=================

"キー探索"（key lookup）とは、
与えられたキーマップからキー列のバインディングを捜し出す処理です。
バインディングを実際に実行することは、キー探索ではありません。

   キー探索では、キー列の各イベントのイベント型のみを使い、
イベントの他の部分は無視します。 実際、キー探索に使われるキー列では、
マウスイベント全体（リスト）ではなく
そのイベント型（シンボル）のみを指定します。 *Note Input Events::。
そのような『キー列』は、`command-execute'の動作には不十分ですが、
キーの探索や再バインディングには十分です。

   キー列が複数のイベントから構成される場合、
キー探索ではイベントを順番に処理します。
先頭のイベントのバインディングを探しますが、
それはキーマップであるはずです。
続いて、そのキーマップから2番目のイベントのバインディングを探します。
これをキー列のすべてのイベントを使い尽くすまで行います。
（このように探した最後のイベントに対するバインディングは、
キーマップであたっりそうでないかもしれない。） つまり、キー探索処理は、
キーマップから単一イベントを探索するという単純な処理として定義できます。
これがどのように行われるかは、
キーマップ内のイベントに対応付けられたオブジェクトの型に依存します。

   キーマップでイベント型を探してみつかった値のことを
"キーマップ項目"（keymap entry）という単語で表します。
（これには、メニューキーバインディングにある
項目文字列や他の追加要素を含まない。
というのは、`lookup-key'や他のキー探索関数は、
それらを戻り値として返さないからである。）
キーマップ項目として任意のLispオブジェクトをキーマップに保存できますが、
キー探索においてそのすべてが意味を持つとは限りません。
意味のある種類のキー項目をつぎに示します。

`nil'
     `nil'は、探索に使ったここまでのイベントが
     未定義キーを構成することを意味する。
     キーマップにイベント型が記載されてなく、かつ、
     デフォルトのバインディングもない場合には、
     そのイベント型に対しては、バインディングが`nil'であるのと等価。

COMMAND
     探索に使ったここまでのイベントは完全なキーを構成し、
     そのバインディングはコマンドCOMMANDである。 *note What Is a
     Function::。

ARRAY
     配列（文字列やベクトル）は、キーボードマクロである。
     探索に使ったここまでのイベントは完全なキーを構成し、
     そのバインディングは配列ARRAYである。 詳しくは*note Keyboard
     Macros::を参照。

KEYMAP
     探索に使ったここまでのイベントはプレフィックスキーを構成する。
     キー列のつぎのイベントはこのキーマップKEYMAPで探す。

LIST
     リストの意味は、リストの要素の型に依存する。

        * LISTのCARがシンボル`keymap'であれば、
          そのリストはキーマップであり、キーマップとして扱われる（上記参照）。

        * LISTのCARがシンボル`lambda'であれば、
          そのリストはラムダ式である。
          これはコマンドとみなされ、そのように扱われる（上記参照）。

        * LISTのCARがキーマップであり、CDRがイベント型であると、
          これは"間接項目"（indirect entry）である。

               (OTHERMAP . OTHERTYPE)

          キー探索中に間接項目に出会うと、
          OTHERTYPEのバインディングをOTHERMAPで探しそれを用いる。

          この機能により、あるキーを別のキーに対する別名として定義できる。
          たとえば、CARが`esc-map'と呼ばれるキーマップであり
          CDRが32（<SPC>の文字コード）である項目は、
          『`Meta-<SPC>'のグローバルバインディングを
          それがなんであれ使う』という意味になる。

SYMBOL
     シンボルSYMBOLのかわりにその関数定義を使う。
     それがまたシンボルであると、この処理を何回でも繰り返す。
     最終的にこれは、キーマップ、コマンド、キーボードマクロの
     いずれかのオブジェクトになるはずである。
     キーマップやコマンドであるリストは許されるが、
     シンボルを介しては間接項目は使えない。

     キーマップやキーボードマクロ（文字列やベクトル）は正しい関数ではないので、
     関数定義としてキーマップ、文字列、ベクトルを持つシンボルは、
     正しい関数ではない。 しかし、キーバインディングとしては正しい。
     定義がキーボードマクロである場合には、そのシンボルは
     `command-execute'の引数としても正しい （*note Interactive
     Call::）。

     シンボル`undefined'について特記しておく。
     これは、キーを未定義として扱うことを意味する。
     正確には、キーは定義されており、
     そのバインディングはコマンド`undefined'である。
     しかし、そのコマンドは、未定義キーに対して自動的に行われることと
     同じことを行う。 つまり、（`ding'を呼び出して）ベルを鳴らすが、
     エラーは通知しない。

     `undefined'は、グローバルキーバインディングを無効にして
     キーをローカルに『未定義』にするためにローカルキーマップで使われる。
     `nil'のローカルバインディングでは、
     グローバルバインディングを無効にしないため、こうはならない。

ÁÁĻ
     その他の型のオブジェクトであると、
     探索に使ったここまでのイベントは完全なキーを構成し、
     当該オブジェクトがそのバインディングであるが、
     当該バインディングはコマンドとしては実行できない。

   まとめると、キー項目は、キーマップ、コマンド、キーボードマクロ、
これら3つのいずれかになるシンボル、間接項目、`nil'です。
2つの文字をコマンドに、1つを別のキーマップに対応付ける
疎なキーマップの例を示します。
このキーマップは、`emacs-lisp-mode-map'の通常の値です。
ここで、それぞれ、9は<TAB>、 127は<DEL>、27は<ESC>、17は`C-q'、
24は`C-x'の文字コードであることに注意してください。

     (keymap (9 . lisp-indent-line)
             (127 . backward-delete-char-untabify)
             (27 keymap (17 . indent-sexp) (24 . eval-defun)))


File: elisp-ja,  Node: Functions for Key Lookup,  Next: Changing Key Bindings,  Prev: Key Lookup,  Up: Keymaps

21.8 キー探索関数
=======================

ここでは、キー探索に関わる関数や変数について述べます。

 -- Function: lookup-key keymap key &optional accept-defaults
     この関数はキーマップKEYMAPにおけるKEYの定義を返す。
     本章で述べる他の関数は、`lookup-key'を用いてキーを探す。 例を示す。

          (lookup-key (current-global-map) "\C-x\C-f")
              => find-file
          (lookup-key (current-global-map) "\C-x\C-f12345")
              => 2

     文字列やベクトルであるKEYが、
     KEYMAPで指定されたプレフィックスキーに対して正しいキー列でなければ、
     KEYは『長すぎる』のであって、
     1つのキー列に収まらない余分なイベントが末尾にある。
     その場合、戻り値は数であり、
     完全なキーを構成するKEYの先頭からのイベント数を表す。

     ACCEPT-DEFAULTSが`nil'以外であると、
     `lookup-key'は、KEYの特定のイベントに
     対するバインディングだけでなく、
     デフォルトのバインディングも考慮する。
     さもなければ、`lookup-key'は、
     KEYの特定のイベントに対するバインディングだけを報告し、
     特に指定しない限りデフォルトのバインディングは無視する。
     （それには、KEYの要素として`t'を与える。 *note Format of
     Keymaps::を参照。）

     KEYにメタ文字が含まれる場合、 当該文字は暗黙のうちに2文字の列、
     つまり、`meta-prefix-char'の値と対応する非メタ文字
     に置き換えられる。
     したがって、つぎの最初の例は、2番目の例に変換して処理される。

          (lookup-key (current-global-map) "\M-f")
              => forward-word
          (lookup-key (current-global-map) "\ef")
              => forward-word

     `read-key-sequence'と異なり、
     この関数は、情報を欠落するようには指定されたイベントを修正しない
     （*note Key Sequence Input::）。 特に、文字を小文字に変換したり、
     ドラッグイベントをクリックイベントに変換したりはしない。

 -- コマンド: undefined
     キーを未定義にするためにキーマップで使われる。
     `ding'を呼び出すが、エラーにはならない。

 -- Function: key-binding key &optional accept-defaults
     この関数は、すべての活性なキーマップを試して
     KEYに対するバインディングを返す。
     キーマップでKEYが未定義であると結果は`nil'。

     引数ACCEPT-DEFAULTSは、`lookup-key'（上記）と同様に、
     デフォルトのバインディングを調べるかどうか制御する。

     KEYが文字列でもベクトルでもないとエラーを通知する。

          (key-binding "\C-x\C-f")
              => find-file

 -- Function: local-key-binding key &optional accept-defaults
     この関数は、現在のローカルキーマップから
     KEYに対するバインディングを返す。 未定義ならば`nil'を返す。

     引数ACCEPT-DEFAULTSは、`lookup-key'（上記）と同様に、
     デフォルトのバインディングを調べるかどうか制御する。

 -- Function: global-key-binding key &optional accept-defaults
     この関数は、現在のグローバルキーマップから
     KEYに対するバインディングを返す。 未定義ならば`nil'を返す。

     引数ACCEPT-DEFAULTSは、`lookup-key'（上記）と同様に、
     デフォルトのバインディングを調べるかどうか制御する。

 -- Function: minor-mode-key-binding key &optional accept-defaults
     この関数は、すべてのオンになっているマイナモードにおける
     KEYのバインディングのリストを返す。 より正確には、対`(MODENAME .
     BINDING)'を要素とする 連想リストを返す。
     ここで、MODENAMEはマイナモードをオンにする変数であり、
     BINDINGは当該モードにおけるKEYのバインディングである。
     KEYにマイナモードでのバインディングがなければ、 値は`nil'である。

     最初にみつかったバインディングがプレフィックスの定義
     （キーマップかキーマップとしてのシンボル）でなければ、
     残りのマイナモードからのバインディングは完全に隠されてしまうので
     それらは省略する。 同様に、プレフィックスバインディングに
     続く非プレフィックスバインディングも省略する。

     引数ACCEPT-DEFAULTSは、`lookup-key'（上記）と同様に、
     デフォルトのバインディングを調べるかどうか制御する。

 -- Variable: meta-prefix-char
     この変数は、メタプレフィックス文字の文字コードである。
     メタ文字をキーマップで探索するために2文字列に変換するときに使われる。
     結果が有用であるためには、 この値はプレフィックスイベント（*note
     Prefix Keys::）であるべきである。
     デフォルト値は27、<ESC>のASCIIコードである。

     `meta-prefix-char'の値が27である限り、 キー探索では`M-b'を`<ESC>
     b'に変換し、 通常、これはコマンド`backward-word'と定義されている。
     しかし、`meta-prefix-char'に`C-x'のコードである24を設定すると、
     Emacsは`M-b'を`C-x b'に変換し、
     その標準のバインディングはコマンド`switch-to-buffer'である。
     これを以下に示す。

          meta-prefix-char                    ; デフォルト値
               => 27
          (key-binding "\M-b")
               => backward-word
          ?\C-x                               ; 文字の表示表現
               => 24
          (setq meta-prefix-char 24)
               => 24
          (key-binding "\M-b")
              => switch-to-buffer            ; ここで`M-b'と打つと
                                              ; `C-x b'と打つのと同じ

          (setq meta-prefix-char 27)          ; 混乱を避けるために
               => 27                         ; デフォルト値に戻す！


File: elisp-ja,  Node: Changing Key Bindings,  Next: Key Binding Commands,  Prev: Functions for Key Lookup,  Up: Keymaps

21.9 キーバインディングの変更
=========================================

キーを再バインドするには、キーマップにおける当該項目を変更します。
グローバルキーマップでバインディングを変更すると、
その変更はすべてのバッファで効果を発揮します
（ただし、ローカルキーマップでグローバルバインディングを
隠しているバッファでは直接の効果はない）。
カレントバッファのローカルキーマップで変更すると、
通常、同じメジャーモードを使っているすべてのバッファに影響します。
関数`global-set-key'や`local-set-key'は、
これらの操作を行うための便利なインターフェイスです （*note Key Binding
Commands::）。 より汎用の関数`define-key'を使うこともできますが、
変更対象のキーマップを明示する必要があります。

   キー列の再バインドを書くときには、 コントロール文字やメタ文字向けの
特別なエスケープシーケンスを使うのがよいです（*note String Type::）。
構文`\C-'は後続の文字がコントロール文字であること、
構文`\M-'は後続の文字がメタ文字であることを意味します。
したがって、文字列`"\M-x"'は単一の`M-x'を含むと読まれ、
`"\C-f"'は単一の`C-f'を含むと読まれ、
`"\M-\C-x"'や`"\C-\M-x"'はいずれも単一の`C-M-x'を 含むと読まれます。
同じエスケープシーケンスは、
ベクトルでも使え、文字列が許されない他の場面でも使えます。
たとえば、`[?\C-\H-x home]'です。 *Note Character Type::。

   キーを定義したり探索する関数では、
ベクトルで表したキー列内のイベント型に対して別の構文、
つまり、修飾子名と1つの基本イベント（文字やファンクションキー名）
から成るリストを受け付けます。 たとえば、`(control
?a)'は`?\C-a'に等価であり、 `(hyper control
left)'は`C-H-left'に等価です。 このようなリストの利点の1つは、
コンパイル済みのファイルに修飾ビットの数値が現れないことです。

   以下の関数では、KEYMAPがキーマップでなかったり、
KEYがキー列を表す文字列やベクトルでないと、エラーを通知します。
リストであるイベントの省略形としてイベント型（シンボル）を使えます。

 -- Function: define-key keymap key binding
     この関数は、キーマップKEYMAPにおいて
     キーKEYに対するバインディングを設定する。
     （KEYが複数イベントの場合、
     KEYMAPから辿った別のキーマップが実際には変更される。）
     引数BINDINGは任意のLispオブジェクトであるが、
     ある種の型のものだけが意味を持つ。
     （意味のある型の一覧については、*note Key Lookup::を参照。）
     `define-key'が返す値はBINDINGである。

     KEYのおのおののプレフィックスはプレフィックスキーである
     （キーマップにある）か未定義であること。
     さもなければ、エラーを通知する。
     KEYのプレフィックスに未定義なものがあると、
     `define-key'は当該プレフィックスをプレフィックスキーと定義し、
     KEYの残りの部分を指定どおりに定義できるようにする。

     KEYMAPにKEYのバインディングがなければ、
     新たなバインディングをKEYMAPの先頭に追加する。
     キーマップ内のバインディングの順序は多くの場合関係ないが、
     メニューキーマップでは意味を持つ（*note Menu Keymaps::）。

   疎なキーマップを作成し、そこにバインディングを作る例を示します。

     (setq map (make-sparse-keymap))
         => (keymap)
     (define-key map "\C-f" 'forward-char)
         => forward-char
     map
         => (keymap (6 . forward-char))

     ;; `C-x'用の疎なサブマップを作り、
     ;; そこに`f'のバインディングを入れる
     (define-key map "\C-xf" 'forward-word)
         => forward-word
     map
     => (keymap
         (24 keymap                ; C-x
             (102 . forward-word)) ;      f
         (6 . forward-char))       ; C-f

     ;; `C-p'を`ctl-x-map'にバインドする
     (define-key map "\C-p" ctl-x-map)
     ;; `ctl-x-map'
     => [nil ... find-file ... backward-kill-sentence]

     ;; `ctl-x-map'で、`C-f'を`foo'にバインドする
     (define-key map "\C-p\C-f" 'foo)
     => 'foo
     map
     => (keymap     ; `foo'は`ctl-x-map'の中にある
         (16 keymap [nil ... foo ... backward-kill-sentence])
         (24 keymap
             (102 . forward-word))
         (6 . forward-char))

`C-p C-f'に対する新しいバインディングは、
実際には`ctl-x-map'の項目を変更していて、 これには、`C-p
C-f'とデフォルトのグローバルキーマップ内の `C-x
C-f'の両方のバインディングを変更する効果がある ことに注意してください。

 -- Function: substitute-key-definition olddef newdef keymap &optional
          oldmap
     この関数は、KEYMAP内のOLDDEFにバインドされたキーの
     OLDDEFをNEWDEFに置き換える。
     いいかえると、OLDDEFに出会うたびにそれをNEWDEFに置き換える。
     関数は`nil'を返す。

     たとえば、Emacsの標準のバインディングであると、 つぎの例は`C-x
     C-f'を再定義する。

          (substitute-key-definition
           'find-file 'find-file-read-only (current-global-map))

     OLDMAPが`nil'以外であると、
     そのバインディングによってどのキーを再バインドするかを決定する。
     再バインディングはKEYMAPで行い、OLDMAPではない。
     つまり、別のキーマップ内のバインディングの制御のもとに、
     キーマップを変更できる。 たとえば、

          (substitute-key-definition
            'delete-backward-char 'my-funny-delete
            my-map global-map)

     では、グローバルには標準の削除コマンドにバインドされているキーに対しては、
     `my-map'では特別な削除コマンドにする。

     変更前後のキーマップを以下に示す。

          (setq map '(keymap
                      (?1 . olddef-1)
                      (?2 . olddef-2)
                      (?3 . olddef-1)))
          => (keymap (49 . olddef-1) (50 . olddef-2) (51 . olddef-1))

          (substitute-key-definition 'olddef-1 'newdef map)
          => nil
          map
          => (keymap (49 . newdef) (50 . olddef-2) (51 . newdef))

 -- Function: suppress-keymap keymap &optional nodigits
     この関数は、完全なキーマップKEYMAPの内容を変更し、
     すべての印字文字を未定義にする。
     より正確には、それらにコマンド`undefined'をバインドする。
     これにより、通常のテキストの挿入を不可能にする。
     `suppress-keymap'は`nil'を返す。

     NODIGITSが`nil'であると、 `suppress-keymap'は、
     数字文字では`digit-argument'を実行し、
     `-'では`negative-argument'を実行するように定義する。
     さもなければ、それらも他の印字文字と同様に未定義にする。

     関数`suppress-keymap'は、
     `yank'や`quoted-insert'などのコマンドを抑制しないので、
     バッファを変更不可能にするわけではない。
     バッファの変更を禁止するには、バッファを読み出し専用にする （*note
     Read Only Buffers::）。

     この関数はKEYMAPを変更するため、
     読者は、通常、新たに作成したキーマップに対して使うであろう。
     ある目的で使用中の既存のキーマップを操作すると、
     問題を引き起こすことがある。
     たとえば、`global-map'に適用するとEmacsをほとんど使用不能にしてしまう。

     多くの場合、テキストの挿入が必要なくバッファを読み出し専用で使う
     rmailやdiredなどのモードのローカルキーマップの初期化に
     `suppress-keymap'を使う。
     ファイル`emacs/lisp/dired.el'から持ってきた例を示す。
     これは、diredモード用のローカルキーマップの設定方法である。

          (setq dired-mode-map (make-keymap))
          (suppress-keymap dired-mode-map)
          (define-key dired-mode-map "r" 'dired-rename-file)
          (define-key dired-mode-map "\C-d" 'dired-flag-file-deleted)
          (define-key dired-mode-map "d" 'dired-flag-file-deleted)
          (define-key dired-mode-map "v" 'dired-view-file)
          (define-key dired-mode-map "e" 'dired-find-file)
          (define-key dired-mode-map "f" 'dired-find-file)
          ...


File: elisp-ja,  Node: Key Binding Commands,  Next: Scanning Keymaps,  Prev: Changing Key Bindings,  Up: Keymaps

21.10 キーをバインドするためのコマンド
======================================================

本節では、キーのバインディングを変更する
便利で対話的なインターフェイスについて述べます。
これらは、`define-key'を呼び出して動作します。

   単純なカスタマイズのために
ファイル`.emacs'で`global-set-key'をしばしば使います。 たとえば、

     (global-set-key "\C-x\C-\\" 'next-line)

や

     (global-set-key [?\C-x ?\C-\\] 'next-line)

や

     (global-set-key [(control ?x) (control ?\\)] 'next-line)

は、1行下がるように`C-x C-\'を再定義します。

     (global-set-key [M-mouse-1] 'mouse-set-point)

は、メタキーを押し下げながらマウスの第1ボタン（左端）をクリックすると
クリック位置にポイントを設定するように再定義します。

 -- コマンド: global-set-key key definition
     この関数は、現在のグローバルキーマップにおいて
     KEYのバインディングをDEFINITIONと設定する。

          (global-set-key KEY DEFINITION)
          ==
          (define-key (current-global-map) KEY DEFINITION)

 -- コマンド: global-unset-key key
     この関数は、現在のグローバルキーマップから
     KEYのバインディングを削除する。

     この関数の1つの用途は、
     KEYに非プレフィックスのバインディングがあると再定義できないため、
     KEYをプレフィックスとして使う長いキーを定義する前準備である。
     たとえば、つぎのとおり。

          (global-unset-key "\C-l")
              => nil
          (global-set-key "\C-l\C-l" 'redraw-display)
              => nil

     この関数は単に`define-key'を使って実装してある。

          (global-unset-key KEY)
          ==
          (define-key (current-global-map) KEY nil)

 -- コマンド: local-set-key key definition
     この関数は、現在のローカルキーマップにおいて
     KEYのバインディングをDEFINITIONと設定する。

          (local-set-key KEY DEFINITION)
          ==
          (define-key (current-local-map) KEY DEFINITION)

 -- コマンド: local-unset-key key
     この関数は、現在のローカルキーマップから
     KEYのバインディングを削除する。

          (local-unset-key KEY)
          ==
          (define-key (current-local-map) KEY nil)


File: elisp-ja,  Node: Scanning Keymaps,  Next: Menu Keymaps,  Prev: Key Binding Commands,  Up: Keymaps

21.11 キーマップの走査
==============================

本節では、ヘルプ情報を表示するために
現在のキーマップをすべて走査する関数について述べます。

 -- Function: accessible-keymaps keymap &optional prefix
     この関数は、KEYMAPから（0個以上のプレフィックスキーにより）辿れる
     すべてのキーマップのリストを返す。 その値は、`(KEY .
     MAP)'の形の要素から成る 連想リストである。
     ここで、KEYはプレフィックスキーであり、
     KEYMAP内でのその定義はMAPである。

     連想リスト内での要素の順番は、KEYの長さが増える順である。
     指定したキーマップKEYMAPはプレフィックスのイベントなしに参照できるので、
     最初の要素はつねに`("" . KEYMAP)'である。

     PREFIXを与える場合、それはプレフィックスキー列であること。
     すると、`accessible-keymaps'は、
     PREFIXで始まるプレフィックスに対応したサブマップのみを含める。
     それらの要素は、`(accessible-keymaps)'の値と同じに見えるが、
     違いは、いくつかの要素が省略されることである。

     つぎの例では、返された連想リストにおいては、
     `^['と表示されたキー<ESC>はプレフィックスキーであり、
     その定義は疎なキーマップ `(keymap (83 . center-paragraph) (115 .
     foo))'であることを表す。

          (accessible-keymaps (current-local-map))
          =>(("" keymap
                (27 keymap   ; Note this keymap for <ESC> is repeated below.
                    (83 . center-paragraph)
                    (115 . center-line))
                (9 . tab-to-tab-stop))

             ("^[" keymap
              (83 . center-paragraph)
              (115 . foo)))

     つぎの例では、`C-h'は、 疎なキーマップ`(keymap (118 .
     describe-variable)...)'を 使うプレフィックスキーである。
     別のプレフィックス`C-x 4'は、
     変数`ctl-x-4-map'の値でもあるキーマップを使う。
     イベント`mode-line'は、
     ウィンドウの特別な箇所におけるマウス操作を表すための
     疑似イベントの1つである。

          (accessible-keymaps (current-global-map))
          => (("" keymap [set-mark-command beginning-of-line ...
                             delete-backward-char])
              ("^H" keymap (118 . describe-variable) ...
               (8 . help-for-help))
              ("^X" keymap [x-flush-mouse-queue ...
               backward-kill-sentence])
              ("^[" keymap [mark-sexp backward-sexp ...
               backward-kill-word])
              ("^X4" keymap (15 . display-buffer) ...)
              ([mode-line] keymap
               (S-mouse-2 . mouse-split-window-horizontally) ...))

     実際に表示されるキーマップはこれらだけとは限らない。

 -- Function: where-is-internal command &optional keymap firstonly
          noindirect
     この関数は、コマンド`where-is' （*note ヘルプ機能:
     (emacs)Help.）が使う サブルーティンである。
     キーマップにおいてCOMMANDにバインドされた
     （任意長の）キー列のリストを返す。

     引数COMMANDは任意のオブジェクトであり、
     キーマップ項目とは`eq'で比較する。

     KEYMAPが`nil'であると、 `overriding-local-map'を無視
     （つまり、その値は`nil'とみな）して、 現在活性なキーマップを使う。
     KEYMAPが`nil'以外であると、
     KEYMAPとグローバルキーマップから辿れるキーマップを使う。

     通常、KEYMAPに対する式には`overriding-local-map'を使うのが
     最良である。
     そうすると、`where-is-internal'は正確に活性なキーマップを走査する。
     グローバルキーマップのみを走査するには、
     KEYMAPとして`(keymap)'（空のキーマップ）を渡す。

     FIRSTONLYが`non-ascii'であると、
     戻り値は、可能なキー列のリストではなく、
     最初にみつかったキー列を表す1つの文字列である。
     FIRSTONLYが`t'であると、 値は最初のキー列であるが、
     ASCII文字（あるいはASCII文字のメタ変種）のみから成るキー列が
     他のキー列より優先される。

     NOINDIRECTが`nil'以外であると、
     `where-is-internal'は間接項目を辿らない。
     これにより、間接項目そのものを探すことができる。

          (where-is-internal 'describe-function)
              => ("\^hf" "\^hd")

 -- コマンド: describe-bindings &optional prefix
     この関数は、現在のすべてのキーバインディングの一覧を作成し、
     `*Help*'という名前のバッファに表示する。
     テキストはモードごとにまとめられ、
     マイナモード、メジャーモード、グローバルバインディングの順である。

     PREFIXが`nil'以外であると、それはプレフィックスキーであること。
     そうすると、PREFIXで始まるキーのみの一覧を作る。

     一覧では、メタ文字は、<ESC>に続けて対応する非メタ文字で表す。

     連続したASCIIコードの一連の文字が同じ定義である場合には、
     それらをまとめて`FIRSTCHAR..LASTCHAR'と表示する。
     この場合、どの文字であるか理解するには、
     ASCIIコードを知っている必要がある。
     たとえば、デフォルトのグローバルキーマップでは、 `<SPC>..
     ~'の文字が1行に表示される。
     <SPC>はASCIIコード32、`~'はASCIIコード126であり、
     そのあいだには普通の印字文字（英文字、数字文字、句読点文字など）が
     すべて含まれる。
     これらの文字はすべて`self-insert-command'にバインドされている。


File: elisp-ja,  Node: Menu Keymaps,  Prev: Scanning Keymaps,  Up: Keymaps

21.12 メニューキーマップ
=================================

キーマップは、キーボードのキーやマウスボタンに対するバインディングに加えて
メニューも定義できます。

* Menu:

* Defining Menus::		How to make a keymap that defines a menu.
* Mouse Menus::			How users actuate the menu with the mouse.
* Keyboard Menus::		How they actuate it with the keyboard.
* Menu Example::		Making a simple menu.
* Menu Bar::			How to customize the menu bar.
* Modifying Menus::             How to add new items to a menu.


File: elisp-ja,  Node: Defining Menus,  Next: Mouse Menus,  Up: Menu Keymaps

21.12.1 メニューの定義
-----------------------------

キーマップに"全面プロンプト文字列"（overall prompt string）、
つまり、キーマップの要素として文字列が現れれば、
メニューとして使えます。 その文字列でメニューの目的を記述します。
プロンプト文字列を持ったキーマップを作成するもっとも簡単な方法は、
`make-keymap'や`make-sparse-keymap'（*note Creating Keymaps::）を
呼ぶときに、引数として文字列を指定します。

   メニュー上での項目の順番は、
キーマップ内のバインディングの順番と同じです。
`define-key'は、新たなバインディングを先頭に追加するので、
順番を気にするのならば、メニューの底の項目から始めて
上の項目へ向かってメニュー項目の定義を入れます。
既存のメニューに項目を追加する場合には、 `define-key-after'（*note
Modifying Menus::）を使って メニュー内での位置を指定できます。

* Menu:

* Simple Menu Items::       A simple kind of menu key binding,
                              limited in capabilities.
* Alias Menu Items::        Using command aliases in menu items.
* Extended Menu Items::     More powerful menu item definitions
                              let you specify keywords to enable
                              various features.


File: elisp-ja,  Node: Simple Menu Items,  Next: Alias Menu Items,  Up: Defining Menus

21.12.1.1 単純なメニュー項目
.....................................

メニューキーマップのバインディングを定義する単純で旧式の方法は
つぎのとおりです。

     (ITEM-STRING . REAL-BINDING)

CARのITEM-STRINGは、メニューに表示される文字列です。
3単語までの短いものにし、対応するコマンドの動作を記述します。

   つぎのように、ヘルプ文字列となる2つめの文字列も指定できます。

     (ITEM-STRING HELP-STRING . REAL-BINDING)

   現状では、Emacsは実際にはHELP-STRINGを使いません。
REAL-BINDINGを取り出すためにHELP-STRINGを無視する方法を
知っているだけです。
将来、ユーザーの要望に応じてメニュー項目に対する追加説明として
HELP-STRINGを使うかもしれません。

   `define-key'に関する限り、 ITEM-STRINGとHELP-STRINGは
イベントのバインディングの一部分です。
しかし、`lookup-key'はREAL-BINDINGのみを返し、
キーの実行にはREAL-BINDINGのみが使われます。

   REAL-BINDINGが`nil'であると、
ITEM-STRINGはメニューに現れますが、それは選択できません。

   REAL-BINDINGがシンボルであり、
その属性`menu-enable'が`nil'以外であると、
当該属性は、メニュー項目を活性にするかどうかを制御する式です。
Emacsは、メニューを表示するためにキーマップを使うたびに、
その式を評価し、式の値が`nil'以外である場合に限り、
当該メニュー項目をオンにします。
メニュー項目がオフであると、『薄く』表示し、それは選択できません。

   メニューバーでは、読者がメニューを見るたびにどの項目がオンであるかを
再計算しません。
Xツールキットがあらかじめメニューの木構造全体を必要とするからです。
メニューバーの再計算を強制するには、
`force-mode-line-update'を呼び出します。 （*note Mode Line Format::）。

   メニュー項目には、同じコマンドを起動する等価なキーボードのキー列が
（あれば）表示されていることに気づいたと思います。
再計算の時間を節約するために、
メニューの表示では、この情報をつぎのように
バインディングの部分リストに隠し持っています。

     (ITEM-STRING [HELP-STRING] (KEY-BINDING-DATA) . REAL-BINDING)

読者は、メニュー項目にこれらの部分リストを入れないでください。
それらはメニューの表示で自動的に計算されます。
冗長になるので、項目の文字列には、等価なキーボード入力を
含めないでください。


File: elisp-ja,  Node: Extended Menu Items,  Prev: Alias Menu Items,  Up: Defining Menus

21.12.1.2 拡張メニュー項目
..................................

拡張形式のメニュー項目は、より柔軟性があり、
単純な形式より見通しがよい代替方法です。
それらは、シンボル`menu-item'で始まるリストから成ります。
選択不可の文字列を定義するには、項目をつぎのようにします。

     (menu-item ITEM-NAME)

ここで、文字列ITEM-NAMEは区切り行を表す複数個のダッシュから成ります。

   選択可能な実際のメニュー項目を定義するには、
拡張形式の項目はつぎのようになります。

     (menu-item ITEM-NAME REAL-BINDING
         . ITEM-PROPERTY-LIST)

ここで、ITEM-NAMEは、メニュー項目の文字列に評価される式です。
つまり、（項目の）文字列は定数である必要はありません。
3番目の要素ITEM-PROPERTY-LISTは実行すべきコマンドです。
リストの残りITEM-PROPERTY-LISTは、
他の情報を含んだ属性リストの形式です。
指定できる属性はつぎのとおりです。

`:enable FORM'
     FORMの評価結果で、項目をオンにするかどうか決定する
     （`nil'以外だとオン）。

`:visible FORM'
     FORMの評価結果で、項目をメニューに含めるかどうか決定する。
     （`nil'以外だと含める）。
     項目を含めない場合、当該項目が定義されていないかのようにメニューを表示する。

`:help HELP'
     この属性の値HELPは、拡張ヘルプ文字列 （現状ではEmacsは使わない）。

`:button (TYPE . SELECTED)'
     この属性は、ラジオボタンとトグルボタンを定義する方法を提供する。
     CARのTYPEは、`:toggle'か`:radio'であり、 どちらであるかを指定する。
     CDRのSELECTEDはフォームであること。
     その評価結果が、現在ボタンが選択されているかどうかを決定する。

     "トグル"（toggle）は、SELECTEDの値に応じて
     『on』か『off』と書かれるメニュー項目である。
     コマンド自身では、SELECTEDが`nil'ならば SELECTEDに`t'を設定し、
     `t'ならば`nil'を設定すること。
     以下は、`debug-on-error'が定義されていれば
     `debug-on-error'をオン／オフするメニュー項目の書き方である。

          (menu-item "Debug on Error" toggle-debug-on-error
                     :button (:toggle
                              . (and (boundp 'debug-on-error)
                                     debug-on-error))

     これは、変数`debug-on-error'をオン／オフするコマンドとして
     `toggle-debug-on-error'が定義されているので動作する。

     "ラジオボタン"（radio button）はメニュー項目のグループであり、
     ある時点ではそれらのうちの1つだけを『選択』できる。
     どれを選択しているかを表す変数が必要である。
     グループ内の各ラジオボタンに対するフォームSELECTEDは、
     当該変数の値が当該ボタンを選択している値かどうかを検査する。
     ボタンをクリックすると、クリックしたボタンが選択されるように
     当該変数に設定すること。

`:key-sequence KEY-SEQUENCE'
     この属性は、このメニュー項目が起動するコマンドにバインド
     される可能性があるキー列を指定する。
     正しいキー列を指定すると、メニュー表示の準備が素早くなる。

     まちがったキー列を指定しても、その効果はない。
     メニューにKEY-SEQUENCEを表示するまえに、
     EmacsはKEY-SEQUENCEがこのメニュー項目に実際に等価かどうか調べる。

`:key-sequence nil'
     この属性は、このメニュー項目に等価なキーバインディングが
     普通はないことを示す。
     この属性を使うとメニュー表示の準備時間を節約できる。
     Emacsはこのメニュー項目に等価なキーボード入力をキーマップで
     探す必要がないからである。

     しかし、ユーザーがこの項目の定義に対してキー列を再バインドすると、
     Emacsは属性`:keys'を無視して等価なキーボード入力を探す。

`:keys STRING'
     この属性は、このメニュー項目に対する等価なキーボード入力として
     表示する文字列STRINGを指定する。
     STRINGでは説明文の`\\[...]'の書き方を使える。

`:filter FILTER-FN'
     この属性は、動的にメニュー項目を計算する方法を与える。
     属性値FILTER-FNは1引数の関数であること。
     それが呼ばれるとき、引数はREAL-BINDINGになる。
     関数はかわりに使用するバインディングを返すこと。


File: elisp-ja,  Node: Alias Menu Items,  Next: Extended Menu Items,  Prev: Simple Menu Items,  Up: Defining Menus

21.12.1.3 メニュー項目の別名
.....................................

『同じ』コマンドを使いながらオン条件が異なるメニュー項目を
作れると便利なことがあります。
現状のEmacsでこれを行う最良の方法は、拡張メニュー項目を使うことです。
この機能がなかった頃には、コマンドの別名を定義し、
それをメニュー項目で使うことで可能でした。
異なるオン条件で`toggle-read-only'を
使う2つの別名の作り方を以下に示します。

     (defalias 'make-read-only 'toggle-read-only)
     (put 'make-read-only 'menu-enable '(not buffer-read-only))
     (defalias 'make-writable 'toggle-read-only)
     (put 'make-writable 'menu-enable 'buffer-read-only)

   メニューに別名を使うときには、
（典型的にはメニュー以外にはキーバインディングがない）別名ではなく
『本物の』コマンド名に対する等価なキーバインディングを
表示しするのがしばしば有用です。 これを行うには、別名のシンボルには
`nil'以外の属性`menu-alias'を与えます。

     (put 'make-read-only 'menu-alias t)
     (put 'make-writable 'menu-alias t)

こうすると、`make-read-only'と`make-writable'のメニュー項目には
`toggle-read-only'に対するキーバインディングが表示されます。


File: elisp-ja,  Node: Mouse Menus,  Next: Keyboard Menus,  Prev: Defining Menus,  Up: Menu Keymaps

21.12.2 メニューとマウス
--------------------------------

メニューキーマップがメニューを表示するようにする普通の方法は、
メニューキーマップをプレフィックスキーの定義にすることです。
（Lispプログラムから明示的にメニューをポップアップして、
ユーザーの選択を受け取れる。 *note Pop-Up Menus::を参照。）

   プレフィックスキーがマウスイベントで終っていると、
Emacsはメニューをポップアップすることでメニューキーマップを扱います。
これで、ユーザーはマウスで選択できるようになります。
ユーザーがメニュー項目をクリックすると、
当該メニュー項目をバインディングとする文字やシンボルが
イベントとして生成されます。
（メニューが複数レベルになっていたりメニューバーから開いたときには、
メニュー項目は一連のイベントを生成する。）

   メニューの開始にはボタン押し下げイベントを使うのがしばしば最良です。
そうすると、ユーザーはボタンを離すことでメニュー項目を選べます。

明示的に配置すれば、1つのキーマップをメニューペインとして表示できます。
それには、各ペインに対するキーマップを作成し、
つぎに、メニューのメインのキーマップにおいて、
（各ペインの）各キーマップに対するバインディングを作ります。
なお、これらのバインディングには、 `@'で始まる項目文字列を指定します。
項目文字列の残りの部分がペインの名前になります。
この例についてはファイル`lisp/mouse.el'を参照してください。
`@'で始まらない項目文字列の他の普通のバインディングは
1つのペインにまとめられ、サブマップに対して明示的に作られた
他のペインとともに表示されます。

   Xツールキットのメニューにはペインはありませんが、
そのかわりに、サブメニューがあります。
項目文字列が`@'で始まるかどうかに関わらず、
入れ子になった各キーマップがサブメニューになります。
Emacsのツールキット版では、項目文字列の先頭の`@'に関して特別なことは、
`@'がメニュー項目に表示されないことです。

   個別のキーマップからも複数ペインやサブメニューを作成できます。
プレフィックスキーの完全な定義は、
さまざまな活性のキーマップ（マイナモード、ローカル、グローバル）が与える
定義を併合することで得られます。
これらのキーマップのうち複数個がメニューであるとき、
そのおのおのが別々のペイン（Xツールキットを使わないEmacs）や
別々のサブメニュー（Xツールキットを使ったEmacs）になります。 *Note
Active Keymaps::。


File: elisp-ja,  Node: Keyboard Menus,  Next: Menu Example,  Prev: Mouse Menus,  Up: Menu Keymaps

21.12.3 メニューとキーボード
--------------------------------------

キーボードイベント（文字や関数）で終るプレフィックスキーに、
メニューキーマップであるような定義があると、
ユーザーはメニュー項目を選ぶためにキーボードを使えます。

   Emacsはメニューの選択項目（バインディングの項目文字列）を
エコー領域に表示します。 それらが1行に収まらなければ、
ユーザーは<SPC>を打つことで選択項目のつぎの行を見ることができます。
<SPC>を連続して使うと最終的にはメニューの最後に達し、
そうするとメニューの先頭に戻ります。
（変数`menu-prompt-more-char'に、このために用いる文字を指定する。
デフォルトは<SPC>。）

   ユーザーは、メニューから望みの項目をみつけたら、
対応する文字、つまり、その項目のバインディングを持つ文字を打ちます。

   Emacs類似エディタにおけるこのようなメニューの使い方は、
システムHierarkeyに触発されたからです。

 -- Variable: menu-prompt-more-char
     この変数は、メニューのつぎの行を見るために使う文字を指定する。
     初期値は、<SPC>の文字コードの32である。


File: elisp-ja,  Node: Menu Example,  Next: Menu Bar,  Prev: Keyboard Menus,  Up: Menu Keymaps

21.12.4 メニューの例
--------------------------

以下に、メニューキーマップの完全な定義の例を示します。
これは、メニューバーのメニュー`Tools'の
サブメニュー`Print'の定義であり、 単純なメニュー項目を使います （*note
Simple Menu Items::）。 まず、キーマップを作成し名前を与えます。

     (defvar menu-bar-print-menu (make-sparse-keymap "Print"))

つぎに、メニュー項目を定義します。

     (define-key menu-bar-print-menu [ps-print-region]
       '("Postscript Print Region" . ps-print-region-with-faces))
     (define-key menu-bar-print-menu [ps-print-buffer]
       '("Postscript Print Buffer" . ps-print-buffer-with-faces))
     (define-key menu-bar-print-menu [separator-ps-print]
       '("--"))
     (define-key menu-bar-print-menu [print-region]
       '("Print Region" . print-region))
     (define-key menu-bar-print-menu [print-buffer]
       '("Print Buffer" . print-buffer))

バインディングが『作られる対象』のシンボルに注意してください。
定義されるキー列の角括弧の内側に現れています。
そのシンボルはコマンド名に等しい場合もあればそうでない場合もあります。
これらのシンボルは『ファンクションキー』として扱われますが、
キーボード上の本物のファンクションキーではありません。
それらはメニュー項目の機能には影響ありませんが、
ユーザーがメニューから選ぶとそれらはエコー領域に『表示』され、
`where-is'や`apropos'の出力にも現れます。

   定義が`("--")'であるようなバインディングは区切り行です。
実際のメニュー項目のように、区切りにもキーシンボルがあり、
例では`separator-ps-print'です。 1つのメニューに複数の区切りがある場合、
それらはすべて異なるキーシンボルでなければなりません。

   つぎには、メニュー内の2つのコマンドのオン条件を定義するコードです。

     (put 'print-region 'menu-enable 'mark-active)
     (put 'ps-print-region-with-faces 'menu-enable 'mark-active)

   つぎは、このメニューを親メニューの項目に現れるようにする方法です。

     (define-key menu-bar-tools-menu [print]
       (cons "Print" menu-bar-print-menu))

ここで使っているのは、サブメニューのキーマップ、つまり、
変数`menu-bar-print-menu'の値であって、
変数そのものではないことに注意してください。
`menu-bar-print-menu'はコマンドではないので、
このシンボルを親メニューの項目に使っても意味がありません。

   同じ印刷メニューをマウスクリックに対応付けたければ、
つぎのようにしてできます。

     (define-key global-map [C-S-down-mouse-1]
        menu-bar-print-menu)

   つぎのようにして、`print-region'に対して拡張メニュー項目 （*note
Extended Menu Items::）を使うこともできます。

     (define-key menu-bar-print-menu [print-region]
       '(menu-item "Print Region" print-region
                   :enable (mark-active)))

拡張メニュー項目では、オン条件はメニュー項目自体の内側に指定します。
マークがないときにはメニューからこの項目が消えるようにするには
つぎのようにします。

     (define-key menu-bar-print-menu [print-region]
       '(menu-item "Print Region" print-region
                   :visible (mark-active)))


File: elisp-ja,  Node: Menu Bar,  Next: Modifying Menus,  Prev: Menu Example,  Up: Menu Keymaps

21.12.5 メニューバー
--------------------------

ほとんどのウィンドウシステムでは、 各フレームに"メニューバー"（menu
bar）、
つまり、フレームの先頭に水平方向に延びているメニューを恒久的に表示できます。
メニューバーの項目は、すべての活性なキーマップで定義された
疑似『ファンクションキー』`menu-bar'のサブコマンドです。

   メニューバーに項目を追加するには、
読者独自の疑似『ファンクションキー』を考え（これをKEYとする）、
キー列`[menu-bar KEY]'に対するバインディングを作ります。
多くの場合、バインディングはメニューキーマップであって、
メニューバーの項目上でボタンを押すと別のメニューへ至るようにします。

   メニューバーに対する同じ疑似ファンクションキーを
複数の活性なキーマップで定義していても、1つの項目だけが表示されます。
ユーザーがメニューバーの当該項目をクリックすると、
当該項目のすべてのサブコマンド、つまり、
グローバルのサブコマンド、ローカルのサブコマンド、
マイナモードのサブコマンドを含む1つの複合メニューが表示されます。

   メニューバーの内容を決定する際には、
通常、変数`overriding-local-map'は無視されます。
つまり、`overriding-local-map'が`nil'であるときに
活性になるキーマップからメニューバーを計算します。 *Note Active
Keymaps::。

   フレームにメニューバーを表示するには、
フレームのパラメータ`menu-bar-lines'が0より大きい必要があります。
Emacsはメニューバーそのものには1行だけ使います。
読者が2行以上を指定すると、
残りの行はフレームのウィンドウとメニューバーを区切る行になります。
`menu-bar-lines'の値には1か2を勧めます。 *Note Window Frame
Parameters::。

   メニューバーの項目の設定例を示します。

     (modify-frame-parameters (selected-frame)
                              '((menu-bar-lines . 2)))

     ;; （プロンプト文字列を持つ）メニューキーマップを作り
     ;; それをメニューバーの項目の定義にする
     (define-key global-map [menu-bar words]
       (cons "Words" (make-sparse-keymap "Words")))

     ;; このメニュー内のサブコマンドを定義する
     (define-key global-map
       [menu-bar words forward]
       '("Forward word" . forward-word))
     (define-key global-map
       [menu-bar words backward]
       '("Backward word" . backward-word))

   グローバルキーマップに作ったメニューバー項目を
ローカルキーマップで取り消すには、
ローカルキーマップの当該疑似ファンクションキーのバインディングを
`undefined'で再バインドします。
たとえば、つぎのようにしてdiredはメニューバーの項目`Edit'を抑制します。

     (define-key dired-mode-map [menu-bar edit] 'undefined)

`edit'は、メニューバー項目`Edit'に対して
グローバルキーマップで使う疑似ファンクションキーです。
グローバルなメニューバー項目を抑制する主な理由は、
モード固有の項目向けに場所を確保するためです。

 -- Variable: menu-bar-final-items
     通常、メニューバーは、グローバルな項目に
     ローカルキーマップで定義された項目を続けて表示する。

     この変数は、通常の順ではなくメニューバーの底に表示する項目に
     対する疑似ファンクションキーのリストを保持する。
     デフォルト値は`(help-menu)'であり、
     したがって、ローカルのメニュー項目に続いて、
     メニュー項目`Help'はメニューバーの最後に通常表示される。

 -- Variable: menu-bar-update-hook
     このノーマルフックは、 ユーザーがメニューバーをクリックするたびに、
     サブメニューを表示するまえに実行される。
     これを用いて、内容が変化するサブメニューを更新できる。


File: elisp-ja,  Node: Modifying Menus,  Prev: Menu Bar,  Up: Menu Keymaps

21.12.6 メニューの修正
-----------------------------

既存のメニューに新たな項目を挿入するとき、
メニューの既存の項目の特定の場所に挿入したいでしょう。
`define-key'で項目を追加すると、通常、メニューの先頭に入ります。
メニューのそれ以外の場所に挿入するには、 `define-key-after'を使います。

 -- Function: define-key-after map key binding after
     KEYに対するバインディングBINDINGをMAP内に作る。
     ただし、MAP内でのバインディングの位置は、
     イベントAFTERに対するバインディングのあとにする。
     引数KEYは長さ1、つまり、1要素のみのベクトルか文字列であること。
     しかし、AFTERは1つのイベント型、つまり、
     シンボルか文字であり列ではないこと。
     新たなバインディングはAFTERに対するバインディングのうしろに入る。
     AFTERが`t'であると、新たなバインディングは最後、
     つまり、キーマップの末尾に入る。

     例を示す。

          (define-key-after my-menu [drink]
                            '("Drink" . drink-command) 'eat)

     これは、疑似ファンクションキー<DRINK>に対するバインディングを作り、
     <EAT>に対するバインディングのあとに入れる。

     shellモードのメニュー`Signals'において、
     項目`break'のあとに項目`Work'を入れる方法はつぎのとおりである。

          (define-key-after
            (lookup-key shell-mode-map [menu-bar signals])
            [work] '("Work" . work-command) 'break)



File: elisp-ja,  Node: Modes,  Next: Documentation,  Prev: Keymaps,  Up: Top

22 メジャーモードとマイナモード
*********************************************

"モード"（mode）とは、Emacsをカスタマイズする定義の集まりであり、
読者は編集中にそれをオン／オフできます。 モードには2種類あります。
"メジャーモード"（major mode）は、互いに排他的で、
特定種類のテキストの編集に使います。 "マイナモード"（minor mode）は、
ユーザーがそれぞれを独立にオンにできる機能を提供します。

   本章では、メジャーモードやマイナモードの書き方、
それらをモード行に表示する方法、
ユーザーが指定したフックをモードがどのように実行するかについて述べます。
キーマップや構文テーブルなどの関連事項については、 *note
Keymaps::や*note Syntax Tables::を参照してください。

* Menu:

* Major Modes::        Defining major modes.
* Minor Modes::        Defining minor modes.
* Mode Line Format::   Customizing the text that appears in the mode line.
* Imenu::              How a mode can provide a menu
                         of definitions in the buffer.
* Font Lock Mode::     How modes can highlight text according to syntax.
* Hooks::              How to use hooks; how to write code that provides hooks.


File: elisp-ja,  Node: Major Modes,  Next: Minor Modes,  Up: Modes

22.1 メジャーモード
==========================

メジャーモードは、特定種類のテキストの編集向けにEmacsを特化します。
各バッファには、ある時点では1つのメジャーモードしかありません。

   もっとも特化されていないメジャーモードは、
"基本（fundamental）モード"です。
このモードには、モードに固有な定義や変数の設定がありません。
そのため、Emacsの各コマンドはデフォルトのふるまいをし、
各オプションもデフォルトの状態です。
他のすべてのメジャーモードでは、さまざまなキーやオプションを再定義します。
たとえば、lisp対話モードでは、 `C-j'（`eval-print-last-sexp'）や
<TAB>（`lisp-indent-line'）など他のキーに対しても
特別なキーバインディングがあります。

読者の特別な編集作業を補佐するために一群の編集コマンドを書く必要がある場合、
新たなメジャーモードを作ることは一般にはよいことです。
実際、メジャーモードを書くことは
（マイナモードを書くことはしばしば難しくなるが、
それに対比すれば）簡単です。

   新たなモードが既存のモードに類似していても、
既存のモードを2つの目的を果たすように修正するのは
賢いことではありません。
そのようにすると、使い難く保守し難くなるからです。
そのかわりに、既存のメジャーモードの定義をコピーし名前変えてから、
コピーを変更します。 あるいは、"派生モード" （derived mode） （*note
Derived Modes::）を定義します。
たとえば、`emacs/lisp/rmailedit.el'にあるrmail編集モードは、
テキスト（text）モードに非常によく似たメジャーモードですが、
追加コマンドが3つあります。
そのような定義がテキスト（text）モードとの違いになるのですが、
rmail編集モードはテキスト（text）モードから派生したものです。

   rmail編集モードは、バッファのメジャーモードを一時的に変更して
バッファを別の方法（rmailのコマンドではなく
Emacsの普通のコマンド）で編集できるようにする例題です。
そのような場合、一時的なメジャーモードには、普通、
バッファの通常のモード（この場合にはrmailモード）に戻る
コマンドがあります。 読者は、再帰編集の中で一時的に再定義し、
ユーザーが再帰編集を抜けるともとに戻す方法に魅了されるかもしれません。
しかし、これを複数のバッファで行うと、
再帰編集はもっとも最近に入った再帰からまず抜けるので、
ユーザーの選択に制約を課すことになり悪い方法です。
別のメジャーモードを使えばこのような制約を回避できます。 *Note
Recursive Editing::。

   標準のGNU Emacs Lispのライブラリのディレクトリには、
`text-mode.el'、`texinfo.el'、`lisp-mode.el'、
`c-mode.el'、`rmail.el'などのファイルに
いくつかのメジャーモードのコードが収めてあります。
モードの書き方を理解するためにこれらのライブラリを調べられます。
テキスト（text）モードは、基本（fundamental）モードについで、
もっとも単純なメジャーモードです。
rmailモードは複雑な特化されたモードです。

* Menu:

* Major Mode Conventions::  Coding conventions for keymaps, etc.
* Example Major Modes::     Text mode and Lisp modes.
* Auto Major Mode::         How Emacs chooses the major mode automatically.
* Mode Help::               Finding out how to use a mode.
* Derived Modes::           Defining a new major mode based on another major
                              mode.


File: elisp-ja,  Node: Major Mode Conventions,  Next: Example Major Modes,  Up: Major Modes

22.1.1 メジャーモードの慣習
-------------------------------------

既存のメジャーモードのコードでは、
ローカルキーマップや構文テーブルの初期化、グローバルな名前、フックなどの
さまざまなコーディング上の慣習を踏襲しています。
読者が新たなメジャーモードを定義するときには、
これらの慣習に従ってください。

   * カレントバッファにおいて新しいモードに切り替える
     引数なしのコマンドを定義し、その名前は`-mode'で終ること。
     このコマンドが、キーマップ、構文テーブル、
     既存バッファにバッファローカルな変数を設定するが、
     バッファの内容は変更しないこと。

   * このモードで使える特別なコマンドに関して記述した
     このコマンドに対する説明文字列を書く。 読者のモードで`C-h
     m'（`describe-mode'）を使うと、 この説明文字列を表示する。

     説明文字列では、`\[COMMAND]'、`\{KEYMAP}'、
     `\<KEYMAP>'の特別な書き方を使え、
     これらはユーザー独自のキーバインディングに自動的に置き換えられる。
     *note Keys in Documentation::。

   * メジャーモードコマンドは、
     `kill-all-local-variables'の呼び出しから始めること。
     それ以前に有効であったメジャーモードのバッファローカルな変数に
     対処するためである。

   * メジャーモードコマンドは、
     変数`major-mode'にメジャーモードコマンドのシンボルを設定すること。
     これにより、`describe-mode'が表示すべき説明文を捜し出す。

   * メジャーモードコマンドは、
     変数`mode-name'にモードの『愛称』を文字列として設定すること。
     この文字列がモード行に現れる。

   * すべてのグローバルな名前は同一の名前空間にあるので、
     モードの構成要素であるすべてのグローバル変数、定数、関数は、
     メジャーモード名（名前が長ければ、その省略）で始まること。 *note
     Coding Conventions::。

   * メジャーモードには、通常、それ独自のキーマップがあるはずで、
     当該モードのすべてのバッファでローカルキーマップとして使われる。
     メジャーモードコマンドは、`use-local-map'を呼び出して、
     そのローカルキーマップを設定すること。 詳しくは、*note Active
     Keymaps::。

     このキーマップは、`MODENAME-mode-map'という名前の
     グローバル変数に恒久的に保持すること。
     通常、モードを定義するライブラリでこの変数に設定する。

     モードのキーマップ変数に設定するコードの書き方に関する助言については
     *note Tips for Defining::。

   * メジャーモードのキーマップでバインドされたキー列は、
     通常、`C-c'で始まり、コントロール文字、数字文字、`{'、
     `}'、`<'、`>'、`:'、`;'のいずれかが続くようにする。
     その他の句読点文字はマイナモード向けに予約されている。
     また、通常の英文字はユーザー向けに予約されている。

     メジャーモードにおいては、そのモードによく適合した形で
     『同じ仕事』を行うコマンドであるならば、
     標準的な意味を持つキー列に当該コマンドを再バインドしても合理的である。
     たとえば、プログラム言語編集用のメジャーモードでは、
     `C-M-a'を当該言語にうまく適合した方法で
     『関数の先頭へ移動する』コマンドに再定義する。

     テキスト挿入を許さないdiredやrmailなどのメジャーモードでは、
     英文字や他の印字文字を編集コマンドとして再定義するのも合理的である。
     diredもrmailもこうしている。

   * モードでは、独自の構文テーブルを用意するか、
     他の関連するモードと構文テーブルを共有する。
     独自の構文テーブルを用意する場合には、
     `MODENAME-mode-syntax-table'という名前の変数に保持すること。 *note
     Syntax Tables::。

   * コメントを書ける言語を扱うモードでは、
     コメントの構文を定義する変数に設定すること。 *note
     コメントを制御するオプション: (emacs)Options for Comments.。

   * モードでは、独自の略語表を用意するか、
     他の関連するモードと略語表を共有する。
     独自の略語表を用意する場合には、
     `MODENAME-mode-abbrev-table'という名前の変数に保持すること。 *note
     Abbrev Tables::。

   * モードでは、 バッファローカルな変数`font-lock-defaults' （*note
     Font Lock Mode::）に設定して、
     フォントロック（font-lock）モードに対して強調表示の方法を指定すること。

   * モードでは、 バッファローカルな変数`imenu-generic-expression'か
     `imenu-create-index-function'（*note Imenu::）に設定して、
     iメニューがどのようにバッファ内の定義や節を探すべきかを指定すること。

   * モードに関連する変数の設定には`defvar'か`defcustom'を使い、
     それらに値が設定されている場合には再初期化しないようにする。
     （再初期化するとユーザーのカスタマイズを廃棄してしまう。）

   * Emacsのカスタマイズ変数に対するバッファローカルな束縛は、
     メジャーモードコマンドにおいて `make-variable-buffer-local'ではなく
     `make-local-variable'で行う。
     前者の関数は、すべてのバッファにおいてそれ以降に設定される当該変数を
     バッファローカルにしてしまい、
     このモードを使わないバッファにも影響する。
     モードにそのような大局的な効果があるのは望ましくない。 *note
     Buffer-Local Variables::。

     単一のLispパッケージ内のみにおいて使われる変数に対しては、
     必要ならば、`make-variable-buffer-local'を使ってもよい。

   * 各メジャーモードには、 `MODENAME-mode-hook'という名前の
     "モードフック"（mode hook）があること。
     モードコマンドは、最後に`run-hooks'を用いてフックを実行すること。
     *note Hooks::。

   *
     メジャーモードコマンドは、より基本的なモードのフックを実行してもよい。
     たとえば、`indented-text-mode'は、
     `indented-text-mode-hook'に加えて`text-mode-hook'も実行する。
     自前のフックを実行する直前（つまり設定が終ったあと）
     にこれらの他のフックを実行するか、より初期の段階で実行してもよい。

   *
     ユーザーがバッファをこのモードから別のメジャーモードに切り替えたときに
     特別なことを行う必要がある場合、
     このモードでは、`change-major-mode-hook'（*note Creating
     Buffer-Local::） のバッファローカルな値を設定しておく。

   * このモードが特別に準備したテキストに対してのみ有効な場合には、
     メジャーモードコマンドのシンボルには、
     つぎのように属性`mode-class'に値`special'を設定しておくこと。

          (put 'funny-mode 'mode-class 'special)

     これは、カレントバッファがfunnyモードのときに新たなバッファを
     作成しても、新しいバッファではfunnyモードを継承しないようにEmacsに指示する。
     dired、rmail、バッファ一覧などのモードではこの機能を使っている。

   *
     新しいモードを識別可能な特定の名前のファイルに対するデフォルトにしたい
     場合には、そのような名前のファイルに対して当該モードを選択するための
     要素を`auto-mode-alist'に追加する。
     モードコマンドを自動ロードと定義する場合、
     `autoload'を呼び出している同じファイルに
     そのような要素を追加しておくこと。
     そうでなければ、モード定義を収めたファイルに当該要素を入れるだけで十分である。
     *note Auto Major Mode::。

   * 説明文には、ユーザーが個人のファイル`.emacs'に書けるように、
     `autoload'の例、 `auto-mode-alist'への追加方法の例を記載すること。

   * モードを定義するファイルのトップレベルのフォームは、
     それらを複数回評価しても不利な結果にならないように書いておくこと。
     読者が当該ファイルを複数回ロードしなくても、誰かがやるかもしれない。


File: elisp-ja,  Node: Example Major Modes,  Next: Auto Major Mode,  Prev: Major Mode Conventions,  Up: Major Modes

22.1.2 メジャーモードの例
----------------------------------

基本（fundamental）モードを除くと、
テキスト（text）モードはもっとも単純なモードです。
上に述べた慣習の例示として、`text-mode.el'の抜粋をあげておきます。

     ;; モード固有の構文テーブルを作る
     (defvar text-mode-syntax-table nil
       "Syntax table used while in text mode.")

     (if text-mode-syntax-table
         ()              ; 構文テーブルが既存ならば変更しない
       (setq text-mode-syntax-table (make-syntax-table))
       (modify-syntax-entry ?\" ".   " text-mode-syntax-table)
       (modify-syntax-entry ?\\ ".   " text-mode-syntax-table)
       (modify-syntax-entry ?' "w   " text-mode-syntax-table))

     (defvar text-mode-abbrev-table nil
       "Abbrev table used while in text mode.")
     (define-abbrev-table 'text-mode-abbrev-table ())

     (defvar text-mode-map nil)   ; モード固有のキーマップを作る

     (if text-mode-map
         ()              ; キーマップが既存ならば変更しない
       (setq text-mode-map (make-sparse-keymap))
       (define-key text-mode-map "\t" 'indent-relative)
       (define-key text-mode-map "\es" 'center-line)
       (define-key text-mode-map "\eS" 'center-paragraph))

   つぎは、テキスト（text）モードのメジャーモード関数の完全な定義です。

     (defun text-mode ()
       "Major mode for editing text intended for humans to read...
      Special commands: \\{text-mode-map}
     Turning on text-mode runs the hook `text-mode-hook'."
       (interactive)
       (kill-all-local-variables)
       (use-local-map text-mode-map)
       (setq local-abbrev-table text-mode-abbrev-table)
       (set-syntax-table text-mode-syntax-table)
       (make-local-variable 'paragraph-start)
       (setq paragraph-start (concat "[ \t]*$\\|" page-delimiter))
       (make-local-variable 'paragraph-separate)
       (setq paragraph-separate paragraph-start)
       (setq mode-name "Text")
       (setq major-mode 'text-mode)
       (run-hooks 'text-mode-hook))      ; 最後に、フックによるモードの
                                         ;   カスタマイズをユーザーに許す

   3つのlispモード（lispモード、emacs-lispモード、lisp対話モード）には、
テキスト（text）モードより多くの機能があり、
それに応じてコードもより複雑です。 これらのモードの書き方を例示する
`lisp-mode.el'からの抜粋をあげておきます。

     ;; モード固有の構文テーブルを作成する
     (defvar lisp-mode-syntax-table nil "")
     (defvar emacs-lisp-mode-syntax-table nil "")
     (defvar lisp-mode-abbrev-table nil "")

     (if (not emacs-lisp-mode-syntax-table) ; 構文テーブルが既存ならば
                                            ;   変更しない
         (let ((i 0))
           (setq emacs-lisp-mode-syntax-table (make-syntax-table))

           ;; 0までの文字に、単語構成文字ではないが
           ;; シンボル名構成文字であるクラスを設定する
           ;; (文字0は、ASCII文字集合では`48')
           (while (< i ?0)
             (modify-syntax-entry i "_   " emacs-lisp-mode-syntax-table)
             (setq i (1+ i)))
           ...
           ;; 他の文字の構文を設定する
           (modify-syntax-entry ?  "    " emacs-lisp-mode-syntax-table)
           (modify-syntax-entry ?\t "    " emacs-lisp-mode-syntax-table)
           ...
           (modify-syntax-entry ?\( "()  " emacs-lisp-mode-syntax-table)
           (modify-syntax-entry ?\) ")(  " emacs-lisp-mode-syntax-table)
           ...))
     ;; lispモード向けの略語表を作る
     (define-abbrev-table 'lisp-mode-abbrev-table ())

   3つのlispモードは多くのコードを共有しています。
つぎの関数はさまざまな変数に設定します。
lispモードの各メジャーモード関数が呼び出します。

     (defun lisp-mode-variables (lisp-syntax)
       (cond (lisp-syntax
     	  (set-syntax-table lisp-mode-syntax-table)))
       (setq local-abbrev-table lisp-mode-abbrev-table)
       ...

   `forward-paragraph'などの関数は、
変数`paragraph-start'の値を使います。
Lispのコードは普通のテキストとは異なるので、
Lispを扱えるように変数`paragraph-start'を特別に設定する必要があります。
また、Lispではコメントの字下げは特殊な形なので、
各lispモードには独自のモード固有の`comment-indent-function'が必要です。
これらの変数に設定するコードが、 `lisp-mode-variables'の残りの部分です。

       (make-local-variable 'paragraph-start)
       (setq paragraph-start (concat page-delimiter "\\|$" ))
       (make-local-variable 'paragraph-separate)
       (setq paragraph-separate paragraph-start)
       ...
       (make-local-variable 'comment-indent-function)
       (setq comment-indent-function 'lisp-comment-indent))

   各lispモードでは、キーマップが多少異なります。
たとえば、lispモードでは`C-c C-z'を`run-lisp'にバインドしますが、
他のlispモードではそうしません。
つぎのコードは、共通するコマンドを設定します。

     (defvar shared-lisp-mode-map ()
       "Keymap for commands shared by all sorts of Lisp modes.")

     (if shared-lisp-mode-map
         ()
        (setq shared-lisp-mode-map (make-sparse-keymap))
        (define-key shared-lisp-mode-map "\e\C-q" 'indent-sexp)
        (define-key shared-lisp-mode-map "\177"
                    'backward-delete-char-untabify))

つぎはlispモード向けのキーマップを設定するコードです。

     (defvar lisp-mode-map ()
       "Keymap for ordinary Lisp mode...")

     (if lisp-mode-map
         ()
       (setq lisp-mode-map (make-sparse-keymap))
       (set-keymap-parent lisp-mode-map shared-lisp-mode-map)
       (define-key lisp-mode-map "\e\C-x" 'lisp-eval-defun)
       (define-key lisp-mode-map "\C-c\C-z" 'run-lisp))

   最後に、emacs-lispモードのメジャーモード関数の完全な定義を示します。

     (defun lisp-mode ()
       "Major mode for editing Lisp code for Lisps other than GNU Emacs Lisp.
     Commands:
     Delete converts tabs to spaces as it moves back.
     Blank lines separate paragraphs.  Semicolons start comments.
     \\{lisp-mode-map}
     Note that `run-lisp' may be used either to start an inferior Lisp job
     or to switch back to an existing one.

     Entry to this mode calls the value of `lisp-mode-hook'
     if that value is non-nil."
       (interactive)
       (kill-all-local-variables)
       (use-local-map lisp-mode-map)          ; モードのキーマップを選択する
       (setq major-mode 'lisp-mode)           ; これにより`describe-mode'は
                                              ; 説明文を探し出せる
       (setq mode-name "Lisp")                ; モード行に表示される
       (lisp-mode-variables t)                ; さまざまな変数を定義する
       (setq imenu-case-fold-search t)
       (set-syntax-table lisp-mode-syntax-table)
       (run-hooks 'lisp-mode-hook))           ; フックによるモードの
                                              ; カスタマイズをユーザーに許す


File: elisp-ja,  Node: Auto Major Mode,  Next: Mode Help,  Prev: Example Major Modes,  Up: Major Modes

22.1.3 メジャーモードの選択方法
-------------------------------------------

Emacsは、ファイル名やファイル自体の情報をもとに、
当該ファイルを訪問するときの新しいバッファに対する
メジャーモードを自動的に選択します。
また、ファイル内のテキストで指定されたローカル変数も処理します。

 -- コマンド: fundamental-mode
     基本（fundamental）モードは、特化してないメジャーモードである。
     他のメジャーモードは、実質的には、このモードとの対比で定義されている。
     つまり、基本（fundamental）モードから始めて、
     それらのメジャーモードではなにを変更するかを定義している。
     関数`fundamental-mode'はフックを実行_しない_ため、
     読者はカスタマイズできない。
     （Emacsの基本（fundamental）モードのふるまいを変えたければ、
     Emacsの_大局的な_状態を変える必要がある。）

 -- コマンド: normal-mode &optional find-file
     この関数は、カレントバッファに対して
     適切なメジャーモードとバッファローカルな変数を確立する。
     この関数はまず`set-auto-mode'を呼び出し、
     続いて、ファイルのローカル変数を必要に応じて解析、束縛、評価するために
     `hack-local-variables'を実行する。

     `normal-mode'に対する引数FIND-FILEが`nil'以外であると、
     `normal-mode'は`find-file'から呼び出されたと仮定する。
     その場合、ファイルの末尾や`-*-'の形式の行にある
     ローカル変数リストを処理することもある。
     変数`enable-local-variables'は、この処理を行うかどうかを制御する。
     ファイル内でのローカル変数リストの構文については、 *Note
     ファイルにローカルな変数: (emacs)File Variables。

     読者が対話的に`normal-mode'を実行すると
     引数FIND-FILEは通常`nil'である。
     その場合、`normal-mode'は、ローカル変数リストを無条件に処理する。

     `normal-mode'は、メジャーモード関数を呼び出す周りでは
     `condition-case'を使うので、エラーを補足して `File mode
     specification error'にもとのエラーメッセージを続けて
     エラーを報告する。

 -- User Option: enable-local-variables
     この変数は、訪問したファイル内のローカル変数リストを処理するかどうかを
     制御する。
     値`t'は、ローカル変数リストを無条件に処理することを意味する。
     `nil'は、それらを無視することを意味する。
     それ以外の値であると、各ファイルごとにユーザーに問い合わせる。
     デフォルト値は`t'である。

 -- Variable: ignored-local-variables
     この変数は、ファイルのローカル変数リストで設定してはならない
     変数のリストを保持する。
     それらの変数に対して指定した値は無視される。

   このリストに加えて、
属性`risky-local-variable'が`nil'以外の値である変数も無視されます。

 -- User Option: enable-local-eval
     この変数は、訪問したファイル内のローカル変数リストの`Eval:'を
     処理するかどうかを制御する。
     値`t'は、それらを無条件に処理することを意味する。
     `nil'は、それらを無視することを意味する。
     それ以外の値であると、各ファイルごとにユーザーに問い合わせる。
     デフォルト値は`maybe'である。

 -- Function: set-auto-mode
     この関数は、カレントバッファに対して適切なメジャーモードを選択する。
     `-*-'行の値、 （`auto-mode-alist'を使って）訪問したファイルの名前、
     （`interpreter-mode-alist'を使って）`#!'行、
     ファイルのローカル変数リストをもとに決定する。
     しかし、この関数はファイルの末尾付近にある
     ローカル変数`mode:'は調べないが、
     関数`hack-local-variables'は調べる。 *Note
     メジャーモードの選択方式: (emacs)Choosing Modes。

 -- User Option: default-major-mode
     この変数は、新たなバッファに対するデフォルトのメジャーモードを保持する。
     標準値は`fundamental-mode'である。

     `default-major-mode'の値が`nil'であると、
     Emacsは（以前の）カレントバッファのメジャーモードを
     新たなバッファのメジャーモードとする。
     しかし、メジャーモードコマンドのシンボルの属性`mode-class'の
     値が`special'であると、新たなバッファのメジャーモードにはせず、
     かわりに基本（fundamental）モードを使う。 この属性を持つモードは、
     特別に準備したテキストに対してのみ有用であるdiredやrmailなどである。

 -- Function: set-buffer-major-mode buffer
     この関数はバッファBUFFERのメジャーモードを
     `default-major-mode'の値とする。 この変数が`nil'であると、
     （適切ならば）カレントバッファのメジャーモードを使う。

     バッファを作成する低レベルの基本関数ではこの関数を使わないが、
     `switch-to-buffer'や`find-file-noselect'などの
     中レベルのコマンドではバッファを作成するときにこのコマンドを使う。

 -- Variable: initial-major-mode
     この変数の値は、最初のバッファ`*scratch*'のメジャーモードを決定する。
     値は、メジャーモードコマンドのシンボルであること。
     デフォルト値は、`lisp-interaction-mode'である。

 -- Variable: auto-mode-alist
     この変数は、ファイル名のパターン（正規表現、*note Regular
     Expressions::）と 対応するメジャーモードの連想リストを保持する。
     通常、ファイル名パターンでは`.el'や`.c'などの接尾辞を調べるが、
     そうでなくてもよい。 連想リストの通常の要素は `(REGEXP .
     MODE-FUNCTION)'の形である。

     たとえばつぎのとおり。

          (("\\`/tmp/fol/" . text-mode)
           ("\\.texinfo\\'" . texinfo-mode)
           ("\\.texi\\'" . texinfo-mode)
           ("\\.el\\'" . emacs-lisp-mode)
           ("\\.c\\'" . c-mode)
           ("\\.h\\'" . c-mode)
           ...)

     展開したファイル名（*note File Name Expansion::）がREGEXPに一致する
     ファイルを訪問すると、
     `set-auto-mode'は対応するMODE-FUNCTIONを呼び出す。
     この機能により、Emacsはほとんどのファイルに対して
     適切なメジャーモードを選択する。

     `auto-mode-alist'の要素が`(REGEXP FUNCTION t)'の
     形であると、FUNCTIONを呼び出したあとで、
     Emacsはファイル名のそれまで一致しなかった部分について`auto-mode-alist'を
     再度探索する。 この機能は解凍パッケージには有用である。
     `("\\.gz\\'" FUNCTION t)'の形の要素で、
     ファイルを解凍し、`.gz'を除いたファイル名に従って
     解凍済みファイルを適切なモードにできる。

     `auto-mode-alist'にいくつかのパターン対を追加する方法を示す。
     （この種の式を読者のファイル`.emacs'に使える。）

          (setq auto-mode-alist
            (append
             ;; ドットで始まる（ディレクトリ名付きの）ファイル名
             '(("/\\.[^/]*\\'" . fundamental-mode)
               ;; ドットのないファイル名
               ("[^\\./]*\\'" . fundamental-mode)
               ;; `.C'で終るファイル名
               ("\\.C\\'" . c++-mode))
             auto-mode-alist))

 -- Variable: interpreter-mode-alist
     この変数は、`#!'行でコマンドインタープリタを指定している
     スクリプトに対して用いるメジャーモードを指定する。
     この値は、`(INTERPRETER . MODE)'の形の要素から成る
     リストであること。 たとえば、デフォルトには`("perl" .
     perl-mode)'の要素がある。
     各要素は、ファイルが指定するインタープリタがINTERPRETERに
     一致したらモードMODEを使うことを意味する。
     INTERPRETERの値は、実際には正規表現である。

     `auto-mode-alist'が使用すべきメジャーモードが
     指定しなかった場合にのみこの変数を使う。

 -- Function: hack-local-variables &optional force
     この関数は、カレントバッファの内容に指定されたローカル変数を
     必要に応じて、解析、束縛、評価する。

     `normal-mode'で述べた`enable-local-variables'の処理は、
     実際にはここで行う。 引数FORCEは、通常、
     `normal-mode'に与えられた引数FIND-FILEからくる。


File: elisp-ja,  Node: Mode Help,  Next: Derived Modes,  Prev: Auto Major Mode,  Up: Major Modes

22.1.4 メジャーモードに関するヘルプ
-------------------------------------------------

関数`describe-mode'は、メジャーモードに関する情報を 得るために使います。
通常、`C-h m'で呼び出されます。
関数`describe-mode'は`major-mode'の値を使いますが、
そのために各メジャーモード関数が
変数`major-mode'に設定する必要があるのです。

 -- コマンド: describe-mode
     この関数は、現在のメジャーモードの説明文を表示する。

     関数`describe-mode'は、`major-mode'の値を引数として
     関数`documentation'を呼び出す。
     そうして、メジャーモード関数の説明文字列を表示する。 （*note
     Accessing Documentation::。）

 -- Variable: major-mode
     この変数は、カレントバッファのメジャーモードに対するシンボルを保持する。
     このシンボルは、当該メジャーモードに切り替えるためのコマンドを
     関数定義として持つこと。 関数`describe-mode'は、
     メジャーモードの説明文として当該関数の説明文字列を使う。


File: elisp-ja,  Node: Derived Modes,  Prev: Mode Help,  Up: Major Modes

22.1.5 派生モードの定義
-------------------------------

既存のメジャーモードを用いて新たなメジャーモードを定義できると便利です。
これを行う簡単な方法は`define-derived-mode'を使うことです。

 -- Macro: define-derived-mode variant parent name docstring body...
     これは、NAMEをモード名を表す文字列として使って
     VARIANTをメジャーモードコマンドとして定義する。

     新たなコマンドVARIANTは、関数PARENTを呼び出してから
     親モードの特定の機能を無効にするように定義される。

        * 新たなモードは、`VARIANT-map'という名前の
          独自のキーマップを持つ。 `define-derived-mode'は、
          このキーマップが定義済みでなければ、
          `PARENT-map'から継承するようにこのキーマップを初期化する。

        * 新たなモードでは、変数に`VARIANT-syntax-table'に
          独自の構文テーブルを保持する。 この変数が定義済みでなければ、
          `PARENT-syntax-table'をコピーしてこの変数を初期化する。

        * 新たなモードでは、変数に`VARIANT-abbrev-table'に
          独自の略語表を保持する。 この変数が定義済みでなければ、
          `PARENT-abbrev-table'をコピーしてこの変数を初期化する。

        * 新たなモードには独自のモードフック`VARIANT-hook'があり、
          通常どおり最後にこれを実行する。
          （新たなモードでは、PARENTを呼び出すことの一部として
          PARENTのモードフックも実行する。）

     さらに、BODYでPARENTの他の部分を無効にする方法を指定できる。
     コマンドVARIANTは、`VARIANT-hook'を呼び出す直前、
     通常の無効化処理を終えてからBODYのフォームを評価する。

     引数DOCSTRINGは、新たなモードに対する説明文字列を指定する。
     DOCSTRINGを省略すると、
     `define-derived-mode'は説明文字列を生成する。

     仮想的な例を示す。

          (define-derived-mode hypertext-mode
            text-mode "Hypertext"
            "Major mode for hypertext.
          \\{hypertext-mode-map}"
            (setq case-fold-search nil))

          (define-key hypertext-mode-map
            [down-mouse-3] 'do-hyper-link)


File: elisp-ja,  Node: Minor Modes,  Next: Mode Line Format,  Prev: Major Modes,  Up: Modes

22.2 マイナモード
=======================

"マイナモード"（minor mode）は、メジャーモードの選択とは独立に
ユーザーがオン／オフできる機能を提供します。
マイナモードは、個別にも組み合わせてもオンにできます。
マイナモードは、長すぎますが『汎用的に使えるオプション機能のモード』と
命名したようがよいかもしれません。

マイナモードは、普通、1つのメジャーモードを変更するだけではありません。
たとえば、自動詰め込みモード（auto-fillモード）は、
テキスト挿入を許す任意のメジャーモードで使えます。
汎用的であるためには、マイナモードは
メジャーモードが行うこととは実質的に独立である必要があります。

マイナモードは、メジャーモードに比べて、実装するのがしばしば困難です。
1つの理由は、任意の順でマイナモードをオン／オフできるようにする
必要があるからです。
マイナモードは、メジャーモードや他のオンになっているマイナモードとは
無関係にその望みの効果を発揮できる必要があります。

   しばしば、マイナモードを実装するうえでもっとも大きな問題は、
Emacsの残りの部分に対して必要なフックを探すことです。
マイナモードキーマップにより、従来に比べて簡単になります。

* Menu:

* Minor Mode Conventions::      Tips for writing a minor mode.
* Keymaps and Minor Modes::     How a minor mode can have its own keymap.
* Easy-Mmode::                  A convenient facility for defining minor modes.


File: elisp-ja,  Node: Minor Mode Conventions,  Next: Keymaps and Minor Modes,  Up: Minor Modes

22.2.1 マイナモードを書くための慣習
-------------------------------------------------

メジャーモードに対するのと同じように、
マイナモードを書くうえでの慣習があります。
メジャーモードの慣習には、マイナモードにも適用されるものがあります。
つまり、モードを初期化する関数の名前、
グローバルシンボルの名前、キーマップやその他のテーブルや表の使い方です。

   それらに加えて、マイナモードに固有な慣習もあります。

   * マイナモードを制御する変数の名前は`-mode'で終ること。
     これを"モード変数"（mode variable）と呼ぶ。
     マイナモードコマンドは、この変数を
     （オフにするには`nil'、オンにするにはそれ以外に）設定 すること。

     可能ならば、変数に設定すると
     自動的にモードがオン／オフされるようにモードを実装する。
     そうすると、マイナモードコマンドは、
     変数に設定する以外にはなにもしないでよくなる。

     この変数は、モード行にマイナモード名を表示するために
     `minor-mode-alist'でも使われる。
     マイナモードキーマップを活性にしたり非活性にしたりもする。
     各コマンドやフックもこの変数の値を検査する。

     各バッファごとに別々にマイナモードをオンにしたい場合には、
     この変数をバッファローカルにする。

   * モード変数と同じ名前のコマンドを定義する。
     その仕事は、当該変数に設定することでモードをオン／オフすることである。

     当該コマンドは、省略可能な引数を1つ受け取ること。
     引数が`nil'であればモードをトグル
     （オンであればオフに、オフであればオンに）する。
     さもなければ、引数が、正整数、`nil'以外のシンボル、
     `-'、あるいは、CARがそのような整数やシンボルであるようなリストの
     場合にはモードをオンにする。 それ以外ではモードをオフにする。

     `transient-mark-mode'の定義から引用した例を示す。
     モードのふるまいをオン／オフする変数としての
     `transient-mark-mode'の使い方、
     および、生の前置引数に基づいたマイナモードの
     オン／オフ／トグルの仕方を示す。

          (setq transient-mark-mode
                (if (null arg) (not transient-mark-mode)
                  (> (prefix-numeric-value arg) 0)))

   * モード行にマイナモードを表示したい場合には、
     各マイナモードについて要素を`minor-mode-alist'に追加する （*note
     Mode Line Variables::）。 この要素はつぎの形のリストであること。

          (MODE-VARIABLE STRING)

     ここで、MODE-VARIABLEはマイナモードのオン／オフを制御する変数であり、
     STRINGはモード行でモードを表す短い空白で始まる文字列である。
     同時に複数のモードを表示できるように、これらの文字列は短いこと。

     `minor-mode-alist'に要素を追加するときには、
     重複を防ぐために既存の要素を検査する`assq'を使うこと。
     たとえばつぎのとおり。

          (or (assq 'leif-mode minor-mode-alist)
              (setq minor-mode-alist
                    (cons '(leif-mode " Leif") minor-mode-alist)))

   このリストに要素を1回だけ追加するならば`add-to-list'も使えます
（*note Setting Variables::）。


File: elisp-ja,  Node: Keymaps and Minor Modes,  Next: Easy-Mmode,  Prev: Minor Mode Conventions,  Up: Minor Modes

22.2.2 キーマップとマイナモード
-------------------------------------------

各マイナモードは、モードがオンのときに活性になる独自のキーマップを持てます。
マイナモード向けのキーマップを設定するには、
`minor-mode-map-alist'に要素を追加します。 *Note Active Keymaps::。

   マイナモードキーマップの1つの用途は、
ある種の自己挿入文字のふるまいを変更して、
自己挿入に加えてなにかを行わせるようにすることです。
一般に、`self-insert-command'をカスタマイズする機構は
（略語モードや自動詰め込みモード向けに設計された）特別な場合に限られるので、
このようなことを行う唯一の方法です。
（標準の`self-insert-command'の定義を読者独自の定義で置き換えないこと。
エディタコマンドループはこの関数を特別扱いしている。）

   マイナモードでバインドしているキー列は、`C-c'で始まり、
`{'、`}'、`<'、`>'、`:'、`;'_以外_の 句読点文字の1つが続くようにします。
（除外した句読点文字はメジャーモード向けに予約されている。）


File: elisp-ja,  Node: Easy-Mmode,  Prev: Keymaps and Minor Modes,  Up: Minor Modes

22.2.3 Easy-Mmode
-----------------

パッケージeasy-mmodeは、マイナモードを実装する便利な方法を提供します。
これを使うと、単純なマイナモードを1つの自己完結した定義に指定できます。

 -- Macro: easy-mmode-define-minor-mode mode doc &optional init-value
          mode-indicator keymap
     このマクロは、MODE（シンボル）という名前の新しいマイナモードを定義する。

     このマクロは、マイナモードをトグルする
     MODEという名前のコマンドを定義し、 その説明文字列をDOCとする。

     また、MODEという名前の変数も定義する。
     この変数はモードのオン／オフにしたがって`t'/`nil'に設定される。
     この変数はINIT-VALUEに初期化される。

     文字列MODE-INDICATORは、モードがオンのときにモード行に
     表示される文字列である。
     それが`nil'であるとモード行にはモードを表示しない。

     省略可能な引数KEYMAPは、マイナモードのキーマップを指定する。
     これは、値がキーマップであるような変数の名前か、
     つぎの形のバインディングを指定した連想リストであること。

          (KEY-SEQUENCE . DEFINITION)

   `easy-mmode-define-minor-mode'を使った例を示します。

     (easy-mmode-define-minor-mode hungry-mode
       "Toggle Hungry mode.
     With no argument, this command toggles the mode.
     Non-null prefix argument turns on the mode.
     Null prefix argument turns off the mode.

     When Hungry mode is enabled, the control delete key
     gobbles all preceding whitespace except the last.
     See the command \\[hungry-electric-delete]."
      ;; 初期値
      nil
      ;; モード行への表示
      " Hungry"
      ;; マイナモードのバインディング
      '(("\C-\^?" . hungry-electric-delete)
        ("\C-\M-\^?"
         . (lambda ()
             (interactive)
             (hungry-electric-delete t)))))

これは、『hungryモード』という名前のマイナモードを定義します。
モードをトグルするコマンドの名前は`hungry-mode'、
モードのオン／オフを表す変数の名前は`hungry-mode'、
モードがオンのときに活性なキーマップを保持する
変数の名前は`hungry-mode-map'です。
`C-<DEL>'と`C-M-<DEL>'に対するキーバインディングで
キーマップを初期化します。


File: elisp-ja,  Node: Mode Line Format,  Next: Imenu,  Prev: Minor Modes,  Up: Modes

22.3 モード行の書式
==========================

Emacsの（ミニバッファ専用ウィンドウを除く）各ウィンドウにはモード行があって、
ウィンドウに表示しているバッファに関する状態情報を表示しています。
モード行には、バッファ名、対応するファイル、再帰編集の深さ、
メジャーモードとマイナモードなどのバッファに関する情報が含まれます。

   本節では、モード行の内容の制御方法について述べます。
モード行に表示される情報のほとんどは
オンになっているメジャーモードとマイナモードに関係するので、
本章に含めます。

   `mode-line-format'は、カレントバッファのモード行に表示する
雛型を保持しているバッファローカルな変数です。
同一バッファに対するすべてのウィンドウは同じ`mode-line-format'を使い、
それらのモード行は（スクロールの割合や行やコラム位置を除いて）
同じように表示されます。

ウィンドウのモード行は、通常、ウィンドウに別のバッファを表示したときや、
バッファの変更状態が`nil'から`t'へあるいはその逆の変化をしたときに
更新されます。 `mode-line-format'（*note Mode Line
Variables::）が参照する
変数を修正したり、テキストの表示方法に影響するその他の変数やデータ構造
（*note Display::）を変更したときには、新しい情報を表示したり
新たな方法で表示するためにモード行の更新を強制できます。

 -- Function: force-mode-line-update
     カレントバッファのモード行の更新を強制する。

   モード行は、通常、反転表示されます。 *note Inverse
Video::の`mode-line-inverse-video'を参照してください。

* Menu:

* Mode Line Data::        The data structure that controls the mode line.
* Mode Line Variables::   Variables used in that data structure.
* %-Constructs::          Putting information into a mode line.


File: elisp-ja,  Node: Mode Line Data,  Next: Mode Line Variables,  Up: Mode Line Format

22.3.1 モード行のデータ構造
-------------------------------------

モード行の内容は、バッファローカルな変数`mode-line-format'に
保持されたリスト、文字列、シンボル、数から成るデータ構造で制御されます。
このデータ構造を"モード行構成"（mode line construct）と呼びます。
これは単純なモード行構成から再帰的に構築します。
同じデータ構造はフレームタイトル（*note Frame Titles::）を
構築するためにも使われます。

 -- Variable: mode-line-format
     この変数の値は、モード行全体の書式に責任を持つモード行構成である。
     この変数の値は、モード行のテキストを作るためにどの変数を使うか、
     それらはモード行のどこに現れるかを制御する。

モード行構成は、定まったテキストの文字列のように単純でもかまいませんが、
普通は、テキストを作るための別の変数の使い方を指定します。
それらの変数の多くはそれ自身、それらの値として
モード行構成を持つように定義されています。

   `mode-line-format'のデフォルト値は、
`mode-name'や`minor-mode-alist'などの変数の値を使います。
多くの目的には、`mode-line-format'が参照するいくつかの変数を
変えるだけで十分です。

   モード行構成は、リスト、シンボル、文字列のいずれかです。
その値がリストであれば、その各要素はリスト、シンボル、文字列のいずれかです。

`STRING'
     モード行構成としての文字列は、
     "`%'記法"を除いて、モード行にそのまま表示される。
     `%'のうしろの10進数は、右側に空白を埋める
     （つまりデータは左端に揃えられる）ときのフィールド幅を指定する。
     *note %-Constructs::。

`SYMBOL'
     モード行構成としてのシンボルは、その値を表す。
     SYMBOLの値は、SYMBOLのかわりにモード行構成として使われる。
     しかし、`t'や`nil'のシンボル、および、シンボルの値が空のものは
     無視する。

     例外が1つある：` ' SYMBOLの値が文字列であると、`%'記法を処理せずに
     文字列をそのまま表示する。

`(STRING REST...) or (LIST REST...)'
     最初の要素が文字列かリストであるリストは、
     すべての要素を再帰的に処理し、結果を連結することを意味する。
     これはもっとも多用されるモード行構成の形である。

`(SYMBOL THEN ELSE)'
     最初の要素がシンボルであるリストは条件節であり、
     その意味はSYMBOLの値に依存する。 その値が`nil'以外であると、
     2番目の要素THENをモード行構成として再帰的に処理する。
     SYMBOLの値が`nil'であると、
     3番目の要素ELSEをモード行構成として再帰的に処理する。
     ELSEは省略してもよいが、その場合、
     SYMBOLの値が`nil'であるところの要素はモード行に表示されない。

`(WIDTH REST...)'
     最初の要素が整数であるリストは、
     RESTの結果の切り詰めや引き伸しを指定する。
     残りの要素RESTはモード行構成として再帰的に処理され連結される。
     （WIDTHが正であれば）結果の右端に空白を追加したり、
     （WIDTHが負であれば）結果を（-WIDTH幅に） 右端から切り詰める。

     たとえば、ウィンドウの上端より上にバッファの何割があるかを表示するには、
     `(-3 "%p")'のようなリストを使う。

   読者が`mode-line-format'自体を変更するときには、
新しい値では、デフォルト値（*note Mode Line Variables::）に現れる
ものと同じ変数を使い、それらの値をコピーして使ったり、
別の書式で情報を表示したりしないでください。
こうしておけば、それらの変数に対する変更を介した
ユーザーや（`display-time'やメジャーモードなどの）Lispプログラムが行った
カスタマイズが効果を発揮できます。

   ホスト名やデフォルトディレクトリを含んだ
`shell-mode'に有用な`mode-line-format'の例を示します。

     (setq mode-line-format
       (list "-"
        'mode-line-mule-info
        'mode-line-modified
        'mode-line-frame-identification
        "%b--"
        ;; リストを作るときに評価されることに注意
        ;; 単なる文字列のモード行構成を作る
        (getenv "HOST")
        ":"
        'default-directory
        "   "
        'global-mode-string
        "   %[("
        'mode-name
        'mode-line-process
        'minor-mode-alist
        "%n"
        ")%]--"
        '(which-func-mode ("" which-func-format "--"))
        '(line-number-mode "L%l--")
        '(column-number-mode "C%c--")
        '(-3 . "%p")
        "-%-"))

（変数`line-number-mode'、`column-number-mode'、
`which-func-mode'は特定のマイナモードをオンにする。
通常どおり、これらの変数の名前はマイナモードコマンドの名前でもある。）


File: elisp-ja,  Node: Mode Line Variables,  Next: %-Constructs,  Prev: Mode Line Data,  Up: Mode Line Format

22.3.2 モード行に使われる変数
----------------------------------------

本節では、`mode-line-format'の標準値でモード行のテキストに
含められる変数について述べます。
これらの変数に関しては、本来特別なことはありません。
別の変数を使うように`mode-line-format'を変更すれば、
別の変数でもモード行において同じ効果を発揮します。

 -- Variable: mode-line-mule-info
     この変数は、言語環境、バッファのコーディングシステム、
     現在の入力方式に関する情報を表示するモード行構成の値を保持する。
     *note Non-ASCII Characters::。

 -- Variable: mode-line-modified
     この変数は、カレントバッファが変更されたかどうかを表示する
     モード行構成の値を保持する。

     `mode-line-modified'のデフォルト値は`("%1*%1+")'である。
     これは、バッファが変更されていると`**'を、
     未変更ならば`--'を、読み出し専用ならば`%%'を、
     読み出し専用でしかも変更されていれば`%*'を
     モード行に表示することを意味する。

     この変数を変更してもモード行の更新を強制しない。

 -- Variable: mode-line-frame-identification
     この変数はカレントフレームを識別する。
     複数のフレームを表示できるウィンドウシステムを使用している場合には
     デフォルト値は`" "'であり、
     ある時点で1つのフレームしか表示できない普通の端末を使用している場合には
     `"-%F "'である。

 -- Variable: mode-line-buffer-identification
     この変数はウィンドウに表示しているバッファを識別する。
     デフォルト値は`("%12b")'であり、
     空白で埋めて最低12コラムでバッファ名を表示する。

 -- Variable: global-mode-string
     この変数は、デフォルトでモード行のバッファ名の直後に現れる
     モード行指定を保持する。 コマンド`display-time'は、
     `global-mode-string'が時刻と負荷情報を含んだ
     変数`display-time-string'を参照するように設定する。

     `%M'記法は`global-mode-string'の値を使うが、
     この変数は`mode-line-format'でモード行に含まれるため
     `%M'は廃れた記法である。

 -- Variable: mode-name
     このバッファローカルな変数は、
     カレントバッファのメジャーモードの『愛称』を保持する。
     各メジャーモードは、モード行にモード名が現れるようにこの変数に設定すること。

 -- Variable: minor-mode-alist
     この変数は、モード行にマイナモードがオンであることを表示する方法を
     指定する要素からなる連想リストを保持する。
     `minor-mode-alist'の各要素は、2要素リストであること。

          (MINOR-MODE-VARIABLE MODE-LINE-STRING)

     より一般的には、MODE-LINE-STRINGはどのようなモード行指定でもよい。
     それは、MINOR-MODE-VARIABLEの値が`nil'以外のときに
     モード行に現れ、さもなければ現れない。
     これらの文字列は、繋がらないように空白で始まること。
     慣習的には、特定モードに対するMINOR-MODE-VARIABLEは、
     当該マイナモードがオンであると`nil'以外に設定される。

     `minor-mode-alist'のデフォルト値はつぎのとおり。

          minor-mode-alist
          => ((vc-mode vc-mode)
              (abbrev-mode " Abbrev")
              (overwrite-mode overwrite-mode)
              (auto-fill-function " Fill")
              (defining-kbd-macro " Def")
              (isearch-mode isearch-mode))

     `minor-mode-alist'自体はバッファローカルではない。
     マイナモードが各バッファごとにオンにできる場合には、
     連想リストに指定した対応する各変数はバッファローカルであること。

 -- Variable: mode-line-process
     このバッファローカルな変数は、
     サブプロセスとの通信用に使われているモードの処理状態に関する
     モード行の情報を保持する。
     メジャーモード名の直後に空白で区切らずに表示される。
     たとえば、バッファ`*shell*'におけるこの変数の値は`(":%s")'であり、
     シェルがその状態をメジャーモードとともに`(Shell: run)'のように
     表示できる。 通常、この変数は`nil'である。

 -- Variable: default-mode-line-format
     この変数は、`mode-line-format'を変更していないバッファの
     デフォルトの`mode-line-format'の値を保持する。
     これは`(default-value 'mode-line-format)'と同じである。

     `default-mode-line-format'のデフォルト値はつぎのリストである。

          ("-"
           mode-line-mule-info
           mode-line-modified
           mode-line-frame-identification
           mode-line-buffer-identification
           "   "
           global-mode-string
           "   %[("
           mode-name
           mode-line-process
           minor-mode-alist
           "%n"
           ")%]--"
           (which-func-mode ("" which-func-format "--"))
           (line-number-mode "L%l--")
           (column-number-mode "C%c--")
           (-3 . "%p")
           "-%-")

 -- Variable: vc-mode
     各バッファにおいてバッファローカルな変数`vc-mode'は、
     バッファで訪問したファイルが版管理されているか、
     そうならばその方式を記録している。
     版管理されていない場合はその値は`nil'、
     さもなければモード行に表示される文字列である。


File: elisp-ja,  Node: %-Constructs,  Prev: Mode Line Variables,  Up: Mode Line Format

22.3.3 モード行の`%'記法
-------------------------------

以下は、認識される`%'記法とその意味の表です。 `%%'以外の記法では、
最大表示文字数を指定する10進数を`%'のあとに追加できます。

`%b'
     関数`buffer-name'で得られたカレントバッファ名。 *note Buffer
     Names::。

`%f'
     関数`buffer-file-name'で得られた訪問したファイルの名前。 *note
     Buffer File Name::。

`%F'
     選択しているフレームのタイトル（ウィンドウシステム上のみ）か名前。
     *note Window Frame Parameters::。

`%c'
     ポイントの現在のコラム番号。

`%l'
     ポイントの現在の行番号。

`%*'
     バッファが読み出し専用であれば`%'（`buffer-read-only'を参照）、
     バッファが変更されていれば`*'（`buffer-modified-p'を参照）、
     さもなければ`-'。 *note Buffer Modification::。

`%+'
     バッファが変更されていれば`*'（`buffer-modified-p'を参照）、
     バッファが読み出し専用であれば`%'（`buffer-read-only'を参照）、
     さもなければ`-'。
     `%*'との違いは、変更された読み出し専用バッファに対してのみである。
     *note Buffer Modification::。

`%&'
     バッファが変更されていれば`*'、さもなければ`-'である。

`%s'
     `process-status'で得たカレントバッファに属するサブプロセスの状態。
     *note Process Information::。

`%t'
     訪問したファイルがテキストファイルであるかバイナリファイルであるかを表す。
     （特定のオペレーティングシステムでのみ意味を持つ。）

`%p'
     ウィンドウの*上端*の上にあるバッファのテキストの割合、
     あるいは、`Top'、`Bottom'、`All'のいずれかである。

`%P'
     ウィンドウの*下端*の上にあるバッファのテキスト
     （ウィンドウに見えてるテキストと上端の上にあるテキスト）の割合に
     バッファの先頭が見えていれば`Top'を加えたもの、
     あるいは、`Bottom'、`All'のいずれかである。

`%n'
     ナロイングしていると`Narrow'、さもなければなにもなし。 （*note
     Narrowing::の`narrow-to-region'を参照）。

`%['
     （ミニバッファのレベルを除く）再帰編集レベルの深さを表す。
     各編集レベルごとに1つの`['。 *note Recursive Editing::。

`%]'
     （ミニバッファのレベルを除く）各再帰編集レベルごとに1つの`]'。

`%%'
     文字`%'。
     `%'記法を許す文字列に`%'をそのまま含めるための方法である。

`%-'
     モード行の残り部分を埋めるに十分な個数のダッシュ。

   つぎの2つの`%'記法はまだ使えますが、
変数`mode-name'や`global-mode-string'を
使って同じ効果を得られるのでこれらは廃れた記法です。

`%m'
     `mode-name'の値。

`%M'
     `global-mode-string'の値。
     現在、`display-time'は`global-mode-string'の値を変更する。


File: elisp-ja,  Node: Imenu,  Next: Font Lock Mode,  Prev: Mode Line Format,  Up: Modes

22.4 iメニュー
==================

"iメニュー"（Imenu）とは、ユーザーが
バッファ内の定義や節の一覧からその1つを選ぶと
バッファ内の当該箇所へ直接移動できる機能です。 iメニューは、
バッファ内の定義や部分の名前や位置を表すバッファインデックスを
構築しておくことで動作し、
当該箇所へ移動するためにユーザーがそれらの1つを選べるようにします。
本節ではメジャーモードに対するiメニューをカスタマイズする方法を説明します。

   普通のもっとも単純な方法は、
変数`imenu-generic-expression'に設定することです。

 -- Variable: imenu-generic-expression
     この変数が`nil'以外であると、
     iメニュー向けの定義を探すための正規表現を指定する。
     もっとも単純な場合、要素はつぎのような形である。

          (MENU-TITLE REGEXP SUBEXP)

     ここで、MENU-TITLEが`nil'以外であると、
     この要素に一致したものはバッファインデックスのサブメニューに置くことを
     意味する。 MENU-TITLE自体はサブメニューの名前を指定する。
     MENU-TITLEが`nil'であると、
     この要素に一致したものはバッファインデックスのメニューに直接置かれる。

     リストの2番目の要素REGEXPは正規表現 （*note Regular
     Expressions::）であり、
     これに一致した箇所がバッファインデックスに現れる定義になる。
     3番目の要素SUBEXPは、 定義の名前に一致するREGEXPの部分式である。

     要素はつぎの形でもよい。

          (MENU-TITLE REGEXP INDEX FUNCTION ARGUMENTS...)

     この要素に一致するものは、バッファインデックスの特別な項目になり、
     ユーザーが当該項目を選ぶと、
     ITEM-NAME、バッファ位置、ARGUMENTSを引数として FUNCTIONを呼び出す。

     emacs-lispモード向けには、PATTERNはつぎのようになる。

          ((nil "^\\s-*(def\\(un\\|subst\\|macro\\|advice\\)\
          \\s-+\\([-A-Za-z0-9+]+\\)" 2)
           ("*Vars*" "^\\s-*(def\\(var\\|const\\)\
          \\s-+\\([-A-Za-z0-9+]+\\)" 2)
           ("*Types*"
            "^\\s-*\
          (def\\(type\\|struct\\|class\\|ine-condition\\)\
          \\s-+\\([-A-Za-z0-9+]+\\)" 2))

     この変数に設定すると、
     カレントバッファにおいてバッファローカルな変数になる。

 -- Variable: imenu-case-fold-search
     この変数は、IMENU-GENERIC-EXPRESSIONとの一致に際して
     大文字小文字を区別するかどうかを制御する。
     デフォルトは`t'であり、大文字小文字を区別せずに一致をとる。

     この変数に設定すると、
     カレントバッファにおいてバッファローカルな変数になる。

 -- Variable: imenu-syntax-alist
     この変数は、`imenu-generic-expression'を処理中に
     カレントバッファの構文テーブルに優先する
     構文テーブルの変更部分の連想リストである。
     各要素はつぎの形であること。

          (CHARACTERS . SYNTAX-DESCRIPTION)

     CARのCHARACTERSは、文字か文字列である。
     それらの文字は、指定した構文SYNTAX-DESCRIPTIONであることを意味する。
     これは`modify-syntax-entry'（*note Syntax Table Functions::）に
     渡される。

     この機能は典型的には、
     通常のシンボル構成文字を単語構成文字として扱い、
     `imenu-generic-expression'を単純化し一致処理を速くする。
     たとえば、fortranモードではつぎのように使っている。

            (setq imenu-syntax-alist '(("_$" . "w")))

     こうすると、`imenu-generic-expression'のパターンでは、
     `\\(\\sw\\|\\s_\\)+'のかわりに`\\sw+'を使える。
     この技法は、名前の先頭文字の集合を名前の残りの文字の集合よりも
     小さく制限する必要があるモードで使うには不便であることに注意してほしい。

     この変数に設定すると、
     カレントバッファにおいてバッファローカルな変数になる。

   メジャーモードのiメニューをカスタマイズする別の方法は、
変数`imenu-prev-index-position-function'や
`imenu-extract-index-name-function'に設定することです。

 -- Variable: imenu-prev-index-position-function
     この変数が`nil'以外であると、その値は、
     バッファインデックスに置くつぎの定義を
     ファイルで後向きに探すための関数であること。

     その関数は、バッファインデックスの項目に対応する箇所にポイントを置くこと。
     項目がみつからなければ`nil'を返すこと。

     この変数に設定すると、
     カレントバッファにおいてバッファローカルな変数になる。

 -- Variable: imenu-extract-index-name-function
     この関数が`nil'以外であると、その値は、
     ポイントが変数`imenu-prev-index-position-function'が返した
     定義の部分にあると仮定して、当該定義の名前を返す関数であること。

     この変数に設定すると、
     カレントバッファにおいてバッファローカルな変数になる。

   メジャーモードのiメニューをカスタマイズする最後の方法は、
変数`imenu-create-index-function'に設定することです。

 -- Variable: imenu-create-index-function
     この関数は、バッファインデックスの作成に使う関数を指定する。
     その関数は引数なしで、カレントバッファに対するインデックスを返すこと。
     `save-excursion'の内側から呼ばれるので、
     その関数がポイントをどこに置こうと関係ない。

     デフォルト値は、インデックスの連想リストを生成するために
     `imenu-generic-expression'を使う関数である。
     読者が別の関数を指定すれば、`imenu-generic-expression'は使われない。

     この変数に設定すると、
     カレントバッファにおいてバッファローカルな変数になる。

 -- Variable: imenu-index-alist
     この変数は、カレントバッファに対するインデックスの連想リストを保持する。
     この変数に設定すると、
     カレントバッファにおいてバッファローカルな変数になる。

     連想リストの単純な要素は`(INDEX-NAME . INDEX-POSITION)'
     のような形である。 このような単純な要素を選ぶと、
     バッファ内でINDEX-POSITIONへ移動する効果がある。

     特別な要素は`(INDEX-NAME POSITION FUNCTION
     ARGUMENTS...)'のような形である。 このような特別な要素を選ぶと、
     つぎのようなフォームを実行する。

          (funcall FUNCTION INDEX-NAME POSITION ARGUMENTS...)

     入れ子になった部分連想リストの要素は `(INDEX-NAME
     SUB-ALIST)'のような形である。


File: elisp-ja,  Node: Font Lock Mode,  Next: Hooks,  Prev: Imenu,  Up: Modes

22.5 フォントロック（font-lock）モード
==================================================

"フォントロック（font-lock）モード"とは、
バッファ内の特定部分に対して、それらの構文上の役割に応じた
属性`face'を自動的に付加する機能のことです。
バッファを解析する方法はメジャーモードに依存しますが、
ほとんどのメジャーモードでは、
どの文脈でどのフェイスを使うかを指示する条件を定義します。
本節では、特定の言語向けに、いいかえれば、 特定のメジャーモード向けに
フォントロックをカスタマイズする方法を説明します。

   フォントロック（font-lock）モードは、強調表示すべきテキストを
2つの方法で、つまり、構文テーブルに基づいた構文解析、あるいは、
（通常、正規表現による）探索で探します。
構文解析による処理を最初に行ってコメントや文字列定数を探し、
`font-lock-comment-face'や`font-lock-string-face' （*note Faces for
Font Lock::）を使ってそれらを強調表示します。
探索による処理がこれに続きます。

* Menu:

* Font Lock Basics::
* Search-based Fontification::
* Other Font Lock Variables::
* Levels of Font Lock::
* Faces for Font Lock::
* Syntactic Font Lock::


File: elisp-ja,  Node: Font Lock Basics,  Next: Search-based Fontification,  Up: Font Lock Mode

22.5.1 フォントロック（font-lock）の基本
----------------------------------------------------

フォントロック（font-lock）モードがテキストを強調表示する方法を
制御する変数がいくつかあります。
しかし、メジャーモードでこれらの変数を直接に設定するべきではありません。
そのかわりに、バッファローカルな
変数`font-lock-defaults'に設定すべきです。
フォントロック（font-lock）モードがオンになると、
この変数に設定された値を使って他のすべての変数に設定します。

 -- Variable: font-lock-defaults
     この変数はメジャーモードがバッファローカルな変数として設定し、
     当該モードにおいてテキストをどのように表示するかを指定する。
     値はつぎの形であること。

          (KEYWORDS KEYWORDS-ONLY CASE-FOLD
           SYNTAX-ALIST SYNTAX-BEGIN OTHER-VARS...)

     最初の要素KEYWORDSは、 間接的に`font-lock-keywords'の値を指定する。
     要素KEYWORDSがシンボルであると、
     その変数としての値が`font-lock-keywords'に使われる。
     あるいは、要素KEYWORDSがそのようなシンボルのリストであると、
     各シンボルが1つのレベルの表示方法を指定する。
     最初のシンボルはレベル1の表示方法、
     2番目のシンボルはレベル2の表示方法といった具合である。

     2番目の要素KEYWORDS-ONLYは、
     変数`font-lock-keywords-only'の値を指定する。
     これが`nil'以外であると（文字列やコメントの）構文による処理を行わない。

     3番目の要素CASE-FOLDは、
     `font-lock-case-fold-search'の値を指定する。
     これが`nil'以外であると、フォントロック（font-lock）モードは
     `font-lock-keywords'で指定された探索で 大文字小文字を区別しない。

     4番目の要素SYNTAX-ALISTが`nil'以外である場合、
     それは`(CHAR-OR-STRING . STRING)'の形の
     コンスセルのリストであること。
     これらは表示方法を選ぶための構文テーブルの設定に使われる （*note
     Syntax Table Functions::）。
     得られた構文テーブルは`font-lock-syntax-table'に保持される。

     5番目の要素SYNTAX-BEGINは、
     `font-lock-beginning-of-syntax-function'の値を指定する
     （下記参照）。

     OTHER-VARS以降の要素は、 `(VARIABLE . VALUE)'という形である。
     この種の要素は、表示方法の選択に影響する
     その他の変数に設定するために使われる。


File: elisp-ja,  Node: Search-based Fontification,  Next: Other Font Lock Variables,  Prev: Font Lock Basics,  Up: Font Lock Mode

22.5.2 探索に基づくフォント選択
-------------------------------------------

フォントロック（font-lock）モードのカスタマイズにおいて
もっとも重要な変数は`font-lock-keywords'です。
探索に基づく表示方法の選択における探索条件を指定します。

 -- Variable: font-lock-keywords
     この変数の値は、強調表示するべきキーワードのリストである。
     このリストに正規表現を書く場合には注意すること。
     貧弱な書き方をしたパターンであると、動作を劇的に遅くする！

   `font-lock-keywords'の各要素は、 特定のテキストの探し方と
当該テキストをどのように強調表示するか指定します。
フォントロック（font-lock）モードは、
`font-lock-keywords'の要素を1つ1つ処理し、
各要素において、それに一致するものすべてを探して処理します。
通常、すでに表示方法を選択済みのテキスト部分については、
それ以降の要素に一致しても表示方法を変えません。
しかし、HIGHLIGHTERの要素OVERRIDEを使って、
異なるふるまいを指定できます。

   `font-lock-keywords'の各要素はつぎのいずれかの形です。

`REGEXP'
     正規表現REGEXPに一致したものはすべて
     `font-lock-keyword-face'を使って強調表示する。

          ;; 孤立した`foo'の出現は
          ;; `font-lock-keyword-face'で強調表示する。
          "\\<foo\\>"

     関数`regexp-opt'（*note Syntax of Regexps::）は、
     異なる複数個のキーワードに一致する最適な正規表現を
     計算するのに有用である。

`FUNCTION'
     関数FUNCTIONを呼び出してテキストを探し、
     それが探し出したものを`font-lock-keyword-face'を使って強調表示する。

     FUNCTIONは、探索限界を引数として呼び出される。
     みつかれば`nil'以外を返すとともに
     みつけた部分を表すマッチデータを設定する。

`(MATCHER . MATCH)'
     この種の要素では、MATCHERは、上に述べた正規表現か関数を表す。
     CDRのMATCHは、（MATCHERに一致した部分全体のかわりに）
     強調表示すべきMATCHERの部分式を指定する。

          ;; `fubar'の各出現の`bar'を
          ;; `font-lock-keyword-face'で強調表示
          ("fu\\(bar\\)" . 1)

     正規表現MATCHERを作るために`regexp-opt'を使った場合、
     MATCHの値を計算するには `regexp-opt-depth'（*note Syntax of
     Regexps::）を使える。

`(MATCHER . FACENAME)'
     この種の要素では、FACENAMEは、
     強調表示に使うフェイス名を指定する値を表す式である。

          ;; `fubar'の出現は、`fubar-face'の値で
          ;; 表されたフェイスを使って強調表示
          ("fubar" . fubar-face)

`(MATCHER . HIGHLIGHTER)'
     この種の要素では、HIGHLIGHTERは、
     MATCHERに一致した部分の強調表示方法を指定するリストである。
     つぎの形であること。

          (SUBEXP FACENAME OVERRIDE LAXMATCH)

     CARのSUBEXPは、 強調表示すべき一致部分の部分式を指定する整数
     （0は一致部分全体を意味する）である。
     2番目の要素FACENAMEは、上に述べたようにフェイスを指定する。

     HIGHLIGHTERの最後の2つの要素、 OVERRIDEとLAXMATCHはフラグである。
     OVERRIDEが`t'であると、当該要素は、
     `font-lock-keywords'のまえの要素で決定済みの
     表示方法に優先することを表す。
     `keep'であると、他の要素では表示方法が決定していない
     各文字の表示方法を表す。 `prepend'であると、
     属性`face'の先頭にフェイスFACENAMEを追加する。 `append'であると、
     属性`face'の末尾にフェイスFACENAMEを追加する。

     LAXMATCHが`nil'以外であると、
     MATCHERで一致したものの中にSUBEXP番目の部分式が
     なくてもエラーとしないことを意味する。

     この種の要素とその動作の例を示す。

          ;; `foo'や`bar'の出現の表示方法がすでに決まっていても
          ;; `foo-bar-face'で強調表示する
          ;; `foo-bar-face'の値はフェイスであること
          ("foo\\|bar" 0 foo-bar-face t)

          ;; 関数`fubar-match'がみつけた各出現内の最初の部分式を
          ;; `fubar-face'の値が表すフェイスで強調表示する
          (fubar-match 1 fubar-face)

`(MATCHER HIGHLIGHTERS...)'
     この種の要素は、1つのMATCHERに対して
     複数のリストHIGHLIGHTERを指定する。 これが有用であるためには、
     各HIGHLIGHTERでSUBEXPの値が異なること。
     つまり、それぞれをMATCHERの異なる部分式に適用できること。

`(eval . FORM)'
     FORMは、バッファにおいて`font-lock-keywords'のこの値が
     始めて使われたときに評価すべき式である。
     その値は、この表にあげた形の1つであること。

   *警告：*` ' `font-lock-keywords'の要素は、
行をまたがって一致するように設計しないこと。
そのような処理は信頼性がない。
`font-lock-fontify-buffer'は、行にまたがるパターンを正しく扱えるが、
読者がバッファを編集したときの更新処理では、
一度に1行ずつ処理するために正しく扱えない。


File: elisp-ja,  Node: Other Font Lock Variables,  Next: Levels of Font Lock,  Prev: Search-based Fontification,  Up: Font Lock Mode

22.5.3 その他のフォントロック変数
----------------------------------------------

本節では、`font-lock-defaults'を用いてメジャーモードで
設定できる他の変数について述べます。

 -- Variable: font-lock-keywords-only
     `nil'以外であると、フォントロック（font-lock）モードは、
     構文に基づいてコメントや文字列を強調表示すべきでないことを意味する。
     `font-lock-keywords'に基づく強調表示のみを行う。

 -- Variable: font-lock-keywords-case-fold-search
     `nil'以外であると、`font-lock-keywords'の
     正規表現探索では大文字小文字を区別しないことを意味する。

 -- Variable: font-lock-syntax-table
     この変数は、コメントや文字列の表示方法に用いる
     構文テーブルを指定する。

 -- Variable: font-lock-beginning-of-syntax-function
     この変数が`nil'以外であると、
     ポイントを構文上の『トップレベル』で文字列やコメントの外側に
     後方移動する関数であること。 フォントロック（font-lock）モードは、
     構文に基づく処理において正しい結果を得るために
     必要に応じてこの関数を使う。

     関数は引数なしで呼び出される。
     ポイントを構文ブロックの先頭に置くこと。 典型的な値は、
     `beginning-of-line'（行頭は構文ブロックの外側である）、 あるいは、
     プログラム向けのモードでは`beginning-of-defun'、
     テキスト向けのモードでは`backward-paragraph'
     （モード固有の関数は構文ブロックの外側にポイントを移動する）である。

     値が`nil'であると、バッファの先頭を構文ブロックの外側の位置として使う。
     これは誤りではないが、動作を遅くする。

 -- Variable: font-lock-mark-block-function
     この変数が`nil'以外であると、 コマンド`M-g
     M-g'（`font-lock-fontify-block'）による
     再表示のためにテキストの括られた範囲を選ぶために
     引数なしで呼ばれ関数であること。

     関数は、選んだ範囲にリージョンを設定すること。
     正しい結果を得られるように大きめのテキスト範囲を選ぶのがよいが、
     再表示処理が遅くならないように大きすぎないこと。
     典型的な値は、プログラム向けモードでは`mark-defun'、
     テキスト向けモードでは`mark-paragraph'である。


File: elisp-ja,  Node: Levels of Font Lock,  Next: Faces for Font Lock,  Prev: Other Font Lock Variables,  Up: Font Lock Mode

22.5.4 フォントロックのレベル
----------------------------------------

多くのメジャーモードでは、3段階の表示方法を提供します。
`font-lock-defaults'のKEYWORDSに
シンボルのリストを使って複数レベルを定義できます。
各シンボルは1つのレベルの表示方法を指定します。
どのレベルを選ぶかはユーザーの責任です。
指定したレベルのシンボルの値は`font-lock-keywords'の初期化に使われます。

   表示方法のレベルを定義する際の慣習をあげておきます。

   * レベル1：` '
     関数宣言、（includeやimportなどの）ファイル指定、文字列、
     コメントを強調表示する。
     速さが肝心であり、重要な構文やトップレベルの構成要素のみを強調表示する。

   * レベル2：` ' レベル1に加えて、キーワードのようにふるまう型名を含む
     当該言語のすべてのキーワード、名前付き定数。
     （構文的な、あるいは、意味的な）すべてのキーワードを
     適切に強調表示するのが目的。

   * レベル3：` ' レベル2に加えて、
     関数や変数宣言で定義されたシンボル、適切なすべての組み込み関数の名前。


File: elisp-ja,  Node: Faces for Font Lock,  Next: Syntactic Font Lock,  Prev: Levels of Font Lock,  Up: Font Lock Mode

22.5.5 フォントロックのフェイス
-------------------------------------------

フォントロック（font-lock）モードでは任意のフェイスを使えますが、
フォントロック（font-lock）モード向けに特別に定義さたフェイスがあります。
これらのシンボルのおのおのは、フェイス名でもあり、
シンボル自身をデフォルト値とする変数でもあります。
つまり、`font-lock-comment-face'のデフォルト値は、
`font-lock-comment-face'です。 これは、
フェイス名を値に持つような式を書く`font-lock-keywords'などの場面で、
`font-lock-comment-face'と書けることを意味します。

`font-lock-comment-face'
     （典型的には）コメントに使われる。

`font-lock-string-face'
     （典型的には）文字列に使われる。

`font-lock-keyword-face'
     （典型的には）キーワード、つまり、
     Cの`for'や`if'のように構文的に重要な名前に使われる。

`font-lock-builtin-face'
     （典型的には）組み込み関数の名前に使われる。

`font-lock-function-name-face'
     （典型的には）関数定義／宣言内において、
     定義／宣言されている関数の名前に使われる。

`font-lock-variable-name-face'
     （典型的には）変数定義／宣言内において、
     定義／宣言されている変数の名前に使われる。

`font-lock-type-face'
     （典型的には）ユーザー定義のデータ型の名前が定義／参照される場所において、
     それらの名前に使われる。

`font-lock-constant-face'
     （典型的には）定数の名前に使われる。

`font-lock-warning-face'
     （典型的には）独特な構文や別のテキストの意味を大きく変えるようなものに
     使われる。 たとえば、Emacs Lispの`;;;###autoload'や
     Cの`#error'指定に使われる。


File: elisp-ja,  Node: Syntactic Font Lock,  Prev: Faces for Font Lock,  Up: Font Lock Mode

22.5.6 構文的なフォントロック
----------------------------------------

フォントロック（font-lock）モードは、
属性`syntax-table'を自動更新するためにも使えます。
1つの構文テーブルだけでは十分でないような言語において有用です。

 -- Variable: font-lock-syntactic-keywords
     この変数は構文的なフォントロックをオンにし制御する。
     その値はつぎの形の要素からなるリストであること。

          (MATCHER SUBEXP SYNTAX OVERRIDE LAXMATCH)

     この要素の各部分には、つぎの`font-lock-keywords'の対応する種類の要素と
     同じ意味がある。

          (MATCHER SUBEXP FACENAME OVERRIDE LAXMATCH)

     しかし、属性`face'に使う値FACENAMEを指定するかわりに、
     属性`syntax-table'に使う値SYNTAXを指定する。
     ここで、SYNTAXは、構文テーブルを値とする変数、 `(SYNTAX-CODE .
     MATCHING-CHAR)'の形の構文テーブルの項目、
     あるいは、この2種類のどちらかを値とする式である。


File: elisp-ja,  Node: Hooks,  Prev: Font Lock Mode,  Up: Modes

22.6 フック
==============

"フック"（hook）とは、既存のプログラムから特定の場面で
呼び出される（1つか一連の）関数を収めた変数です。
Emacsは、カスタマイズのためにフックを用意しています。
ほとんどの場合、フックはファイル`.emacs'で設定しますが、
Lispプログラムが行ってもかまいません。
標準のフック関数一覧については、*Note Standard Hooks::。

   Emacsの多くのフックは"ノーマルフック"（normal hook）です。
これらの変数は、引数なしで呼び出される関数のリストを保持しています。
フック名が`-hook'で終っていると、ノーマルフックを意味します。
読者がそれらを単一の方法で使えるように、
可能な限りノーマルフックにするように心掛けています。

   各メジャーモード関数は、 その初期化の最終段階で"モードフック"（mode
hook）と呼ばれる ノーマルフックを実行すると期待されます。
これにより、モードがすでに設定したバッファローカルな変数を上書きすることで、
ユーザーがモードのふるまいをカスタマイズしやすくしています。
しかし、フックは別の場面でも使われています。
たとえば、フック`suspend-hook'は、
Emacsが自身を一時休止する直前に実行されます。 （*note Suspending
Emacs::）。

   ノーマルフックにフック関数を追加する推奨方法は、
`add-hook'（下記参照）を呼ぶことです。 フック関数は、`funcall'（*note
What Is a Function::）が
受け付けるならばどんな種類の関数でもかまいません。
ほとんどのノーマルフック変数は最初は空ですが、
`add-hook'はその扱い方を知っています。

   フック変数の名前が`-hook'で終らない場合、
それが"アブノーマルフック"（abnormal hook）であることを表します。
読者は、そのようなフックの正しい使い方を説明書で調べるべきです。

   変数名が`-functions'や`-hooks'で終っていると、
その値は関数のリストですが、 それらの関数を引数ありで呼び出したり、
関数の戻り値をどこかで使うという意味でアブノーマル（異常）なのです。
リストに関数を追加するには`add-hook'を使えますが、
関数を書くときには注意する必要があります。
（これらの変数のうち、実際にはノーマルフックであるものもある。
ノーマルフックには`-hook'を使うという慣習を
確立するまえに命名したものである。）

   変数名が`-function'で終っていると、
その値は、関数のリストではなく、1つの関数です。

   lisp対話モードで自動詰め込み（auto-fill）モードをオンにするために
モードフックを使った例を示します。

     (add-hook 'lisp-interaction-mode-hook 'turn-on-auto-fill)

   適当な時期に、Emacsは関数`run-hooks'を使って
特定のフックを実行します。
この関数は、`add-hook'で追加されたフック関数を呼び出します。

 -- Function: run-hooks &rest hookvar
     この関数は複数個のフック変数名を引数にとり、各フックを順に実行する。
     各引数HOOKVARは、フック変数のシンボルであること。
     これらの引数は、指定された順に処理される。

     フック変数が`nil'以外の値であると、
     その値は、関数か関数のリストである。
     値が関数（ラムダ式や関数定義を持つシンボル）であると、それを呼び出す。
     値がリストであると、順番にその要素を呼び出す。
     フック関数は、引数なしで呼び出される。
     現在、フック変数に1つの関数を入れることは廃れかけている。
     つねに関数のリストを使うべきである。

     例として、`emacs-lisp-mode'がそのモードフックをどのように
     実行するかを示す。

          (run-hooks 'emacs-lisp-mode-hook)

 -- Function: run-hook-with-args hook &rest args
     この関数は、フック関数に引数を渡すアブノーマルフックを実行する方法である。
     各フック関数に引数ARGSを渡して呼び出す。

 -- Function: run-hook-with-args-until-failure hook &rest args
     この関数は、フック関数に引数を渡すアブノーマルフックを実行するが、
     フック関数が失敗するとただちに止める方法である。
     フック関数が`nil'を返すまで、
     各フック関数に引数ARGSを渡して呼び出す。
     `nil'が返ってくると`nil'で戻る。
     さもなければ、`nil'以外の値を返す。

 -- Function: run-hook-with-args-until-success hook &rest args
     この関数は、フック関数に引数を渡すアブノーマルフックを実行するが、
     フック関数が成功するとただちに止める方法である。
     フック関数が`nil'以外を返すまで、
     各フック関数に引数ARGSを渡して呼び出す。 `nil'以外が返ってくると
     最後に呼び出したフック関数の戻り値を返す。

 -- Function: add-hook hook function &optional append local
     この関数はフック変数HOOKに関数FUNCTIONを追加する 手軽な方法である。
     引数FUNCTIONは、正しい個数の引数をとる任意の正しいLisp関数であること。
     たとえば、

          (add-hook 'text-mode-hook 'my-text-hook-function)

     は、`text-mode-hook'というフックに
     `my-text-hook-function'を追加する。

     `add-hook'は、ノーマルフックに加えてアブノーマルフックにも使える。

     フック関数は実行順序に依存しないように設計するのが最良である。
     実行順序に依存すると『トラブルを呼び込む』ようなものである。
     しかし、順序は予測できる。
     通常、FUNCTIONはフックリストの先頭に置かれるので、
     （ほかに`add-hook'の呼び出しがなければ）最初に実行される。
     省略可能な引数APPENDが`nil'以外であると、
     新たなフック関数はフックリストの末尾に置かれ、 最後に実行される。

     LOCALが`nil'以外であると、
     新たなフック関数をカレントバッファにバッファローカルにすることを意味する。
     これを行うまえに、（`make-local-variable'*ではなく*）
     `make-local-hook'を呼んで
     フック自身をバッファローカルにしておく必要がある。
     フック自身がバッファローカルでないと、LOCALの値は意味を持たない。
     フック関数はつねにグローバルである。

 -- Function: remove-hook hook function &optional local
     この関数は、フック変数HOOKからFUNCTIONを取り除く。

     LOCALが`nil'以外であると、
     グローバルなフックリストではなくバッファローカルなフックリストから
     FUNCTIONを削除することを指定する。
     フック変数自身がバッファローカルでないと、LOCALの値は意味を持たない。

 -- Function: make-local-hook hook
     この関数は、フック変数`hook'をカレントバッファにバッファローカルにする。
     フック変数がバッファローカルであると、
     バッファローカルなフック関数とグローバルなフック関数を持つことができ、
     `run-hooks'はそれらすべてを実行する。

     この関数は、バッファローカルな値の要素を`t'にすることで動作する。
     これは、バッファローカルな値に加えてフック変数のデフォルト値にある
     フック関数を使うことを表すフラグである。
     `run-hooks'はこのフラグを理解し、
     `make-local-hook'はすべてのノーマルフックを処理できる。
     アブノーマルフックに関しては、
     `t'の意味を理解するように更新したものだけが処理できる。

     フック変数に対して`make-local-variable'を直接使わないこと。
     それだけでは不十分である。



File: elisp-ja,  Node: Documentation,  Next: Files,  Prev: Modes,  Up: Top

23 説明文
************

GNU Emacs Lispには、便利なオンラインのヘルプ機能があります。
そのほとんどは、関数や変数に付随した説明文字列から取り出したものです。
本章では、説明文を参照するプログラムの書き方に加えて、
読者のLispプログラムに適切な説明文字列を書く方法を説明します。

Emacsの説明文字列は、Emacsマニュアルと同じものではないことに注意願います。
マニュアルには言語texinfoで書いた独自のソースファイルがありますが、
説明文字列は関数や変数の定義の中で指定されています。
説明文字列を集めても、よいマニュアルとは構成が違いますので、
マニュアルとしては十分ではありません。

* Menu:

* Documentation Basics::      Good style for doc strings.
                                Where to put them.  How Emacs stores them.
* Accessing Documentation::   How Lisp programs can access doc strings.
* Keys in Documentation::     Substituting current key bindings.
* Describing Characters::     Making printable descriptions of
                                non-printing characters and key sequences.
* Help Functions::            Subroutines used by Emacs help facilities.


File: elisp-ja,  Node: Documentation Basics,  Next: Accessing Documentation,  Up: Documentation

23.1 説明文の基本
=======================

説明文字列は、文字列に対するLisp構文、
つまり、文字列のテキストをダブルクォートで囲って書きます。
これは、説明文字列が実際にはLispの文字列オブジェクトだからです。
関数や変数の定義の正しい箇所に文字列を書くと、
説明文としての役割を果たします。
関数定義においては、説明文字列は引数のつぎにあります。
変数定義においては、変数の初期値のつぎにあります。

   説明文字列を書くときには、
最初の1行は1つの（あるいは2つの）完全な文にしてください。
`apropos'などのある種のコマンドは、
複数行にまたがる説明文字列の最初の1行だけを表示するからです。
また、説明文字列の2行目以降を字下げしないでください。 字下げがあると、
`C-h f'（`describe-function'）や `C-h
v'（`describe-variable'）で説明文字列を表示すると 不恰好になります。
*Note Documentation Tips::。

   説明文字列には、特別な部分文字列、つまり、
説明文を表示するときに現在のキーマップからキーバインディングを探す
ことを表すものがあります。
これにより、ユーザーがキーバインディングを変更していても
説明文字列から関連するコマンドのキーを参照できます。 （*note Accessing
Documentation::）。

   Emacs
Lispでは、説明文字列はその説明対象である関数や変数を介して参照します。

   * 関数の説明文は、関数定義自身に収められている （*note Lambda
     Expressions::）。 関数`documentation'がその取り出し方を知っている。

   * 変数の説明文は、変数の属性リストに
     属性名`variable-documentation'で収められている。
     関数`documentation-property'がその取り出し方を知っている。

   場所を節約するために、あらかじめロード済みの関数や変数
（基本関数や自動ロード対象の関数を含む）に対する説明文は、
Emacs本体にではなく、ファイル`emacs/etc/DOC-VERSION'に 収めてあります。
Emacsセッションの最中にバイトコンパイル済みのファイルから
ロードされる関数や変数の説明文字列は、当該ファイルに収めてあります
（*note Docs and Compilation::）。

   Emacs内部のデータ構造では、説明文字列のかわりに、
ファイル内の位置を表す整数かファイル名と整数を含むリストで表します。
関数`documentation'や`documentation-property'は、
この情報を用いて適切なファイルから説明文字列を取り出します。
この処理はユーザーには見えません。

   説明文字列の利用に関する情報は、 *note ヘルプ機能:
(emacs)Help.を参照してください。

   ディレクトリ`emacs/lib-src'には、
ファイル`emacs/etc/DOC-VERSION'を美しく印刷するための
コマンドが2つあります。 `sorted-doc'と`digest-doc'です。


File: elisp-ja,  Node: Accessing Documentation,  Next: Keys in Documentation,  Prev: Documentation Basics,  Up: Documentation

23.2 説明文字列の参照
=============================

 -- Function: documentation-property symbol property &optional verbatim
     この関数は、シンボルSYMBOLの属性リストに
     属性PROPERTYで記録されている説明文字列を返す。
     必要ならばファイルからテキストを取り出し、
     実際のキーバインディングに置き換えるために
     `substitute-command-keys'を実行する。
     （VERBATIMが`nil'以外であると、置換を行わない。）

          (documentation-property 'command-line-processed
             'variable-documentation)
               => "Non-nil once command line has been processed"
          (symbol-plist 'command-line-processed)
               => (variable-documentation 188902)

 -- Function: documentation function &optional verbatim
     この関数は、関数FUNCTIONの説明文字列を返す。
     必要ならばファイルからテキストを取り出す。
     続いて、（VERBATIMが`nil'ならば）
     実際の（現在の）キーバインディングを含んだ値を返すために
     `substitute-command-keys'を実行する。

     関数`documentation'は、FUNCTIONに関数定義がないと
     エラー`void-function'を通知する。
     しかし、関数定義に説明文字列がなくてもエラーではない。
     その場合、`documentation'は`nil'を返す。

   2つの関数`documentation'と`documentation-property'を用いて、
数個のシンボルの説明文字列をバッファ`*Help*'に表示する例を示します。

     (defun describe-symbols (pattern)
       "Describe the Emacs Lisp symbols matching PATTERN.
     All symbols that have PATTERN in their name are described
     in the `*Help*' buffer."
       (interactive "sDescribe symbols matching: ")
       (let ((describe-func
              (function
               (lambda (s)
                 ;; Print description of symbol.
                 (if (fboundp s)             ; これは関数
                     (princ
                      (format "%s\t%s\n%s\n\n" s
                        (if (commandp s)
                            (let ((keys (where-is-internal s)))
                              (if keys
                                  (concat
                                   "Keys: "
                                   (mapconcat 'key-description
                                              keys " "))
                                "Keys: none"))
                          "Function")
                        (or (documentation s)
                            "not documented"))))

                 (if (boundp s)              ; これは変数
                     (princ
                      (format "%s\t%s\n%s\n\n" s
                        (if (user-variable-p s)
                            "Option " "Variable")
                        (or (documentation-property
                              s 'variable-documentation)
                            "not documented")))))))
             sym-list)

         ;; パターンに一致するシンボルのリストを作る
         (mapatoms (function
                    (lambda (sym)
                      (if (string-match pattern (symbol-name sym))
                          (setq sym-list (cons sym sym-list))))))

         ;; データを表示する
         (with-output-to-temp-buffer "*Help*"
           (mapcar describe-func (sort sym-list 'string<))
           (print-help-return-message))))

   関数`describe-symbols'は`apropos'のように動作しますが、
より多くの情報を提供します。

     (describe-symbols "goal")

     ---------- Buffer: *Help* ----------
     goal-column     Option
     *Semipermanent goal column for vertical motion, as set by ...

     set-goal-column Keys: C-x C-n
     Set the current horizontal position as a goal for C-n and C-p.
     Those commands will move to this position in the line moved to
     rather than trying to keep the same horizontal position.
     With a non-nil argument, clears out the goal column
     so that C-n and C-p resume vertical motion.
     The goal column is stored in the variable `goal-column'.

     temporary-goal-column   Variable
     Current goal column for vertical motion.
     It is the column where point was
     at the start of current run of vertical motion commands.
     When the `track-eol' feature is doing its job, the value is 9999.
     ---------- Buffer: *Help* ----------

 -- Function: Snarf-documentation filename
     この関数は、実行可能なEmacsをダンプする直前の
     Emacsの初期化処理中にのみ使われる。
     ファイルFILENAMEに格納された説明文字列のファイル内位置を探し出し、
     それらの情報を実際の文字列のかわりに
     メモリ内の関数定義や変数の属性リストに記録する。 *note Building
     Emacs::。

     EmacsはファイルFILENAMEをディレクトリ`emacs/etc'から読む。
     ダンプしたEmacsをのちに実行すると、
     同じファイルをディレクトリ`doc-directory'で探す。
     通常、FILENAMEは`"DOC-VERSION"'である。

 -- Variable: doc-directory
     この変数は、組み込みであったりあらかじめロード済みの関数や変数の
     説明文字列を収めたファイル`"DOC-VERSION"'を置いた
     ディレクトリの名前を保持する。

     ほとんどの場合、これは`data-directory'と同じである。
     Emacsをインストールせずに構築したディレクトリから起動すると、
     それらは異なることがある。 *note Help
     Functions::の`data-directory'を参照。

     Emacsの古い版では、この目的には`exec-directory'を用いていた。


File: elisp-ja,  Node: Keys in Documentation,  Next: Describing Characters,  Prev: Accessing Documentation,  Up: Documentation

23.3 説明文内のキーバインディングの置換
========================================================

説明文字列からキー列を参照するときには、
現在の活性なキーバインディングを使うべきです。
これは以下に述べる特別なテキスト列でできます。
普通の方法で説明文字列を参照すると、
これらの特別な列は現在のキーバインディング情報で置き換えられます。
置き換えは`substitute-command-keys'を呼び出して行います。
読者自身がこの関数を使うこともできます。

   特別な列とその意味を以下にあげます。

`\[COMMAND]'
     コマンドCOMMANDを起動するキー列を表す。
     COMMANDにキーバインディングがなければ、 `M-x COMMAND'を表す。

`\{MAPVAR}'
     変数MAPVARの値であるキーマップの概要を表す。
     この概要は`describe-bindings'を使って作成する。

`\<MAPVAR>'
     空テキストを表す。 副作用のためだけに使う。
     つまり、この説明文字列内のこれ以降にある列`\[COMMAND]'に
     対するキーマップとしてMAPVARの値を指定する。

`\='
     後続の文字をクォートし`\='は破棄する。
     したがって、`\=\['は`\['という出力になり、
     `\=\='は`\='という出力になる。

   *注意：*` ' Emacs Lispでは、文字列内の`\'は、2つ続けて書くこと。

 -- Function: substitute-command-keys string
     この関数は、STRINGから上記の特別な列を探し、
     それらをそれらが意味するものに置き換え、結果を文字列で返す。
     これにより、説明文の表示では、
     ユーザー独自のカスタマイズしたキーバインディングを実際に参照できる。

   特別な列の例を示します。

     (substitute-command-keys
        "To abort recursive edit, type: \\[abort-recursive-edit]")
     => "To abort recursive edit, type: C-]"

     (substitute-command-keys
        "The keys that are defined for the minibuffer here are:
       \\{minibuffer-local-must-match-map}")
     => "The keys that are defined for the minibuffer here are:

     ?               minibuffer-completion-help
     SPC             minibuffer-complete-word
     TAB             minibuffer-complete
     C-j             minibuffer-complete-and-exit
     RET             minibuffer-complete-and-exit
     C-g             abort-recursive-edit
     "

     (substitute-command-keys
        "To abort a recursive edit from the minibuffer, type\
     \\<minibuffer-local-must-match-map>\\[abort-recursive-edit].")
     => "To abort a recursive edit from the minibuffer, type C-g."


File: elisp-ja,  Node: Describing Characters,  Next: Help Functions,  Prev: Keys in Documentation,  Up: Documentation

23.4 ヘルプメッセージ用の文字変換
===============================================

これらの関数は、イベント、キー列、文字をテキスト表記に変換します。
これらの表記は、メッセージに文字やキー列をテキストとして含めるのに有用です。
というのは、非印字文字や白文字を印字文字の列に変換するからです。
白文字でない印字文字は文字そのもので表記します。

 -- Function: key-description sequence
     この関数は、SEQUENCEの入力イベントに対する
     Emacsの標準表記を含んだ文字列を返す。
     引数SEQUENCEは、文字列、ベクトル、リストである。
     正しいイベントについて詳しくは*note Input Events::。
     下記の`single-key-description'の例を参照。

 -- Function: single-key-description event
     この関数は、EVENTをキーボード入力向けのEmacsの標準表記で
     表した文字列を返す。 普通の印字文字はそのまま現れるが、
     コントロール文字は`C-'で始まる文字列に、
     メタ文字は`M-'で始まる文字列に、
     空白、タブなどは、`SPC'、`TAB'などとなる。
     ファンクションキーのシンボルはそれ自身が現れる。
     リストであるイベントはリストのCARのシンボルの名前が現れる。

          (single-key-description ?\C-x)
               => "C-x"
          (key-description "\C-x \M-y \n \t \r \f123")
               => "C-x SPC M-y SPC C-j SPC TAB SPC RET SPC C-l 1 2 3"
          (single-key-description 'C-mouse-1)
               => "C-mouse-1"

 -- Function: text-char-description character
     この関数は、CHARACTERを
     テキストに現れる文字向けのEmacsの標準表記で表した文字列を返す。
     `single-key-description'に似ているが、
     コントロール文字は、始めにカレットを付けて表現する点が異なる
     （Emacsのバッファでは、コントロールは普通このように表示される）。

          (text-char-description ?\C-c)
               => "^C"
          (text-char-description ?\M-m)
               => "M-m"
          (text-char-description ?\C-\M-m)
               => "M-^M"

 -- Function: read-kbd-macro string
     この関数は、キーボードマクロの処理に主に使われるが、
     `key-description'に対するおおまかな逆変換にも使える。
     空白で区切ったキーの表記を収めた文字列で、この関数を呼び出す。
     対応するイベントを収めた文字列かベクトルを返す。
     （指定したイベントに依存して、正しい単一のキー列であったりなかったりする。
     *note Keymap Terminology::。）


File: elisp-ja,  Node: Help Functions,  Prev: Describing Characters,  Up: Documentation

23.5 ヘルプ機能
====================

Emacsにはさまざまオンラインヘルプ関数があり、
それらはすべてプレフィックス`C-h'のサブコマンドとして使えます。
それらについて詳しくは、 *note ヘルプ機能:
(emacs)Help.を参照してください。
ここでは、同じ情報を得るプログラムレベルのインターフェイスを説明します。

 -- コマンド: apropos regexp &optional do-all
     この関数は、正規表現REGEXPに一致する名前を持つすべてのシンボルを探し、
     それらのリストを返す（*note Regular Expressions::）。
     さらに、バッファ`*Help*'に、各シンボルについて、
     シンボルとその説明文字列の始めの部分から取り出した1行の説明文を表示する。

     DO-ALLが`nil'以外であると、
     `apropos'は、みつけた関数に対するキーバインディングも表示する。
     さらに、関数や変数以外も含めてすべてのシンボルを表示する。

     つぎの例では、`apropos'は、
     `exec'を名前に含むすべてのシンボルを探しだす。
     （ここではバッファ`*Help*'の表示は示さない。）

          (apropos "exec")
               => (Buffer-menu-execute command-execute exec-directory
              exec-path execute-extended-command execute-kbd-macro
              executing-kbd-macro executing-macro)

 -- Variable: help-map
     この変数の値は、ヘルプキー`C-h'に続く文字向けのローカルキーマップである。

 -- プレフィックスコマンド: help-command
     このシンボルは関数ではない。
     その関数定義セルは、`help-map'として知られるキーマップを保持している。
     `help.el'での定義はつぎのとおりである。

          (define-key global-map "\C-h" 'help-command)
          (fset 'help-command help-map)

 -- Function: print-help-return-message &optional function
     この関数は、ヘルプコマンドのあとでそれ以前のウィンドウの状態に復元する
     方法を述べた文字列を作成する。
     メッセージを作成後、FUNCTIONが`nil'以外であれば、
     メッセージをFUNCTIONに適用する。
     さもなければ、メッセージをエコー領域に表示するために`message'を呼び出す。

     この関数は、スペシャルフォーム`with-output-to-temp-buffer'の
     中から呼び出され、しかも、
     当該スペシャルフォームで`standard-output'に値が束縛されているものと
     仮定する。 使用例については、*note Accessing
     Documentation::の長い例を参照。

 -- Variable: help-char
     この変数の値はヘルプ文字、つまり、
     Emacsがヘルプを意味すると認識する文字である。
     デフォルトでは、その値は`C-h'を表す8である。
     `help-form'が`nil'以外のLisp式であると、
     Emacsがこの文字を読み取るとその式を評価し、
     その結果が文字列であれば結果をウィンドウに表示する。

     通常、`help-form'の値は`nil'である。
     そうすると、ヘルプ文字にはコマンド入力のレベルでは特別な意味はなく、
     普通の意味でのキー列の一部になる。
     `C-h'の標準のキーバインディングは、
     いくつかの汎用目的のヘルプ機能向けのプレフィックスキーである。

     ヘルプ文字は、プレフィックスキーのうしろでも特別である。
     プレフィックスのサブコマンドとしてのバインディングがないと、
     プレフィックスキーのすべてのサブコマンドの一覧を表示する
     `describe-prefix-bindings'を実行する。

 -- Variable: help-event-list
     この変数の値は、別の『ヘルプ文字』として動作するイベント型のリストである。
     これらのイベントは`help-char'で指定されたイベントと
     まったく同様に扱われる。

 -- Variable: help-form
     この変数が`nil'以外であると、その値は、
     `help-char'を読むたびに評価すべきフォームである。
     フォームを評価すると文字列を生成すれば、その文字列が表示される。

     `read-event'や`read-char'を呼ぶコマンドは、
     入力中には`help-form'を`nil'以外に（たぶん）束縛すべきである。
     （`C-h'に別の意味がある場合には、こうしないこと。）
     この式の評価結果は、なんのための入力でどのように入力すべきかを
     説明する文字列であること。

     ミニバッファに入ると、この変数は`minibuffer-help-form' （*note
     Minibuffer Misc::）の値に束縛される。

 -- Variable: prefix-help-command
     この変数はプレフィックスキーに対するヘルプを表示する関数を保持する。
     ユーザーがプレフィックスキーに続けてヘルプ文字や
     当該プレフィックスのあとではバインディングを持たない文字を打つと
     その関数が呼ばれる。
     この変数のデフォルト値は`describe-prefix-bindings'である。

 -- Function: describe-prefix-bindings
     この関数は、もっとも最近のキー列のプレフィックスキーの
     すべてのサブコマンドの一覧を表示するために`describe-bindings'を呼び出す。
     プレフィックスの説明には、当該キー列の最後のイベント以外のすべてが含まれる。
     （最後のイベントはヘルプ文字であると仮定する。）

   つぎの2つの関数は、『エレクトリック』モードのように
制御を放棄せずにヘルプを提供したいモードのためです。
それらの名前は、普通のヘルプ関数と区別するために`Helper'で始まります。

 -- コマンド: Helper-describe-bindings
     このコマンドは、ローカルキーマップとグローバルキーマップの両者の
     すべてのキーバインディングの一覧を収めたヘルプバッファを表示した
     ウィンドウをポップアップする。
     `describe-bindings'を呼び出すことで動作する。

 -- コマンド: Helper-help
     このコマンドはカレントモードについてのヘルプを提供する。
     ミニバッファにおいて`Help (Type ? for further
     options)'のメッセージで
     ユーザーに問い合わせ、キーバインディングの意味やモードの目的を
     調べることを補佐する。 `nil'を返す。

     このコマンドは、キーマップ`Helper-help-map'を
     変更することでカスタマイズできる。

 -- Variable: data-directory
     この変数は、Emacsとともに配布された特定の説明文やテキストファイルを
     Emacsが探すためのディレクトリの名前を保持する。
     Emacsの古い版では、この目的には`exec-directory'を用いていた。

 -- Macro: make-help-screen fname help-line help-text help-map
     このマクロは、サブコマンドの一覧を表示するプレフィックスキーのように
     動作するFNAMEという名前のコマンドのヘルプを定義する。

     起動されると、FNAMEはウィンドウにHELP-TEXTを表示し、
     HELP-MAPに従ってキー列を読み実行する。
     文字列HELP-TEXTは、HELP-MAPが提供する
     バインディングを記述するべきである。

     コマンドFNAMEは、HELP-TEXTの表示をスクロールすることで、
     それ自身では少数のイベントを扱うように定義される。
     FNAMEがそれらの特殊イベントの1つを読み取ると、
     スクロールしてつぎのイベントを読み取る。
     読み取ったイベントが、扱えるものでなく、
     HELP-MAPにバインディングがあれば、
     当該キーのバインディングを実行して戻る。

     HELP-LINEは、HELP-MAP内の選択項目を1行にまとめたものであること。
     Emacsの現在の版では、この引数はオプション`three-step-help'を`t'に
     設定してある場合にのみ使われる。

     このマクロは、`C-h C-h'のバインディングである
     コマンド`help-for-help'で使われている。

 -- User Option: three-step-help
     この変数が`nil'以外であると、
     `make-help-screen'で定義されたコマンドは、
     まず文字列HELP-LINEをエコー領域に表示し、
     ユーザーがヘルプ文字を再度打った場合にのみより長い文字列を表示する。



File: elisp-ja,  Node: Files,  Next: Backups and Auto-Saving,  Prev: Documentation,  Up: Top

24 ファイル
***************

Emacsでは、ファイルやディレクトリを
探したり、作成したり、眺めたり、保存したり、その他のことをできます。
本章では、Emacs Lispのファイル関連の関数のほとんどについて説明しますが、
他の一部は*note Buffers::で、バックアップや自動保存に関することは *note
Backups and Auto-Saving::で説明します。

   ファイル関数の多くは、ファイル名の引数を1つないし複数個取ります。
ファイル名は実際には文字列です。
これらのほとんどの関数では、`expand-file-name'を呼び出して
ファイル名引数を展開することで`~'や
（`../'を含む）相対ファイル名を正しく処理します。
これらの関数は、`$HOME'などの環境変数置換は認識しません。 *Note File
Name Expansion::。

* Menu:

* Visiting Files::           Reading files into Emacs buffers for editing.
* Saving Buffers::           Writing changed buffers back into files.
* Reading from Files::       Reading files into buffers without visiting.
* Writing to Files::         Writing new files from parts of buffers.
* File Locks::               Locking and unlocking files, to prevent
                               simultaneous editing by two people.
* Information about Files::  Testing existence, accessibility, size of files.
* Changing Files::           Renaming files, changing protection, etc.
* File Names::               Decomposing and expanding file names.
* Contents of Directories::  Getting a list of the files in a directory.
* Create/Delete Dirs::	     Creating and Deleting Directories.
* Magic File Names::	     Defining "magic" special handling
			       for certain file names.
* Format Conversion::        Conversion to and from various file formats.


File: elisp-ja,  Node: Visiting Files,  Next: Saving Buffers,  Up: Files

24.1 ファイルの訪問
==========================

ファイルを訪問するとは、ファイルをバッファに読み込むことです。
いったんこうすると、バッファはそのファイルを
"訪問している"（visiting）といい、
そのファイルをバッファの『訪問しているファイル』と呼びます。

   ファイルとバッファは2つの異なるものです。
ファイルは、コンピュータ内に（読者が削除しない限り）恒久的に
記録されている情報です。 一方、バッファはEmacs内部にある情報であり、
編集セッションを終了する（あるいはバッファを削除する）と消えてしまいます。
通常、バッファにはファイルからコピーした情報があります。
つまり、バッファはそのファイルを訪問しているのです。
読者は、バッファ内のコピーを編集コマンドで修正するのです。
バッファに対するそのような変更では、ファイルは変更しません。
したがって、変更を恒久的なものにするには、
読者はバッファを"保存"（save）する、つまり、
バッファの変更した内容をファイルにコピーし戻す必要があります。

   ファイルとバッファの区別にも関わらず、
バッファを意味してファイルといったり、その逆のいい方をしばしばします。
もちろん、『同じ名前のファイルにただちに保存するつもりでバッファを
編集している』とはいわずに『ファイルを編集している』といいます。
しばしば、人間は明確に区別する必要はありません。
しかし、コンピュータプログラムを扱ううえでは、
区別を心得ておくことがよいのです。

* Menu:

* Visiting Functions::         The usual interface functions for visiting.
* Subroutines of Visiting::    Lower-level subroutines that they use.


File: elisp-ja,  Node: Visiting Functions,  Next: Subroutines of Visiting,  Up: Visiting Files

24.1.1 ファイルを訪問する関数
----------------------------------------

本節では、ファイルを訪問するために通常使う関数について述べます。
歴史的な理由で、これらの関数は`visit-'でなく`find-'という
名前で始まります。
バッファで訪問したファイルの名前を参照するための関数や変数、ならびに、
訪問したファイルの名前で既存バッファを探すための関数や変数については、
*Note Buffer File Name::。

Lispプログラムにおいて、ファイルの内容を変更せずにその内容を調べたいときには、
もっとも速い方法は一時的なバッファで`insert-file-contents'を
使うことです。
ファイルを訪問する必要はありませんし、それには余計に時間がかかります。
*Note Reading from Files::。

 -- コマンド: find-file filename
     このコマンドはファイルFILENAMEを訪問したバッファを選択する。
     そのようなバッファが既存ならば当該バッファを使う。
     さもなければ、新たなバッファを作成してファイルを読み込む。
     当該バッファを返す。

     関数`find-file'の本体は非常に簡単で、つぎのとおりである。

          (switch-to-buffer (find-file-noselect filename))

     （*note Displaying Buffers::の`switch-to-buffer'を参照。）

     `find-file'が対話的に呼び出されると、
     ミニバッファでFILENAMEを問い合わせる。

 -- Function: find-file-noselect filename &optional nowarn rawfile
     この関数は、ファイルを訪問するすべての関数の基である。
     ファイルFILENAMEを訪問した／するバッファを探し／作成し、
     当該バッファを返す。
     そのようなバッファが既存ならば当該バッファを使う。
     さもなければ、新たなバッファを作成してファイルを読み込む。
     必要に応じて、バッファをカレントバッファにしたり
     ウィンドウに表示できるが、この関数はそこまでは行わない。

     `find-file-noselect'が既存バッファを使うときには、
     ファイルの内容が当該バッファに最後に訪問してから、あるいは、
     当該バッファを最後に保存してから変更されたかどうかまず確認する。
     ファイルが変更されていれば、この関数は変更されたファイルを
     再度読み込むかどうかユーザーに問い合わせる。
     ユーザーが`yes'と答えると、バッファ内の変更は破棄される。

     省略可能な引数NOWARNが`nil'であると、
     この関数はさまざまな場面で警告／助言メッセージを表示する。
     たとえば、バッファを作成する必要があり、かつ、
     指定したファイルFILENAMEがない場合には、
     エコー領域にメッセージ`New file'を表示し、バッファは空にしておく。

     関数`find-file-noselect'は、
     ファイルを読み込み終えると通常`after-find-file'を呼び出す （*note
     Subroutines of Visiting::）。
     その関数は、バッファのメジャーモードを設定し、ローカル変数を解析し、
     訪問したファイルより新しい自動保存ファイルが存在するとユーザーに警告を発し、
     `find-file-hooks'の関数を実行して処理を終える。

     省略可能な引数RAWFILEが`nil'以外であると、
     `after-find-file'を呼び出さず、
     失敗しても`find-file-not-found-hooks'を実行しない。
     さらに、RAWFILEの値が`nil'以外であると、
     コーディングシステムの変換（*note Coding Systems::）や
     書式変換（*note Format Conversion::）も行わない。

     関数`find-file-noselect'は、
     ファイルFILENAMEを訪問したバッファを返す。

          (find-file-noselect "/etc/fstab")
               => #<buffer fstab>

 -- コマンド: find-file-other-window filename
     このコマンドは、選択しているウィンドウ以外のウィンドウにおいて、
     ファイルFILENAMEを訪問したバッファを選択する。
     別の既存ウィンドウを使うか、ウィンドウを分割する。 *note
     Displaying Buffers::を参照。

     このコマンドが対話的に呼び出されると、 FILENAMEを問い合わせる。

 -- コマンド: find-file-read-only filename
     このコマンドは、`find-file'のようにファイルFILENAMEを訪問した
     バッファを選択するが、当該バッファは読み出し専用となる。 *Note
     Read Only Buffers::。

     このコマンドが対話的に呼び出されると、 FILENAMEを問い合わせる。

 -- コマンド: view-file filename
     このコマンドは、閲覧（view）モードでFILENAMEを訪問し、
     閲覧（view）モードを抜けるとそれ以前のバッファに戻る。
     閲覧（view）モードは、ファイルを素早く眺めるためのコマンドを与えるが
     テキストの変更は許さないマイナモードである。
     閲覧（view）モードに入ると、ノーマルフック`view-mode-hook'を実行する。
     *note Hooks::。

     `view-file'が対話的に呼び出されると、 FILENAMEを問い合わせる。

 -- Variable: find-file-hooks
     この変数の値は、ファイルを訪問後に呼び出される関数のリストである。
     ファイルにローカル変数指定（があれば）は、
     フックを実行するまえに処理される。 フック関数が実行されときには、
     ファイルを訪問したバッファはカレントバッファになっている。

     この変数はノーマルフックのように動作するが、
     改名すべきではないと考えている。 *note Hooks::。

 -- Variable: find-file-not-found-hooks
     この変数の値は、`find-file'や`find-file-noselect'に
     存在しないファイルを与えたときに呼び出される関数のリストである。
     `find-file-noselect'は、ファイルが存在しないことがわかると
     ただちにこれらの関数を呼び出す。
     `nil'以外の値が返されるまで、リストに現れる順に呼び出す。
     `buffer-file-name'は設定済みである。

     関数の値を使い、しかも、一部の関数だけを呼び出すので、
     これはノーマルフックではない。


File: elisp-ja,  Node: Subroutines of Visiting,  Prev: Visiting Functions,  Up: Visiting Files

24.1.2 訪問するためのサブルーティン
-------------------------------------------------

関数`find-file-noselect'は、ユーザーのLispコードでも有用な
2つの重要なサブルーティン、`create-file-buffer'と
`after-find-file'を使います。 本節ではそれらの使い方を説明します。

 -- Function: create-file-buffer filename
     この関数は、FILENAMEを訪問するのに適するように命名した
     バッファを作成しそれを返す。
     （ディレクトリを除外した）FILENAMEが使用中の名前でなければ、
     それを名前とする。
     さもなければ、未使用の名前を得るために`<2>'などの文字列を付加する。
     *note Creating Buffers::も参照。

     *注意：*` ' `create-file-buffer'は、
     新たなバッファをファイルに対応付け_ない_し、
     当該バッファを選択しない。 デフォルトのメジャーモードも使わない。

          (create-file-buffer "foo")
               => #<buffer foo>
          (create-file-buffer "foo")
               => #<buffer foo<2>>
          (create-file-buffer "foo")
               => #<buffer foo<3>>

     この関数は`find-file-noselect'で使われる。
     この関数は`generate-new-buffer'（*note Creating Buffers::）を使う。

 -- Function: after-find-file &optional error warn
     この関数は、バッファのメジャーモードを設定し、
     ローカル変数を解析する（*note Auto Major Mode::）。
     `find-file-noselect'や デフォルトの復元処理関数（*note
     Reverting::）から呼ばれる。

     ディレクトリはあるのにファイルが存在しないために
     ファイルの読み込みがエラーになった場合には、
     呼び出し側はERRORの値として`nil'以外を渡すこと。
     その場合、`after-find-file'は警告`(New File)'を表示する。
     より重大なエラーの場合には、`after-find-file'を呼び出すべきでない。

     WARNが`nil'以外であると、
     自動保存ファイルが存在しそれが訪問したファイルより新しい場合には、
     この関数は警告を発する。

     `after-find-file'が最後に行うことは、
     リスト`find-file-hooks'内のすべての関数を呼び出すことである。


File: elisp-ja,  Node: Saving Buffers,  Next: Reading from Files,  Prev: Visiting Files,  Up: Files

24.2 バッファの保存
==========================

Emacsでファイルを編集するときには、
ファイルを訪問したバッファを実際には扱っています。
つまり、ファイルの内容はバッファにコピーされ、
そのコピーを編集しているのです。
バッファを変更しても、当該バッファを"保存"（save）するまで、
つまり、バッファの内容をファイルへコピーするまでは、
ファイルを変更しません。

 -- コマンド: save-buffer &optional backup-option
     この関数は、最後に訪問／保存してからカレントバッファが変更されていれば、
     カレントバッファの内容を訪問しているファイルへ保存する。

     `save-buffer'は、バックアップの作成に責任がある。
     通常、BACKUP-OPTIONは`nil'であり、
     `save-buffer'は、ファイルを訪問してから
     最初に保存するときにのみバックアップファイルを作成する。
     BACKUP-OPTIONが別の値であると、
     別の場面でもバックアップファイルを作成することを指示する。

        * 引数が1つか3つの`C-u'を反映した4か64であると、
          関数`save-buffer'は、バッファをつぎに保存したときに
          ファイルの現在の版をバックアップするように印を付ける。

        * 引数が2つか3つの`C-u'を反映した16か64であると、
          `save-buffer'は、保存するまえに無条件に
          ファイルのまえの版をバックアップする。

 -- コマンド: save-some-buffers &optional save-silently-p exiting
     このコマンドは、ファイルを訪問している変更されたバッファを保存する。
     通常、各バッファについてユーザーに問い合わせる。
     しかし、SAVE-SILENTLY-Pが`nil'以外であると、
     ユーザーに問い合わせずにファイルを訪問しているバッファをすべて保存する。

     省略可能な引数EXITINGが`nil'以外であると、
     この関数は、ファイルを訪問していないある種のバッファを保存する機会も与える。
     `buffer-offer-save'のバッファローカルな値が
     `nil'以外のバッファが対象となる。
     （ユーザーがこれらのバッファの1つを保存するように答えると、
     ファイル名を指定するように聞いてくる。）
     関数`save-buffers-kill-emacs'は、 この引数に`nil'以外の値を渡す。

 -- コマンド: write-file filename
     この関数は、カレントバッファをファイルFILENAMEに保存し、
     当該ファイルを訪問しているバッファとし、さらに未変更という印を付ける。
     続いて、バッファ名を一意にするために必要ならば`<2>'のような
     文字列を付加して、バッファをFILENAMEに基づいた名前に改名する。
     この処理のほとんどは、`set-visited-file-name'（*note Buffer File
     Name::） と`save-buffer'を呼び出して行う。

   バッファを保存すると、いくつかのフックを実行します。
また、書式変換（*note Format Conversion::）を行い、
テキスト属性を『注記』（annotations）（*note Saving Properties::）に
保存することもあります。

 -- Variable: write-file-hooks
     この変数の値は、バッファを訪問しているファイルに書き出すまえに
     呼ばれる関数のリストである。
     それらの1つが`nil'以外を返すと、すでにファイルに書き出したとみなして
     残りの関数を呼び出さず、ファイルに書き出すための通常のコードも実行しない。

     `write-file-hooks'の関数が`nil'以外を返すときには、
     その関数には（必要ならば）バックアップファイルを作成する責任がある。
     そのためにはつぎのコードを実行する。

          (or buffer-backed-up (backup-buffer))

     `backup-buffer'が返したファイルモードの値を保存しておき、
     読者が書くファイルのモードにその値を使いたい場合がある。
     `save-buffer'は通常そのようにする。

     `write-file-hooks'のフック関数は、
     （必要ならば）データの符号化にも責任がある。
     適切なコーディングシステム（*note Lisp and Coding
     Systems::）を選び、 符号化（*note Explicit Encoding::）を行い、
     使用したコーディングシステムを`last-coding-system-used'に設定する
     （*note Encoding and I/O::）。

     この変数をバッファローカルにはしないこと。
     バッファ固有のフック関数を指定するには、
     かわりに`write-contents-hooks'を使う。

     これはノーマルフックではないが、
     `add-hook'と`remove-hook'でリストを扱える。 *note Hooks::。

 -- Variable: local-write-file-hooks
     これは`write-file-hooks'のように働くが、
     特定のバッファにバッファローカルにするように意図してあり、
     ファイル名に関するフックやバッファ内容を得た方法に関する
     フックとして使われる。

     変数は恒久的にバッファローカルと印が付いているので、
     メジャーモードを変更してもバッファローカルな値は変更されない。
     これは、『ファイル』の内容を特別な方法で読み込み、
     対応した方法でデータを保存するフックを設定するようなパッケージには便利である。

 -- Variable: write-contents-hooks
     この変数は`write-file-hooks'のように働くが、
     ファイルの場所に関するフックではなく、
     ファイルの内容に関するフックであると意図されている。
     そのようなフックは、この変数のバッファローカルな束縛として
     メジャーモードが通常設定する。

     この変数に設定すると自動的にバッファローカルになる。
     このフックに要素を追加するために`add-hooks'を使うときには、
     引数LOCALに`nil'以外を指定し_ない_こと。
     この変数はバッファローカル_のみ_であるからである。

 -- Variable: after-save-hook
     このノーマルフックは、バッファを訪問したファイルに
     保存し終えてから実行される。
     このフックの用途の1つは高速ロック（fast-lock）モードである。
     このフックを使って強調表示情報をキャッシュファイルに保存する。

 -- Variable: file-precious-flag
     この変数が`nil'以外ならば、
     `save-buffer'は保存処理中の入出力エラーに備えて対処する。
     つまり、目的の名前のファイルにではなく一時的な名前の新規ファイルに書き出し、
     エラーがないことを確認してから目的の名前に改名する。
     これにより、不正なファイルに起因する問題からディスク容量の不足といった
     問題を回避できる。

     副作用として、バックアップも必然的にコピーして行う。 *note Rename
     or Copy::。
     それと同時に、大事な（precious）ファイルとして保存すると、
     読者が保存したファイルと別のファイル名とのあいだの
     ハードリンクをつねに切ってしまう。

     特定のバッファではこの変数に`nil'以外のバッファローカルな値を
     指定するモードもある。

 -- User Option: require-final-newline
     この変数は、改行で終ら_ない_ファイルを書き出すかどうかを決定する。
     この変数の値が`t'であると、`save-buffer'は、
     保存するバッファが改行で終っていないと黙ってファイルの末尾に改行を追加する。
     この変数の値が`t'ではない`nil'以外であると、
     `save-buffer'は、必要な場面では
     改行を追加するかどうかユーザーに問い合わせる。

     この変数の値が`nil'であると、`save-buffer'は改行を追加しない。
     デフォルト値は`nil'であるが、特定のバッファでは`t'に
     設定するメジャーモードもある。

   関数`set-visited-file-name'（*note Buffer File Name::）も
参照してください。


File: elisp-ja,  Node: Reading from Files,  Next: Writing to Files,  Prev: Saving Buffers,  Up: Files

24.3 ファイルの読み込み
================================

関数`insert-file-contents'を使って
ディスクからファイルをバッファへコピーできます。
ユーザーレベルのコマンド`insert-file'はマークを設定するので
Lispプログラムでは使わないでください。

 -- Function: insert-file-contents filename &optional visit beg end
          replace
     この関数は、ファイルFILENAMEの内容をカレントバッファの
     ポイントのうしろに挿入する。
     絶対ファイル名と挿入したデータの長さから成るリストを返す。
     FILENAMEが読み込めるファイルの名前でないと、エラーを通知する。

     関数`insert-file-contents'は、
     ファイルの内容を定義済みのファイルの書式と比較し、
     必要ならばファイルの内容を変換する。 *note Format Conversion::。
     リスト`after-insert-file-functions'の関数も呼び出す。 *note Saving
     Properties::を参照。

     VISITが`nil'以外であると、 この関数はバッファを未変更と印を付け、
     ファイルFILENAMEを訪問しているバッファとなるように
     バッファのさまざまな部分を設定する。
     これには、バッファが訪問しているファイルの名前、ファイル更新時刻を含む。
     この機能は`find-file-noselect'で使われており、
     読者自身が使うことはないであろう。

     BEGとENDが`nil'以外であると、
     それらは挿入すべきファイルの部分を指定する整数であること。
     この場合、VISITは`nil'であること。 たとえば、

          (insert-file-contents filename nil 0 500)

     はファイルの最初の500文字を挿入する。

     引数REPLACEが`nil'以外であると、
     バッファの内容（実際には参照可能な部分のみ）を
     ファイルの内容で置き換えることを意味する。
     これは、単純にバッファの内容を削除してからファイル全体を挿入するより
     好ましい。 なぜなら、（1）マーカ位置を保存できる場合がある、
     （2）アンドゥリストにほとんどデータを入れない、からである。

     REPLACEとVISITが`nil'である限り、
     `insert-file-contents'で（FIFOや入出力装置などの）
     特別なファイルを読むことも可能である。

 -- Function: insert-file-contents-literally filename &optional visit
          beg end replace
     この関数は`insert-file-contents'のように動作するが、
     書式を変換しない（*note Format Conversion::）、
     文字コードを変換しない（*note Coding Systems::）、
     `find-file-hooks'を実行しない、自動的に解凍しないなどが異なる。

   別のプログラムが読めるようにファイル名を別のプロセスに渡すには、
関数`file-local-copy'を使います。 *note Magic File
Names::を参照してください。


File: elisp-ja,  Node: Writing to Files,  Next: File Locks,  Prev: Reading from Files,  Up: Files

24.4 ファイルへの書き出し
===================================

関数`append-to-file'や`write-region'を使って、
バッファの内容やその一部をディスク上のファイルへ直接書き出せます。
訪問しているファイルには、これらの関数で書き出さないでください。
訪問の機構に混乱をきたすことがあります。

 -- コマンド: append-to-file start end filename
     この関数は、カレントバッファのSTARTからENDで
     区切られる領域の内容をファイルFILENAMEの末尾に追加する。
     当該ファイルが存在しなければ作成する。 この関数は`nil'を返す。

     書き込めないファイルをFILENAMEに指定したり、
     ファイルを作成できないディレクトリ上の存在しないファイルを
     FILENAMEに指定するとエラーを通知する。

 -- コマンド: write-region start end filename &optional append visit
          confirm
     この関数は、カレントバッファのSTARTからENDで
     区切られる領域の内容をFILENAMEで指定したファイルに書き出す。

     STARTが文字列であると、 `write-region'はバッファのテキストではなく
     その文字列を書いたり追加する。

     APPENDが`nil'以外であると、
     指定したテキストを既存ファイル（があれば）の内容に追加する。

     CONFIRMが`nil'以外であると、 FILENAMEが既存ファイルの名前であると
     `write-region'は確認を求める。

     VISITが`t'であると、 Emacsはバッファとファイルの対応を確立する。
     つまり、バッファはそのファイルを訪問していることになる。
     さらに、カレントバッファの最終ファイル更新時刻を
     FILENAMEの更新時刻にし、 バッファには未変更と印を付ける。
     この機能は`save-buffer'が使っているが、
     読者自身が使うことはないであろう。

     VISITが文字列であると、訪問するファイルの名前を指定する。
     このようにして、データを1つのファイル（FILENAME）に書き出す一方で、
     バッファは別のファイル（VISIT）を訪問していると設定できる。
     引数VISITはエコー領域のメッセージに使われ、
     ファイルのロックにも使われる。
     VISITは`buffer-file-name'に保存される。
     この機能は`file-precious-flag'の実装に使われているが、
     読者は、なにをしているか理解できない限り、この機能を使わないこと。

     関数`write-region'は、書き出すデータを
     `buffer-file-format'で指定される適切なファイル書式に変換する。
     *note Format Conversion::。
     さらに、リスト`write-region-annotate-functions'の関数も呼び出す。
     *note Saving Properties::を参照。

     通常、`write-region'はエコー領域にメッセージ `Wrote
     FILENAME'を表示する。 VISITが`t'でも`nil'でも文字列でもないと、
     このメッセージは表示しない。 この機能は、ユーザーが知る必要のない
     内部目的にファイルを使うプログラムに有用である。

 -- Macro: with-temp-file file body...
     マクロ`with-temp-file'は、一時的なバッファをカレントバッファとして
     フォームBODYを評価する。
     そして最後にバッファの内容をファイルFILEに書き出す。
     終了すると一時的なバッファを削除し、
     フォーム`with-temp-file'のまえにカレントバッファであったバッファに戻る。
     BODYの最後のフォームの値を返す。

     `throw'やエラーによる異常終了（*note Nonlocal Exits::）であっても
     カレントバッファに戻る。

     *note Current Buffer::の`with-temp-buffer'も参照。


File: elisp-ja,  Node: File Locks,  Next: Information about Files,  Prev: Writing to Files,  Up: Files

24.5 ファイルロック
==========================

2人のユーザーが同時に同じファイルを編集すると、互いに干渉し合います。
Emacsは、ファイルが変更されると"ファイルロック"（file lock）を
記録することで、このような状況が発生しないように努めます。
すると、Emacsは別のEmacsがロックしているファイルを訪問した
バッファを変更しようとする最初の試みを検出でき、
ユーザーにどうすべきかを問い合わせます。

   複数の計算機がファイルシステムを共有している場合には、
ファイルロックには完全な信頼性はありません。
ファイルロックが働かないと、
2人のユーザーが同時に変更する可能性がありますが、
それでも、Emacsは2番目に保存したユーザーに警告できます。
また、ディスク上で変更されたファイルを訪問しているバッファの変更を
検出することで、同時編集のある場面を捕捉できます。 *note Modification
Time::を参照してください。

 -- Function: file-locked-p filename
     ファイルFILENAMEがロックされていなければ、この関数は`nil'を返す。
     このEmacsプロセスがロックしているときには`t'を返す。
     他のEmacsがロックしている場合には、ロックしているユーザーの名前を返す。

          (file-locked-p "foo")
               => nil

 -- Function: lock-buffer &optional filename
     この関数は、カレントバッファが変更されていれば
     ファイルFILENAMEをロックする。 引数FILENAMEのデフォルトは、
     カレントバッファで訪問しているファイルである。
     カレントバッファがファイルを訪問していなかったり、
     未変更ならばなにもしない。

 -- Function: unlock-buffer
     この関数は、バッファが変更されていれば、
     カレントバッファで訪問しているファイルのロックを解除する。
     バッファが未変更ならばファイルをロックしていないはずであり、
     この関数はなにもしない。
     カレントバッファがファイルを訪問していなければ、
     やはりなにもしない。

 -- Function: ask-user-about-lock file other-user
     この関数は、別のユーザーOTHER-USERがロックしている
     ファイルFILEをユーザーが変更しようとしたときに呼び出される。
     この関数のデフォルトの定義は、ユーザーになにをすべきか
     問い合わせることである。
     この関数の戻り値がEmacsのつぎの動作を決定する。

        * 値が`t'であると、ファイルのロックを取得することを意味する。
          すると、このユーザーはファイルを編集でき、
          別のユーザーOTHER-USERはロックを失う。

        * 値が`nil'であると、ロックを無視して
          とにかくユーザーにファイルの編集を許す。

        * この関数はエラー`file-locked'を通知する。
          この場合、ユーザーが行おうとしていた変更は行われない。

          このエラーのエラーメッセージはつぎのようである。

               error--> File is locked: FILE OTHER-USER

          ここで、`file'はファイル名であり、
          OTHER-USERはそのファイルをロックしているユーザー名である。

     読者は、関数`ask-user-about-lock'を
     別の方法で決定する読者独自のものに置き換えてもよい。
     通常の定義に対応したコードは`userlock.el'にある。


File: elisp-ja,  Node: Information about Files,  Next: Changing Files,  Prev: File Locks,  Up: Files

24.6 ファイルに関する情報
===================================

本節に述べる関数はすべて、ファイル名を表す文字列に作用します。
すべての関数の名前は単語`file'で始まり、
それらの引数は、特に断らないかぎり、
既存のファイルやディレクトリである必要があります。

* Menu:

* Testing Accessibility::   Is a given file readable?  Writable?
* Kinds of Files::          Is it a directory?  A symbolic link?
* Truenames::		    Eliminating symbolic links from a file name.
* File Attributes::         How large is it?  Any other names?  Etc.


File: elisp-ja,  Node: Testing Accessibility,  Next: Kinds of Files,  Up: Information about Files

24.6.1 参照可能性の検査
-------------------------------

これらの関数は、特別な方法でファイル参照のパーミッションを検査します。

 -- Function: file-exists-p filename
     ファイルFILENAMEが存在すれば、この関数は`t'を返す。
     これは必ずしもファイルを読めることは意味せず、
     単にファイルの属性を調べられるだけである。
     （UNIXでは、ファイルが存在し、かつ、
     それを収めたディレクトリに対する実行パーミッションがあれば、
     ファイル自体のパーミッションに関係なくこのようになる。）

     ファイルが存在しなかったり、ファイルの属性を探す権限がなければ、
     この関数は`nil'を返す。

 -- Function: file-readable-p filename
     ファイルFILENAMEが存在しそれを読むことができるならば、
     この関数は`t'を返す。 さもなければ`nil'を返す。

          (file-readable-p "files.texi")
               => t
          (file-exists-p "/usr/spool/mqueue")
               => t
          (file-readable-p "/usr/spool/mqueue")
               => nil

 -- Function: file-executable-p filename
     ファイルFILENAMEが存在しそれを実行できるならば、
     この関数は`t'を返す。 さもなければ`nil'を返す。
     ファイルがディレクトリである場合、実行パーミッションは、
     ディレクトリ内のファイルの存在やその属性を検査でき、
     それらのファイルのモードが許せばオープンできることを意味する。

 -- Function: file-writable-p filename
     ファイルFILENAMEに書き出したり作成できるならば、
     この関数は`t'を返し、さもなければ`nil'を返す。
     ファイルに書き出せるのは、ファイルが存在し書ける場合である。
     作成できるのは、ファイルは存在しないが
     指定したディレクトリが存在しそのディレクトリに書ける場合である。

     以下の3番目の例では、`foo'の親ディレクトリが存在しないので、
     たとえディレクトリを作成できるとしても`foo'は書けない。

          (file-writable-p "~/foo")
               => t
          (file-writable-p "/foo")
               => nil
          (file-writable-p "~/no-such-dir/foo")
               => nil

 -- Function: file-accessible-directory-p dirname
     ディレクトリDIRNAMEの既存ファイルをオープンするパーミッションがあれば、
     この関数は`t'を返す。
     さもなければ（あるいは当該ディレクトリが存在しなければ）`nil'を返す。
     DIRNAMEの値はディレクトリ名である。

     例：` 'つぎの例では、

          (file-accessible-directory-p "/foo")
               => nil

     から、`/foo/'内のファイルを読もうとすると
     エラーになると推論できる。

 -- Function: access-file filename string
     この関数は、ファイルFILENAMEを読むためにオープンし、
     クローズしてから`nil'を返す。
     しかし、オープンに失敗するとSTRINGをエラーメッセージのテキストとした
     エラーを通知する。

 -- Function: file-ownership-preserved-p filename
     もしファイルFILENAMEを削除して改めて作成しても
     ファイルの所有者が変更されなければ、この関数は`t'を返す。

 -- Function: file-newer-than-file-p filename1 filename2
     ファイルFILENAME1がFILENAME2より新しければ、 この関数は`t'を返す。
     FILENAME1が存在しなければ`nil'を返す。
     FILENAME2が存在しなければ`t'を返す。

     以下の例で、ファイル`aug-19'は19日に書かれ、
     ファイル`aug-20'は20日に書かれ、
     ファイル`no-file'は存在しないと仮定する。

          (file-newer-than-file-p "aug-19" "aug-20")
               => nil
          (file-newer-than-file-p "aug-20" "aug-19")
               => t
          (file-newer-than-file-p "aug-19" "no-file")
               => t
          (file-newer-than-file-p "no-file" "aug-19")
               => nil

     `file-attributes'を使って、
     2つの数から成るリストとしてファイルの最終更新時刻を取得できる。
     *note File Attributes::。


File: elisp-ja,  Node: Kinds of Files,  Next: Truenames,  Prev: Testing Accessibility,  Up: Information about Files

24.6.2 ファイルの種類の区別
-------------------------------------

本節ではさまざまな種類のファイル、つまり、
ディレクトリ、シンボリックリンク、普通のファイルを区別する方法を
説明します。

 -- Function: file-symlink-p filename
     ファイルFILENAMEがシンボリックリンクであると、
     関数`file-symlink-p'は当該リンクが指すファイルの名前を返す。
     これは、テキストファイル、ディレクトリ、別のシンボリックリンク、
     存在しないファイルの名前のいずれかである。

     ファイルFILENAMEがシンボリックリンクでない
     （あるいは当該ファイルが存在しない）場合、
     `file-symlink-p'は`nil'を返す。

          (file-symlink-p "foo")
               => nil
          (file-symlink-p "sym-link")
               => "foo"
          (file-symlink-p "sym-link2")
               => "sym-link"
          (file-symlink-p "/bin")
               => "/pub/bin"


 -- Function: file-directory-p filename
     ファイルFILENAMEが既存ディレクトリの名前であると`t'を返し、
     さもなければ`nil'を返す。

          (file-directory-p "~rms")
               => t
          (file-directory-p "~rms/lewis/files.texi")
               => nil
          (file-directory-p "~rms/lewis/no-such-file")
               => nil
          (file-directory-p "$HOME")
               => nil
          (file-directory-p
           (substitute-in-file-name "$HOME"))
               => t

 -- Function: file-regular-p filename
     ファイルFILENAMEが存在しそれが普通のファイル
     （ディレクトリでもシンボリックリンクでも名前付きパイプでも
     端末でもその他の入出力装置でもない）であれば、
     この関数は`t'を返す。


File: elisp-ja,  Node: Truenames,  Next: File Attributes,  Prev: Kinds of Files,  Up: Information about Files

24.6.3 実名
-------------

ファイルの"実名"（truename）とは、
シンボリックリンクをすべて辿り尽くしてから、 要素として現れる`.' や`..'
を簡略化して得られる名前です。
厳密にいえば、ファイルが一意の実名を持つ必要はありません。
ファイルの異なる実名の個数は、当該ファイルに対するハードリンクの個数に
等しいのです。
それでも、実名はシンボリックリンクによる名前の変動を取り除くため、
実名は有用です。

 -- Function: file-truename filename
     関数`file-truename'はファイルFILENAMEの実名を返す。
     これはシンボリックリンクをすべて辿り尽くして得られる名前である。
     引数は絶対ファイル名であること。

   関連情報については、*Note Buffer File Name::。


File: elisp-ja,  Node: File Attributes,  Prev: Truenames,  Up: Information about Files

24.6.4 ファイルに関する他の情報
-------------------------------------------

本節では、ファイルの内容以外の詳しい情報を得るための関数を説明します。
この情報には、参照パーミッションを制御するモードビット、
所有者とグループの番号、名前の個数、iノード番号、サイズ、
参照時刻と更新時刻が含まれます。

 -- Function: file-modes filename
     この関数はFILENAMEのモードビットを整数で返す。
     モードビットはファイルのパーミッションとも呼ばれ、
     UNIX流の参照制御を指定する。
     最下位ビットが1であると、当該ファイルはすべてのユーザーが実行でき、
     2番目の下位ビットが1であると、当該ファイルはすべてのユーザーが書ける
     といった具合である。

     戻り値の最大値は4095（8進数7777）であり、これは、
     だれもが読み／書き／実行でき、
     所有者とグループの両者にビットSUIDが設定してあり、
     スティッキービットも設定されていることを意味する。

          (file-modes "~/junk/diffs")
               => 492               ; 10進整数
          (format "%o" 492)
               => "754"             ; 8進数に変換

          (set-file-modes "~/junk/diffs" 438)
               => nil

          (format "%o" 438)
               => "666"             ; 8進数に変換

          % ls -l diffs
            -rw-rw-rw-  1 lewis 0 3063 Oct 30 16:00 diffs

 -- Function: file-nlinks filename
     この関数は、ファイルFILENAMEの
     名前（つまりハードリンク）の個数を返す。
     ファイルが存在しなければ、この関数は`nil'を返す。
     シンボリックリンクはそれが指すファイルの名前とはみなさないので、
     シンボリックリンクはこの関数には効果を持たない。

          % ls -l foo*
          -rw-rw-rw-  2 rms       4 Aug 19 01:27 foo
          -rw-rw-rw-  2 rms       4 Aug 19 01:27 foo1

          (file-nlinks "foo")
               => 2
          (file-nlinks "doesnt-exist")
               => nil

 -- Function: file-attributes filename
     この関数はファイルFILENAMEの属性のリストを返す。
     オープンできないファイルを指定すると`nil'を返す。

     リストの要素は順につぎのとおりである。

       0. ディレクトリは`t'、
          シンボリックリンクは（それが指す名前の）文字列、
          テキストファイルは`nil'である。

       1. ファイルの名前の個数。 別の名前、つまり、
          ハードリンクは関数`add-name-to-file'（*note Changing Files::）
          を使って作成する。

       2. ファイルのUID（所有者番号）。

       3. ファイルのGID（グループ番号）。

       4. 2つの整数から成るリストとしての最終参照時刻。
          最初の整数は時刻の上位16ビットであり、2番目は下位16ビット。
          （これは`current-time'の値と同様。 *note Time of
          Day::を参照。）

       5. 2つの整数から成るリストとしての最終更新時刻（上記と同様）。

       6.
          2つの整数から成るリストとしての最終状態更新時刻（上記と同様）。

       7. バイト単位でのファイルのサイズ。

       8. `ls -l'と同様のファイルのモードを表す10文字の文字列。

       9. もしファイルを削除して再度作成した場合に
          ファイルのGID（グループ番号）が変わる場合には`t'。
          さもなければ`nil'。

      10. ファイルのiノード番号。 可能ならばこれは整数である。
          iノード番号がEmacs
          Lispの整数として表現できないほど大きな場合、 値は`(HIGH .
          LOW)'の形である。 ただし、LOWは下位16ビットである。

      11. ファイルが置いてあるファイルシステムのファイルシステム番号。
          この要素とファイルのiノード番号により、
          システム上の任意の2つのファイルを区別するために十分な情報を与える。
          つまり、2つのファイルが同じ値のこれらの番号を持つことはない。

     たとえば、`files.texi'のファイル属性はつぎのようである。

          (file-attributes "files.texi")
               =>  (nil 1 2235 75
                    (8489 20284)
                    (8489 20284)
                    (8489 20285)
                    14906 "-rw-rw-rw-"
                    nil 129500 -32252)

     この意味はつぎのとおりである。

    `nil'
          ディレクトリでもシンボリックリンクでもない。

    `1'
          唯一の名前（カレントディレクトリで`files.texi'）を持つ。

    `2235'
          UID（ユーザー番号）2235のユーザーが所有している。

    `75'
          GID（グループ番号）75のグループに属する。

    `(8489 20284)'
          最後に参照されたのは8月19日00時09分である。

    `(8489 20284)'
          最後に更新されたのは8月19日00時09分である。

    `(8489 20285)'
          最後にこのiノードを変更したのは8月19日00時09分である。

    `14906'
          長さは14906バイトである。

    `"-rw-rw-rw-"'
          モードは、所有者／グループ／その他は読み書きできる。

    `nil'
          再度作成してもGID（グループ番号）は保存される。

    `129500'
          iノード番号は129500。

    `-32252'
          ファイルシステム番号は-32252。


File: elisp-ja,  Node: Changing Files,  Next: File Names,  Prev: Information about Files,  Up: Files

24.7 ファイルの名前と属性の変更
============================================

本節の関数は、ファイルを改名／コピー／削除／リンクしたり、
ファイルのモードを設定するためのものです。

   引数NEWNAMEをとる関数では、 NEWNAMEで指定したファイルが既存の場合、
関数の動作は引数OK-IF-ALREADY-EXISTSの値に依存します。

   * OK-IF-ALREADY-EXISTSが`nil'であると、
     エラー`file-already-exists'を通知する。

   * OK-IF-ALREADY-EXISTSが数であると、確認を必要とする。

   * OK-IF-ALREADY-EXISTSがそれ以外の値であると、
     確認せずに古いファイルを置き換える。

 -- Function: add-name-to-file oldname newname &optional
          ok-if-already-exists
     この関数は、OLDNAMEで指定したファイルに 追加の名前NEWNAMEを与える。
     つまり、NEWNAMEはOLDNAMEへの新たな『ハードリンク』になる。

     つぎの例では、2つのファイル`foo'と`foo3'がある。

          % ls -li fo*
          81908 -rw-rw-rw-  1 rms       29 Aug 18 20:32 foo
          84302 -rw-rw-rw-  1 rms       24 Aug 18 20:31 foo3

     `add-name-to-file'を呼んでハードリンクを作成し、
     ファイル一覧を表示し直す。
     1つのファイルに2つの名前`foo'と`foo2'があることがわかる。

          (add-name-to-file "foo" "foo2")
               => nil

          % ls -li fo*
          81908 -rw-rw-rw-  2 rms       29 Aug 18 20:32 foo
          81908 -rw-rw-rw-  2 rms       29 Aug 18 20:32 foo2
          84302 -rw-rw-rw-  1 rms       24 Aug 18 20:31 foo3

     最後につぎの式を評価し

          (add-name-to-file "foo" "foo3" t)

     ファイル一覧を表示し直す。
     今度は、1つのファイルに3つの名前`foo'、`foo2'、`foo3'がある。
     古い`foo3'の内容は失われている。

          (add-name-to-file "foo1" "foo3")
               => nil

          % ls -li fo*
          81908 -rw-rw-rw-  3 rms       29 Aug 18 20:32 foo
          81908 -rw-rw-rw-  3 rms       29 Aug 18 20:32 foo2
          81908 -rw-rw-rw-  3 rms       29 Aug 18 20:32 foo3

     1つのファイルに複数の名前を許さないオペレーティングシステムでは、
     この関数は意味がない。

     *note File Attributes::の`file-nlinks'も参照。

 -- コマンド: rename-file filename newname &optional
          ok-if-already-exists
     このコマンドは、ファイルFILENAMEをNEWNAMEと改名する。

     FILENAMEにFILENAME以外の名前があれば、 それらの名前は存在し続ける。
     実際、`add-name-to-file'で名前NEWNAMEを追加してから
     FILENAMEを削除すると、一時的な中間状態があることを除けば、
     改名と同じ効果がある。

     対話的に呼び出されると、この関数は
     ミニバッファでFILENAMEとNEWNAMEを聞く。
     また、NEWNAMEが既存であると確認を求める。

 -- コマンド: copy-file oldname newname &optional ok-if-exists time
     このコマンドはファイルOLDNAMEをNEWNAMEへコピーする。
     OLDNAMEが存在しないとエラーを通知する。

     TIMEが`nil'以外であると、
     この関数は新たなファイルに古いファイルと同じ最終更新時刻を与える。
     （これは特定のオペレーティングシステムでのみ動作する。）
     時刻設定でエラーがあると、`copy-file'は
     エラー`file-date-error'を通知する。

     対話的に呼び出されると、この関数は
     ミニバッファでOLDNAMEとNEWNAMEを聞く。
     また、NEWNAMEが既存であると確認を求める。

 -- コマンド: delete-file filename
     このコマンドは、シェルコマンド`rm FILENAME'と同様に
     ファイルFILENAMEを削除する。
     ファイルに複数の名前があると、他の名前では存在し続ける。

     ファイルが存在しなかったり削除できないと、
     エラー`file-error'の適切な種類が通知される。
     （UNIXでは、ファイルを収めたディレクトリに書けると
     当該ファイルは削除可能である。）

     *note Create/Delete Dirs::の`delete-directory'も参照。

 -- コマンド: make-symbolic-link filename newname &optional ok-if-exists
     このコマンドは、FILENAMEに対するシンボリックリンクNEWNAMEを
     作成する。 これはシェルコマンド`ln -s FILENAME
     NEWNAME'と同じである。

     対話的に呼び出されると、この関数は
     ミニバッファでFILENAMEとNEWNAMEを聞く。
     また、NEWNAMEが既存であると確認を求める。

 -- Function: define-logical-name name string
     この関数は論理名NAMEに値STRINGを定義する。 VMSでのみ使える。

 -- Function: set-file-modes filename mode
     この関数はFILENAMEのモードビットを
     MODE（整数であること）と設定する。 MODEの下位12ビットのみを使う。

 -- Function: set-default-file-modes mode
     この関数は、Emacsやそのサブプロセスが作成する新規ファイルの
     デフォルトのファイルモードを設定する。
     Emacsが作成する各ファイルは最初このモードになる。
     UNIXでは、デフォルトのモードは『umask』の値の1の補数である。

     引数MODEは整数であること。
     ほとんどのシステムでは、MODEの下位9ビットのみが意味を持つ。

     既存ファイルの変更を保存することはファイルの作成とはみなさないため、
     ファイルのモードは変わらず、デフォルトのファイルモードを使わない。

 -- Function: default-file-modes
     この関数は、現在のデフォルトのファイルモードの値を返す。

MS-DOSでは、『実行可能』ファイルモードビットのようなものはありません。
そのためEmacsは、`.com'、`.bat'、`.exe'のいずれかで
終る名前のファイルを実行可能であるとみなします。
これは、`file-modes'や`file-attributes'が返す値に反映されます。


File: elisp-ja,  Node: File Names,  Next: Contents of Directories,  Prev: Changing Files,  Up: Files

24.8 ファイル名
====================

他の場面と同様にEmacsでは、一般にファイルはその名前で参照します。
Emacsではファイル名は文字列で表します。
ファイルを操作する関数はすべてファイル名引数を仮定します。

   ファイル自体の操作に加えて、Emacs Lispプログラムは
ファイルの名前そのものを操作する必要があります。
つまり、ファイル名を分解したり、関連するファイル名を作成するために
その一部を使います。 本節ではファイル名を操作する方法を説明します。

   本節の関数は実際にはファイルを参照しませんから、
既存のファイルやディレクトリを表さないファイル名を操作できます。

   VMSでは、これらの関数はすべて、VMSのファイル名構文と
UNIXの構文の両方を理解します。
つまり、標準LispライブラリはUNIX構文でファイル名を指定でき、
変更せずにVMS上で正しく動作します。
MS-DOSやMS-Windowsでは、これらの関数は、
UNIX構文に加えてMS-DOSやMS-Windowsのファイル名構文を理解します。

* Menu:

* File Name Components::  The directory part of a file name, and the rest.
* Directory Names::       A directory's name as a directory
                            is different from its name as a file.
* Relative File Names::   Some file names are relative to a current directory.
* File Name Expansion::   Converting relative file names to absolute ones.
* Unique File Names::     Generating names for temporary files.
* File Name Completion::  Finding the completions for a given file name.
* Standard File Names::   If your package uses a fixed file name,
                            how to handle various operating systems simply.


File: elisp-ja,  Node: File Name Components,  Next: Directory Names,  Up: File Names

24.8.1 ファイル名の構成要素
-------------------------------------

オペレーティングシステムは、一連のファイルをディレクトリにまとめます。
ファイルを指定するには、ディレクトリと当該ディレクトリ内のファイルの名前を
指定する必要があります。 そのためEmacsは、ファイル名には2つの部分、
"ディレクトリ名"（directory name）部分と
"非ディレクトリ名"（nondirectory name）部分
（つまり"ディレクトリ内のファイル名"）があるとみなします。
どちらかの部分は空でもかまいません。
これらの2つの部分を連結するともとのファイル名になります。

   UNIXでは、ディレクトリ部分は最後のスラッシュまでを含んだ部分であり、
非ディレクトリ部分は残りの部分です。 VMSの構文規則は複雑です。

   ある種の目的のために、非ディレクトリ部分をさらに
名前だけの部分と"版番号"（version number）に分けます。
UNIXでは、バックアップファイルだけにそれらの名前に版番号があります。
VMSでは各ファイルに版番号がありますが、
ほとんどの場合、Emacsで実際に使うファイル名では版番号を省略します。
そのため、Emacsで版番号が見えるのは多くの場合ディレクトリ一覧です。

 -- Function: file-name-directory filename
     この関数はFILENAMEのディレクトリ部分
     （ディレクトリ部分がなければ`nil'）を返す。
     UNIXでは、この関数はスラッシュで終る文字列を返す。
     VMSでは、`:'、`]'、`>'のいずれかで終る文字列を返す。

          (file-name-directory "lewis/foo")  ; UNIXの例
               => "lewis/"
          (file-name-directory "foo")        ; UNIXの例
               => nil
          (file-name-directory "[X]FOO.TMP") ; VMSの例
               => "[X]"

 -- Function: file-name-nondirectory filename
     この関数はFILENAMEの非ディレクトリ部分を返す。

          (file-name-nondirectory "lewis/foo")
               => "foo"
          (file-name-nondirectory "foo")
               => "foo"
          ;; つぎの例はVMSでのみ正確である
          (file-name-nondirectory "[X]FOO.TMP")
               => "FOO.TMP"

 -- Function: file-name-sans-versions filename
     この関数は、FILENAMEから版番号、バックアップ版番号、
     末尾のティルダをすべて削除したものを返す。

          (file-name-sans-versions "~rms/foo.~1~")
               => "~rms/foo"
          (file-name-sans-versions "~rms/foo~")
               => "~rms/foo"
          (file-name-sans-versions "~rms/foo")
               => "~rms/foo"
          ;; つぎの例はVMSでのみ正確である
          (file-name-sans-versions "foo;23")
               => "foo"

 -- Function: file-name-sans-extension filename
     この関数は、FILENAMEからあれば『拡張子』を除いたものを返す。
     ファイル名の拡張子とは、
     名前の最後の部分にある`.'で始まる部分である。
     たとえばつぎのとおりである。

          (file-name-sans-extension "foo.lose.c")
               => "foo.lose"
          (file-name-sans-extension "big.hack/foo")
               => "big.hack/foo"


File: elisp-ja,  Node: Directory Names,  Next: Relative File Names,  Prev: File Name Components,  Up: File Names

24.8.2 ディレクトリ名
----------------------------

"ディレクトリ名"（directory name）とはディレクトリの名前です。
ディレクトリはファイルの一種であり、ファイル名を持ちますが、
それはディレクトリ名に関連付けられますが同一ではありません。
（これはUNIXの通常の用語と同じではない。）
同じものに対するこれらの異なる2つの名前は、構文の変換で関連付けます。
UNIXではこれは簡単であり、ディレクトリ名はスラッシュで終りますが、
ファイルとしてのディレクトリの名前にはスラッシュはありません。
VMSでは、関係はより複雑です。

ディレクトリ名とそのファイルとしての名前との違いはわずかですが重大です。
Emacsの変数や関数引数がディレクトリ名と記述されているときには、
ディレクトリのファイルとしての名前は受け付けません。

つぎの2つの関数はディレクトリ名とファイルとしての名前を相互に変換します。
これらは、`$HOME'などの環境変数置換や
`~'や`..'などの構造にはなにも特別なことはしません。

 -- Function: file-name-as-directory filename
     この関数は、オペレーティングシステムが
     ディレクトリ名と解釈する表現で表したFILENAMEの文字列を返す。
     UNIXでは、文字列に（最後にスラッシュがなければ）スラッシュを
     付加することを意味する。
     VMSでは、`[X]Y.DIR.1'の形の文字列を`[X.Y]'の形に変換する。

          (file-name-as-directory "~rms/lewis")
               => "~rms/lewis/"

 -- Function: directory-file-name dirname
     この関数は、オペレーティングシステムが
     ファイルの名前と解釈する表現で表したDIRNAMEの文字列を返す。
     UNIXでは、文字列の最後のスラッシュを取り除くことを意味する。
     VMSでは、`[X.Y]'の形の文字列を`[X]Y.DIR.1'の形に変換する。

          (directory-file-name "~lewis/")
               => "~lewis"

   シンボリックリンクを介して通常参照されるディレクトリには
ディレクトリ名の省略形が有用です。
ユーザーはリンクの名前をディレクトリの『名前』としばしばみなし、
ディレクトリの『本当の』名前を見るのをわずらわしく思うことがあります。
リンク名を『本当の』名前の省略形と定義しておくと、
Emacsはユーザーに省略形を表示します。

 -- Variable: directory-abbrev-alist
     変数`directory-abbrev-alist'は、
     ディレクトリに使う省略形の連想リストを保持する。 各要素は`(FROM .
     TO)'の形であり、
     ディレクトリ名にFROMが現れるとこれをTOに置き換えることを指示する。
     文字列FROMは実際には正規表現であり、つねに`^'で始まること。
     関数`abbreviate-file-name'がこれらの置換を行う。

     ファイル`site-init.el'でこの変数に設定し、
     読者のサイトに適した省略形を記述できる。

     ファイルシステム`/home/fsf'などをシンボリック名`/fsf'で通常参照する
     システムの例をつぎに示す。

          (("^/home/fsf" . "/fsf")
           ("^/home/gp" . "/gp")
           ("^/home/gd" . "/gd"))

   ディレクトリ名をその省略形に変換するには、つぎの関数を使います。

 -- Function: abbreviate-file-name dirname
     この関数は、`directory-abbrev-alist'の省略形を引数に適用し、
     ユーザーのホームディレクトリを`~'に置き換える。


File: elisp-ja,  Node: Relative File Names,  Next: File Name Expansion,  Prev: Directory Names,  Up: File Names

24.8.3 ファイルの絶対名と相対名
-------------------------------------------

ファイルシステム内のすべてのディレクトリは、
ルートディレクトリから始まる木を形作ります。
ファイル名では、木のルートから始まるすべてのディレクトリ名を指定できて、
これを"絶対"（absolute）ファイル名と呼びます。
あるいは、デフォルトディレクトリを基準に
木の中でのファイルの位置を指定することもでき、
これを"相対"（relative）ファイル名と呼びます。
UNIXでは、絶対ファイル名はスラッシュかティルダ（`~'）で始まり、
相対ファイル名はそれらでは始まりません。 VMSでの規則は複雑です。

 -- Function: file-name-absolute-p filename
     この関数は、ファイルFILENAMEが絶対ファイル名であれば`t'を返し、
     さもなければ`nil'を返す。
     VMS上では、この関数はUNIXの構文とVMSの構文の両方を理解する。

          (file-name-absolute-p "~rms/foo")
               => t
          (file-name-absolute-p "rms/foo")
               => nil
          (file-name-absolute-p "/user/rms/foo")
               => t


File: elisp-ja,  Node: File Name Expansion,  Next: Unique File Names,  Prev: Relative File Names,  Up: File Names

24.8.4 ファイル名を展開する関数
-------------------------------------------

ファイル名の"展開"（expansion）とは、
相対ファイル名を絶対ファイル名に変換することです。
これはデフォルトディレクトリを基準に行うので、
展開すべきファイル名に加えて、デフォルトディレクトリの名前も
指定する必要があります。
また、展開では、`./'や`NAME/../'のような冗長部分を
取り除いてファイル名を単純にします。

 -- Function: expand-file-name filename &optional directory
     この関数はFILENAMEを絶対ファイル名に変換する。
     DIRECTORYが与えられると、 FILENAMEが相対ファイル名であれば、
     デフォルトディレクトリを基準にする。
     （DIRECTORYの値そのものは絶対ディレクトリ名であること。
     `~'で始まってもよい。）
     さもなければ、バッファの`default-directory'の値を使う。
     たとえばつぎのとおり。

          (expand-file-name "foo")
               => "/xcssun/users/rms/lewis/foo"
          (expand-file-name "../foo")
               => "/xcssun/users/rms/foo"
          (expand-file-name "foo" "/usr/spool/")
               => "/usr/spool/foo"
          (expand-file-name "$HOME/foo")
               => "/xcssun/users/rms/lewis/$HOME/foo"

     `.'や`..'を含むファイル名は、それらの正則な形に単純化する。

          (expand-file-name "bar/../foo")
               => "/xcssun/users/rms/lewis/foo"

     `expand-file-name'は環境変数を展開_しない_ことに注意。
     `substitute-in-file-name'だけがそれを行う。

 -- Function: file-relative-name filename directory
     この関数は展開の逆操作を行う。 つまり、DIRECTORYを基準に解釈すると
     FILENAMEと等価になる相対名を返す。

     絶対ファイル名が装置名で始まるシステムもある。
     そのようなシステムでは、DIRECTORYとFILENAMEが
     2つの異なる装置名で始まると、
     FILENAMEに等価なDIRECTORYを基準にした相対名はない。
     そのような場合、`file-relative-name'は 絶対名の形でFILENAMEを返す。

          (file-relative-name "/foo/bar" "/foo/")
               => "bar"
          (file-relative-name "/foo/bar" "/hack/")
               => "/foo/bar"

 -- Variable: default-directory
     このバッファローカルな変数の値は、
     カレントバッファのデフォルトディレクトリである。
     これは絶対ディレクトリ名であること。 `~'で始まってもよい。
     この変数は各バッファにおいてバッファローカルである。

     `expand-file-name'は、その第2引数が`nil'であると
     デフォルトディレクトリを使う。

     UNIXでは、この値はつねにスラッシュで終る文字列である。

          default-directory
               => "/user/lewis/manual/"

 -- Function: substitute-in-file-name filename
     この関数は、FILENAME内の環境変数の参照を 環境変数の値で置き換える。
     UNIXのシェルの構文規則に従って、
     `$'は環境変数の値に置換するための接頭辞である。

     環境変数名は、`$'に続く（下線を含む）英数字の列である。
     `$'のつぎの文字が`{'であると、 対応する`}'までが変数名である。

     ここでは、環境変数`HOME'はユーザーのホームディレクトリ名
     `/xcssun/users/rms'を保持していると仮定する。

          (substitute-in-file-name "$HOME/foo")
               => "/xcssun/users/rms/foo"

     置換後、`/'のつぎに`~'か`/'が現れると、
     `/'までの部分をすべて取り除く。

          (substitute-in-file-name "bar/~/foo")
               => "~/foo"
          (substitute-in-file-name "/usr/local/$HOME/foo")
               => "/xcssun/users/rms/foo"
               ;; `/usr/local/' has been discarded.

     VMSでは、`$'による置換は行わないため、
     この関数は冗長部分を取り除く以外にはなにも行わない。


File: elisp-ja,  Node: Unique File Names,  Next: File Name Completion,  Prev: File Name Expansion,  Up: File Names

24.8.5 一意なファイル名の生成
----------------------------------------

一時的なファイルに書く必要があるプログラムもあります。
そのようなファイル向けの名前を作る通常の方法はつぎのとおりです。

     (make-temp-name
      (expand-file-name NAME-OF-APPLICATION
                        temporary-file-directory))

`make-temp-name'の仕事は、
異なる2人のユーザーや異なる2つのジョブがまったく同じファイル名を
使わないようにすることです。
この例では、変数`temporary-file-directory'を使って
一時的なファイルを置く場所を決めています。 すべてのEmacs
Lispプログラムでは、
すべての一時的なファイル向けのディレクトリを指定する
一意な方法をユーザーに提供するために、
この目的には`temporary-file-directory'を使うべきです。

 -- Function: make-temp-name string
     この関数は、一意なファイル名として使える文字列を生成する。
     名前はSTRINGで始まり、各Emacsジョブごとに異なる数を含む。

          (make-temp-name "/tmp/foo")
               => "/tmp/foo232J6v"

     同じEmacsで動作している異なるライブラリのあいだで衝突しないように、
     `make-temp-name'を使う各Lispプログラムでは、
     独自のSTRINGを使うべきである。 STRINGの末尾に付加される数は、
     異なるEmacsジョブで動いている同じアプリケーションを区別する。
     文字を余計に追加することで、1つのEmacsジョブであっても
     異なる名前の個数を非常に多くできる。

 -- Variable: temporary-file-directory
     この変数は、一時的なファイルを作成するためのディレクトリ名を指定する。
     その値はディレクトリ名（*note Directory Names::）であるべきだが、
     Lispプログラムにとっては、
     その値がディレクトリのファイルとしての名前であっても処理できるほうがよい。
     この値を`expand-file-name'の第2引数に使うと、 そのようにできる。

     デフォルト値は、読者のオペレーティングシステムにおいて
     合理的な方法で決定される。
     GNUとUNIXシステムでは、環境変数`TMP'や`TMPDIR'を基にする。

     読者が一時的なファイル名を選ぶために`make-temp-name'を
     使わない場合であっても、
     一時的なファイル名を置くディレクトリを決めるために
     この変数を使うべきである。


File: elisp-ja,  Node: File Name Completion,  Next: Standard File Names,  Prev: Unique File Names,  Up: File Names

24.8.6 ファイル名の補完
-------------------------------

本節では、ファイル名の補完向けの低レベルのサブルーティンについて述べます。
他の補完関数については、*note Completion::を参照してください。

 -- Function: file-name-all-completions partial-filename directory
     この関数は、ディレクトリDIRECTORYにおいて
     PARTIAL-FILENAMEで始まる名前のファイルに対する
     すべての補完候補から成るリストを返す。
     候補の順番はディレクトリ内でのファイルの順番であり、
     それは予測できず有用な情報はなにもない。

     引数PARTIAL-FILENAMEは、ディレクトリ部分やスラッシュを
     いっさい含まないファイル名であること。 DIRECTORYが絶対名でないと、
     カレントバッファのデフォルトディレクトリをDIRECTORYのまえに補う。

     つぎの例で、カレントデフォルトディレクトリは`~rms/lewis'であり、
     `f'で始まる名前のファイルは、
     `foo'、`file~'、`file.c'、`file.c.~1~'、
     `file.c.~2~'の5つであると仮定する。

          (file-name-all-completions "f" "")
               => ("foo" "file~" "file.c.~2~"
                          "file.c.~1~" "file.c")

          (file-name-all-completions "fo" "")
               => ("foo")

 -- Function: file-name-completion filename directory
     この関数は、ディレクトリDIRECTORYにおいてファイル名FILENAMEを
     補完する。 ディレクトリDIRECTORYにおいてFILENAMEで始まる
     すべてのファイル名に共通な最長の文字列を返す。

     FILENAMEで始まるものがたった1つであり完全に一致すると、
     この関数は`t'を返す。
     ディレクトリDIRECTORYにFILENAMEで始まる名前がないと `nil'を返す。

     つぎの例で、カレントデフォルトディレクトリには
     `f'で始まる名前のファイルは、
     `foo'、`file~'、`file.c'、`file.c.~1~'、
     `file.c.~2~'の5つであると仮定する。

          (file-name-completion "fi" "")
               => "file"

          (file-name-completion "file.c.~1" "")
               => "file.c.~1~"

          (file-name-completion "file.c.~1~" "")
               => t

          (file-name-completion "file.c.~3" "")
               => nil

 -- User Option: completion-ignored-extensions
     `file-name-completion'は、このリスト内のいずれかの文字列で終る
     名前のファイルを通常無視する。
     補完候補すべてがこれらの接頭辞の1つで終る場合や、
     補完候補すべてを含んだバッファが表示されている場合には無視しない。

     典型的な値はつぎのとおりである。

          completion-ignored-extensions
               => (".o" ".elc" "~" ".dvi")


File: elisp-ja,  Node: Standard File Names,  Prev: File Name Completion,  Up: File Names

24.8.7 標準ファイル名
----------------------------

Lispプログラムで使われるほとんどのファイル名は、
ユーザーが入力したものです。 しかし、Lispプログラムでは、
特定目的の標準ファイル名を指定する必要がある場合があります。
典型的には、各ユーザーごとのカスタマイズ情報を保持するものです。
たとえば、省略形の定義は（デフォルトでは）
ファイル`~/.abbrev_defs'に保存されます。 パッケージ`completion'は、
補完情報をファイル`~/.completions'に保存します。
これらは、Emacsで特定目的に使われる多くの標準ファイル名のうちの2つです。

   さまざまなのオペレーティングシステムには、
正しいファイル名やユーザーのプロフィールデータに使うファイル名に
独自の慣習があります。
標準ファイル名を使用するファイルを読み込むLispプログラムでは、
各システムごとに当該システムに適したファイル名を使うべきです。
関数`convert-standard-filename'は、これを簡単にします。

 -- Function: convert-standard-filename filename
     この関数は、ファイル名FILENAMEを使用しているオペレーティングシステム
     の慣習に従うように変換し、新たな文字列として結果を返す。

   Lispプログラムにおいて標準ファイル名を指定する推奨方法は、
GNUとUNIXシステムの慣習に従った名前を選ぶことです。
つまり、ピリオドで始まる非ディレクトリ部分を選び、
それを直接使うかわりに`convert-standard-filename'に渡します。
パッケージ`completion'からの例をつぎに示します。

     (defvar save-completions-file-name
             (convert-standard-filename "~/.completions")
       "*The file name to save completions to.")

   GNUとUNIXシステム、および、他のいくつかのシステムでは、
`convert-standard-filename'は引数を未変更で返します。
別のシステムでは、システムの慣習に従うように名前を変更します。

   たとえば、MS-DOSではこの関数は、先頭の`.'を`_'に、
`.'がどこにもなければ名前の途中の`_'を`.'に、
8文字目のうしろに`.'がなければ`.'を挿入し、
`.'以降の3文字よりうしろを切り詰めるなどを行います。
（これ以外にも変更する。）
したがって、`.abbrev_defs'は`_abbrev.def'となり、
`.completions'は`_complet.ion'となります。


File: elisp-ja,  Node: Contents of Directories,  Next: Create/Delete Dirs,  Prev: File Names,  Up: Files

24.9 ディレクトリの内容
================================

ディレクトリは、さまざまな名前で入れた別のファイルを
収めているファイルの一種です。
ディレクトリは、ファイルシステムの機能です。

   Emacsは、ディレクトリ内のファイル名をLispのリストとして一覧にしたり、
シェルコマンド`ls'を使ってバッファに名前を表示できます。
後者の場合、コマンド`ls'に渡したオプションに応じて、
各ファイルに関する情報も表示できます。

 -- Function: directory-files directory &optional full-name
          match-regexp nosort
     この関数は、ディレクトリDIRECTORY内の
     ファイルの名前から成るリストを返す。
     デフォルトでは、リストはアルファベット順になる。

     FULL-NAMEが`nil'以外であると、
     関数はファイルの絶対ファイル名を返す。
     さもなければ、指定したディレクトリに対する相対名を返す。

     MATCH-REGEXPが`nil'以外であると、
     この関数は正規表現MATCH-REGEXPに一致するファイル名のみを返す。
     つまり、他の名前のファイルはリストから除かれる。

     NOSORTが`nil'以外であると、
     `directory-files'はリストをソートしないので、
     ファイル名の順番に規則はない。
     処理速度を最大にしてファイルの処理順序に拘らないならば、これを用いる。
     処理順序がユーザーに見える場合には、
     ソートしたほうがユーザーは幸せであろう。

          (directory-files "~lewis")
               => ("#foo#" "#foo.el#" "." ".."
                   "dired-mods.el" "files.texi"
                   "files.texi.~1~")

     DIRECTORYが読めないディレクトリの名前であるとエラーを通知する。

 -- Function: file-name-all-versions file dirname
     この関数は、ディレクトリDIRNAME内のFILEという名前の
     ファイルのすべての版から成るリストを返す。

 -- Function: insert-directory file switches &optional wildcard
          full-directory-p
     この関数は、`ls'にSWITCHESを渡して表示した
     ディレクトリFILEの一覧を（カレントバッファに）挿入する。
     ポイントは挿入したテキストのうしろに置かれる。

     引数FILEは、ディレクトリ名であるか
     ワイルドカードを含んだファイル指定である。
     WILDCARDが`nil'以外であると、
     FILEをワイルドカードを含むファイル指定として扱う。

     FULL-DIRECTORY-Pが`nil'以外であると、
     ディレクトリ一覧はディレクトリの全内容を表すと仮定することを意味する。
     FILEがディレクトリでありSWITCHESに`-d'を含まない場合には、
     `t'を指定すべきである。 （`ls'のオプション`-d'は、
     ディレクトリの内容ではなく、ファイルとしてのディレクトリ自身を
     表示することを意味する。）

     この関数は、変数`insert-directory-program'で指定される
     名前のディレクトリ表示プログラムを実行して動作する。
     WILDCARDが`nil'以外であると、
     ワイルドカードを展開するために`shell-file-name'で指定される
     シェルを実行する。

 -- Variable: insert-directory-program
     この変数の値は、関数`insert-directory'で
     ディレクトリ一覧を生成するために実行するプログラムである。


File: elisp-ja,  Node: Create/Delete Dirs,  Next: Magic File Names,  Prev: Contents of Directories,  Up: Files

24.10 ディレクトリの作成と削除
==========================================

Emacs Lispのほとんどのファイル操作関数は、
ディレクトリであるファイルに使うとエラーになります。
たとえば、`delete-file'ではディレクトリを削除できません。
これらの特別な関数はディレクトリを作成したり削除するためのものです。

 -- Function: make-directory dirname
     この関数はDIRNAMEという名前のディレクトリを作る。

 -- Function: delete-directory dirname
     この関数は、ディレクトリDIRNAMEを削除する。
     関数`delete-file'は、ディレクトリであるファイルには使えない。
     ディレクトリには`delete-directory'を使う必要がある。
     ディレクトリ内にファイルがあると、`delete-directory'は
     エラーを通知する。


File: elisp-ja,  Node: Magic File Names,  Next: Format Conversion,  Prev: Create/Delete Dirs,  Up: Files

24.11 ファイル名を『マジック』にする
===================================================

特定のファイル名を特別に扱うことができます。
これをそれらの名前を"マジック"（magic）にするといいます。
この機能の主な用途はリモートファイル名 （*note リモートファイル:
(emacs)Remote Files.） を実装することです。

   マジックファイル名の種類を定義するには、
名前のクラス（正規表現に一致するものすべて）を定義する正規表現と、
それに一致するファイルに対する
Emacsの基本ファイル操作を実装するハンドラを指定する必要があります。

   変数`file-name-handler-alist'は、
ハンドラと当該ハンドラの適用を決定する正規表現からなるリストを保持します。
各要素の形はつぎのとおりです。

     (REGEXP . HANDLER)

Emacsのすべてのファイル操作基本関数とファイル名変換基本関数は、
指定された名前を`file-name-handler-alist'に対して検査します。
ファイル名がREGEXPに一致すると、
基本関数はHANDLERを呼び出して当該ファイルを処理します。

   HANDLERに与える最初の引数は基本関数の名前です。
残りの引数は当該操作に渡されるべき引数です。
（それらの引数の最初のものは典型的にはファイル名自身である。）
たとえば、つぎのようにした場合、

     (file-exists-p FILENAME)

FILENAMEにハンドラHANDLERがあると、
HANDLERはつぎのように呼び出されます。

     (funcall HANDLER 'file-exists-p FILENAME)

   つぎは、マジックファイル名のハンドラが処理すべき操作です。

`add-name-to-file'、`copy-file'、`delete-directory'、 `delete-file'、
`diff-latest-backup-file'、 `directory-file-name'、 `directory-files'、
`dired-call-process'、 `dired-compress-file'、`dired-uncache'、
`expand-file-name'、 `file-accessible-directory-p'、
`file-attributes'、 `file-directory-p'、
`file-executable-p'、`file-exists-p'、
`file-local-copy'、 `file-modes'、`file-name-all-completions'，
`file-name-as-directory'、 `file-name-completion'、
`file-name-directory'、 `file-name-nondirectory'、
`file-name-sans-versions'、`file-newer-than-file-p'、
`file-ownership-preserved-p'、
`file-readable-p'、`file-regular-p'、`file-symlink-p'、
`file-truename'、`file-writable-p'、 `find-backup-file-name'、
`get-file-buffer'、
`insert-directory'、 `insert-file-contents'、 `load', `make-directory'、
`make-symbolic-link'、`rename-file'、`set-file-modes'、
`set-visited-file-modtime'、`shell-command'、
`unhandled-file-name-directory'、 `vc-registered'、
`verify-visited-file-modtime'、
`write-region'。

   `insert-file-contents'に対するハンドラは、
引数VISITが`nil'以外であるときには `(set-buffer-modified-p nil)'を使って
バッファの変更フラグをクリアする必要が典型的にはあります。

   ハンドラ関数は、上のすべての操作、ならびに、
将来追加されるものを扱える必要があります。
これらの操作すべてをハンドラ自身で実装する必要はありません。
特定の操作について特別なことを行う必要がなければ、
『通常どおりに』操作を処理するために基本関数を再起動できます。
ハンドラが認識できない操作については、 基本関数を再起動するべきです。
1つの方法はつぎのとおりです。

     (defun my-file-handler (operation &rest args)
       ;; まず、特別に扱う必要がある操作かどうか検査する
       (cond ((eq operation 'insert-file-contents) ...)
             ((eq operation 'write-region) ...)
             ...
             ;; 知らない操作を扱う
             (t (let ((inhibit-file-name-handlers
                       (cons 'my-file-handler
                             (and (eq inhibit-file-name-operation operation)
                                  inhibit-file-name-handlers)))
                      (inhibit-file-name-operation operation))
                  (apply operation args)))))

ハンドラ関数で、指定された操作についてはEmacsの通常の基本関数を呼び出すと
決定したときには、基本関数から同じハンドラが再度呼ばれて
無限再帰になることを防ぐ必要があります。
上の例は、変数`inhibit-file-name-handlers'と
`inhibit-file-name-operation'を使ってこれを行う方法を示すものです。
それらを上に示したとおりに使うように注意してください。
複数のハンドラがあったり、
2つのファイルを扱う操作において各ファイルにハンドラがある場合には、
この詳細は重要です。

 -- Variable: inhibit-file-name-handlers
     この変数は、特定操作については
     現在適用を禁止されているハンドラのリストを保持する。

 -- Variable: inhibit-file-name-operation
     特定のハンドラにおいて現在禁止されている操作。

 -- Function: find-file-name-handler file operation
     この関数はファイル名FILEに対するハンドラ関数を返す。
     ハンドラがなければ`nil'を返す。
     引数OPERATIONは、ファイルに対して適用する操作であること。
     つまり、ハンドラを呼び出すときに第1引数として渡される値。
     当該操作は`inhibit-file-name-operation'と比較する必要がある。

 -- Function: file-local-copy filename
     この関数は、ファイルFILENAMEがマジックでない普通のファイルでなければ、
     FILENAMEをマジックでない普通のファイルにコピーする。

     FILENAMEが、
     Emacsの外側のプログラムからは直接読んだり書けないマジックファイル名であると、
     この関数は普通のファイルにコピーしてそのファイルの名前を返す。

     FILENAMEが普通のファイル名でマジックでなければ、
     この関数はなにもせずに`nil'を返す。

 -- Function: unhandled-file-name-directory filename
     この関数は、マジックではないディレクトリの名前を返す。
     FILENAMEがマジックでなければ、 FILENAMEのディレクトリ部分を使う。
     マジックファイル名であると、ファイル名ハンドラを起動し、
     当該ハンドラがどんな値を返すか決定する。

     これは実行中のサブプロセスに有用である。
     各サブプロセスには、カレントディレクトリとしてマジックでないディレクトリが
     必要であり、この関数はそれを扱うのによい方法である。


File: elisp-ja,  Node: Format Conversion,  Prev: Magic File Names,  Up: Files

24.12 ファイル書式変換
==============================

変数`format-alist'は、
Emacsバッファ内のデータ（テキスト、テキスト属性、その他の情報）を
ファイル内でテキスト表現する方法を記述した "ファイル書式"（file
format）のリストを定義します。
Emacsはファイルを読み書きするときに必要ならば書式変換を行います。

 -- Variable: format-alist
     このリストは、各ファイル書式の定義を含んだリストである。

   各書式定義はつぎの形のリストです。

     (NAME DOC-STRING REGEXP FROM-FN TO-FN MODIFY MODE-FN)

   書式定義の各要素の意味はつぎのとおりです。

NAME
     当該書式の名前。

DOC-STRING
     当該書式の説明文字列。

REGEXP
     当該書式で表現されたファイルを認識するために使用する正規表現。

FROM-FN
     当該書式のデータを復号化（ファイル内のデータをEmacsの通常のデータ表現へ
     変換）するためのシェルコマンドか関数。

     シェルコマンドは文字列で表現し、
     Emacsは変換を行うために当該コマンドをフィルタとして実行する。

     FROM-FNが関数であると、
     バッファの変換すべき部分を指定するBEGINとENDの2つの引数で
     呼ばれる。 当該関数はその場で編集してテキストを変換すること。
     これによりテキストの長さが変わる可能性があるので、
     FROM-FNは変更部分の末尾位置を返すこと。

     FROM-FNの責任の1つは、
     ファイルの先頭がREGEXPで始まらないように保証することである。
     さもないと、再度呼び出される可能性がある。

TO-FN
     当該書式にデータを符号化するためのシェルコマンドか関数。
     つまり、Emacsの通常のデータ表現を当該書式に変換する。

     TO-FNが文字列であるとそれはシェルコマンドであり、
     Emacsは変換を行うために当該コマンドをフィルタとして実行する。

     TO-FNが関数であると、
     バッファの変換すべき部分を指定するBEGINとENDの2つの引数で
     呼ばれる。 変換を行うには2つの方法がある。

        * その場でバッファを編集する。
          この場合、TO-FNは変更したテキスト範囲の終了位置を返すこと。

        * 注記のリストを返す。 このリストは、`(POSITION .
          STRING)'の形の要素から成り、
          POSITIONは書き出すべきテキスト内での相対位置を指定する整数、
          STRINGはそこに追加すべき注記である。
          TO-FNがリストを返すときには、
          リストはPOSITIONの順にソートしてあること。

          `write-region'がバッファからファイルへ実際に書き出すとき、
          指定された注記を対応する位置に埋め込む。
          これらすべては、バッファを変更せずに行われる。

MODIFY
     フラグであり、 符号化関数がバッファを変更する場合には`t'、
     注記のリストを返す場合には`nil'である。

MODE
     当該書式から変換されたファイルを訪問後に呼び出されるモード関数。

   関数`insert-file-contents'は、指定されたファイルを読み込むときに
ファイル書式を自動的に認識します。
ファイルの先頭のテキストを書式定義の正規表現に対して検査して、
一致がみつかれば当該書式の復号化関数を呼び出します。
そして、既知の書式について再度調べ直します。
適用できる書式がなくなるまで検査し続けます。

   関数`find-file-noselect'やこれを使うコマンドでファイルを訪問すると、
（`insert-file-contents'を呼び出すので）同様に変換を行います。
さらに、この関数は、復号した各書式についてモード関数を呼び出します。
バッファローカルな変数`buffer-file-format'に
書式名のリストを保存します。

 -- Variable: buffer-file-format
     この変数は、訪問したファイルの書式を記述している。
     より正確には、カレントバッファのファイルを訪問する過程で
     復号したファイル書式名のリストである。
     この変数は、すべてのバッファにおいてつねにバッファローカルである。

   `write-region'がデータをファイルに書き出すときには、まず、
`buffer-file-format'で指定された書式の符号化関数を
リストに現れる順に呼び出します。

 -- コマンド: format-write-file file format
     このコマンドは、カレントバッファの内容を書式FORMATにて
     ファイルFILEに書き出す。
     さらに、当該書式をバッファを将来保存するときのデフォルトとする。
     引数FORMATは、書式名のリストである。

 -- コマンド: format-find-file file format
     このコマンドは、ファイルFILEを探し、
     それを書式FORMATに従って変換する。
     さらに、当該書式をバッファをのちに保存するときのデフォルトとする。

     引数FORMATは、書式名のリストである。
     FORMATが`nil'であると、変換を行わない。 対話的に呼び出した場合、
     FORMATに`nil'を指定するには<RET>のみを打つ。

 -- コマンド: format-insert-file file format &optional beg end
     このコマンドは、ファイルFILEの内容を書式FORMATに従って
     変換して挿入する。 BEGとENDが`nil'以外であると、
     それらは、`insert-file-contents'（*note Reading from
     Files::）と同様に、 読み込むべきファイルの部分を指定する。

     戻り値は、`insert-file-contents'が返す値に似ており、
     絶対ファイル名と挿入データの（変換後の）長さのリストである。

     引数FORMATは、書式名のリストである。
     FORMATが`nil'であると、変換を行わない。 対話的に呼び出した場合、
     FORMATに`nil'を指定するには<RET>のみを打つ。

 -- Variable: auto-save-file-format
     この変数は、自動保存に対して使用する書式を指定する。
     その値は、`buffer-file-format'の値のように、書式名のリストであるが、
     `buffer-file-format'のかわりに
     自動保存ファイルを書くために使われる。
     この変数は、すべてのバッファにおいてつねにバッファローカルである。


File: elisp-ja,  Node: Backups and Auto-Saving,  Next: Buffers,  Prev: Files,  Up: Top

25 バックアップと自動保存 _(2003/10/30)_
***************************************************

バックアップファイルと自動保存ファイルは、
クラッシュやユーザー自身の誤りから
Emacsがユーザーを保護するための2つの方式です。
自動保存により、現在の編集セッションにおいて、
まえの時点でのテキストを確保します。
バックアップファイルにより、現在のセッション以前の
ファイル内容を確保します。

* Menu:

* Backup Files::   How backup files are made; how their names are chosen.
* Auto-Saving::    How auto-save files are made; how their names are chosen.
* Reverting::      `revert-buffer', and how to customize what it does.


File: elisp-ja,  Node: Backup Files,  Next: Auto-Saving,  Up: Backups and Auto-Saving

25.1 バックアップファイル _(2003/10/30)_
==================================================

"バックアップファイル"（backup file）とは、
読者が編集中のファイルの古い内容のコピーです。
バッファを訪問しているファイルに初めて保存するときに、
Emacsはバックアップファイルを作成します。
通常これは、バックアップファイルは
現在の編集セッションよりまえのファイルの内容を保持することを意味します。
バックアップファイルの内容は、通常、それが作られると変更されません。

   訪問したファイルを新たな名前に改名することで
通常バックアップは作られます。
訪問したファイルをコピーしてバックアップファイルを作るように
指示することもできます。
どちらを選ぶかによって、複数の名前を持つファイルでは違いがでます。
また、編集したファイルの所有者が元所有者と同じであるか、
それとも編集したユーザーが所有者になるかにも影響します。

デフォルトでは、Emacsは各編集ファイルに1つのバックアップファイルを作ります。
番号付きのバックアップファイルを作るように指示することもでき、
そうすると、新たなバックアップファイルごとに新たな名前が付きます。
古い番号付きバックアップファイルは必要なくなれば削除できますし、
Emacsがそれらを自動的に削除することも可能です。

* Menu:

* Making Backups::     How Emacs makes backup files, and when.
* Rename or Copy::     Two alternatives: renaming the old file or copying it.
* Numbered Backups::   Keeping multiple backups for each source file.
* Backup Names::       How backup file names are computed; customization.


File: elisp-ja,  Node: Making Backups,  Next: Rename or Copy,  Up: Backup Files

25.1.1 バックアップファイルの作成 _(2003/10/30)_
-------------------------------------------------------------

 -- Function: backup-buffer
     この関数は、必要ならば、カレントバッファで訪問しているファイルの
     バックアップを作成する。
     バッファを初めて保存するまえに`save-buffer'がこの関数を呼び出す。

 -- Variable: buffer-backed-up
     このバッファローカルな変数は、
     当該バッファのもとで当該バッファのファイルの
     バックアップを作成済みかどうかを表す。
     `nil'以外であれば、バックアップファイルは作成済みであることを表す。
     さもなければ、（バックアップがオンになっていれば）つぎに保存するときに
     ファイルのバックアップを作成するべきであることを表す。
     これは恒久的にバッファローカルであり、
     `kill-all-local-variables'によって変更されない。

 -- User Option: make-backup-files
     この変数は、バックアップファイルを作成するかどうかを決定する。
     `nil'以外であると、`backup-inhibited'が`nil'ならば（下記参照）
     Emacsは初めて保存するときに各ファイルのバックアップを作成する。

     つぎの例は、rmailのバッファでのみ変数`make-backup-files'を
     変更する方法である。 この変数を`nil'にすると、
     Emacsはそれらのファイルのバックアップを作成しなくなり、
     ディスクスペースの節約になる。
     （このコードを読者の設定ファイルに入れてもよい。）

          (add-hook 'rmail-mode-hook
                    (function (lambda ()
                                (make-local-variable
                                 'make-backup-files)
                                (setq make-backup-files nil))))

 -- Variable: backup-enable-predicate
     この変数の値は、ファイルをバックアップすべきかどうかを決定する
     ために特定の場面で呼び出される関数である。
     当該関数は、調べるべきファイルの名前を引数にとる。
     当該関数が`nil'を返すと、当該ファイルのバックアップは禁止である。
     さもなければ、本節の他の変数が、
     バックアップするかどうかやバックアップ方法を指定する。

     この変数のデフォルト値は`normal-backup-enable-predicate'であり、
     `temporary-file-directory' や `small-temporary-file-directory'
     にあるファイルを確認し、バックアッ プを行う。

 -- Variable: backup-inhibited
     この変数が`nil'以外であると、バックアップを禁止する。
     この変数は、訪問したファイルの名前に対する`backup-enable-predicate'の
     検査結果を記録している。
     訪問したファイルに基づいてバックアップを禁止する
     他の機構でもこの変数を使える。
     たとえば、VCはこの変数に`nil'以外を設定し、
     版管理システムで管理されているファイルに対してバックアップの作成を禁止する。

     これは恒久的にバッファローカルであり、
     メジャーモードを変更しても値は失われない。
     メジャーモードはこの変数に設定するべきではなく、
     かわりに、`make-backup-files'に設定するべきである。

 -- Variable: backup-directory-alist
     これはファイル名の正規表現とバックアップディレクトリの連想リストである。
     それぞれの要素は以下のようになる。
          (REGEXP . DIRECTORY)

     REGEXPに一致した名前を持つファイルのバックアップは
     DIRECTORYに保存される。DIRECTORYが相対パスか絶対パスである。
     絶対パスであれば、あるREGEXPに一致したファイルのバックアップはす
     べて同じディレクトリにできる。そして、そのバックアップファイルの名前は
     衝突を防ぐために、ディレクトリの区切り文字を`!'に変えたフルパスに
     なる。この方法はファイルシステムがファイル名を短縮して与える場合にはう
     まく動作しないだろう。

     すべてのバックアップが1つのディレクトリにできるようにするには、
     `"."'と適切なディレクトリのペアを持つ連想リストであればよい。

     この変数が`nil'かファイル名に一致しなかった場合には、バックアップ
     ファイルは元ファイルと同じディレクトリにできる。

     この変数は、MS-DOSのように長いファイル名に対応していないシステムでは無
     視される。

 -- Variable: make-backup-file-name-function
     この変数の値は関数名である。この関数はバックアップファイル名を作る関数
     であり、デフォルト関数 `make-backup-file-name' のかわりに使われる。
     nilであれば、`make-backup-file-name' と同じことになる。

     ある種のファイルでは特別な処理ができるように、この変数はバッファローカ
     ルになっている。もしこれを設定した場合には、`backup-file-name-p'
     や `file-name-sans-versions' の変更も必要となる場合がある。


File: elisp-ja,  Node: Rename or Copy,  Next: Numbered Backups,  Prev: Making Backups,  Up: Backup Files

25.1.2 改名によるバックアップかコピーによるバックアップか _(2003/10/30)_
-------------------------------------------------------------------------------------------------

Emacsは2つの方法でバックアップファイルを作れます。

   * Emacsは、元ファイルを改名してバックアップファイルとしてから、
     保存すべきバッファを新たなファイルに書き出す。
     この処理のあとでは、元ファイルの他の名前（つまりハードリンク）は
     バックアップファイルを指す。
     新たなファイルの所有者は編集しているユーザーになり、そのグループは
     当該ディレクトリでユーザーが新規にファイルを書いた場合のデフォルトである。

   * Emacsは元ファイルをバックアップファイルにコピーしてから、
     元ファイルを新たな内容で上書きする。
     この処理のあとでは、元ファイルの他の名前（つまりハードリンク）は
     ファイルの（更新した）現在の版を指し続ける。
     ファイルの所有者とグループは変わらない。

   最初の改名による方式がデフォルトです。

   変数`backup-by-copying'が`nil'以外であると、
2番目の方式、つまり、元ファイルをコピーしてから
バッファの新たな内容で上書きすることを指示します。
変数`file-precious-flag'が`nil'以外であっても
（その主目的の副作用として）同じ効果があります。 *Note Saving
Buffers::。

 -- Variable: backup-by-copying
     この変数が`nil'以外であると、
     Emacsはつねにコピーしてバックアップファイルを作る。

   つぎの2つの変数が`nil'以外であると、
特定の場面では2番目の方式を使うことになります。
これらの変数は、特別な場面に該当しないファイルの扱い方には影響しません。

 -- Variable: backup-by-copying-when-linked
     この変数が`nil'以外の場合、Emacsは、
     複数の名前（ハードリンク）を持つファイルはコピーしてバックアップする。

     この変数は`backup-by-copying'が`nil'以外の場合にのみ意味を持つ。
     というのは、その変数が`nil'以外の場合にコピーを用いるからである。

 -- Variable: backup-by-copying-when-mismatch
     この変数が`nil'以外の場合、Emacsは、
     改名するとファイルの所有者やグループを変更してしまう場合に
     コピーしてバックアップする。

     改名してもファイルの所有者やグループを変更しなければ、
     この値は効果を持たない。
     つまり、ユーザーが所有しているファイルであり、
     そのグループが当該ユーザーが新規作成するファイルのデフォルトに一致する
     場合である。

     この変数は`backup-by-copying'が`nil'以外の場合にのみ意味を持つ。
     というのは、その変数が`nil'以外の場合にコピーを用いるからである。

 -- Variable: backup-by-copying-when-privileged-mismatch
     この変数が`nil'でなければ、 `backup-by-copying-when-mismatch'
     と同じ動作になる。ただし、ある
     ユーザIDの値、すなわちある数以下のIDの場合に限られる。この変数には数整
     数を指定する。

     そうして、`backup-by-copying-when-privileged-mismatch' に0を設定
     すると、コピーによるバックアップはスーパーユーザで、ファイルの所有者の
     変更を破棄する必要がある時にのみ、コピーによるバックアップが行われる。

     デフォルトは200である。


File: elisp-ja,  Node: Numbered Backups,  Next: Backup Names,  Prev: Rename or Copy,  Up: Backup Files

25.1.3 番号付きバックアップファイルの作成と削除 _(2003/10/30)_
----------------------------------------------------------------------------------

ファイル名が`foo'であると、
その番号付きバックアップファイルの名前はVを整数として
`foo.~V~'となります。 つまり、`foo.~1~'、`foo.~2~'、`foo.~3~'、...、
`foo.~259~'といった具合です。

 -- User Option: version-control
     この変数は、番号なしの1つのバックアップファイルを作るのか
     複数の番号付きバックアップファイルを作るのかを制御する。

    `nil'
          訪問したファイルにすでに番号付きバックアップファイルがあれば
          番号付きバックアップを作る。 さもなければ作らない。

    `never'
          番号付きバックアップは作らない。

    ÁÁĻ
          番号付きバックアップを作る。

   番号付きバックアップファイルを使うと、
最終的には非常に多くのバックアップファイルができてしまい、
それらは削除しなければなりません。 Emacsはそれらを自動的に削除したり、
削除するかどうかユーザーに問い合わせることができます。

 -- User Option: kept-new-versions
     この変数の値は、新たに番号付きバックアップを作成したときに
     保存すべき最新のバックアップの個数である。
     新たに作成したバックアップも数える。 デフォルト値は2である。

 -- User Option: kept-old-versions
     この変数の値は、新たに番号付きバックアップを作成したときに
     保存すべき最古のバックアップの個数である。 デフォルト値は2である。

   1、2、3、5、7と番号が付いたバックアップがあり、
これらのどちらの変数の値も2であるとすると、
最古のものとして1と2の番号が付いたバックアップを保存し、
最新のものとして5と7の番号が付いたバックアップを保存する。
関数`find-backup-file-name'（*note Backup Names::）は、
どの番号のバックアップを削除すべきかを決定する責任があるが、
それ自身はそれらを削除しない。

 -- User Option: delete-old-versions
     この変数が`t'であると、
     ファイルを保存すると黙って範囲外のバックアップを削除する。`nil'
     であれば、それを削除するかどうかユーザーに問い合わせる。さもなければ、
     すべて削除されない。

 -- User Option: dired-kept-versions
     この変数は、diredのコマンド`.'（`dired-clean-directory'）で
     最新のバックアップを何個保存するかを指定する。
     これは、新たなバックアップファイルの作成を指示したときに
     `kept-new-versions'が指定することと同じである。
     デフォルト値は2である。


File: elisp-ja,  Node: Backup Names,  Prev: Numbered Backups,  Up: Backup Files

25.1.4 バックアップファイルの命名方法 _(2003/10/30)_
-------------------------------------------------------------------

本節の関数は、それらを再定義することでバックアップファイルの命名方法を
カスタマイズできるため、ここで述べることにします。
どれか1つを変更すると、残りのものも変更する必要があるでしょう。

 -- Function: backup-file-name-p filename
     この関数は、FILENAMEがバックアップファイルの名前である
     可能性があると`nil'以外の値を返す。
     FILENAMEという名前のファイルが存在する必要はなく、
     この関数は単に名前だけを検査する。

          (backup-file-name-p "foo")
               => nil
          (backup-file-name-p "foo~")
               => 3

     この関数の標準定義はつぎのとおりである。

          (defun backup-file-name-p (file)
            "Return non-nil if FILE is a backup file \
          name (numeric or not)..."
            (string-match "~\\'" file))

     したがって、ファイル名が`~'で終っていると、
     この関数は`nil'以外の値を返す。
     （説明文字列を2行に分けるためにバックスラッシュを使っているが、
     文字列としては1行になる。）

     カスタマイズのために再定義しやすいように、
     この単純な式を独立した関数にしてある。

 -- Function: make-backup-file-name filename
     この関数は、ファイルFILENAMEに対する
     番号なしバックアップファイルに使う名前を表す文字列を返す。
     UNIXでは、単にFILENAMEの末尾にティルダを付加したものである。

     ほとんどのオペレーティングシステムでは、
     この関数の標準定義はつぎのとおりである。

          (defun make-backup-file-name (file)
            "Create the non-numeric backup file name for FILE..."
            (concat file "~"))

     この関数を再定義すれば、バックアップファイルの命名方法を変更できる。
     つぎの例では、ティルダに加えて先頭に`.'を付けるように
     `make-backup-file-name'を再定義する。

          (defun make-backup-file-name (filename)
            (expand-file-name
              (concat "." (file-name-nondirectory filename) "~")
              (file-name-directory filename)))

          (make-backup-file-name "backups.texi")
               => ".backups.texi~"

     diredコマンドを含めてEmacsには、
     バックアップファイルは`~'で終ると仮定しているものがある。
     この慣習に従わない場合、重大な問題には至らないであろうが、
     それらのコマンドがあまり望ましくない結果をもたらすかもしれない。

 -- Function: find-backup-file-name filename
     この関数は、FILENAMEに対する新たなバックアップファイルの
     ファイル名を計算する。
     さらに、削除すべき既存のバックアップファイルも計算する。
     `find-backup-file-name'は、 CARに新たなバックアップファイルの名前、
     CDRに削除すべきバックアップファイルのリストを持つリストを返す。

     2つの変数、`kept-old-versions'と`kept-new-versions'は、
     どのバックアップを保存すべきかを決定する。
     この関数は、値のCDRではそれらのバックアップファイルは
     除外してある。 *note Numbered Backups::。

     つぎの例の値では、`~rms/foo.~5~'が
     新たなバックアップファイルの名前であり、
     `~rms/foo.~3~'が『範囲外』のものであり、
     呼び出し側で削除するかどうか考慮すべきである。

          (find-backup-file-name "~rms/foo")
               => ("~rms/foo.~5~" "~rms/foo.~3~")

 -- Function: file-newest-backup filename
     この関数は、FILENAMEの最新のバックアップファイルの名前を返す。
     当該ファイルにバックアップファイルがなければ`nil'を返す。

     ファイルを比較するコマンドのなかには、
     最新のバックアップファイルと自動的に比較できるように
     この関数を使うものがある。


File: elisp-ja,  Node: Auto-Saving,  Next: Reverting,  Prev: Backup Files,  Up: Backups and Auto-Saving

25.2 自動保存 _(2003/10/30)_
================================

Emacsは編集中のすべてのファイルを定期的に保存します。
これを"自動保存"（auto-savign）と呼びます。
自動保存により、システムがクラッシュしても、
一定量以上の作業を失わないようにします。
デフォルトでは、300打鍵ごと、あるいは、30秒間なにもしないと自動保存します。
ユーザー向けの自動保存に関する情報については、 *Note
自動保存、不慮の事故に対する備え: (emacs)Auto Save。
ここでは、自動保存を実装するための関数と
それらを制御する変数について述べます。

 -- Variable: buffer-auto-save-file-name
     このバッファローカルな変数は、カレントバッファの自動保存に
     用いるファイル名である。
     当該バッファを自動保存しない場合には`nil'である。

          buffer-auto-save-file-name
               => "/xcssun/users/rms/lewis/#backups.texi#"

 -- コマンド: auto-save-mode arg
      -- Command: auto-save-mode arg
          引数なしに対話的に呼ばれると、
          このコマンドは自動保存機能をトグルする。
          つまり、カレントバッファの自動保存がオンであるとオフにし、
          オフならばオンにする。 引数ARGを指定すると、
          ARGの値が`t'、空でないリスト、正整数のいずれかであれば、
          このコマンドは自動保存をオンにする。
          さもなければ自動保存をオフにする。

      -- Function: auto-save-file-name-p filename
          この関数は、FILENAMEが自動保存ファイルの名前であるならば、
          `nil'以外を返す。
          この関数は自動保存ファイルの通常の名前の慣習を仮定する。
          つまり、名前がハッシュマーク（`#'）で始まりかつ終っていれば、
          自動保存ファイルの名前である可能性があると判断する。
          ただし、引数FILENAMEにはディレクトリ部分を含まないこと。

               (make-auto-save-file-name)
                    => "/xcssun/users/rms/lewis/#backups.texi#"
               (auto-save-file-name-p "#backups.texi#")
                    => 0
               (auto-save-file-name-p "backups.texi")
                    => nil

          この関数の標準定義はつぎのとおりである。

               (defun auto-save-file-name-p (filename)
                 "Return non-nil if FILENAME can be yielded by..."
                 (string-match "^#.*#$" filename))

          この関数は、自動保存ファイルの名前の慣習を変更したい場合に
          当該関数をカスタマイズできるようにするためである。
          当該関数を再定義した場合には、関数`make-auto-save-file-name'も
          それに従って必ず再定義すること。

      -- Function: make-auto-save-file-name
          この関数は、カレントバッファの自動保存に使うファイル名を返す。
          その名前は、単にファイル名の前後にハッシュマーク（`#'）を
          付加するだけである。
          この関数は変数`auto-save-visited-file-name'（下記参照）を
          調べない。そのため、この関数を呼び出すような関数は、まずその変数を検査
          しておくべきである。

               (make-auto-save-file-name)
                    => "/xcssun/users/rms/lewis/#backup.texi#"

          この関数の標準定義はつぎのとおりである。

               (defun make-auto-save-file-name ()
                 "Return file name to use for auto-saves \
               of current buffer..."
                 (if buffer-file-name
                     (concat
                      (file-name-directory buffer-file-name)
                      "#"
                      (file-name-nondirectory buffer-file-name)
                      "#")
                   (expand-file-name
                    (concat "#%" (buffer-name) "#"))))

          自動保存ファイルの名前の慣習をカスタマイズするために
          関数を再定義できるように1つの関数にしてある。
          関数`auto-save-file-name-p'もそれに従って必ず変更すること。

      -- Variable: auto-save-visited-file-name
          この変数が`nil'以外であると、
          Emacsは訪問しているファイルにバッファを自動保存する。
          つまり、読者が編集しているファイルと同じファイルに自動保存を行う。
          通常、この変数は`nil'であり、自動保存ファイルには
          `make-auto-save-file-name'で作成した別の名前がある。

          この変数の値を変更しても、すでにあるバッファでは、
          バッファの自動保存をつぎにオンにするまで、新しい値は効果を発揮しない。
          自動保存がすでにオンであると、
          `auto-save-mode'を再度呼び出すまでは、
          同じファイルの名前に自動保存し続ける。

      -- Function: recent-auto-save-p
          カレントバッファに最後に読み込んだり保存してから以降に自動保存していると、
          この関数は`t'を返す。

      -- Function: set-buffer-auto-saved
          この関数は、カレントバッファに自動保存済みであると印を付ける。
          バッファのテキストが再度変更されない限り、バッファは自動保存されない。
          この関数は`nil'を返す。

      -- User Option: auto-save-interval
          この変数の値は、つぎの自動保存までに
          Emacsがキーボードから読み取る文字の個数である。
          これだけの文字を読み取るたびに、自動保存をオンにしてあるすべてのバッファを
          自動保存する。

      -- User Option: auto-save-timeout
          この変数の値は、自動保存を引き起こすまでのなにもしていない期間の秒数である。
          この時間だけユーザーがなにもしないと、
          Emacsは自動保存する必要があるすべてのバッファを自動保存する。
          （カレントバッファが大きい場合には、指定した時間にサイズに依存した係数
          を掛ける。これは100万バイトでおよそ4である）。

          この変数が0かnilの場合には、なにもしていなくても自動保存はさ

      -- Variable: auto-save-hook
          このノーマルフックは、自動保存を行う直前に毎回実行される。

      -- User Option: auto-save-default
          この変数が`nil'以外であると、
          ファイルを訪問しているバッファはデフォルトで自動保存をオンにする。
          さもなければ、そうしない。

      -- コマンド: do-auto-save &optional no-message current-only
          この関数は、自動保存する必要があるすべてのバッファを自動保存する。
          自動保存がオンになっていて、かつ、以前の自動保存からあとで
          変更されているすべてのバッファを自動保存する。

          通常、バッファを自動保存すると、
          自動保存を実行中にはエコー領域にメッセージ`Auto-saving...'が表示される。
          しかし、NO-MESSAGEが`nil'以外であると、
          メッセージを表示しない。

          CURRENT-ONLYが`nil'以外であると、
          カレントバッファのみを自動保存する。

      -- Function: delete-auto-save-file-if-necessary
          この関数は、`delete-auto-save-files'が`nil'以外であると、
          カレントバッファの自動保存ファイルを削除する。
          バッファを保存するたびに呼び出される。

      -- Variable: delete-auto-save-files
          この変数は、関数`delete-auto-save-file-if-necessary'が使う。
          `nil'以外であると、Emacsは（訪問しているファイルに）実際に
          保存すると自動保存ファイルを削除する。
          これによりディスクスペースを節約し、読者のディレクトリを整頓できる。

      -- Function: rename-auto-save-file
          この関数は、訪問しているファイルの名前が変更されていると、
          カレントバッファの自動保存ファイルの名前を修正する。
          さらに、既存の自動保存ファイルも改名する。
          訪問しているファイルの名前が変更されていなければ、
          この関数はなにもしない。

      -- Variable: buffer-saved-size
          このバッファローカルな変数の値は、
          最後に読み込んだり保存したり自動保存したときの
          カレントバッファの長さである。
          サイズの大幅な変更を検知すると自動保存をオフにするために使われる。

          この変数が-1であると、
          大幅にサイズが減少したために一時的に自動保存をオフにしたことを意味する。
          明示的にバッファを保存すると、この変数に正の値が保存され、
          自動保存が再度オンになる。
          自動保存をオフにしたりオンにしても、この変数が変更される。つまり、大幅
          なサイズ減少の情報は消えてしまうことになる。

      -- Variable: auto-save-list-file-name
          この変数は（`nil'以外であると）、
          すべての自動保存ファイルの名前を記録するファイルを指定する。
          Emacsが自動保存を行うたびに、
          自動保存がオンである各バッファに関する2行をこのファイルに書き出す。
          1行目は訪問しているファイルの名前を与え（訪問していなければ空）、
          2行目は自動保存ファイルの名前を与える。

          Emacsが正常に終ると、このファイルは削除される。Emacsがクラッシュしたら、
          失われてしまう作業内容を含んでいるかもしれない自動保存ファイルを探すた
          めに読者はこのファイルを調べられる。コマンド`recover-session'は作
          業中だったファイルを探すために、このファイルを使う。

          このファイルのデフォルト名は、
          読者のホームディレクトリにあり`.saves-'で始まる。
          さらに、EmacsのプロセスIDとホスト名も含む。

      -- Variable: auto-save-list-file-prefix
          Emacsが初期化ファイルを読み込んだ後に、`auto-save-list-file-name'
          (すでに`nil'以外を設定していなければ)、この変数を基にホスト名やプ
          ロセスIDを加えて初期化される。初期化ファイルでこの変数に`nil'を設
          定すると、Emacsは`auto-save-list-file-name'を初期化しない。


File: elisp-ja,  Node: Reverting,  Prev: Auto-Saving,  Up: Backups and Auto-Saving

25.3 復元 _(2003/10/30)_
==========================

     ファイルを大幅に変更したあとで、そのような変更をやめたい場合には、
コマンド`revert-buffer'でファイルのまえの版を読み込めます。 *Note
バッファを復元する: (emacs)Reverting。

      -- コマンド: revert-buffer &optional ignore-auto noconfirm
          このコマンドは、バッファのテキストを
          ディスク上の訪問しているファイルのテキストで置き換える。
          これにより、ファイルを訪問したり保存してから行った変更をすべて取り消せる。

          デフォルトでは、最後の自動保存ファイルが
          訪問しているファイルよりも新しい場合には、
          `revert-buffer'は自動保存ファイルを使うかどうか
          ユーザーに問い合わせる。
          しかし、引数IGNORE-AUTOが`nil'以外であると、
          訪問したファイルのみを使う。
          対話的に呼ばれた場合、数値前置引数を指定しない限り、
          IGNORE-AUTOは`t'である。
          したがって、対話的な場合のデフォルトでは、自動保存ファイルを検査する。

          通常、バッファを変更するまえに`revert-buffer'は確認してくる。
          しかし、引数NOCONFIRMが`nil'以外であると、
          `revert-buffer'は確認しない。

          復元作業では、 `insert-file-contents'の置換機能を用いて
          バッファ内のマーカ位置を保存するように努める。
          復元操作のまえにバッファの内容とファイルの内容が同一であれば、
          すべてのマークが保存される。
          同一でなければ、復元によりバッファが変更され、
          バッファの先頭と末尾の（あれば）未変更なテキスト内のマーカを保存する。
          それ以外のマーカを保存しても問題を引き起こすだけであろう。

        この節の残りで述べる変数を設定することで、
`revert-buffer'の動作をカスタマイズできます。

      -- Variable: revert-without-query
          この変数は、問い合わせずに復元すべきファイルのリストを保持する。
          値は、正規表現のリストである。
          訪問中のファイル名がこれらの正規表現の1つに一致すると、
          ディスク上のファイルが変更されていて当該バッファが未変更であれば、
          `revert-buffer'はユーザーに確認せずに当該ファイルを復元する。

        あるメジャーモードは
これらの関数をバッファローカルで設定することで
、`revert-buffer'をカスタマイズしています。

      -- Variable: revert-buffer-function
          この変数の値は、このバッファを復元するために使う関数である。
          `nil'以外であれば、復元を行う引数なしの関数として呼び出される。
          値が`nil'であると、復元操作は通常の方法で行われる。

          diredモードなどのモードでは、
          編集中のテキストはファイルの内容ではなく
          別の方法で再生成されたものなので、
          この変数のバッファローカルな値には内容を再生成する関数を指定することが
          できます。

      -- Variable: revert-buffer-insert-file-contents-function
          この変数の値が`nil'以外であると、
          このバッファを復元するときに更新内容を挿入するために使われる関数である。
          当該関数は2つの引数をとる。
          第1引数は、使用するファイル名である。
          第2引数は、ユーザーが自動保存ファイルを
          読むように指示していると`t'である。

          あるモードでこの変数を`revert-buffer-function'のかわりに設定する
          のは、`revert-buffer'が行う処理の残りが重複したり置き換わってしま
          うのを避けるためである。つまり、アンドゥ情報を消去する場合や適当なメ
          ジャーモードを決定する場合、以下で述べるフックを走らせる場合に確認を行
          う。

      -- Variable: before-revert-hook
          このノーマルフックは、`revert-buffer-function'が`nil'である
          場合にのみ、変更内容を挿入するまえに`revert-buffer'が実行する。

      -- Variable: after-revert-hook
          このノーマルフックは、`revert-buffer-function'が`nil'である
          場合にのみ、変更内容を挿入したあとに`revert-buffer'が実行する。



File: elisp-ja,  Node: Buffers,  Next: Windows,  Prev: Backups and Auto-Saving,  Up: Top

26 バッファ _(2003/10/30)_
******************************

     "バッファ"（buffer）は、編集するテキストを収めている
Lispオブジェクトです。
バッファは、訪問しているファイルのテキストを保持するために使われますが、
ファイルを訪問していないバッファもあります。
一度に複数のバッファが存在してかまいませんが、
ある時点では1つのバッファだけが"カレントバッファ" （current
buffer）として区別されます。
ほとんどの編集コマンドは、カレントバッファの内容に作用します。
カレントバッファを含む各バッファは、ウィンドウに表示されることも
されないこともあります。

     * Menu:

     * Buffer Basics::       What is a buffer?
     * Current Buffer::      Designating a buffer as current
                               so that primitives will access its contents.
     * Buffer Names::        Accessing and changing buffer names.
     * Buffer File Name::    The buffer file name indicates which file is visited.
     * Buffer Modification:: A buffer is "modified" if it needs to be saved.
     * Modification Time::   Determining whether the visited file was changed
                              ``behind Emacs's back''.
     * Read Only Buffers::   Modifying text is not allowed in a read-only buffer.
     * The Buffer List::     How to look at all the existing buffers.
     * Creating Buffers::    Functions that create buffers.
     * Killing Buffers::     Buffers exist until explicitly killed.
     * Indirect Buffers::    An indirect buffer shares text with some other buffer.
     * Buffer Gap::          The gap in the buffer.


File: elisp-ja,  Node: Buffer Basics,  Next: Current Buffer,  Up: Buffers

26.1 バッファの基本 _(2003/10/30)_
=========================================

     "バッファ"（buffer）は、編集するテキストを収めている
Lispオブジェクトです。
バッファは、訪問しているファイルのテキストを保持するために使われますが、
ファイルを訪問していないバッファもあります。複数のバッファは普通に存在
できますが、常に一つのバッファだけが"カレントバッファ"(current
buffer)となります。
ほとんどの編集コマンドは、カレントバッファの内容に作用します。
カレントバッファを含む各バッファは、ウィンドウに表示されることも
されないこともあります。

     異なる名前を持ち編集可能なテキストを保持するオブジェクトです。
バッファは、Lispプログラムには特別なデータ型として見えます。
バッファの内容は拡張可能な文字列であると考えることができます。
つまり、バッファのどの部分ででも挿入や削除を行えるのです。 *Note
Text::。

        Lispのバッファオブジェクトには、さまざまな情報が含まれています。
変数を介してプログラマが直接参照できる情報もあれば、
特別目的の関数のみを介して参照できる情報もあります。
たとえば、訪問しているファイルの名前は、変数を介して直接参照できますが、
ポイントの値は基本関数を介してのみ参照できます。

        直接参照可能なバッファに固有の情報は、
"バッファローカル"（buffer-local）な変数束縛、
つまり、特定のバッファでのみ有効な変数に保持されています。
この機能により、各バッファでは特定の変数の値を優先できます。
ほとんどのメジャーモードでは、このようにして、
`fill-column'や`comment-column'などの変数を優先させます。
バッファローカルな変数とそれらに関する関数について詳しくは、 *note
Buffer-Local Variables::を参照してください。

        バッファで訪問しているファイルに関する関数や変数については、
*note Visiting Files::と*note Saving Buffers::を参照してください。
ウィンドウにバッファを表示することに関する関数や変数については、 *note
Buffers and Windows::を参照してください。

      -- Function: bufferp object
          この関数は、OBJECTがバッファであれば`t'を返し、
          さもなければ`nil'を返す。


File: elisp-ja,  Node: Current Buffer,  Next: Buffer Names,  Prev: Buffer Basics,  Up: Buffers

26.2 カレントバッファ _(2003/10/30)_
============================================

     いつの時点でも、それらの1つを"カレントバッファ" （current
buffer）として区別します。
バッファ内のテキストを検査したり変更する基本関数は
暗黙のうちにカレントバッファに作用するため、
ほとんどの編集はカレントバッファに対して行われます （*note Text::）。
通常、スクリーン上で選択されたウィンドウに表示されているバッファが
カレントバッファですが、つねにそうとは限りません。
Lispプログラムでは、スクリーン上の表示は変えずに、
任意のバッファの内容を操作するために
一時的に当該バッファをカレントバッファにできます。

        Lispプログラムでカレントバッファを指定するには、
`set-buffer'を呼び出します。
新たに指定し直すまで指定したバッファがカレントバッファであり続けます。

        編集コマンドがエディタコマンドループへ戻ると、
コマンドループは、混乱を避けるために、選択されているウィンドウに
表示されているバッファをカレントバッファとします。
つまり、Emacsがコマンドを読むときにカーソルがあるバッファが
コマンドが適用されるバッファです。 （*Note Command Loop::。）
したがって、`set-buffer'は、
ユーザーが編集できるように別のバッファへ切り替える方法にはなりません。
これには、*note Displaying
Buffers::で述べている関数を使う必要があります。

        しかし、別のカレントバッファに替えるLisp関数では、
コマンドループがカレントバッファを
あとで戻すということに依存してはいけません。 Emacs
Lispで書かれた編集コマンドは、コマンドループに加えて
別のプログラムからも呼ばれます。
サブルーティンがカレントバッファを替えないほうが
（それがサブルーティンの目的でなければ）、
呼び出し側にとっては便利です。
したがって、関数の実行が終るともとのカレントバッファに戻す
フォーム`save-current-buffer'や `save-excursion'（*note
Excursions::）の内側で、 普通は`set-buffer'を使います。
例として、（説明文字列を簡略にして）コマンド`append-to-buffer'
のコードを示します。

          (defun append-to-buffer (buffer start end)
            "Append to specified buffer the text of the region.
          ..."
            (interactive "BAppend to buffer: \nr")
            (let ((oldbuf (current-buffer)))
              (save-current-buffer
                (set-buffer (get-buffer-create buffer))
                (insert-buffer-substring oldbuf start end))))

     この関数では、ローカル変数を束縛してカレントバッファを記録し、
`save-current-buffer'でそれがカレントバッファに戻るようにしています。
つぎに、`set-buffer'で指定したバッファをカレントバッファにします。
最後に、`insert-buffer-substring'でもとのカレントバッファから
指定された（いまはカレント）バッファに文字列をコピーします。

        内容を付加したバッファがどれかのウィンドウに表示されていると、
つぎに表示を更新したときに変更されたテキストが表示されます。
それ以外では、スクリーン上でただちには変更を見ることはできません。
コマンドの実行中にはバッファが一時的にカレントバッファになりますが、
それによりそのバッファが表示されるわけではありません。

        バッファローカルな束縛を持つ変数を（`let'や関数の引数で）
ローカルに束縛する場合には、ローカルな束縛の有効範囲の開始時と終了時には、
同じバッファが必ずカレントバッファであるようにします。
さもないと、あるバッファでは変数を束縛し、
別のバッファではその束縛を解除してしまうことがあります。
これには2つの方法があります。 単純な場合には、束縛の有効範囲内で
カレントバッファが替わらないを確認します。
さもなければ、`save-current-buffer'や`save-excursion'を使って、
始めにカレントバッファであったバッファが、
変数束縛が解除されるときにはつねにカレントバッファであるようにします。

        `set-buffer'でカレントバッファに戻すことを期待してはいけません。
正しくないバッファがカレントバッファであるときに
中断が起きると戻せないからです。 しては_いけない_ことをつぎに示します。

          (let (buffer-read-only
                (obuf (current-buffer)))
            (set-buffer ...)
            ...
            (set-buffer obuf))

     つぎのように`save-current-buffer'を使えば、
通常の評価に加えて、中断、エラー、`throw'も扱えます。

          (let (buffer-read-only)
            (save-current-buffer
              (set-buffer ...)
              ...))

      -- Function: current-buffer
          この関数はカレントバッファを返す。

               (current-buffer)
                    => #<buffer buffers.texi>

      -- Function: set-buffer buffer-or-name
          この関数は、BUFFER-OR-NAMEをカレントバッファにする。
          この関数はどのウィンドウにも
          当該バッファを表示しないので、ユーザーが当該バッファを見られるとは限らない。
          しかし、Lispプログラムはいずれにしても当該バッファを操作できる。

          この関数はBUFFER-OR-NAMEで指定されるバッファを返す。
          BUFFER-OR-NAMEが既存のバッファを指定しなければ、エラーを通知する。

      -- Special Form: save-current-buffer body...
          マクロ`save-current-buffer'は、
          カレントバッファの識別子を保存し、フォームBODYを評価し、
          最後にもとのカレントバッファに戻す。
          戻り値は、BODYの最後のフォームの値である。
          `throw'やエラー（*note Nonlocal
          Exits::）による異常終了であっても カレントバッファは戻される。

          `save-current-buffer'から抜けるときに、
          もとのカレントバッファとして使われていたバッファが削除されていると、
          もちろん、カレントバッファにはならない。
          そのかわりに、抜けるまえにカレントバッファであったバッファが
          カレントバッファであり続ける。

      -- Macro: with-current-buffer buffer body...
          マクロ`with-current-buffer'は、
          カレントバッファの識別子を保存し、
          BUFFERをカレントバッファにし、フォームBODYを評価し、
          最後にもとのカレントバッファに戻す。
          戻り値は、BODYの最後のフォームの値である。
          `throw'やエラー（*note Nonlocal
          Exits::）による異常終了であっても カレントバッファは戻される。

      -- Macro: with-temp-buffer body...
          マクロ`with-temp-buffer'は、
          一時的なバッファをカレントバッファとして
          フォームBODYを評価する。 カレントバッファの識別子を保存し、
          一時的なバッファを作成してそれをカレントバッファにし、
          フォームBODYを評価し、
          最後にもとのカレントバッファに戻すとともに一時的なバッファを削除する。

          戻り値は、BODYの最後のフォームの値である。
          最後のフォームとして`(buffer-string)'を使えば、
          一時的なバッファの内容を返せる。

          `throw'やエラー（*note Nonlocal
          Exits::）による異常終了であっても カレントバッファは戻される。

        *note Writing to Files::の`with-temp-file'も参照してください。


File: elisp-ja,  Node: Buffer Names,  Next: Buffer File Name,  Prev: Current Buffer,  Up: Buffers

26.3 バッファ名 _(2003/10/30)_
===================================

     各バッファには、文字列で一意な名前があります。
バッファに作用するほとんどの関数は、
引数としてバッファかバッファ名を受け付けます。
BUFFER-OR-NAMEという名前の引数はこの種のものであり、
当該引数が文字列でもバッファでもないとエラーを通知します。
BUFFERという名前の引数は
実際のバッファオブジェクトである必要があり、名前ではだめです。

短命で一般にはユーザーが関心を示さないバッファの名前は空白で始まり、
コマンド`list-buffers'や`buffer-menu'はそれらを表示しません。
さらに、空白で始まる名前のバッファでは、
アンドゥ情報の記録も最初は禁止してあります。 *note
Undo::を参照してください。

      -- Function: buffer-name &optional buffer
          この関数は、BUFFERの名前を文字列で返す。
          BUFFERを指定しないと、デフォルトはカレントバッファである。

          `buffer-name'が`nil'を返す場合、
          BUFFERが削除されたことを意味する。 *note Killing Buffers::。

               (buffer-name)
                    => "buffers.texi"

               (setq foo (get-buffer "temp"))
                    => #<buffer temp>
               (kill-buffer foo)
                    => nil
               (buffer-name foo)
                    => nil
               foo
                    => #<killed buffer>

      -- コマンド: rename-buffer newname &optional unique
          この関数は、カレントバッファをNEWNAMEと改名する。
          NEWNAMEが文字列でなかったり、
          当該名のバッファがすでに存在していると、エラーを通知する。
          関数はNEWNAMEを返す。

          通常、NEWNAMEがすでに使われていると、
          `rename-buffer'はエラーを通知する。
          しかし、UNIQUEが`nil'以外であると、
          NEWNAMEを未使用な名前に修正する。
          対話的に呼び出した場合、数値前置引数を指定すると
          UNIQUEは`nil'以外になる。(このように`rename-uniquely'
          は実行されるのです)

          このコマンドの1つの用途は、
          バッファ`*shell*'を別の名前に改名して、
          同じ`*shell*'という名前で別のシェルを作れるようにすることである。

      -- Function: get-buffer buffer-or-name
          この関数は、BUFFER-OR-NAMEで指定したバッファを返す。
          BUFFER-OR-NAMEが文字列であり、
          そのような名前のバッファが存在しなければ`nil'を返す。
          BUFFER-OR-NAMEがバッファであればそれ自身を返す。
          これは有用ではないので、普通、引数は名前である。 例を示す。

               (setq b (get-buffer "lewis"))
                    => #<buffer lewis>
               (get-buffer b)
                    => #<buffer lewis>
               (get-buffer "Frazzle-nots")
                    => nil

          *note Creating Buffers::の関数`get-buffer-create'も参照。

      -- Function: generate-new-buffer-name starting-name &rest ignore
          この関数は、新たなバッファ向けの一意な名前を返すが、バッファは作成しない。
          名前はSTARTING-NAMEで始まり、
          `<...>'で囲った数を追加することで、
          どのバッファでも現在使っていない名前を作成する。

          2番目のオプション引数IGNOREが`nil'でなければ、文字列を与え
          る必要がある。一意な名前を探す時に、IGNOREで設定した名前があると
          動作が異なってくる。指定した名前がたとえ既に存在しているバッファの名前
          であったとしても、一意な名前と認識するのである。例えば、`foo',
          `foo<2>', `foo<3>' and `foo<4>' という名前のバッファが
          あるとすると、

               (generate-new-buffer-name "foo")
                    => "foo<5>"
               (generate-new-buffer-name "foo" "foo<3>")
                    => "foo<3>"
               (generate-new-buffer-name "foo" "foo<6>")
                    => "foo<5>"

          のように、`foo<3>'というバッファが既に存在していても、 IGNORE
          で設定すると、一意なバッファ名として`foo<3>' が返っ
          てくるのである。

          *note Creating
          Buffers::の関連する関数`generate-new-buffer'を参照。


File: elisp-ja,  Node: Buffer File Name,  Next: Buffer Modification,  Prev: Buffer Names,  Up: Buffers

26.4 バッファファイル名 _(2003/10/30)_
===============================================

     "バッファファイル名"（buffer file name）とは、
当該バッファで訪問しているファイルの名前です。
バッファでファイルを訪問していないときには、
バッファファイル名は`nil'です。 ほとんどの場面で、バッファ名は
バッファファイル名の非ディレクトリ部分と同じですが、
バッファファイル名とバッファ名は別のものであり個別に設定できます。
*Note Visiting Files::。

      -- Function: buffer-file-name &optional buffer
          この関数は、BUFFERで訪問しているファイルの
          絶対ファイル名を返す。 BUFFERがファイルを訪問していなければ、
          `buffer-file-name'は`nil'を返す。 BUFFERを指定しないと、
          デフォルトはカレントバッファである。

               (buffer-file-name (other-buffer))
                    => "/usr/user/lewis/manual/files.texi"

      -- Variable: buffer-file-name
          このバッファローカルな変数は、
          カレントバッファで訪問しているファイルの名前を保持する。
          あるいは、ファイルを訪問していなければ`nil'である。
          これは恒久的にバッファローカルな変数であり、
          `kill-all-local-variables'に影響されない。

               buffer-file-name
                    => "/usr/user/lewis/manual/buffers.texi"

          他のさまざまなことを行わずにこの変数の値だけを変更することは危険である。
          通常、`set-visited-file-name'（下記参照）を使うほうがよい。
          バッファ名を変更するなどの重要でないことも行うが、
          Emacsを混乱させないように本質的なことも行うからである。

      -- Variable: buffer-file-truename
          このバッファローカルな変数は、
          カレントバッファで訪問しているファイルの実名を保持する。
          あるいは、ファイルを訪問していなければ`nil'である。
          これは恒久的にバッファローカルであり、
          `kill-all-local-variables'に影響されない。 *note Truenames::。

      -- Variable: buffer-file-number
          このバッファローカルな変数は、
          カレントバッファで訪問しているファイルの
          ファイル番号とディレクトリ装置番号を保持する。
          あるいは、ファイルを訪問していなければ`nil'である。
          これは恒久的にバッファローカルであり、
          `kill-all-local-variables'に影響されない。

          この値は、通常、`(FILENUM DEVNUM)'の形のリストである。
          この数の対により、システム上のすべての参照可能なファイルを一意に識別できる。
          これらについてより詳しくは、 *note File
          Attributes::の関数`file-attributes'を参照。

      -- Function: get-file-buffer filename
          この関数は、ファイルFILENAMEを訪問しているバッファを返す。
          そのようなバッファが存在しなければ`nil'を返す。
          引数FILENAMEは文字列であり、 展開（*note File Name
          Expansion::）してから
          すべてのバッファの訪問しているファイル名と比較する。

               (get-file-buffer "buffers.texi")
                   => #<buffer buffers.texi>

          稀れな状況では、複数のバッファが同じ名前のファイルを訪問している場合がある。
          そのような場合、この関数はバッファリストで最初にみつかったバッファを返す。

      -- コマンド: set-visited-file-name filename &optional no-query
               along-with-file
          FILENAMEが空でない文字列であると、
          この関数はカレントバッファで訪問しているファイルの名前を
          FILENAMEに変える。 （ファイルを訪問していないバッファでは、
          当該バッファに訪問しているファイル名を指定する。）
          バッファを_つぎに_保存すると、指定した新たなファイルに保存される。
          このコマンドは、バッファに変更済みと印を付ける。
          変更まえの訪問しているファイルの内容とバッファ内容が一致していたとしても
          （Emacsにとっては）
          バッファ内容はFILENAMEの内容と一致しないからである。

          FILENAMEが`nil'だったり空文字列であると、
          『ファイルを訪問していない』ことにする。
          この場合、`set-visited-file-name'は、
          当該バッファではファイルを訪問していないと印を付ける。

          通常、この関数は、指定したファイルが既存の場合には
          ユーザーに確認をとる。
          NO-QUERYが`nil'以外であると、確認をとらない。

          ALONG-WITH-FILEが`nil'以外であると、
          それ以前に訪問していたファイルはFILENAMEと改名してあると仮定する。

          関数`set-visited-file-name'を対話的に呼び出すと、
          ミニバッファでFILENAMEを問い合わせる。

      -- Variable: list-buffers-directory
          このバッファローカルな変数は、
          訪問しているファイル名を持たないバッファに対して、
          バッファ一覧において訪問しているファイル名を表示する部分に
          表示する文字列を指定する。 diredのバッファはこの変数を使う。


File: elisp-ja,  Node: Buffer Modification,  Next: Modification Time,  Prev: Buffer File Name,  Up: Buffers

26.5 バッファの変更 _(2003/10/30)_
=========================================

     Emacsは、各バッファごとに当該バッファのテキストを変更したかどうかを
記録する"変更フラグ"（modified flag）と呼ばれるフラグを保持しています。
バッファの内容が変わるたびにこのフラグは`t'に設定され、
保存するたびに`nil'に設定されます。
つまり、このフラグは未保存の変更があるかどうかを表します。
このフラグの値は通常モード行（*note Mode Line Variables::）に表示され、
保存（*note Saving Buffers::）と 自動保存（*note
Auto-Saving::）を制御します。

        このフラグを明示的に設定するLispプログラムもあります。
たとえば、関数`set-visited-file-name'はこのフラグを`t'に設定します。
ファイルを訪問してから変更していなくても、
バッファのテキストが新たな訪問しているファイルとは一致しないからです。

        バッファの内容を変更する関数については*note
Text::に述べてあります。

      -- Function: buffer-modified-p &optional buffer
          この関数は、最後にファイルから読み込んだり保存してから
          バッファBUFFERが変更されていれば`t'を返し、
          さもなければ`nil'を返す。
          BUFFERを指定しないとカレントバッファを調べる。

      -- Function: set-buffer-modified-p flag
          この関数は、FLAGが`nil'以外であれば
          カレントバッファは変更されていると印を付け、
          `nil'ならば未変更であると印を付ける。

          この関数を呼び出した別の効果として、
          カレントバッファのモード行を無条件に再表示する。
          実際、関数`force-mode-line-update'はつぎのようにしている。

               (set-buffer-modified-p (buffer-modified-p))

      -- コマンド: not-modified
          このコマンドは、カレントバッファを未変更であり
          保存する必要がないと印を付ける。
          前置引数を指定すると、バッファに変更されていると印を付け、
          以降の適当な場面で保存される。

          エコー領域にメッセージを表示するので、
          プログラムからこの関数を使わないこと。
          かわりに`set-buffer-modified-p'を使う（上記）。

      -- Function: buffer-modified-tick &optional buffer
          この関数は、BUFFERの変更回数を返す。
          変更回数はバッファを変更するたびに増やされる。
          BUFFERが`nil'であると（あるいは省略すると）、
          カレントバッファを使う。


File: elisp-ja,  Node: Modification Time,  Next: Read Only Buffers,  Prev: Buffer Modification,  Up: Buffers

26.6 更新時刻の比較 _(2003/10/30)_
=========================================

     ファイルを訪問してそのバッファで変更したとします。
そのあいだに、ディスク上の当該ファイル自身も変更されたとします。
ここでバッファを保存すると、ファイルの変更内容を上書きしてしまいます。
たしかにこれを望む場合もあるでしょうが、
普通は重要な情報を失うことになります。
そのため、Emacsは、ファイルに保存するまえに、
以下に述べる関数を用いてファイルの更新時刻を検査します。

      -- Function: verify-visited-file-modtime buffer
          この関数は、BUFFERに記録してある
          訪問しているファイルの更新時刻と、
          オペレーティングシステムが記録している
          ファイルの実際の更新時刻を比較する。
          Emacsが当該ファイルを訪問したり保存してから
          他のプロセスが当該ファイルに書いていない限り、
          2つの時刻は同じはずである。

          実際の更新時刻とEmacsに記録している更新時刻が同じならば`t'を返し、
          さもなければ`nil'を返す。

      -- Function: clear-visited-file-modtime
          この関数は、カレントバッファで訪問しているファイルの
          最終更新時刻の記録を破棄する。
          その結果、つぎにこのバッファを保存しようとしても、
          ファイルの更新時刻のと不一致を報告しない。

          この関数は、`set-visited-file-name'や
          変更されたファイルを上書きしないためのテストを行わない例外的な場面で
          呼び出される。

      -- Function: visited-file-modtime
          この関数は、 バッファに記録されているファイルの最終更新時刻を
          `(HIGH . LOW)'の形のリストで返す。
          （これは`file-attributes'が時刻を返すために使う形と同じである。
          *note File Attributes::を参照。）

      -- Function: set-visited-file-modtime &optional time
          この関数は、TIMEが`nil'以外であるときには、
          バッファに記録してあるファイルの最終更新時刻を
          TIMEで指定された時刻にする。
          さもなければ、訪問しているファイルの最終更新時刻にする。

          TIMEが`nil'でないときには、 `(HIGH . LOW)'か`(HIGH
          LOW)'の形であること。
          いずれの場合も、2つの整数は時刻の16ビットを保持する。

          この関数は、ファイルから普通に読み込んだのではないバッファや
          ファイル自体が明確な理由で変更された場合に有用である。

      -- Function: ask-user-about-supersession-threat filename
          この関数は、ファイルFILENAMEを訪問している廃れたバッファを
          変更しようとしたときにどのように処理すべきかをユーザーに問い合わせる
          ために用いる。 "廃れたバッファ"（obsolete buffer）とは、
          未変更のバッファではあるが、対応するディスク上のファイルが
          バッファの最終更新時刻よりも新しいものである。
          つまり、別のプログラムが当該ファイルを変更した可能性があることを意味する。

          ユーザーの応答に依存して、関数は正常に戻る。
          その場合、バッファは変更できる。
          あるいは、データ`(FILENAME)'を付けて
          エラー`file-supersession'を通知する。
          その場合、バッファの変更は許されない。

          この関数は、適切な場面でEmacsが自動的に呼び出す。
          これを再定義することでEmacsをカスタマイズできるようにしている。
          標準定義についてはファイル`userlock.el'を参照。

          *note File Locks::のファイルロック機構も参照。


File: elisp-ja,  Node: Read Only Buffers,  Next: The Buffer List,  Prev: Modification Time,  Up: Buffers

26.7 読み出し専用バッファ _(2003/10/30)_
==================================================

     バッファが"読み出し専用"（read-only）であると、
スクロールしたりナロイングしてその内容を眺めることはできますが、
その内容は変更できません。

        読み出し専用バッファは、2種類の場面で使われます。

        *
          書き込み不可のファイルを訪問しているバッファは、通常、読み出し専用である。

          ここでの目的は、バッファを編集してファイルに保存しようとしても
          それに失敗するか望ましくないことであることをユーザーに伝えることである。
          それにも関わらずバッファのテキストを変更したいユーザーは、
          読み出し専用フラグを`C-x C-q'でクリアすれば編集できる。

        * diredやrmailなどのモードは、
          普通の編集コマンドで内容を変更することが誤りであるような
          場合にバッファを読み出し専用にする。

          これらのモードの特別なコマンドは、
          それら自身がテキストを変更する場面では、
          （`let'で）`buffer-read-only'に`nil'を束縛したり、
          `inhibit-read-only'に`t'を束縛する。

      -- Variable: buffer-read-only
          このバッファローカルな変数は、
          バッファが読み出し専用であるかどうかを指定する。
          この変数が`nil'以外であると、バッファは読み出し専用である。

      -- Variable: inhibit-read-only
          この変数が`nil'以外であると、
          読み出し専用バッファや読み出し専用文字を変更できる。
          バッファ内の読み出し専用文字とは
          （テキスト属性やオーバレイ属性の）
          属性`read-only'が`nil'以外の文字である。
          テキスト属性について詳しくは、*note Special Properties::。
          重ね合わせとそれらの属性について詳しくは、*note Overlays::。

          `inhibit-read-only'が`t'であると、
          すべての文字の属性`read-only'は効果を失う。
          `inhibit-read-only'がリストであると、
          文字の属性`read-only'が（`eq'で比較して）
          リストのメンバであると効果を失う。

      -- コマンド: toggle-read-only
          このコマンドは、カレントバッファが読み出し専用かどうかを変更する。
          対話的な使用を意図しており、プログラムからは使わないこと。
          プログラムの任意の箇所で、読み出し専用フラグを
          オンにしたいかオフにしたいかを読者は知っているはずであり、
          そうすれば、読者は`buffer-read-only'を
          `t'か`nil'の正しい値に明示的に設定できる。

      -- Function: barf-if-buffer-read-only
          この関数は、カレントバッファが読み出し専用であると
          エラー`buffer-read-only'を通知する。
          カレントバッファが読み出し専用であるときに
          エラーを通知する別の方法については、*note Interactive Call::。


File: elisp-ja,  Node: The Buffer List,  Next: Creating Buffers,  Prev: Read Only Buffers,  Up: Buffers

26.8 バッファリスト _(2003/10/30)_
=========================================

     "バッファリスト"（buffer list）は、 すべてのバッファのリストです。
バッファを作成すると当該バッファはこのリストに追加され、
削除するとこのリストから取り除かれます。
リスト内のバッファの順序は、各バッファが選択されているウィンドウに
どの程度最近に表示されたかを主な基準にしています。
バッファが選択されるとリストの先頭に移動し、
隠されると（下記の`bury-buffer'を参照）末尾に移動します。
`other-buffer'をはじめとするいくつかの関数が、この順序を使います。
ユーザーに表示するバッファ一覧もこの順序を反映しています。

        Emacs基本バッファリストに加えて、
各フレームには独自のバッファリストがあります。 そのリストでは、
_当該フレームで_もっとも最近に選択されたバッファから順に
当該フレームで選択されたバッファが先にきます。
（この順番は、フレームのフレームパラメータ`buffer-list'に入っている。
*note Window Frame Parameters::を参照。）
当該フレームで選択されたことがないバッファは、
Emacs基本バッファリストでの順にうしろに続きます。

      -- Function: buffer-list &optional frame
          この関数は、空白で始まる名前のバッファを含めて、
          すべてのバッファを含んだバッファリストを返す。
          要素は実際にバッファであり、それらの名前ではない。

          FRAMEがフレームであると、
          この関数はフレームFRAMEのバッファリストを返す。
          FRAMEが`nil'であるとEmacs基本バッファリストを使う。

               (buffer-list)
                    => (#<buffer buffers.texi>
                        #<buffer  *Minibuf-1*> #<buffer buffer.c>
                        #<buffer *Help*> #<buffer TAGS>)

               ;; ミニバッファの名前は空白で始まることに注意
               (mapcar (function buffer-name) (buffer-list))
                   => ("buffers.texi" " *Minibuf-1*"
                       "buffer.c" "*Help*" "TAGS")

        `buffer-list'が返すリストは`buffer-list'が構築したものであり、
Emacsの内部データ構造ではなく、
それを変更してもバッファの順序には影響しません。
フレーム独立なバッファリスト内のバッファ順序を変更するには、
つぎのような簡単な方法があります。

          (defun reorder-buffer-list (new-list)
            (while new-list
              (bury-buffer (car new-list))
              (setq new-list (cdr new-list))))

        この方法を使えば、どんな順序でもリストに指定でき、
しかも、バッファを失ったり正しくないバッファを
追加してしまう危険はありません。

        フレームのバッファリストの順序や値を変更するには、
`modify-frame-parameters'（*note Parameter Access::）で、
フレームのフレームパラメータ`buffer-list'に設定します。

      -- Function: other-buffer &optional buffer visible-ok frame
          この関数は、バッファリストからBUFFER以外の最初のバッファを返す。
          通常、当該バッファは、BUFFERを除いて
          （FRAMEか現在選択されているフレームで、*note Input Focus::）
          もっとも最近に選択されたバッファである。
          空白で始まる名前のバッファは完全に除外する。

          BUFFERを指定しないと（あるいはバッファでないと）、
          `other-buffer'は、選択されているフレームのバッファリストの中から
          可視フレームのどのウィンドウにも表示されていない最初のバッファを返す。

          FRAMEに`nil'以外のパラメータ`buffer-predicate'があると、
          `other-buffer'は当該述語を使って
          どのバッファを考慮に入れるかを決定する。
          各バッファについて当該述語を1回呼び出し、
          その値が`nil'であると当該バッファを無視する。 *note Window
          Frame Parameters::。

          VISIBLE-OKが`nil'であると、
          `other-buffer'は可視フレームのいずれかのウィンドウに
          表示されているバッファを可能な限り返さないようにする。
          VISIBLE-OKが`nil'以外であると、
          バッファが表示されているかどうかは関係ない。

          適当なバッファが存在しない場合には、
          バッファ`*scratch*'を（必要ならば作成して）返す。

      -- コマンド: bury-buffer &optional buffer-or-name
          この関数は、バッファリストの他のバッファの順序は変えずに
          BUFFER-OR-NAMEを末尾に置く。
          この結果、当該バッファは、`other-buffer'が返す候補としては
          もっとも可能性が低くなる。

          `bury-buffer'は、
          Emacsのフレーム独立なバッファリストに加えて、
          各フレームのパラメータ`buffer-list'も操作する。
          したがって、指定したバッファは、 `(buffer-list
          FRAME)'と`(buffer-list nil)'の いずれの値でも最後になる。

          BUFFER-OR-NAMEが`nil'であるか省略すると、
          カレントバッファを最後尾に置くことを意味する。
          さらに、当該バッファが選択されているウィンドウに表示されていると、
          そのウィンドウでは（`other-buffer'で得られる）
          別のバッファに切り替わる。
          当該バッファが別のウィンドウにも表示されている場合、
          その表示は替わらない。

          すべてのウィンドウに表示している特定のバッファを置き換えるには、
          `replace-buffer-in-windows'を使う。 *note Buffers and
          Windows::。


File: elisp-ja,  Node: Creating Buffers,  Next: Killing Buffers,  Prev: The Buffer List,  Up: Buffers

26.9 バッファの作成 _(2003/10/30)_
=========================================

     本節では、バッファを作成するための2つの基本関数を説明します。
`get-buffer-create'は、指定した名前のバッファが
存在しなければバッファを作成します。
`generate-new-buffer'は、つねに新たなバッファを作成し、
それに一意な名前を与えます。

        バッファを作成するために読者が使える他の関数には、
`with-output-to-temp-buffer'（*note Temporary Displays::）、
`create-file-buffer'（*note Visiting Files::）があります。
サブプロセスを開始してもバッファを作ります（*note Processes::）。

      -- Function: get-buffer-create name
          この関数は、NAMEという名前のバッファを返す。
          その名前のバッファが存在すれば、当該バッファを返す。
          さもなければ、新たなバッファを作成する。
          バッファはカレントバッファにはならない。
          この関数は、どのバッファがカレントバッファであるかは変更しない。

          NAMEが文字列でないとエラーを通知する。

               (get-buffer-create "foo")
                    => #<buffer foo>

          新たなバッファのメジャーモードは基本（fundamental）モードに設定される。
          変数`default-major-mode'は、より高いレベルで処理される。
          *note Auto Major Mode::。

      -- Function: generate-new-buffer name
          この関数は、新たに作成した空のバッファを返すが、
          それをカレントバッファにはしない。
          NAMEという名前のバッファが存在しなければ、
          新たなバッファの名前はNAMEである。
          その名前が使われている場合には、
          この関数は、Nを整数として`<N>'の形の接尾辞を NAMEに付加する。
          Nを2から始めて順に使える名前を探す。

          NAMEが文字列でないとエラーを通知する。

               (generate-new-buffer "bar")
                    => #<buffer bar>
               (generate-new-buffer "bar")
                    => #<buffer bar<2>>
               (generate-new-buffer "bar")
                    => #<buffer bar<3>>

          新たなバッファのメジャーモードは基本（fundamental）モードに設定される。
          変数`default-major-mode'は、より高いレベルで処理される。
          *note Auto Major Mode::。

          *note Buffer
          Names::の関連する関数`generate-new-buffer-name'を参照。


File: elisp-ja,  Node: Killing Buffers,  Next: Indirect Buffers,  Prev: Creating Buffers,  Up: Buffers

26.10 バッファの削除 _(2003/10/30)_
==========================================

     "バッファを削除する"とは、Emacsに当該バッファの名前を忘れさせ、
それが使っていた場所を他の目的に使えるようにすることです。

        削除されたバッファを表すバッファオブジェクトは、
それを指すものが存在する限り存在し続けますが、
それをカレントバッファにしたり表示できないように特別な印が付いています。
削除されたバッファの識別子は残っているので、
異なる2つのバッファを削除しても、
`eq'に関する限りそれらは区別できるのです。

        カレントバッファやウィンドウに表示しているバッファを削除すると、
そのかわりにEmacsは別のバッファを選択したり表示します。
つまり、バッファを削除すると一般にはカレントバッファが
替わりうることを意味します。 したがって、バッファを削除するときには、
（削除するバッファがカレントバッファではないことがわかっていない限り）
カレントバッファを替える可能性についてあらかじめ注意しておく必要があります。
*Note Current Buffer::。

        複数の間接バッファの基底バッファであるバッファを削除すると、
間接バッファも自動的に削除されます。

        削除されたバッファの`buffer-name'は`nil'です。
これを使えばバッファが削除されているかどうか調べられます。

          (defun buffer-killed-p (buffer)
            "Return t if BUFFER is killed."
            (not (buffer-name buffer)))

      -- コマンド: kill-buffer buffer-or-name
          この関数はバッファBUFFER-OR-NAMEを削除し、
          当該バッファが使用していたすべてのメモリを他の目的に使えるように解放したり、
          オペレーティングシステムに返すために解放する。
          この関数は`nil'を返す。

          当該バッファを`process-buffer'としているすべてのプロセスに
          シグナル`SIGHUP'を送る。
          このシグナルは、通常、プロセスを終了させる。
          （`SIGHUP'の基本的な意味は、接続回線が切断されたである。）
          *note Deleting Processes::。

          当該バッファがファイルを訪問していて、かつ、未保存の変更があれば、
          `kill-buffer'は当該バッファを削除するまえにユーザーに確認をとる。
          確認をとらないようにするには、`kill-buffer'を呼び出すまえに
          バッファの変更フラグをクリアしておく。 *note Buffer
          Modification::。

          削除済みのバッファを削除してもなんの効果もない。

               (kill-buffer "foo.unchanged")
                    => nil
               (kill-buffer "foo.changed")

               ---------- Buffer: Minibuffer ----------
               Buffer foo.changed modified; kill anyway? (yes or no) yes
               ---------- Buffer: Minibuffer ----------

                    => nil

      -- Variable: kill-buffer-query-functions
          未保存の変更を確認したあとで、`kill-buffer'は、
          リスト`kill-buffer-query-functions'の関数を現れる順に
          引数なしで呼び出す。 これらの関数が呼び出されるときには、
          削除対象のバッファがカレントバッファである。
          これらの関数でユーザーの確認をとることがこの機能の目的である。
          いずれかが`nil'を返すと、`kill-buffer'はバッファを削除しない。

      -- Variable: kill-buffer-hook
          これは、`kill-buffer'が問い合わせをすべて完了し
          バッファを実際に削除する直前に実行されるノーマルフックである。
          フック関数を実行するときには、削除対象のバッファがカレントバッファである。
          *note Hooks::。

      -- Variable: buffer-offer-save
          この変数が特定のバッファで`nil'以外であると、
          `save-buffers-kill-emacs'と`save-some-buffers'に対して
          ファイルを訪問しているバッファと同様に
          当該バッファを保存する機会を与えるように指示する。
          変数`buffer-offer-save'に
          設定すると自動的にバッファローカルになる。


File: elisp-ja,  Node: Indirect Buffers,  Next: Buffer Gap,  Prev: Killing Buffers,  Up: Buffers

26.11 間接バッファ _(2003/10/30)_
=======================================

     "間接バッファ"（indirect buffer）は、
間接バッファの"基底バッファ"（base buffer）と呼ばれる
他のバッファのテキストを共有します。 ある意味で、バッファにおいて
ファイルのシンボリックリンクに相当するものです。
基底バッファそのものは間接バッファであってはなりません。

間接バッファのテキストは、その基底バッファのテキストとつねに同一です。
どれかを編集して変更すると、別のものでただちに見えます。
これには、文字そのものに加えてテキスト属性も含みます。

        それ以外に関しては、間接バッファと
その基底バッファは完全に別のものです。
別の名前を持ち、ポイントの値も別であり、異なったナロイングをでき、
（いずれかのバッファでテキストを挿入したり削除すると
マーカと重ね合わせは再配置されるが）マーカやオーバレイも異なり、
異なるメジャーモードを持ち、バッファローカルな変数も異なります。

間接バッファはファイルを訪問できませんが、その基底バッファでは訪問できます。
間接バッファを保存しようとすると、実際にはその基底バッファを保存します。

        間接バッファを削除しても、その基底バッファには影響ありません。
基底バッファを削除すると、その間接バッファを実質的には削除することになり、
間接バッファをカレントバッファにはけっしてできなくなります。

      -- コマンド: make-indirect-buffer base-buffer name
          BASE-BUFFERを基底バッファとするNAMEという名前の
          間接バッファを作成する。
          引数BASE-BUFFERは、バッファか文字列である。

          BASE-BUFFERが間接バッファであると、
          その基底バッファを新たなバッファの基底バッファとして用いる。

      -- Function: buffer-base-buffer buffer
          この関数はBUFFERの基底バッファを返す。
          BUFFERが間接バッファでなければ、値は`nil'である。
          さもなければ、値は間接バッファではない別のバッファである。


File: elisp-ja,  Node: Buffer Gap,  Prev: Indirect Buffers,  Up: Buffers

26.12 バッファ ギャップ _(2003/10/30)_
==============================================

     Emacsのバッファは挿入や削除を高速にするために、目に見えない"ギャッ
プ"(gap)を使って実行されます。挿入はギャップの部分を埋めるように、削除
はギャップを加えるように働きます。もちろん、このことはギャップを挿入や
削除の軌跡上に最初に動かさなければならないということです。ユーザが挿入
や削除をしようとすると、Emacsはギャップだけを動かします。大きなバッファ
の一部だけを素早く編集できる方法であり、先に他の離れた部分を編集した後
だと、たまに大きな遅延を生じます。

この方法は目に触れない状態で動いてますし、Lispコードもギャップの現在一
に影響されるべきではありません。しかし、ギャップの状態を得るための関数
は利用できます。

      -- Function: gap-position
          カレントバッファで、現在ギャップがある位置を返します

      -- Function: gap-size
          カレントバッファで、今のギャップサイズを返します



File: elisp-ja,  Node: Windows,  Next: Frames,  Prev: Buffers,  Up: Top

27 ウィンドウ
******************

本章では、Emacsのウィンドウに関したほとんどの関数と変数について述べます。
ウィンドウにどのようにテキストが表示されるかに関しては、 *note
Display::を参照してください。

     * Menu:

     * Basic Windows::           Basic information on using windows.
     * Splitting Windows::       Splitting one window into two windows.
     * Deleting Windows::        Deleting a window gives its space to other windows.
     * Selecting Windows::       The selected window is the one that you edit in.
     * Cyclic Window Ordering::  Moving around the existing windows.
     * Buffers and Windows::     Each window displays the contents of a buffer.
     * Displaying Buffers::      Higher-lever functions for displaying a buffer
                                   and choosing a window for it.
     * Choosing Window::	    How to choose a window for displaying a buffer.
     * Window Point::            Each window has its own location of point.
     * Window Start::            The display-start position controls which text
                                   is on-screen in the window.
     * Vertical Scrolling::      Moving text up and down in the window.
     * Horizontal Scrolling::    Moving text sideways on the window.
     * Size of Window::          Accessing the size of a window.
     * Resizing Windows::        Changing the size of a window.
     * Coordinates and Windows:: Converting coordinates to windows.
     * Window Configurations::   Saving and restoring the state of the screen.
     * Window Hooks::            Hooks for scrolling, window size changes,
                                   redisplay going past a certain point,
                                   or window configuration changes.


File: elisp-ja,  Node: Basic Windows,  Next: Splitting Windows,  Up: Windows

27.1 Emacsウィンドウの基本概念
========================================

     Emacsの"ウィンドウ"（window）は、
バッファを表示するスクリーン上の物理的な領域のことです。
この用語は、Emacs Lispにおいて、当該物理領域を表す
Lispオブジェクトを意味するためにも使います。
どちらの意味かは文脈から明らかなはずです。

        Emacsではウィンドウをフレームにまとめています。
フレームは、Emacsが使えるスクリーンの領域を表します。
各フレームには少なくとも1つのウィンドウがつねにありますが、
フレームは上下や左右に重なり合わない複数のEmacsのウィンドウに分割できます。

ある時点では、各フレームには"フレームの選択されている"ウィンドウと
区別されるウィンドウがたった1つだけあります。
フレームのカーソルはそのようなウィンドウに現れます。
ある時点では、1つのフレームが選択されているフレームであり、
当該フレームで選択されているウィンドウが"選択されているウィンドウ"です。
選択されているウィンドウのバッファが、
（`set-buffer'を使った場合を除いて）普通はカレントバッファです。 *Note
Current Buffer::。

実用上、ウィンドウは、それがフレームに表示されている期間だけ存在します。
フレームからいったん取りさると、（ウィンドウへの参照が残っているとしても）
ウィンドウは実質的には削除され使えません。
保存したウィンドウ構成を復元する以外に、
スクリーンから消えたウィンドウを戻す方法はありません。 （*note Deleting
Windows::。）

        各ウィンドウにはつぎの属性があります。

        * ウィンドウを含んでいるフレーム

        * ウィンドウの高さ

        * ウィンドウの幅

        * スクリーンやフレームを基準にしたウィンドウの隅

        * ウィンドウが表示しているバッファ

        * ウィンドウの左上隅に対応するバッファ内の位置

        * コラム単位の水平方向のスクロール量

        * ポイント

        * マーク

        * どの程度最近にウィンドウが選択されたか

複数のバッファを同時に見られるようにユーザーは複数のウィンドウを作ります。
さまざまな理由でLispライブラリは複数のウィンドウを使いますが、
そのほとんどは、関連する情報を表示するためです。
たとえば、rmailでは、あるウィンドウのサマリバッファで移動すると、
別のウィンドウでは対応するメッセージを表示します。

        Emacsにおける『ウィンドウ』の意味は、
Xのような汎用目的のウィンドウシステムにおける意味に似ていますが、
同一ではありません。
Xウィンドウシステムは、スクリーン上にXのウィンドウを配置します。
Emacsは、1つか複数のXのウィンドウをフレームとして使い、
それらをEmacsのウィンドウに分割します。 文字端末でEmacsを使うと、
Emacsは端末のクリーン全体を1つのフレームとして扱います。

ほとんどのウィンドウシステムは、任意に重ね合わさったウィンドウを扱えます。
対照的に、Emacsのウィンドウは"タイル型"です。
つまり、互いに重なり合うことはなく、
スクリーンやフレームの全面に敷き詰められます。
Emacsが新たなウィンドウを作成する方法や
ウィンドウサイズの変更方法に起因するのですが、
Emacsのフレームを任意の形にウィンドウで敷き詰めることは、
実際には必ずしも可能であるとは限りません。 *note Splitting
Windows::と*Note Size of Window::。

ウィンドウのバッファの内容がどのようにウィンドウに表示されるかについては、
*Note Display::。

      -- Function: windowp object
          この関数は、OBJECTがウィンドウであれば`t'を返す。


File: elisp-ja,  Node: Splitting Windows,  Next: Deleting Windows,  Prev: Basic Windows,  Up: Windows

27.2 ウィンドウの分割
=============================

     ここで述べる関数は、ウィンドウを2つに分割するための基本関数です。
上位レベルの2つの関数、`pop-to-buffer'と`display-buffer'も
ウィンドウを分割しますが、 つねに分割するとは限りません（*note
Displaying Buffers::）。

        ここに述べる関数は、引数にはバッファを受け付けません。
分割されたウィンドウの2つの『部分』には、分割前に表示されていたのと
同じバッファが始めは表示されます。

      -- コマンド: split-window &optional window size horizontal
          この関数はWINDOWを2つのウィンドウに分割する。
          もとのウィンドウWINDOWは、選択されているウィンドウであり続けるが、
          以前のスクリーン領域の一部を占めるだけである。
          残りの部分は新たに作成されたウィンドウが占め、
          そのウィンドウがこの関数の値として返される。

          HORIZONTALが`nil'以外であると、WINDOWは左右に分かれる。
          もとのウィンドウWINDOWは左端のSIZEコラムに留まり、
          残りのコラムは新たなウィンドウに与えられる。
          さもなければ、ウィンドウは上下に分かれ、
          WINDOWは上側のSIZE行に留まり、
          残りの行は新たなウィンドウに与えられる。
          したがって、もとのウィンドウは左側か上側にあり、
          新たなウィンドウは右側か下側にある。

          WINDOWを省略したり`nil'であると、
          選択されているウィンドウを分割する。
          SIZEを省略したり`nil'であると、 WINDOWを均等に分ける。
          （余分な行は新たなウィンドウに与える。）
          `split-window'が対話的に呼び出されると、
          すべての引数は`nil'である。

          つぎの例では、50行×80コラムのスクリーン上の1つのウィンドウを分割する。

               (setq w (selected-window))
                    => #<window 8 on windows.texi>
               (window-edges)          ; 順に
                    => (0 0 80 50)     ;   左端-上端-右端-下端

               ;; 作成したウィンドウを返す
               (setq w2 (split-window w 15))
                    => #<window 28 on windows.texi>
               (window-edges w2)
                    => (0 15 80 50)    ; 下側のウィンドウの上端は15行目
               (window-edges w)
                    => (0 0 80 15)     ; 上側のウィンドウ

          スクリーンはつぎのようになる。

               　　　┌──────┐
               　　　│　　　　　　│ 0行目
               　　　│　　　ｗ　　│
               　　　│　　　　　　│
               　　　├──────┤
               　　　│　　　　　　│15行目
               　　　│　　　ｗ２　│
               　　　│　　　　　　│
               　　　└──────┘
               　　　　　　　　　　　50行目
               コラム0         コラム80

          つぎに上側のウィンドウを左右に分割する。

               (setq w3 (split-window w 35 t))
                    => #<window 32 on windows.texi>
               (window-edges w3)
                    => (35 0 80 15)  ; 左端は35コラム目
               (window-edges w)
                    => (0 0 35 15)   ; 右端は35コラム目
               (window-edges w2)
                    => (0 15 80 50)  ; 下側のウィンドウは未変更

          スクリーンはつぎのようになる。

                  コラム35
               　　　┌─┬────┐
               　　　│　│　　　　│ 0行目
               　　　│ｗ│　ｗ３　│
               　　　│　│　　　　│
               　　　├─┴────┤
               　　　│　　　　　　│15行目
               　　　│　　　ｗ２　│
               　　　│　　　　　　│
               　　　└──────┘
               　　　　　　　　　　　50行目
               コラム0         コラム80

          通常、Emacsは左右に並んだウィンドウの境界を
          スクロールバー（*note Scroll Bars: Window Frame
          Parameters.）か 文字`|'で表す。
          表示テーブルで境界に別の文字を指定できる。 *note Display
          Tables::を参照。

      -- コマンド: split-window-vertically size
          この関数は、選択されているウィンドウを上下に2つに分割する。
          上側が選択されているウィンドウのままで、SIZE行の大きさになる。
          （SIZEが負であると、下側のウィンドウが- SIZE行になり、
          上側のウィンドウは残りになる。
          しかし、それでも上側が選択されているウィンドウである。）

          この関数は`split-window'の単なるインターフェイスである。
          その完全な関数定義はつぎのとおりである。

               (defun split-window-vertically (&optional arg)
                 "Split current window into two windows, ..."
                 (interactive "P")
                 (split-window nil (and arg (prefix-numeric-value arg))))

      -- コマンド: split-window-horizontally size
          この関数は、選択されているウィンドウを左右に2つに分割し、
          選択されているウィンドウにはSIZEコラム残す。

          この関数は`split-window'の単なるインターフェイスである。
          `split-window-horizontally'の完全な関数定義は
          （説明文字列を除けば）つぎのとおりである。

               (defun split-window-horizontally (&optional arg)
                 "Split selected window into two windows, side by side..."
                 (interactive "P")
                 (split-window nil (and arg (prefix-numeric-value arg)) t))

      -- Function: one-window-p &optional no-mini all-frames
          この関数は、ウィンドウがたった1つしかなければ`nil'以外を返す。
          引数NO-MINIが`nil'以外であると、
          ミニバッファが活性であってもそれを数えないことを意味する。
          さもなければ、ミニバッファが活性であればそれも総ウィンドウ個数に数えて
          1と比較する。

          引数ALL-FRAMESは、どのフレームを対象にするかを指定する。
          指定できる値とその意味はつぎのとおりである。

         `nil'
               選択されているフレームのウィンドウに加えて、
               ミニバッファがどこに置かれていようと
               当該フレームが使っているミニバッファを数える。

         `t'
               既存のすべてのフレームのウィンドウを数える。

         `visible'
               すべての可視フレームのすべてのウィンドウを数える。

         0
               すべての可視フレームやアイコンになっているフレームの
               すべてのウィンドウを数える。

         その他
               選択されているフレームだけでウィンドウを正確に数える。


File: elisp-ja,  Node: Deleting Windows,  Next: Selecting Windows,  Prev: Splitting Windows,  Up: Windows

27.3 ウィンドウの削除
=============================

     ウィンドウを削除するある種の関数を呼び出して
ウィンドウを"削除"しない限り、
ウィンドウはそのフレームに表示され続けます。
削除されたウィンドウがスクリーンに現れることはありませんが、
それを参照するものがある限りLispオブジェクトととしては 存在し続けます。
保存したウィンドウ構成（*note Window
Configurations::）を復元する以外には、
ウィンドウの削除は取り消せません。 ウィンドウ構成を復元すると、
その構成に含まれないウィンドウはすべて削除されます。

        ウィンドウを削除すると、それが使っていた場所は
近接する兄弟ウィンドウの1つに与えられます。

      -- Function: window-live-p window
          この関数は、WINDOWが削除されていると`nil'を返し、
          さもなければ`t'を返す。

          *警告：*` ' 削除されたウィンドウを正しいものとして使うと、
          誤った情報や重大なエラーを引き起こす。

      -- コマンド: delete-window &optional window
          この関数は、ディスプレイからWINDOWを取りさり、`nil'を返す。
          WINDOWを省略すると、選択されているウィンドウを削除する。
          `delete-window'を呼び出したときにたった1つのウィンドウしかないと
          エラーを通知する。

      -- コマンド: delete-other-windows &optional window
          この関数は、WINDOWのフレームにある他のウィンドウを削除して
          WINDOWを当該フレームで唯一のウィンドウにする。
          WINDOWを省略したり`nil'であると、
          選択されているウィンドウをデフォルトで使う。

          これは`nil'を返す。

      -- コマンド: delete-windows-on buffer &optional frame
          この関数は、BUFFERを表示しているすべてのウィンドウを削除する。
          BUFFERを表示しているウィンドウがなければなにもしない。

          `delete-windows-on'はフレームを1つ1つ処理する。
          フレームに異なるバッファを表示しているウィンドウが複数ある場合、
          それらのうちでBUFFERを表示しているものを削除し、
          他のものは空いた領域を埋めるために拡張される。
          あるフレームのすべてのウィンドウ（たった1つのウィンドウである場合も含む）
          がBUFFERを表示している場合、当該フレームは、
          `other-buffer'で選ばれる別のバッファを表示する
          1つのウィンドウだけになる。 *note The Buffer List::。

          引数FRAMEは、どのフレームを対象にするかを指定する。
          この関数は、すべてのウィンドウを走査する他の関数と同じようには
          FRAMEを使わない。
          特に、`t'と`nil'の値の意味は他の関数とは逆である。
          以下に詳細を示す。

             * `nil'であると、すべてのフレームを対象にする。

             * `t'であると、選択されているフレームを対象にする。

             * `visible'であると、すべての可視フレームを対象にする。

             *
               0であると、すべての可視フレームやアイコンになっているフレームを対象にする。

             * フレームであると、当該フレームを対象にする。

          この関数はつねに`nil'を返す。


File: elisp-ja,  Node: Selecting Windows,  Next: Cyclic Window Ordering,  Prev: Deleting Windows,  Up: Windows

27.4 ウィンドウの選択
=============================

ウィンドウを選択すると、当該ウィンドウのバッファがカレントバッファになり、
カーソルがそのウィンドウに現れます。

      -- Function: selected-window
          この関数は、選択されているウィンドウを返す。
          カーソルが表示され多くのコマンドが作用するウィンドウがそれである。

      -- Function: select-window window
          この関数は、WINDOWを選択されているウィンドウにする。
          すると、カーソルは（再表示すると）WINDOWに現れる。
          WINDOWに表示されているバッファがただちにカレントバッファになる。

          戻り値はWINDOWである。

               (setq w (next-window))
               (select-window w)
                    => #<window 65 on windows.texi>

      -- Macro: save-selected-window forms...
          このマクロは、選択されているウィンドウを記録して、
          FORMSを順に実行し、 もとの選択されているウィンドウに戻す。

          このマクロは、ウィンドウサイズ、配置、内容に関して
          いっさいなにも保存したり復元しないので、
          FORMSがそれらを変更するとその変更は持続する。

          ある時点で、各フレームにはフレームの選択されているウィンドウがある。
          このマクロは、選択されているウィンドウ_だけ_を保存し、
          他のフレームについてはなにも保存しない。
          FORMSが別のフレームを選択して
          そのフレームの選択されているウィンドウを変更すると、その変更は持続する。

以下の関数は、さまざま条件でスクリーン上のウィンドウの1つを選びます。

      -- Function: get-lru-window &optional frame
          この関数は、もっとも昔に『使われた』
          （つまり選択されていた）ウィンドウを返す。
          選択されているウィンドウはつねにもっとも最近に使われたウィンドウである。

          ウィンドウがたった1つであると、 選択されているウィンドウが
          もっとも昔に使われたウィンドウであることもありうる。
          新たに作成されたウィンドウは、選択されるまではもっとも昔に
          使われたウィンドウになる。
          ミニバッファ用ウィンドウは候補にはならない。

          引数FRAMEは、どのウィンドウを対象とするかを制御する。

             *
               `nil'であると、選択されているフレームのウィンドウを対象とする。

             * `t'であると、すべてのフレームのウィンドウを対象とする。

             * `visible'であると、
               すべての可視フレームのウィンドウを対象とする。

             *
               0であると、すべての可視フレームやアイコンになっているフレーム
               のウィンドウを対象にする。

             * フレームであると、当該フレームのウィンドウを対象にする。

      -- Function: get-largest-window &optional frame
          この関数は、もっとも大きな領域（高さ×幅）のウィンドウを返す。
          左右に並んだウィンドウがなければ、
          これがもっとも行数を持つウィンドウである。
          ミニバッファ用ウィンドウは候補にはならない。

          同じ大きさのウィンドウが2つある場合、
          この関数は、選択されているウィンドウから始めて
          ウィンドウの巡回順序（次節参照）で最初のウィンドウを返す。

          引数FRAMEは、ウィンドウのどのような集まりを対象にするかを指定する。
          うえの`get-lru-window'を参照。


File: elisp-ja,  Node: Cyclic Window Ordering,  Next: Buffers and Windows,  Prev: Selecting Windows,  Up: Windows

27.5 ウィンドウの巡回順序
===================================

     つぎのウィンドウを選択するためにコマンド`C-x o'（`other-window'）を
使うと、スクリーン上のすべてのウィンドウをある巡回順序で巡ります。
ウィンドウのある構成において、この順序は変わりません。
これを"ウィンドウの巡回順序"（cyclic ordering of windows）と呼びます。

        この順番は一般に上から下、左から右になります。
しかし、ウィンドウを分割した順番に依存して、
下や右が最初になることもあります。

        最初に上下に分割してつぎに左右に分割すると、
順番は、フレームの上側で左から右、フレームのその下では左から右
といった具合になります。 最初に左右に分割すると、
順番は、フレームの左側で上から下といった具合になります。
一般に、ウィンドウ木のあるレベルで分割された各兄弟の中では、
順番は、左から右、あるいは、上から下になります。

      -- Function: next-window &optional window minibuf all-frames
          この関数は、ウィンドウの巡回順序においてWINDOWのつぎの
          ウィンドウを返す。 これは、WINDOWが選択されているときに `C-x
          o'が選択するであろうウィンドウである。
          WINDOWが唯一の可視ウィンドウであると、
          この関数はWINDOWを返す。
          WINDOWを省略すると、デフォルトは選択されているウィンドウである。

          引数MINIBUFの値は、ミニバッファを
          ウィンドウの順序に含めるかどうかを決定する。
          MINIBUFが`nil'であると、
          ミニバッファが活性であるときにはミニバッファを含める。
          これは`C-x o'のふるまいである。
          （ミニバッファが使われているあいだは、
          ミニバッファ用ウィンドウは活性である。 *note Minibuffers::。）

          MINIBUFが`t'であると、
          ミニバッファが活性でなくても巡回順序にミニバッファ用ウィンドウを含める。

          MINIBUFが`t'でも`nil'でもないと、
          活性であってもミニバッファ用ウィンドウを含めない。

          引数ALL-FRAMESは、どのフレームを対象にするかを指定する。
          可能な値とその意味を以下に示す。

         `nil'
               WINDOWのフレームのすべてのウィンドウに加えて、
               ミニバッファがどこに置かれていようと
               当該フレームが使っているミニバッファを対象にする。

         `t'
               既存のすべてのフレームのすべてのウィンドウを対象にする。

         `visible'
               すべての可視フレームのすべてのウィンドウを対象にする。
               （結果が有用であるためには、可視フレームにWINDOWがあること）

         0
               すべての可視フレームやアイコンになっているフレームの
               すべてのウィンドウを対象にする。

         その他
               WINDOWのフレームだけのウィンドウを正確に対象にする。

          つぎの例では、2つのウィンドウがあり、
          どちらもバッファ`windows.texi'を表示していると仮定する。

               (selected-window)
                    => #<window 56 on windows.texi>
               (next-window (selected-window))
                    => #<window 52 on windows.texi>
               (next-window (next-window (selected-window)))
                    => #<window 56 on windows.texi>

      -- Function: previous-window &optional window minibuf all-frames
          この関数は、ウィンドウの巡回順序においてWINDOWのまえの
          ウィンドウを返す。 他の引数は、`next-window'と同様に、
          どのようなウィンドウを巡回に含めるかを指定する。

      -- コマンド: other-window count
          この関数は、ウィンドウの巡回順序においてCOUNT番目うしろの
          ウィンドウを選択する。 COUNTが負であると、巡回順序において
          -COUNT番目まえのウィンドウに戻る。 この関数は`nil'を返す。

          対話的に呼び出すと、COUNTは数値前置引数である。

      -- Function: walk-windows proc &optional minibuf all-frames
          この関数は、各ウィンドウごとに当該ウィンドウを唯一の引数として
          PROCを呼び出してすべてのウィンドウを巡る。

          省略可能な引数MINIBUFとALL-FRAMESは、
          走査するウィンドウの集まりを指定する。
          詳しくは上記の`next-window'を参照。


File: elisp-ja,  Node: Buffers and Windows,  Next: Displaying Buffers,  Prev: Cyclic Window Ordering,  Up: Windows

27.6 バッファとウィンドウ
===================================

     本節では、ウィンドウを調べたり、
正確に制御してウィンドウにバッファを表示する低レベルの関数について述べます。
使用するウィンドウを探したりそれにバッファを指定する関連する関数については、
*Note Displaying Buffers::。
そこに述べた関数は本節の関数より簡単に使えますが、
それらはウィンドウを選んだり作ったりするときに発見的手法を使います。
完全に制御する必要があるときには、本節の関数を使います。

      -- Function: set-window-buffer window buffer-or-name
          この関数は、WINDOWの内容としてBUFFER-OR-NAMEを表示するようにする。
          この関数は`nil'を返す。
          これは、ウィンドウに表示するバッファを切り替える
          もっとも基本の基本関数であり、
          他の切り替え関数はこの関数を呼び出す。

               (set-window-buffer (selected-window) "foo")
                    => nil

      -- Function: window-buffer &optional window
          この関数は、WINDOWに表示しているバッファを返す。
          WINDOWを省略すると、この関数は選択されているウィンドウのバッファを返す。

               (window-buffer)
                    => #<buffer windows.texi>

      -- Function: get-buffer-window buffer-or-name &optional all-frames
          この関数は、現在BUFFER-OR-NAMEを表示しているウィンドウを返す。
          そのようなウィンドウがなければ`nil'を返す。
          そのようなウィンドウが複数ある場合、
          ウィンドウの巡回順序において選択されているウィンドウから始めて
          最初にみつかったウィンドウを返す。 *note Cyclic Window
          Ordering::。

          引数ALL-FRAMESは、どのウィンドウを対象とするかを制御する。

             *
               `nil'であると、選択されているフレームのウィンドウを対象とする。

             * `t'であると、すべてのフレームのウィンドウを対象とする。

             * `visible'であると、
               すべての可視フレームのすべてのウィンドウを対象にする。

             *
               0であると、すべての可視フレームやアイコンになっているフレーム
               のウィンドウを対象にする。

             * フレームであると、当該フレームのウィンドウを対象にする。

      -- Function: get-buffer-window-list buffer-or-name &optional
               minibuf all-frames
          この関数は、現在BUFFER-OR-NAMEを表示している
          すべてのウィンドウのリストを返す。

          省略可能な2つの引数は、`next-window'（*note Cyclic Window
          Ordering::）の 省略可能な引数と同様に働き、
          `get-buffer-window'の省略可能な単一の引数と同じでは_ない_。
          `get-buffer-window'を他の関数と互換性があるように
          将来変更すべきなのであろう。

          引数ALL-FRAMESは、どのウィンドウを対象とするかを制御する。

             *
               `nil'であると、選択されているフレームのウィンドウを対象とする。

             * `t'であると、すべてのフレームのウィンドウを対象とする。

             * `visible'であると、
               すべての可視フレームのすべてのウィンドウを対象にする。

             *
               0であると、すべての可視フレームやアイコンになっているフレーム
               のウィンドウを対象にする。

             * フレームであると、当該フレームのウィンドウを対象にする。

      -- Variable: buffer-display-time
          この変数は、バッファがウィンドウで見えるようになった最後の時刻を記録する。
          この変数は各バッファでつねにバッファローカルであり、
          `set-window-buffer'は、呼ばれるたびに
          指定されたバッファのこの変数に`(current-time)'を設定する
          （*note Time of Day::）。
          バッファが初めて作られると、`buffer-display-time'は値`nil'で始まる。


File: elisp-ja,  Node: Displaying Buffers,  Next: Choosing Window,  Prev: Buffers and Windows,  Up: Windows

27.7 ウィンドウへのバッファの表示
===============================================

     本節では、ウィンドウを自動的に選びそれに指定したバッファを表示する
便利な関数について述べます。
これらの関数は、ある状況では、既存のウィンドウを分割します。
ウィンドウを選ぶ際の発見的手法を制御する変数についても述べます。
より正確に制御するための低レベルの関数については、 *Note Buffers and
Windows::。
これらの関数はすべて`set-window-buffer'を呼び出して動作します。

バッファをカレントバッファにしてLispプログラムで参照したり変更できるように
するためには、本節の関数を使わないでください。
これらはその目的には強力すぎます。
ウィンドウのバッファの表示をユーザーにとっては迷惑で驚くようなものに
変更してしまうからです。
そのかわりに、ウィンドウのバッファの表示には影響せずに
バッファをプログラムから参照するためにカレントバッファにする
`set-buffer'と`save-current-buffer'（*note Current Buffer::）を
使います。

      -- コマンド: switch-to-buffer buffer-or-name &optional norecord
          この関数は、BUFFER-OR-NAMEをカレントバッファにし、
          さらに、選択されているウィンドウに当該バッファを表示する。
          つまり、人間が当該バッファを見ることができるようになり、
          以降のキーボードコマンドは当該バッファに適用される。
          BUFFER-OR-NAMEをカレントバッファにするが
          選択されているウィンドウには表示しない`set-buffer'と比較してほしい。
          *note Current Buffer::。

          BUFFER-OR-NAMEが既存のバッファを指定しなければ、
          その名前の新たなバッファが作成される。
          新たなバッファのメジャーモードは変数`default-major-mode'に
          従って設定される。 *note Auto Major Mode::。

          通常、指定したバッファはバッファリスト
          （選択されているフレームのバッファリストとフレーム独立のバッファリストの
          両方）の先頭に置かれる。
          これは、`other-buffer'の動作に影響する。
          しかし、NORECORDが`nil'以外であると、これを行わない。 *note
          The Buffer List::。

          関数`switch-to-buffer'は、しばしば、 `C-x
          b'にバインドされて対話的に使われる。
          プログラムでも多用される。 つねに`nil'を返す。

      -- コマンド: switch-to-buffer-other-window buffer-or-name
               &optional norecord
          この関数は、BUFFER-OR-NAMEをカレントバッファにし、
          現在選択されていないウィンドウに当該バッファを表示する。
          そして当該ウィンドウを選択する。
          バッファの扱い方は`switch-to-buffer'と同じである。

          現在選択されているウィンドウは、この処理には絶対に使わない。
          それが唯一のウィンドウである場合には、この目的のために
          ウィンドウを分割して別のウィンドウを作る。
          選択されているウィンドウがすでに当該バッファを表示している場合には、
          当該ウィンドウはそのまま表示し続けるが、それにも関わらず、
          表示するために別のウィンドウを探す。

          この関数は、NORECORDが`nil'であると、
          `switch-to-buffer'のようにバッファリストを更新する。

      -- Function: pop-to-buffer buffer-or-name &optional other-window
               norecord
          この関数は、BUFFER-OR-NAMEをカレントバッファにし、
          以前には選択されていない別のウィンドウで当該バッファに切り替える。
          そのウィンドウがそのフレームの選択されているウィンドウになる。

          変数`pop-up-frames'が`nil'以外であると、
          `pop-to-buffer'は、可視フレームから
          当該バッファをすでに表示しているウィンドウを探す。
          そのようなウィンドウがあれば、そのウィンドウを返すとともに、
          そのウィンドウをそのフレームの選択されているウィンドウにする。
          そのようなウィンドウがなければ、新たなフレームを作成し
          それにバッファを表示する。

          `pop-up-frames'が`nil'であると、
          `pop-to-buffer'は選択されているフレーム内だけで処理を行う。
          （選択されているフレームがミニバッファのみであるときには、
          `pop-to-buffer'は、ミニバッファのみでない
          もっとも最近に選択されたフレーム内で処理する。）

          変数`pop-up-windows'が`nil'以外であると、
          もとのウィンドウとは異なる新たなウィンドウを作成するために
          ウィンドウを分割することがある。 詳しくは、*note Choosing
          Window::を参照。

          OTHER-WINDOWが`nil'以外であると、
          選択されているウィンドウにBUFFER-OR-NAMEがすでに表示されていても、
          `pop-to-buffer'は別のウィンドウを探したり作成する。
          そのため、BUFFER-OR-NAMEは2つのウィンドウに表示されることになる。
          一方で、BUFFER-OR-NAMEが選択されているウィンドウに
          すでに表示されていて、かつ、OTHER-WINDOWが`nil'であると、
          選択されているウィンドウはBUFFER-OR-NAMEの表示には十分であるとみなし、
          なにも行わない。

          `display-buffer'に影響するすべての変数は、
          `pop-to-buffer'にも影響する。 *note Choosing Window::。

          BUFFER-OR-NAMEが文字列であり既存のバッファを指定しない場合、
          その名前のバッファを作成する。
          新たなバッファのメジャーモードは変数`default-major-mode'に
          従って設定される。 *note Auto Major Mode::。

          この関数は、NORECORDが`nil'であると、
          `switch-to-buffer'のようにバッファリストを更新する。

      -- コマンド: replace-buffer-in-windows buffer
          この関数は、BUFFERを表示しているすべてのウィンドウにおいて
          BUFFERを別のバッファに切り替える。
          別のバッファは`other-buffer'で選ぶ。
          この関数の普通の用途は、別のバッファがどれになるか気にしない場合である。
          つまり、BUFFERが表示されていないことを保証したい場合である。

          この関数は`nil'を返す。


File: elisp-ja,  Node: Choosing Window,  Next: Window Point,  Prev: Displaying Buffers,  Up: Windows

27.8 表示ウィンドウを選ぶ
===================================

本節では、バッファを表示するためのウィンドウを選ぶための基本的な機能、
`display-buffer'について述べます。
上位レベルの関数やコマンドはすべてこのサブルーティンを使います。
ここでは、`display-buffer'の使い方とカスタマイズ方法を説明します。

      -- コマンド: display-buffer buffer-or-name &optional
               not-this-window frame
          このコマンドは、`pop-to-buffer'のように、
          BUFFER-OR-NAMEをあるウィンドウに表示するが、
          そのウィンドウを選択しないので当該バッファもカレントバッファにならない。
          この関数は、選択されているウィンドウを変えない。

          NOT-THIS-WINDOWが`nil'以外であると、
          指定したバッファが選択されているウィンドウにすでに表示されていても、
          別のウィンドウに当該バッファを表示することを意味する。
          これにより、当該バッファが同時に2つのウィンドウに表示される。
          さもなければ、BUFFER-OR-NAMEがウィンドウにすでに表示されていると、
          それで十分とみなしこの関数はなにもしない。

          `display-buffer'は、BUFFER-OR-NAMEを表示するために
          選んだウィンドウを返す。

          引数FRAMEが`nil'以外であると、
          バッファがすでに表示されているかどうかを検査するときに
          どのフレームを対象とするかを指定する。
          それらのフレームのどれかのウィンドウに当該バッファがすでに表示されていると、
          `display-buffer'は単にそのウィンドウを返す。
          FRAMEの可能な値はつぎのとおりである。

             *
               `nil'であると、選択されているフレームのウィンドウを対象とする。

             * `t'であると、すべてのフレームのウィンドウを対象とする。

             * `visible'であると、
               すべての可視フレームのすべてのウィンドウを対象にする。

             *
               0であると、すべての可視フレームやアイコンになっているフレーム
               のウィンドウを対象にする。

             * フレームであると、当該フレームのウィンドウを対象にする。

          `display-buffer'がウィンドウを作成したり探す詳しい手順は、
          以下に述べる変数に依存する。

      -- User Option: pop-up-windows
          この変数は、`display-buffer'が新たにウィンドウを作るかどうかを制御する。
          `nil'以外であり、かつ、ウィンドウがたった1つである場合、
          そのウィンドウを分割する。 `nil'であると、`display-buffer'は
          単一のウィンドウを分割せずにそれ全体を使う。

      -- User Option: split-height-threshold
          この変数は、ウィンドウが複数ある場合に
          `display-buffer'がどの時点でウィンドウを分割するかを決定する。
          `display-buffer'は、最大ウィンドウの行数が
          この変数による指定行数より大きければ、最大ウィンドウをつねに分割する。
          最大ウィンドウがこれだけ大きくない場合には、
          それが唯一のウィンドウであり、かつ、`pop-up-windows'が`nil'以外
          の場合にのみ最大ウィンドウを分割する。

      -- User Option: pop-up-frames
          この変数は、`display-buffer'が新たなフレームを作るかどうかを制御する。
          `nil'以外であると、`display-buffer'は、
          すべての可視フレームから指定されたバッファをすでに表示している
          既存のウィンドウを探す。
          そのようなウィンドウがあれば、そのウィンドウを返す。
          さもなければ、新たなフレームを作る。
          変数`pop-up-frames'が`nil'以外であると、
          変数`pop-up-windows'と`split-height-threshold'は影響しない。

          `pop-up-frames'が`nil'であると、
          `display-buffer'はウィンドウを分割するか再利用する。

          詳しくは、*note Frames::。

      -- Variable: pop-up-frame-function
          この変数は、`pop-up-frames'が`nil'以外であるときに
          どのように新たなフレームを作るかを指定する。

          その値は引数なしの関数であること。
          `display-buffer'が新たにフレームを作るとき、
          フレームを返すこの関数を呼び出す。 この変数のデフォルト値は、
          `pop-up-frame-alist'のパラメータを使って新たなフレームを作る関数である。

      -- Variable: pop-up-frame-alist
          この変数は、`display-buffer'が新たにフレームを作るときに
          使用するフレームパラメータを指定する連想リストを保持する。
          フレームパラメータに関して詳しくは、 *note Frame
          Parameters::。

      -- User Option: special-display-buffer-names
          特別に表示すべきバッファのバッファ名のリスト。
          バッファ名がこのリストにあると、
          `display-buffer'は当該バッファを特別に扱う。

          デフォルトでは、特別に表示するとは、
          専用のフレームにバッファを表示することである。

          リストの要素が文字列でなくリストであると、
          リストのCARがバッファ名であり、
          リストの残りはフレームの作成方法を指定する。
          それは、フレームパラメータを指定する連想リストであるか、
          関数とそれに渡す引数である。
          （関数の第1引数はつねに表示すべきバッファである。
          そのあとにリスト内の引数が続く。）

      -- User Option: special-display-regexps
          特別に表示すべきバッファを指定する正規表現のリスト。
          バッファ名がこのリストのいずれかの正規表現に一致すると、
          `display-buffer'は当該バッファを特別に扱う。

          デフォルトでは、特別に表示するとは、
          専用のフレームにバッファを表示することである。

          リストの要素が文字列でなくリストであると、
          リストのCARが正規表現であり、
          リストの残りはフレームの作成方法を指定する。
          上記の`special-display-buffer-names'を参照。

      -- Variable: special-display-function
          この変数は、バッファを特別に表示するために呼び出す関数を保持する。
          引数としてバッファを受け取り、
          当該バッファを表示したウィンドウを返すこと。

          この関数のデフォルト値は`special-display-popup-frame'である。

      -- Function: special-display-popup-frame buffer
          この関数は、BUFFERをそれ専用のフレームに表示する。
          あるフレームのウィンドウにBUFFERがすでに表示されている場合、
          当該ウィンドウを使うために当該フレームを可視にし手前に持ってくる。
          さもなければ、BUFFER用にフレームを作成する。

          この関数は、BUFFERを表示している既存のウィンドウのフレームで
          当該バッファだけを表示しているかどうかに関わらず、
          既存の当該ウィンドウを使う。
          しかし、BUFFERを作るまえに読者の初期化ファイルで上記の変数に設定
          しているときには、当該ウィンドウは以前にこの関数が作成したものであろう。

      -- User Option: special-display-frame-alist
          この変数は、`special-display-popup-frame'がフレームを作るときに
          使用するフレームパラメータを保持する。

      -- User Option: same-window-buffer-names
          選択されているウィンドウに表示すべきバッファのバッファ名のリスト。
          バッファ名がこのリストにあると、
          `display-buffer'は選択されているウィンドウで当該バッファに切り替える。

      -- User Option: same-window-regexps
          選択されているウィンドウに表示すべきバッファを指定する正規表現のリスト。
          バッファ名がこのリストのいずれかの正規表現に一致すると、
          `display-buffer'は選択されているウィンドウで当該バッファに切り替える。

      -- Variable: display-buffer-function
          この変数は、`display-buffer'のふるまいをカスタマイズする
          もっとも柔軟な方法である。
          `nil'以外であると、`display-buffer'が処理を依頼するために
          呼び出す関数であること。
          その関数は、`display-buffer'が受け取るのと同じ2つの引数を受け付けること。
          その関数は、ウィンドウを選ぶか作成し、指定されたバッファを表示し、
          当該ウィンドウを返すこと。

          このフックは、上に述べた他のオプションやフックすべてに優先する。

        ウィンドウにはそのバッファ『専用』と印を付けられます。
そうすると、`display-buffer'は他のバッファを表示するために
当該ウィンドウを使わないようにします。

      -- Function: window-dedicated-p window
          この関数は、WINDOWに専用と印が付いていれば`t'を返し、
          さもなければ`nil'を返す。

      -- Function: set-window-dedicated-p window flag
          この関数は、FLAGが`nil'以外であるとWINDOWに専用の印を付け、
          さもなければ専用の印を消す。


File: elisp-ja,  Node: Window Point,  Next: Window Start,  Prev: Choosing Window,  Up: Windows

27.9 ウィンドウとポイント
===================================

     各ウィンドウには、同じバッファを表示している
別のウィンドウのポイントの値とは独立な独自のポイントの値があります。
これにより、あるバッファを複数のウィンドウに表示しても有用なのです。

        *
          ウィンドウのポイントは、ウィンドウを最初に作成したときに確立される。
          バッファのポイントか、バッファをすでに表示しているウィンドウがあれば
          そのウィンドウのポイントで初期化される。

        * ウィンドウを選択すると、ウィンドウのポイント値が
          そのバッファのポイント値になる。
          逆に、ウィンドウの選択をやめると、
          バッファのポイント値がウィンドウのポイント値になる。
          したがって、同じバッファを表示している複数のウィンドウのあいだで
          切り替えると、選択されているウィンドウではウィンドウのポイント値が
          当該バッファで有効になり、
          選択されていない他のウィンドウの各ポイント値は、
          それぞれのウィンドウに保持される。

        * 選択されているウィンドウがカレントバッファを表示し続ける限り、
          ウィンドウのポイントとバッファのポイントはともに動いて、
          両者は同じであり続ける。

        * バッファ内位置について詳しくは、*note Positions::。

        ユーザーにとっては、ポイントとはカーソルが置かれた箇所であり、
別のバッファに切り替えるとそのバッファのポイント位置に
カーソルが移動します。

      -- Function: window-point window
          この関数は、WINDOWの現在のポイント位置を返す。
          選択されていないウィンドウでは、
          当該ウィンドウを選択したときになるであろう
          （ウィンドウのバッファの）ポイント値である。

          WINDOWが選択されているウィンドウであり、かつ、
          そのバッファがカレントバッファであれば、
          戻り値は当該バッファのポイントと同じである。

          厳密にいえば、すべてのフォーム`save-excursion'の外側での
          『トップレベル』のポイントの値を返すほうがより正確である。
          しかし、そのような値を探すのは困難である。

      -- Function: set-window-point window position
          この関数は、WINDOWのバッファ内の位置POSITIONを
          WINDOWのポイント位置とする。


File: elisp-ja,  Node: Window Start,  Next: Vertical Scrolling,  Prev: Window Point,  Up: Windows

27.10 ウィンドウの開始位置
====================================

     各ウィンドウには、バッファのどの箇所から表示を始めるかを指定する
バッファ内位置を追跡するために使うマーカがあります。
この位置をウィンドウの"表示開始"（display-start）位置
（あるいは単に"開始"（start）位置）と呼びます。
この位置の直後にある文字が、ウィンドウの左上隅に現れます。
この位置は、通常、テキスト行の先頭にありますが、必須ではありません。

      -- Function: window-start &optional window
          この関数は、ウィンドウWINDOWの表示開始位置を返す。
          WINDOWが`nil'であると、 選択されているウィンドウを使う。
          たとえばつぎのとおりである。

               (window-start)
                    => 7058

          新たにウィンドウを作成したり異なるバッファをウィンドウに表示すると、
          表示開始位置は、当該バッファの最近に使われた表示開始位置になるか、
          バッファに表示開始位置がなければ1になる。

          再表示するとウィンドウ開始位置は
          （それ以前の再表示で明示的に位置を指定していなければ）、
          ポイントがスクリーンに現れるように更新される。
          再表示以外には、ウィンドウ開始位置を自動的に変更しない。
          ポイントを移動しても、つぎの再表示までは、
          連動してウィンドウ開始位置が変更されると期待しないこと。

          `window-start'を使った実際的な例は、 *note Text
          Lines::の`count-lines'の記述を参照。

      -- Function: window-end &optional window update
          この関数は、ウィンドウWINDOWの表示の末尾の位置を返す。
          WINDOWが`nil'であると、選択されているウィンドウを使う。

          バッファのテキストを変更したりポイントを移動しただけでは、
          `window-end'が返す値は更新されない。
          この値は、Emacsが再表示を実行し途中で止めることなく
          最後まで終了した場合にのみ更新される。

          WINDOWの最後の再表示が途中で止められて完了していないと、
          当該ウィンドウの表示の末尾の位置はEmacsにはわからない。

          UPDATEが`nil'以外であると、
          `window-end'はウィンドウの末尾の更新値をつねに返す。
          保存しておいた値が正しければ`window-end'はそれを返す。
          さもなければ、バッファのテキストを走査して正しい値を計算する。

      -- Function: set-window-start window position &optional noforce
          この関数は、WINDOWの表示開始位置を
          WINDOWのバッファ内の位置POSITIONとする。
          これはPOSITIONを返す。

          表示ルーティンは、バッファを表示するときには
          ポイント位置が可視であることを強要する。
          通常、表示ルーティンは、ポイントを可視にするために必要なときには
          表示開始位置を（つまりウィンドウをスクロールして）変更する。
          しかし、NOFORCEに`nil'を指定してこの関数で開始位置を指定すると、
          ポイント位置がスクリーンからはみ出したとしても、
          表示開始位置をPOSITIONとすることを意味する。
          ポイントがスクリーンからはみ出す場合には、
          表示ルーティンはウィンドウの中央行の左端にポイントを移動する。

          たとえば、ポイントが1にあるときに
          ウィンドウの開始位置を2にしたとすると、
          ポイントはウィンドウの上端より『上』になる。
          表示ルーティンは、再表示時にポイントが1のままであると
          自動的にポイントを移動する。 以下に例を示す。

               ;; 式`set-window-start'を実行するまえの
               ;; `foo'の見え方

               ---------- Buffer: foo ----------
               -!-This is the contents of buffer foo.
               2
               3
               4
               5
               6
               ---------- Buffer: foo ----------

               (set-window-start
                (selected-window)
                (1+ (window-start)))
               => 2

               ;; 式`set-window-start'を実行したあとの
               ;; `foo'の見え方
               ---------- Buffer: foo ----------
               his is the contents of buffer foo.
               2
               3
               -!-4
               5
               6
               ---------- Buffer: foo ----------

          NOFORCEが`nil'以外であって
          POSITIONにするとつぎの再表示時にポイントがスクリーンからはみ出す
          場合には、再表示ではポイントが収まるように新たなウィンドウ開始位置を
          計算し、POSITIONを使わない。

      -- Function: pos-visible-in-window-p &optional position window
          この関数は、WINDOW内のPOSITIONがスクリーン上で
          現在可視なテキストの範囲内にあれば`t'を返す。
          POSITIONがスクリーンの上下端からはみ出す場合には`nil'を返す。
          引数POSITIONのデフォルトはポイントの現在位置であり、
          WINDOWのデフォルトは選択されているウィンドウである。
          例を示す。

               (or (pos-visible-in-window-p
                    (point) (selected-window))
                   (recenter 0))

          関数`pos-visible-in-window-p'は、垂直方向のスクロールだけを考慮する。
          WINDOWを水平方向にスクロールしたために
          POSITIONがはみ出している場合には、
          `pos-visible-in-window-p'は`t'を返す。 *note Horizontal
          Scrolling::。


File: elisp-ja,  Node: Vertical Scrolling,  Next: Horizontal Scrolling,  Prev: Window Start,  Up: Windows

27.11 垂直スクロール
===========================

垂直スクロールとは、ウィンドウ内のテキストを上向きや下向きに動かすことです。
ウィンドウの表示開始位置の値を変更することで動作します。
ポイントがスクリーン内に留まるように`window-point'の
値を変更することもあります。

        コマンド`scroll-up'や`scroll-down'の
方向を示す『up』（上向き）と『down』（下向き）は、
ウィンドウを見ているときのバッファ内のテキストの移動方向を表します。
テキストは縦に長い紙に（横書きで）書いてあり、
スクロールコマンドはその紙を上下に動かすと想像してください。
したがって、バッファの中ほどのテキストを見ているときに
`scroll-down'を繰り返し呼び出すと、
最終的にはバッファの先頭を見ることになります。

        逆の慣習の名前を使うべきだと主張する人々もいます。
彼らは、固定されたテキストのうえをウィンドウが動いていると想像するのです。
すると、『下向き』のコマンドはバッファの末尾に移動することになります。
この見方は、ウィンドウとバッファ内のテキストとの実際の関係に
よく適合しているのですが、ユーザーはそのように考えないようです。
端末上ではウィンドウは動きませんし、スクロールコマンドは
明らかにテキストをスクリーン上で上下に動かしています。
ユーザーの視点に合う名称を選んだのです。

        カレントバッファと選択されているウィンドウに
表示されているバッファとが異なる場合には、
（`scroll-other-window'以外の）スクロール関数の結果は予測できません。
*Note Current Buffer::。

      -- コマンド: scroll-up &optional count
          この関数は、選択されているウィンドウのテキストを
          上向きにCOUNT行だけスクロールする。
          COUNTが負であると、実際のスクロール方向は下向きである。

          COUNTが`nil'（あるいは省略）であると、
          スクロール量は、ウィンドウの（モード行を数えない）利用可能な高さより
          `next-screen-context-lines'だけ少なくなる。

          `scroll-up'は`nil'を返す。

      -- コマンド: scroll-down &optional count
          この関数は、選択されているウィンドウのテキストを
          下向きにCOUNT行だけスクロールする。
          COUNTが負であると、実際のスクロール方向は上向きである。

          COUNTが`nil'（あるいは省略）であると、
          スクロール量は、ウィンドウの（モード行を数えない）利用可能な高さより
          `next-screen-context-lines'だけ少なくなる。

          `scroll-down'は`nil'を返す。

      -- コマンド: scroll-other-window &optional count
          この関数は、別のウィンドウのテキストを上向きに
          COUNT行だけスクロールする。
          COUNTの値が負であったり`nil'であると、
          `scroll-up'と同様に扱う。

          変数`other-window-scroll-buffer'で、スクロールするバッファを指定できる。
          選択されているウィンドウがミニバッファ用であるときには、
          つぎのウィンドウは、通常、もっとも左上隅にあるウィンドウである。
          変数`minibuffer-scroll-window'で、
          スクロールする別のウィンドウを指定できる。
          別のウィンドウが選択されている場合には、この変数の効果はない。
          *note Minibuffer Misc::。

          ミニバッファが活性であると、
          右下隅のウィンドウが選択されているウィンドウであるときには、
          つぎのウィンドウはミニバッファ用ウィンドウである。
          この場合、`scroll-other-window'はミニバッファをスクロールしようとする。
          ミニバッファにたった1行しか入っていなければスクロールできず、
          エコー領域に『Beginning of buffer』と短時間表示されたあとで、
          ミニバッファの行が再度現れる。

      -- Variable: other-window-scroll-buffer
          この変数が`nil'以外であると、
          `scroll-other-window'がスクロールするバッファを指定する。

      -- User Option: scroll-margin
          このオプションは、スクロール時の余白の大きさ、
          つまり、ポイントとウィンドウの上端や下端とのあいだにある最低行数を指定する。
          ウィンドウの上端や下端からこの行数以内にポイントが移動するたびに、
          （可能ならば）ウィンドウを自動的にスクロールして、
          ポイントを余白の外側でウィンドウの中央近くに移動する。

      -- User Option: scroll-conservatively
          この変数は、ポイントがスクリーンからはみ出したとき
          （あるいはスクロール時の余白に入ったとき）に
          どのように自動的にスクロールするかを制御する。
          値が0であると、ウィンドウの縦方向でポイントが中央にくるように
          テキストをスクロールして再表示する。 値が正の整数Nであると、
          ウィンドウをどちらかの方向に最大N行だけスクロールすると
          ポイントが見えるようになるときには、そのようにスクロールして再表示する。
          さもなければ、ポイントが中央にくるようにする。
          デフォルト値は0である。

      -- User Option: scroll-step
          この変数は、`scroll-conservatively'の古い変種である。
          違いは、値がNであると正確にN行だけのスクロールを許すことである。
          この機能は`scroll-margin'では働かない。
          デフォルト値は0である。

      -- User Option: scroll-preserve-screen-position
          このオプションが`nil'以外であると、
          スクロール関数は、可能ならばカーソルの垂直方向の位置を
          変えないようにポイントを移動する。

      -- User Option: next-screen-context-lines
          この変数の値は、1画面分スクロールしたときに連続して残っている行数である。
          たとえば、引数`nil'の`scroll-up'は、
          ウィンドウの下端にあるこの行数だけの行が上端にくるようにスクロールする。
          デフォルト値は`2'である。

      -- コマンド: recenter &optional count
          この関数は、選択されているウィンドウをスクロールして
          ポイント位置にあるテキストがウィンドウ内の垂直方向の指定位置にくるようにする。

          COUNTが非負の数であると、ポイント位置にある行を
          ウィンドウの上端からCOUNT行下にくるようにする。
          COUNTが負の数であると、ウィンドウの下端から数え、
          -1はウィンドウの使用可能な最後の行を表す。
          COUNTが`nil'以外のリストであると、
          ウィンドウの中央の行を表す。

          COUNTが`nil'であると、`recenter'は、
          ポイント位置にある行がウィンドウの中央にくるようにして、
          選択されているフレーム全体をクリアして再表示する。

          `recenter'が対話的に呼び出されると、COUNTは生の前置引数である。
          したがって、前置引数として`C-u'と打つと
          COUNTは`nil'以外のリストになり、 `C-u
          4'と打つとCOUNTは4になって上端から4行目に現在行がくる。

          引数が0であると、
          `recenter'はウィンドウの上端に現在行がくるようにする。
          この動作は、このための専用のキーバインディングをする人がいるくらい便利である。
          たとえばつぎのようにする。

               (defun line-to-top-of-window ()
                 "Scroll current line to top of window.
               Replaces three keystroke sequence C-u 0 C-l."
                 (interactive)
                 (recenter 0))

               (global-set-key [kp-multiply] 'line-to-top-of-window)


File: elisp-ja,  Node: Horizontal Scrolling,  Next: Size of Window,  Prev: Vertical Scrolling,  Up: Windows

27.12 水平スクロール
===========================

英文は『内側のループ』では左から右へ『外側のループ』では上から下へと読むので、
水平スクロールは垂直スクロールには似ていません。
垂直スクロールでは表示するテキストの連続部分を選びますが、
水平スクロールでは各行の一部がスクリーンからはみ出すことになります。
そのため、水平スクロールの量は、バッファ内の位置ではなく、
コラム数で指定します。
これは、`window-start'が返す表示開始位置とはなんの関係もありません。

        通常、水平スクロールは行われません。
つまり、左端のコラムはウィンドウの左端にあります。
この状態で右向きにスクロールしても、
それによって見えてくるスクリーンの左側にはなにもないので意味がありません。
ですから、これは禁止されます。 左向きへのスクロールは許されて、
テキストの先頭コラムはウィンドウの端からはみ出し、
それまで切り詰められていた右側のコラムが見えるようになります。
左向きの水平スクロール量が0でなければ、
右向きへスクロールして戻せますが、
これは全体としての水平スクロール量が0になるまでです。
左向きスクロールの限界はありませんが、
最終的にはテキストすべてが左端からはみ出してしまいます。

      -- コマンド: scroll-left count
          この関数は、選択されているウィンドウをCOUNTコラムだけ
          左向きに（COUNTが負ならば右向きに）スクロールする。
          戻り値は、変更後の左向き水平スクロール量の総量であり、
          `window-hscroll'（下記参照）が返す値と同じである。

      -- コマンド: scroll-right count
          この関数は、選択されているウィンドウをCOUNTコラムだけ
          右向きに（COUNTが負ならば左向きに）スクロールする。
          戻り値は、変更後の左向き水平スクロール量の総量であり、
          `window-hscroll'（下記参照）が返す値と同じである。

          可能なだけウィンドウを右向きにスクロールしてしまうと、
          通常の状態、つまり、左向き水平スクロール量が0になり、
          それ以降、右向きスクロールは効果がなくなる。

      -- Function: window-hscroll &optional window
          この関数は、WINDOWの左向き水平スクロール量の総量、
          つまり、WINDOWのテキストが左端を超えてスクロールされたコラム数を返す。

          値はけっして負にはならない。
          WINDOWが水平方向にスクロールされていなければ
          （これが通常の状態）0である。

          WINDOWが`nil'であると、選択されているウィンドウを使う。

               (window-hscroll)
                    => 0
               (scroll-left 5)
                    => 5
               (window-hscroll)
                    => 5

      -- Function: set-window-hscroll window columns
          この関数は、WINDOWのスクロールされている左端からのコラム数を
          COLUMNSの値とする。 引数COLUMNSは0か正であること。
          さもないと0と仮定する。

          戻り値はCOLUMNSである。

               (set-window-hscroll (selected-window) 10)
                    => 10

        水平スクロールのために指定位置POSITIONが
スクリーンからはみ出しているかどうかを調べる方法をつぎに示します。

          (defun hscroll-on-screen (window position)
            (save-excursion
              (goto-char position)
              (and
               (>= (- (current-column) (window-hscroll window)) 0)
               (< (- (current-column) (window-hscroll window))
                  (window-width window)))))


File: elisp-ja,  Node: Size of Window,  Next: Resizing Windows,  Prev: Horizontal Scrolling,  Up: Windows

27.13 ウィンドウサイズ
==============================

     Emacsのウィンドウは矩形であり、そのサイズ情報は
高さ（行数）と幅（各行の文字数）から成ります。
モード行は高さに含みます。
しかし、スクロールバーや左右のウィンドウを隔てる文字`|'のコラムは
幅には含みません。

        つぎの3つの関数は、ウィンドウのサイズ情報を返します。

      -- Function: window-height &optional window
          この関数は、モード行を含むWINDOWの行数を返す。
          WINDOWがフレーム全体を占める場合、この値は典型的には、
          当該フレームにおける`frame-height'の値より1小さい
          （最後の行はミニバッファ用につねに確保してあるため）。

          WINDOWが`nil'であると、この関数は選択されているウィンドウを使う。

               (window-height)
                    => 23
               (split-window-vertically)
                    => #<window 4 on windows.texi>
               (window-height)
                    => 11

      -- Function: window-width &optional window
          この関数は、WINDOWのコラム数を返す。
          WINDOWがフレーム全体を占める場合、この値は、
          当該フレームにおける`frame-width'の値と同じである。
          この幅には、ウィンドウのスクロールバーや
          左右のウィンドウを隔てる文字`|'のコラムは含まない。

          WINDOWが`nil'であると、この関数は選択されているウィンドウを使う。

               (window-width)
                    => 80

      -- Function: window-edges &optional window
          この関数は、WINDOWの四隅の座標から成るリストを返す。
          WINDOWが`nil'であると、選択されているウィンドウを使う。

          list内の順番は`(LEFT TOP RIGHT BOTTOM)'
          （つまり、左端、上端、右端、下端）であり、
          フレームの左上隅を0としてすべての要素は0を基準とする。
          要素RIGHTはWINDOWが使用する右端のコラムより1大きく、
          BOTTOMはWINDOWが使用する下端より1大きく モード行と同じである。

          左右に隣り合ったウィンドウがある場合、
          右隣にウィンドウがあるウィンドウの右端の値には、
          ウィンドウを隔てる区切りの幅が含まれる。
          この区切りは、文字`|'のコラムであるかスクロールバーである。
          ウィンドウの幅にはこの区切りは含まないため、
          この場合、左端と右端の差は幅に等しくない。

          典型的な24行の端末でウィンドウが1つの場合に得られる結果を示す。

               (window-edges (selected-window))
                    => (0 0 80 23)

          下端が23行目であるのは、最下行はエコー領域だからである。

          WINDOWがフレームの左上隅にあると、
          BOTTOMは`(window-height)'の値に等しく、
          RIGHTは`(window-width)'の値にほぼ等しく (1)、
          TOPとLEFTは0である。
          たとえば、つぎのウィンドウは`0 0 5 8'である。
          当該フレームには8コラムより多くあり、
          ウィンドウの最終コラム（7コラム目）はテキストではなく境界であると仮定する。
          最後の行（4行目）はモード行であり、ここでは`xxxxxxxxx'で示した。

                          0
                          _______
                       0 |       |
                         |       |
                         |       |
                         |       |
                         xxxxxxxxx  4

                                 7

          左右に隣り合ったウィンドウがあるときには、
          フレームの右端にないウィンドウの最後のコラムは区切りである。
          区切りは、ウィンドウの幅では1コラムか2コラム占める。
          左側の区切りは左隣のウィンドウに属するので、
          ウィンドウには左側の区切りは含まれない。

          つぎの例では、フレームは7コラム幅であるとする。
          すると、左側のウィンドウの四隅は`0 0 4 3'であり、
          右側のウィンドウの四隅は`4 0 7 3'である。

                          ___ ___
                         |   |   |
                         |   |   |
                         xxxxxxxxx

                          0  34  7

        ---------- Footnotes ----------

        (1) RIGHTは垂直の区切り行やスクロールバーを含むが、
     `(window-width)'はそれらを含まないため、 完全に等しくはない。


File: elisp-ja,  Node: Resizing Windows,  Next: Coordinates and Windows,  Prev: Size of Window,  Up: Windows

27.14 ウィンドウサイズの変更
=======================================

     ウィンドウサイズ関数は2つに大別できます。
ウィンドウサイズを変える上位レベルのコマンドと
ウィンドウサイズを調べる下位レベルの関数です。
Emacsでは重なり合ったウィンドウやウィンドウのあいだに隙間を許さないので、
1つのウィンドウの大きさを変えると別のウィンドウにも影響します。

      -- コマンド: enlarge-window size &optional horizontal
          この関数は、隣り合うウィンドウから場所を奪って、
          選択されているウィンドウをSIZE行高くする。
          1つのウィンドウから場所を奪い取り、奪い尽くすと別のウィンドウから取る。
          場所を奪われたウィンドウが`window-min-height'行未満になると、
          そのウィンドウは消える。

          HORIZONTALが`nil'以外であると、
          この関数は、隣り合うウィンドウから場所を奪って、
          選択されているウィンドウをSIZEコラム広くする。
          場所を奪われたウィンドウが`window-min-width'コラム未満になると、
          そのウィンドウは消える。

          指定した大きさがウィンドウのフレームの大きさを超える場合、
          この関数は、ウィンドウがフレームの高さ（あるいは幅）全体を占めるようにする。

          SIZEが負であると、この関数は-SIZE行／コラムだけ
          ウィンドウを縮める。
          ウィンドウが（`window-min-height'と`window-min-width'の）
          最小サイズより小さくなると、`enlarge-window'は
          当該ウィンドウを削除する。

          `enlarge-window'は`nil'を返す。

      -- コマンド: enlarge-window-horizontally columns
          この関数は、選択されているウィンドウをCOLUMNSコラム広くする。

               (defun enlarge-window-horizontally (columns)
                 (enlarge-window columns t))

      -- コマンド: shrink-window size &optional horizontal
          この関数は`enlarge-window'に似ているが引数SIZEの符号を変えて、
          選択されているウィンドウを縮めて指定行数（コラム数）を
          他のウィンドウに与える。
          ウィンドウが`window-min-height'や`window-min-width'未満に縮むと、
          そのウィンドウは消える。

          SIZEが負であると、ウィンドウは -SIZE行／コラムだけ伸びる。

      -- コマンド: shrink-window-horizontally columns
          この関数は、選択されているウィンドウをCOLUMNSコラム狭くする。
          つぎのように定義できる。

               (defun shrink-window-horizontally (columns)
                 (shrink-window columns t))

      -- コマンド: shrink-window-if-larger-than-buffer window
          このコマンドは、バッファの全内容を表示するに十分なだけの大きさに
          WINDOWを縮めるが、`window-min-height'行未満にはしない。

          しかし、バッファの全テキストを表示するにはウィンドウが小さすぎる場合や、
          内容の一部がスクロールでスクリーンからはみ出している場合や、
          ウィンドウの幅がフレームの幅と同じでない場合や、
          ウィンドウがフレームの唯一のウィンドウである場合には、
          このコマンドはなにもしない。

つぎの2つの変数は、ウィンドウサイズを変える関数に最小の高さと幅を課します。

      -- User Option: window-min-height
          この変数の値は、ウィンドウが自動的に削除されるまでに
          どの程度までウィンドウが短くなりうるかを決定する。
          ウィンドウを`window-min-height'行未満に小さくすると自動的に削除され、
          これより短いウィンドウは作成できない。
          絶対的な最小の高さは2行（モード行に1行、バッファの表示に1行）である。
          ウィンドウサイズを変える処理では、この変数が2未満であると2に設定し直す。
          デフォルト値は4である。

      -- User Option: window-min-width
          この変数の値は、ウィンドウが自動的に削除されるまでに
          どの程度までウィンドウが狭くなりうるかを決定する。
          ウィンドウを`window-min-width'コラム未満に小さくすると自動的に削除され、
          これより狭いウィンドウは作成できない。
          絶対的な最小の幅は1であり、それ未満は無視する。
          デフォルト値は10である。


File: elisp-ja,  Node: Coordinates and Windows,  Next: Window Configurations,  Prev: Resizing Windows,  Up: Windows

27.15 座標とウィンドウ
==============================

     本節では、スクリーン座標をウィンドウに関連付ける方法を述べます。

      -- Function: window-at x y &optional frame
          この関数は、フレームFRAMEにおいて指定したカーソル位置を含んでいる
          ウィンドウを返す。
          座標XとYは、フレームの左上隅から文字単位で数える。
          座標が範囲外であると`window-at'は`nil'を返す。

          FRAMEを省略すると、選択されているフレームを使う。

      -- Function: coordinates-in-window-p coordinates window
          この関数は、指定したフレーム位置がウィンドウWINDOWの中に
          入るかどうかを検査する。

          引数COORDINATESは、`(X . Y)'の形のコンスセルである。
          座標XとYは、スクリーンやフレームの左上隅から文字単位で数える。

          `coordinates-in-window-p'が返す値が`nil'以外であると、
          当該座標はWINDOWの内側にある。
          つぎのように、この値はウィンドウ内での位置も表す。

         `(RELX . RELY)'
               当該座標はWINDOWの内側である。
               数RELXとRELYは、指定位置に対応するウィンドウ相対の座標であり、
               ウィンドウの左上隅を0として数えたものである。

         `mode-line'
               当該座標はWINDOWのモード行の内側である。

         `vertical-split'
               当該座標はWINDOWと右隣のウィンドウのあいだの垂直行である。
               ウィンドウにスクロールバーがない場合に限って、この値になる。
               スクロールバーはウィンドウの外側であるとみなす。

         `nil'
               当該座標はWINDOWのどこでもない。

          関数`coordinates-in-window-p'は、
          WINDOWのフレームをつねに使うため、引数にフレームを必要としない。


File: elisp-ja,  Node: Window Configurations,  Next: Window Hooks,  Prev: Coordinates and Windows,  Up: Windows

27.16 ウィンドウ構成
===========================

     "ウィンドウ構成"（window configuration）は、
1つのフレームの全体の配置、つまり、
すべてのウィンドウ、それらの大きさ、表示しているバッファ、
各バッファの表示位置、ポイントとマークの値を記録します。
保存しておいたウィンドウ構成を復元すれば、
まえとまったく同じ配置に戻せます。

        1つのフレームではなくすべてのフレームを記録するには、
ウィンドウ構成のかわりにフレーム構成を使います。 *Note Frame
Configurations::。

      -- Function: current-window-configuration
          この関数は、選択されているフレームの現在のウィンドウ構成を表す
          新たなオブジェクトを返す。
          ウィンドウ構成には、ウィンドウの個数、それらの大きさとカレントバッファ、
          どのウィンドウが選択されているウィンドウであるか、
          各ウィンドウが表示しているバッファ、表示開始位置、
          ポイントとマークの位置が含まれる。
          `window-min-height'、`window-min-width'、
          `minibuffer-scroll-window'の値も含む。
          例外はカレントバッファのポイントであり、その値は保存されない。

      -- Function: set-window-configuration configuration
          この関数は、CONFIGURATIONで指定される
          ウィンドウとバッファの構成に復元する。 引数CONFIGURATIONは、
          `current-window-configuration'が返した値であること。
          CONFIGURATIONを作成したフレームにおいて、
          そのフレームが選択されているかどうかに関わらず、この構成を復元する。
          `set-window-configuration'は、新たな構成が古いものと
          実際に異なるのかどうか識別する方法を知らないため、
          ウィンドウサイズの変更とつねにみなして
          `window-size-change-functions'（*note Window Hooks::）の
          実行を引き起こす。

          CONFIGURATIONを保存したフレームがなくなっていると、
          この関数は、3つの変数、`window-min-height'、
          `window-min-width'、`minibuffer-scroll-window'を
          復元するだけである。

          `save-window-excursion'と同じ効果を得るための
          この関数の使い方をつぎに示す。

               (let ((config (current-window-configuration)))
                 (unwind-protect
                     (progn (split-window-vertically nil)
                            ...)
                   (set-window-configuration config)))

      -- Special Form: save-window-excursion forms...
          このスペシャルフォームは、ウィンドウ構成を記録し、
          FORMSを順に評価し、もとのウィンドウ構成に復元する。
          ウィンドウ構成には、ポイントの値と可視なバッファの部分が含まれる。
          また、選択されているウィンドウも含む。
          しかし、これにはカレントバッファのポイント値は含まれないため、
          ポイント位置を保存したい場合には`save-excursion'も使う。

          `save-selected-window'で十分なときには、この構文を使わないこと。

          `save-window-excursion'から抜けると、
          `window-size-change-functions'の実行をつねに引き起こす。
          （復元した構成とFORMSの終りでの構成が実際に異なるかどうかを
          識別する方法を知らない。）

          戻り値は、FORMSの最後のフォームの値である。 例を示す。

               (split-window)
                    => #<window 25 on control.texi>
               (setq w (selected-window))
                    => #<window 19 on control.texi>
               (save-window-excursion
                 (delete-other-windows w)
                 (switch-to-buffer "foo")
                 'do-something)
                    => do-something
                    ;; スクリーンはここでふたたび分割される

      -- Function: window-configuration-p object
          この関数は、OBJECTがウィンドウ構成であれば`t'を返す。

      -- Function: compare-window-configurations config1 config2
          この関数は、ウィンドウの構造を基に2つのウィンドウ構成を比較する。
          ポイントとマークの値、保存されたスクロール位置は無視するので、
          それらが異なっていても`t'を返す。

          関数`equal'でも2つのウィンドウ構成を比較できるが、
          保存されたポイントやマークが違うだけであっても異なる部分があると、
          等しくない構成とみなす。

        ウィンドウ構成の内部を調べる基本関数には意味があるでしょうが、
実装してありません。
実装するだけの価値があるほど有用なのかはっきりしないのです。


File: elisp-ja,  Node: Window Hooks,  Prev: Window Configurations,  Up: Windows

27.17 ウィンドウのスクロールとサイズ変更向けのフック
===========================================================================

     本節では、ウィンドウにバッファの別の部分を表示したり
別のバッファを表示するたびに、 Lispプログラムが動作する方法を述べます。
変更できる動作は3種類、ウィンドウをスクロールするとき、
ウィンドウでバッファを切り替えるとき、
ウィンドウサイズを変えるときです。
最初の2つの動作では`window-scroll-functions'を実行し、
3つ目は`window-size-change-functions'を実行します。
これらのフックの模範的な使用例は遅延ロック（lazy-lock）モードの
実装の中にあります。 *note フォントロックのモード: (emacs)Support
Modes.を参照してください。

      -- Variable: window-scroll-functions
          この変数は、スクロールによりウィンドウを再表示するまえに
          Emacsが呼び出すべき関数のリストを保持する。
          各関数はウィンドウと新たな表示開始位置の2つの引数で呼ばれるため、
          これはノーマルフックではない。

          ウィンドウに別のバッファを表示する場合でも
          これらの関数が実行される。

          これらの関数で`window-end'（*note Window Start::）を使うには
          注意が必要である。
          更新された値が必要なときには、確実に更新値を得るために
          引数UPDATEを使う必要がある。

      -- Variable: window-size-change-functions
          この変数は、いかなる理由であれウィンドウサイズが変わるときに
          呼び出される関数のリストを保持する。
          関数は、再表示のたびにサイズ変更が起きたフレームごとに呼ばれる。

          各関数はフレームを唯一の引数として受け取る。
          当該フレームで大きさが変更されたウィンドウを探す直接的な方法や
          正確な方法はない。 しかし、サイズ変更関数が呼ばれるたびに
          既存のウィンドウとそれらの大きさを記録すれば、
          現在の大きさと以前の大きさを比較できる。

          ウィンドウを作成したり削除してもサイズ変更とみなすので、
          これらの関数が呼び出される。
          フレームの大きさが変わると既存のウィンドウの大きさも変わるので、
          これもサイズ変更とみなす。

          これらの関数で`save-window-excursion' （*note Window
          Configurations::）を使うのはよくない。
          この関数はつねにサイズ変更とみなしこれらの関数を呼び出し、
          これが繰り返されてしまうからである。
          多くの場合、ここで必要なのは`save-selected-window' （*note
          Selecting Windows::）である。

      -- Variable: redisplay-end-trigger-functions
          このアブノーマルフックは、ウィンドウの再表示において、
          指定された終了トリガ位置を超えて伸びるテキストを使うたびに実行される。
          終了トリガ位置は関数`set-window-redisplay-end-trigger'で設定する。
          フック関数は2つの引数、ウィンドウと終了トリガ位置で呼ばれる。
          終了トリガ位置として`nil'を保存するとこの機能をオフにし、
          フックを実行直後にトリガ値は自動的に`nil'に再設定される。

      -- Function: set-window-redisplay-end-trigger window position
          この関数は、WINDOWの終了トリガ位置をPOSITIONとする。

      -- Function: window-redisplay-end-trigger window
          この関数は、WINDOWの現在の終了トリガ位置を返す。

      -- Variable: window-configuration-change-hook
          このノーマルフックは、
          既存のフレームのウィンドウの構成を変更するたびに呼び出される。
          これには、ウィンドウの分割や削除、ウィンドウサイズの変更、
          ウィンドウに別のバッファを表示することが含まれる。
          このフックを実行するときには、
          ウィンドウの構成が変更されたフレームが選択されているフレームである。



File: elisp-ja,  Node: Frames,  Next: Positions,  Prev: Windows,  Up: Top

28 フレーム
***************

     "フレーム"（frame）とは、1つかそれ以上のEmacsのウィンドウを
収めているスクリーン上の矩形です。
フレームには最初は1つのウィンドウ（およびミニバッファ用ウィンドウ）が
ありますが、それを上下や左右に小さなウィンドウに分割できます。

        Emacsを文字端末で実行すると、 1つの"端末フレーム"（terminal
frame）を使います。 別のフレームを作成すると、もちろん端末画面上では、
Emacsは一度に1つのフレームしか表示しません。

        EmacsがXウィンドウのような対応しているウィンドウシステムと
直接通信しているときには、端末フレームは使いません。
そのかわりに、1つの"ウィンドウフレーム"（window frame）で始まりますが、
いくつでもフレームを作れますし、ウィンドウシステムでは普通のことですが、
Emacsはそのようなフレームを同時に複数表示できます。

      -- Function: framep object
          この関数は、OBJECTがフレームならば`t'を返し、
          さもなければ`nil'を返す。

     * Menu:

     * Creating Frames::		Creating additional frames.
     * Multiple Displays::           Creating frames on other displays.
     * Frame Parameters::		Controlling frame size, position, font, etc.
     * Frame Titles::                Automatic updating of frame titles.
     * Deleting Frames::		Frames last until explicitly deleted.
     * Finding All Frames::		How to examine all existing frames.
     * Frames and Windows::		A frame contains windows;
     				  display of text always works through windows.
     * Minibuffers and Frames::	How a frame finds the minibuffer to use.
     * Input Focus::			Specifying the selected frame.
     * Visibility of Frames::	Frames may be visible or invisible, or icons.
     * Raising and Lowering::	Raising a frame makes it hide other windows;
     				  lowering it makes the others hide them.
     * Frame Configurations::	Saving the state of all frames.
     * Mouse Tracking::		Getting events that say when the mouse moves.
     * Mouse Position::		Asking where the mouse is, or moving it.
     * Pop-Up Menus::		Displaying a menu for the user to select from.
     * Dialog Boxes::                Displaying a box to ask yes or no.
     * Pointer Shapes::              Specifying the shape of the mouse pointer.
     * Window System Selections::    Transferring text to and from other X clients.
     * Font Names::                  Looking up font names.
     * Fontsets::                    A fontset is a collection of fonts
                                       for displaying various character sets.
     * Color Names::	                Getting the definitions of color names.
     * Resources::		        Getting resource values from the server.
     * Server Data::		        Getting info about the X server.

        Emacsの再表示の制御に関連する情報については*Note Display::。


File: elisp-ja,  Node: Creating Frames,  Next: Multiple Displays,  Up: Frames

28.1 フレームの作成
==========================

     新たなフレームを作成するには、関数`make-frame'を呼び出します。

      -- Function: make-frame &optional alist
          この関数は新たなフレームを作成する。
          対応しているウィンドウシステムを使っていれば、ウィンドウフレームを作る。
          さもなければ端末フレームを作る。

          引数ALISTはフレームパラメータを指定する連想リストである。
          ALISTで指定していないパラメータは、
          変数`default-frame-alist'の値に従って決まる。
          それでも決まらないパラメータは、
          標準のXリソースやそれにかわる読者のシステムの設定を使う。

          指定可能なパラメータは、Emacsがフレームの表示に使う
          ウィンドウシステムの種類に原理的には依存します。
          指定可能な各パラメータの説明は、*note Window Frame
          Parameters::。

      -- Variable: before-make-frame-hook
          `make-frame'がフレームを実際に作成する直前に実行するノーマルフック。

      -- Variable: after-make-frame-hook
          `make-frame'がフレームを作成後に実行するアブノーマルフック。
          `after-make-frame-hook'の各関数は、1つの引数、
          つまり、作成したばかりのフレームを受け取る。


File: elisp-ja,  Node: Multiple Displays,  Next: Frame Parameters,  Prev: Creating Frames,  Up: Frames

28.2 複数ディスプレイ
=============================

     1つのEmacsは複数のXディスプレイと通信できます。
Emacsは始めは1つのディスプレイ、つまり、
環境変数`DISPLAY'かオプション`--display' （*note 初期化オプション:
(emacs)Initial Options.）で決まる ものを使います。
別のディスプレイに接続するには、
コマンド`make-frame-on-display'を使うか、
フレームを作るときにフレームパラメータ`display'を指定します。

        Emacsは各Xサーバーを別々の端末として扱い、
それらのおのおのには選択されているフレームと
ミニバッファ用ウィンドウがあります。

        少数のLisp変数は"端末にローカル"（terminal-local）です。
つまり、各端末ごとに別々の束縛があります。
ある時点で有効な束縛は、選択されているフレームが属する端末のものです。
このような変数には、`default-minibuffer-frame'、
`defining-kbd-macro'、`last-kbd-macro'、 `system-key-alist'があります。
これらはつねに端末にローカルであり、 バッファローカル（*note
Buffer-Local Variables::）や フレームローカルにはけっしてなりません。

        1つのXサーバーは複数のスクリーンを扱えます。
ディスプレイ名`HOST:SERVER.SCREEN'には3つの部分があり、
最後の部分で指定したサーバーのスクリーン番号を指定します。
1つのサーバーに属する2つのスクリーンを使うと、
Emacsはそれらの名前の類似性からそれらが1つのキーボードを共有していると判断し、
それらのスクリーンを1つの端末として扱います。

      -- コマンド: make-frame-on-display display &optional parameters
          新たなフレームをディスプレイDISPLAY上に作成する。
          他のフレームパラメータはPARAMETERSから得る。
          引数DISPLAYを除けば`make-frame'（*note Creating Frames::）と
          同様である。

      -- Function: x-display-list
          Emacsが接続しているXディスプレイを表すリストを返す。
          リストの要素は文字列であり、それぞれはディスプレイ名である。

      -- Function: x-open-connection display &optional xrm-string
          この関数はXディスプレイDISPLAYとの接続を開く。
          当該ディスプレイ上にフレームは作らないが、
          これにより当該ディスプレイと通信可能かどうか検査できる。

          省略可能な引数XRM-STRINGが`nil'でなければ、
          ファイル`.Xresources'で使われ書式と同じ
          リソース名と値を表す文字列である。
          これに指定した値は、Xサーバー自体に記録されているリソースの値に優先し、
          Emacsが当該ディスプレイ上に作成するすべてのフレームに適用される。
          この文字列の例を以下に示す。

               "*BorderWidth: 3\n*InternalBorder: 2\n"

          *note Resources::。

      -- Function: x-close-connection display
          この関数はディスプレイDISPLAYとの接続を閉じる。
          これを行うまえに、
          まず当該ディスプレイ上に作ったフレームをすべて削除しておくこと。


File: elisp-ja,  Node: Frame Parameters,  Next: Frame Titles,  Prev: Multiple Displays,  Up: Frames

28.3 フレームパラメータ
================================

フレームには、その見ためやふるまいを制御する多くのパラメータがあります。
フレームのパラメータの種類は、使用する表示機構に依存します。

        フレームパラメータはウィンドウシステム向けです。
端末フレームにはごく少数のパラメータがありますが、
そのほとんどは互換性のためであり、 `height'、`width'、`name'、`title'、
`buffer-list'、`buffer-predicate'のパラメータだけが意味を持ちます。

     * Menu:

     * Parameter Access::       How to change a frame's parameters.
     * Initial Parameters::	   Specifying frame parameters when you make a frame.
     * Window Frame Parameters:: List of frame parameters for window systems.
     * Size and Position::      Changing the size and position of a frame.


File: elisp-ja,  Node: Parameter Access,  Next: Initial Parameters,  Up: Frame Parameters

28.3.1 フレームパラメータの参照
-------------------------------------------

これらの関数は、フレームのパラメータの値を読んだり変更するためのものです。

      -- Function: frame-parameters frame
          関数`frame-parameters'は、
          FRAMEのすべてのパラメータとそれらの値から成る連想リストを返す。

      -- Function: modify-frame-parameters frame alist
          この関数は、ALISTの要素に基づいてフレームFRAMEの
          パラメータを変更する。 ALISTの各要素は`(PARM .
          VALUE)'の形であり、 PARMはパラメータを表すシンボルである。
          ALISTに指定しないパラメータの値は変更されない。


File: elisp-ja,  Node: Initial Parameters,  Next: Window Frame Parameters,  Prev: Parameter Access,  Up: Frame Parameters

28.3.2 初期フレームのパラメータ
-------------------------------------------

     読者のファイル`.emacs'で`initial-frame-alist'に設定すれば、
起動時の初期フレームのパラメータを指定できます。

      -- Variable: initial-frame-alist
          この変数の値は、初期フレームを作るときに
          使用するパラメータの値から成る連想リストである。
          この変数を指定すれば初期フレームの見ためを指定できるが、
          それ以降に作成するフレームには影響しない。
          各要素はつぎの形である。

               (PARAMETER . VALUE)

          Emacsは読者のファイル`~/.emacs'を読むまえに初期フレームを作る。
          このファイルを読んだあとに、Emacsは`initial-frame-alist'を検査し
          異なる値が設定されているパラメータをすでに作成した初期フレームに適用する。

          これらの設定がフレームの大きさと位置や見ために関するものであると、
          指定とは違うフレームが現れてから指定したものに変わるのを目にする。
          これがわずらわしい場合には、Xリソースにも同じ大きさと位置や見ためを指定する。
          Xリソースはフレームを作成するまえに適用される。 *note
          Xリソース: (emacs)Resources X.。

          Xリソースの設定は、典型的にはすべてのフレームに適用される。
          初期フレームだけに特定のXリソースを指定し、
          それ以降のフレームに適用したくない場合には、つぎのようにする。
          パラメータを`default-frame-alist'で指定し、
          以降のフレーム向けのXリソースを無効にする。
          そしてそれらが初期フレームに影響しないように、
          `initial-frame-alist'のパラメータでXリソースに一致する値を指定する。

        これらのパラメータにミニバッファ専用のフレームを作る
`(minibuffer . nil)'を指定しているのに
ミニバッファ専用フレームを作っていないと、Emacsがそれを作成します。

      -- Variable: minibuffer-frame-alist
          この変数の値は、初期のミニバッファ専用フレームを作るときに使用する
          パラメータの連想リストである。
          初期フレームのパラメータからミニバッファ専用フレームが
          必要であると判断するとそれを作る。

      -- Variable: default-frame-alist
          これは、Emacsのすべてのフレーム、つまり、
          初期フレームとそれ以降のフレームのフレームパラメータのデフォルト値を
          指定する連想リストである。
          Xウィンドウシステムを使っているときには、多くの場合、
          Xリソースによっても同じ結果を得られる。

        *note Choosing Window::の`special-display-frame-alist'も
参照してください。

Emacsを起動するときにウィンドウの見ためを指定するオプションを使うと、
それらは`default-frame-alist'に要素を追加することで効果を発揮します。
1つの例外は`-geometry'で、指定位置は`initial-frame-alist'に
追加されます。 *Note コマンド行引数: (emacs)Command Arguments。


File: elisp-ja,  Node: Window Frame Parameters,  Next: Size and Position,  Prev: Initial Parameters,  Up: Frame Parameters

28.3.3 ウィンドウフレームのパラメータ
----------------------------------------------------

     フレームのパラメータの種類は、使用する表示機構に依存します。
ウィンドウフレームにおいて特別な意味を持つパラメータの一覧をつぎに示します。
これらのうち、`name'、`title'、`height'、
`width'、`buffer-list'、`buffer-predicate'は
端末フレームでも意味を持ちます。

    `display'
          このフレームを開くディスプレイ。 環境変数`DISPLAY'と同様に、
          `"HOST:DPY.SCREEN"'の形の文字列であること。

    `title'
          フレームのタイトル`title'が`nil'以外であると、
          フレーム向けのウィンドウシステムの枠にタイトルが現れる。
          また、`mode-line-frame-identification'に`%F' （*note
          %-Constructs::）を使っていれば、
          当該フレームのモード行にもタイトルが現れる。
          Emacsがウィンドウシステムを使っていない場合には、
          これは普通はモード行に表示され一度に1つのフレームだけを表示できる。
          *note Frame Titles::。

    `name'
          フレームの名前。
          パラメータ`title'を指定しないか`nil'であると、
          フレーム名はフレームタイトルのデフォルトになる。
          `name'を指定しないと、Emacsが自動的にフレーム名を設定する
          （*note Frame Titles::）。

          フレームを作るときにフレーム名を明示的に指定すると、
          その名前は（Emacsの実行形式ファイルの名前のかわりに）
          フレーム向けのXリソースを探すためにも使われる。

    `left'
          スクリーンの左端を基準にしたピクセル単位の左端位置。
          この値は正の数POSであるか、 負のPOSの値を指定できる`(+
          POS)'の形のリストである。

          負の数-POSや`(- POS)'の形のリストは、
          実際には、スクリーンの右端を基準にしたウィンドウの右端位置を指定する。
          POSの正の値は左へ向けて数える。 *注意：*`
          'パラメータが負の整数-POSであると、 POSは正である。

          プログラムが指定した位置を無視するウィンドウマネージャもある。
          指定した位置が無視されないように保証したい場合には、
          パラメータ`user-position'にも`nil'以外の値を指定する。

    `top'
          スクリーンの上端を基準にしたピクセル単位の上端位置。
          この値は正の数POSであるか、 負のPOSの値を指定できる`(+
          POS)'の形のリストである。

          負の数-POSや`(- POS)'の形のリストは、
          実際には、スクリーンの下端を基準にしたウィンドウの下端位置を指定する。
          POSの正の値は上へ向けて数える。 *注意：*`
          'パラメータが負の整数-POSであると、 POSは正である。

          プログラムが指定した位置を無視するウィンドウマネージャもある。
          指定した位置が無視されないように保証したい場合には、
          パラメータ`user-position'にも`nil'以外の値を指定する。

    `icon-left'
          スクリーンの左端を基準にした
          _フレームのアイコン_のピクセル単位の左端位置。
          フレームをアイコンにしたときに効果を発揮する。

    `icon-top'
          スクリーンの上端を基準にした
          _フレームのアイコン_のピクセル単位の上端位置。
          フレームをアイコンにしたときに効果を発揮する。

    `user-position'
          パラメータ`left'と`top'でスクリーン上の位置を指定して
          フレームを作るときに、このパラメータは指定位置が、
          （利用者がなんらかの方法で与えた）ユーザー指定のものなのか、
          （プログラムが選んだ）プログラム指定のものなのかを指定する。
          `nil'以外の値であるとユーザー指定の位置であることを意味する。

          ウィンドウマネージャはユーザー指定の位置を一般に尊重し、
          プログラム指定の位置も尊重するものもある。
          しかしその多くはプログラム指定の位置を無視し、
          デフォルトに基づいてウィンドウを配置したり、
          マウスでユーザーに配置させる。
          `twm'を含むウィンドウマネージャには、
          プログラム指定の位置に従うかそれらを無視するかを
          ユーザーが指定できるものもある。

          `make-frame'を呼び出すときには、
          パラメータ`left'と`top'の値がユーザーの希望を表す場合には
          このパラメータの値には`nil'以外を指定すること。
          さもなければ`nil'を指定する。

    `height'
          フレームの内側の文字単位の高さ。
          （ピクセル単位の高さを得るには`frame-pixel-height'を呼び出す。
          *note Size and Position::を参照。）

    `width'
          フレームの内側の文字単位の幅。
          （ピクセル単位の幅を得るには`frame-pixel-width'を呼び出す。
          *note Size and Position::を参照。）

    `window-id'
          フレームとして使うウィンドウシステムのウィンドウ番号。

    `minibuffer'
          このフレームに独自のミニバッファがあるかどうかを表す。
          値`t'はあることを表し、`nil'はないことを表す。
          `only'は、このフレームがミニバッファだけであることを表す。
          （別のフレームの）値がミニバッファだけであると、
          新たなフレームはそのミニバッファを使う。

    `buffer-predicate'
          このフレーム向けのバッファ述語関数。 これが`nil'でなければ、
          関数`other-buffer'が（選択されているフレームから）この述語を使用して、
          どのバッファにするかを決定する。
          `other-buffer'は各バッファごとにバッファを引数としてこの述語を呼び出す。
          この述語が`nil'以外を返すと当該バッファを選ぶ。

    `buffer-list'
          このフレームで選択されたバッファを
          もっとも最近に選択されたものから順に並べたリスト。

    `font'
          フレーム内でテキストの表示に使うフォントの名前。
          これは、読者のシステムにおいて正しいフォントの名前であるか
          Emacsのフォントセット（*note
          Fontsets::）の名前を表す文字列である。

    `auto-raise'
          フレームを選択したときにフレームを手前に移動するかどうかを表す
          （`nil'以外であるとそのようにする）。

    `auto-lower'
          フレームの選択を止めたときにフレームを奥へ移動するかどうかを表す
          （`nil'以外であるとそのようにする）。

    `vertical-scroll-bars'
          フレームに垂直スクロール用のスクロールバーを付けるかどうか、
          どちら側に付けるかを表す。
          指定できる値は、`left'、`right'、あるいは
          スクロールバーなしを意味する`nil'。

    `horizontal-scroll-bars'
          水平スクロール用のスクロールバーを付けるかどうかを表す
          （`nil'以外だと付ける）。
          （水平スクロールバーはいまのところ実装してない。）

    `scroll-bar-width'
          垂直スクロールバーのピクセル単位の幅。

    `icon-type'
          このフレームをアイコンにしたときに使うアイコンの種類。
          値が文字列であると、使用するビットマップを収めたファイルを指定する。
          それ以外の`nil'以外の値はデフォルトのビットマップアイコン
          （gnuの絵）を指定する。 `nil'はテキストのアイコンを指定する。

    `icon-name'
          このフレーム向けのアイコンを表示するときに使用するアイコンの名前。
          これが`nil'であると、フレームのタイトルを使う。

    `foreground-color'
          文字の描画に使う表示色。 これは文字列である。
          ウィンドウシステムが妥当な表示色の名称を定義する。

          フレームパラメータ`foreground-color'に設定したときには、
          それに対応してフェイスを更新するために
          `frame-update-face-colors'を呼び出すこと。

    `background-color'
          文字の背景に使う表示色。

          フレームパラメータ`background-color'に設定したときには、
          それに対応してフェイスを更新するために
          `frame-update-face-colors'を呼び出すこと。 *note Face
          Functions::。

    `background-mode'
          背景色が明るいか暗いかにしたがって、
          このパラメータは`dark'か`light'である。

    `mouse-color'
          マウスポインタの表示色。

    `cursor-color'
          ポイントを表すカーソルの表示色。

    `border-color'
          フレームの枠の表示色。

    `display-type'
          このパラメータはこのフレームで使用可能な表示色の範囲を表す。
          値は、`color'、`grayscale'、`mono'のいずれかである。

    `cursor-type'
          カーソルの表示方法。 正しい値は、`bar'、`box'、 `(bar .
          WIDTH)'のいずれかである。
          シンボル`box'は、ポイント直後の文字に重なる通常の黒い箱型の
          カーソルを指定し、これがデフォルトである。
          シンボル`bar'は、カーソルとして文字のあいだに縦棒を置く指定である。
          `(bar . WIDTH)'は、ピクセル幅WIDTHの縦棒を指定する。

    `border-width'
          ウィンドウ枠のピクセル単位の幅。

    `internal-border-width'
          枠とテキストのあいだのピクセル単位の間隔。

    `unsplittable'
          `nil'以外であると、このフレームのウィンドウをけっして自動的に分割しない。

    `visibility'
          フレームの可視性。 不可視を表す`nil'、可視を表す`t'、
          アイコンになっていることを表す`icon'の3の可能性がある。 *note
          Visibility of Frames::。

    `menu-bar-lines'
          フレームの上端に割り当てるメニューバー向けの行の個数。
          デフォルトは1である。 *note Menu Bar::。
          （Xツールキットを使うEmacsでは、メニューバーは1行だけである。
          この場合、0より大きな数を指定したかどうかに意味がある。）



File: elisp-ja,  Node: Size and Position,  Prev: Window Frame Parameters,  Up: Frame Parameters

28.3.4 フレームのサイズと位置
----------------------------------------

     フレームパラメータ`left'、`top'、`height'、`width'を
使って、フレームのサイズや位置を読み取ったり変更できます。
指定しなかった大きさと位置のパラメータは、
ウィンドウマネージャが通常どおりに選びます。

        以下はサイズや位置を操作する特別な機能です。

      -- Function: set-frame-position frame left top
          この関数は、フレームFRAMEの左上隅の位置を
          LEFT（左端）とTOP（上端）にする。
          これらの引数は、スクリーンの左上隅からピクセル単位で数える。

          パラメータ値が負であると、スクリーンの下端から測ってウィンドウの下端を
          位置決めしたり、スクリーンの右端から測ってウィンドウの右端を位置決めする。
          つねに左端や上端から測った値にして、負の値はフレームを
          スクリーンの上端や左端から部分的にはみ出して位置決めする
          意味にするほうがよいかもしれないが、
          現状ではそのように変えるのは不適当と思われる。

      -- Function: frame-height &optional frame
      -- Function: frame-width &optional frame
          この関数は、フレームFRAMEの高さや幅を行単位やコラム単位で返す。
          FRAMEを指定しないと、選択されているフレームを使う。

      -- Function: screen-height
      -- Function: screen-width
          これらの関数は`frame-height'や`frame-width'の古い別名である。
          文字端末を使っている場合、通常、フレームの大きさは
          端末スクリーンの大きさと同じである。

      -- Function: frame-pixel-height &optional frame
      -- Function: frame-pixel-width &optional frame
          これらの関数は、フレームFRAMEの高さや幅をピクセル単位で返す。
          FRAMEを指定しないと、選択されているフレームを使う。

      -- Function: frame-char-height &optional frame
      -- Function: frame-char-width &optional frame
          これらの関数は、フレーム内の文字の高さや幅をピクセル単位で返す。
          FRAMEを指定しないと、選択されているフレームを使う。

      -- Function: set-frame-size frame cols rows
          この関数は、フレームFRAMEの大きさを文字単位で指定する。
          COLSとROWSは、新たな幅と高さを指定する。

          ピクセル単位で大きさを指定するには、
          `frame-char-height'と`frame-char-width'で
          ピクセル単位の値を文字単位に変換する。

      -- Function: set-frame-height frame lines &optional pretend
          この関数は、フレームFRAMEの高さをLINES行に変える。
          それに合わせてFRAME内の既存のウィンドウの大きさは比例して変わる。

          PRETENDが`nil'以外であると、
          EmacsはFRAMEのLINESだけを表示するが、
          フレームの実際の高さは変更しない。
          これは端末フレームでのみ有用である。
          実際の端末より小さな高さを使うと、小さなスクリーンでの動作を再現したり、
          スクリーン全体を使うと端末が誤動作するような場合に有用である。
          フレームの『実際』の高さを指定してもつねにそうなるとは限らない。
          端末フレーム上で正しくカーソルを位置決めするには、
          実サイズを知る必要がある場合もあるからである。

      -- Function: set-frame-width frame width &optional pretend
          この関数は、フレームFRAMEの幅を設定する。
          引数PRETENDは`set-frame-height'と同じ意味を持つ。

        `set-screen-height'と`set-screen-width'の古い関数は、
複数フレームを扱えないEmacsの版でスクリーンの高さや幅を
指定するために使われていました。
これらはほぼ廃れていますが、まだ動作します。
これらは選択されているフレームに適用されます。

      -- Function: x-parse-geometry geom
          関数`x-parse-geometry'は、Xウィンドウの標準のジオメトリ文字列を
          `make-frame'の引数の一部に使えるように連想リストに変換する。

          この連想リストは、GEOMで指定されているパラメータとその値を記述する。
          各要素は`(PARAMETER . VALUE)'の形である。
          PARAMETERの可能な値は、
          `left'、`top'、`width'、`height'である。

          大きさを表すパラメータでは、その値は整数であること。
          位置を表すパラメータでは、右端や下端の位置を表す値もあるので、
          `left'や`top'というパラメータ名は必ずしも正確ではない。
          位置を表すパラメータの可能なVALUEはつぎのとおりである。

         整数
               正の整数は、ウィンドウの左端や上端をスクリーンの左端や上端に関連付ける。
               負の整数は、ウィンドウの右端や下端をスクリーンの右端や下端に関連付ける。

         `(+ POSITION)'
               スクリーンの左端や上端を基準にしたウィンドウの左端や上端の位置を指定する。
               整数POSITIONは正でも負でもよいが、
               負の値はスクリーンからはみ出した位置を指定する。

         `(- POSITION)'
               スクリーンの右端や下端を基準にしたウィンドウの右端や下端の位置を指定する。
               整数POSITIONは正でも負でもよいが、
               負の値はスクリーンからはみ出した位置を指定する。

          例を示す。

               (x-parse-geometry "35x70+0-0")
                    => ((height . 70) (width . 35)
                        (top - 0) (left . 0))


File: elisp-ja,  Node: Frame Titles,  Next: Deleting Frames,  Prev: Frame Parameters,  Up: Frames

28.4 フレームタイトル
=============================

     各フレームにはパラメータ`name'があります。
これは、典型的にはウィンドウシステムがフレームの先頭に表示する
フレームタイトルのデフォルトにもなります。
フレーム属性`name'に設定することで明示的に名前を指定できます。

        通常は名前を明示的に指定しないでしょうから、
変数`frame-title-format'に保持してある雛型から
Emacsが自動的にフレーム名を計算します。
Emacsは、フレームを再表示するたびに名前を再計算します。

      -- Variable: frame-title-format
          この変数は、読者がフレーム名を明示的に指定しなかったときの
          フレーム向けの名前の計算方法を指定する。
          変数の値は実際には、`mode-line-format'のようなモード行構成である。
          *note Mode Line Data::。

      -- Variable: icon-title-format
          この変数は、フレームタイトルを明示的に指定しなかったときの
          アイコンにしたフレーム向けの名前の計算方法を指定する。
          これはアイコンそのものに現れる。

      -- Variable: multiple-frames
          この変数はEmacsが自動的に設定する。
          （ミニバッファ専用のフレームや不可視フレームを数えずに）
          複数個のフレームがあるとこの値が`t'である。
          `frame-title-format'のデフォルト値では`multiple-frames'を使っており、
          複数のフレームがあるときに限りフレームタイトルにバッファ名が入るようにする。


File: elisp-ja,  Node: Deleting Frames,  Next: Finding All Frames,  Prev: Frame Titles,  Up: Frames

28.5 フレームの削除
==========================

     フレームを明示的に"削除"（delete）しない限り、
フレームは見える可能性があります。
フレームを削除するとスクリーンに表示できなくなりますが、
それを参照するものがなくならない限りLispオブジェクトとしては存在し続けます。
保存したフレーム構成（*note Frame Configurations::）を復元する以外には、
フレームの削除を取り消すことはできません。 これはウィンドウと同様です。

      -- コマンド: delete-frame &optional frame
          この関数はフレームFRAMEを削除する。
          デフォルトでは、FRAMEは選択されているフレームである。

      -- Function: frame-live-p frame
          関数`frame-live-p'は、フレームFRAMEが削除されていなければ
          `nil'以外を返す。

ウィンドウを削除するコマンドを与えるウィンドウマネージャもあります。
それらは、ウィンドウを操作しているプログラムに特別なメッセージを
送ることで動作します。 Emacsがそのようなコマンドを受け取ると、
イベント`delete-frame'を生成します。
このイベントの普通の定義は、関数`delete-frame'を呼び出すコマンドです。
*Note Misc Events::。


File: elisp-ja,  Node: Finding All Frames,  Next: Frames and Windows,  Prev: Deleting Frames,  Up: Frames

28.6 すべてのフレームを探す
======================================

      -- Function: frame-list
          関数`frame-list'は、削除されていないすべてのフレームから成るリストを返す。
          これは、バッファに対する`buffer-list'に相当する。
          得られるリストは新たに作成したものであり、
          このリストを変更してもEmacs内部にはなんの効果もない。

      -- Function: visible-frame-list
          この関数は、現在可視のフレームだけのリストを返す。 *note
          Visibility of Frames::。
          （選択されているフレームだけが実際に表示されている場合でも、
          端末フレームはすべてつねに『可視』とみなす。）

      -- Function: next-frame &optional frame minibuf
          関数`next-frame'により、
          任意の位置から始めてすべてのフレームを便利に巡回できる。
          巡回順の中でFRAMEの『つぎ』のフレームを返す。
          FRAMEを省略したり`nil'であると、
          デフォルトでは選択されているフレームを使う。

          第2引数MINIBUFは、対象とするフレームを指定する。

         `nil'
               ミニバッファ専用のフレームを除外する。

         `visible'
               すべての可視なフレームを対象にする。

         0
               すべての可視なフレームやアイコンにしたフレームを対象にする。

         ウィンドウ
               ミニバッファとして特定のウィンドウを使っているフレームのみを対象にする。

         その他
               すべてのフレームを対象にする。

      -- Function: previous-frame &optional frame minibuf
          `next-frame'と同様であるが、すべてのフレームを逆方向に巡回する。

        *note Cyclic Window
Ordering::の`next-window'と`previous-window'も 参照してください。


File: elisp-ja,  Node: Frames and Windows,  Next: Minibuffers and Frames,  Prev: Finding All Frames,  Up: Frames

28.7 フレームとウィンドウ
===================================

     各ウィンドウはある1つのフレームだけの一部であり、
`window-frame'で当該フレームを得られます。

      -- Function: window-frame window
          この関数は、WINDOWが属するフレームを返す。

        フレーム内のミニバッファ用以外のすべてウィンドウには、
巡回順序がついています。
その順序は、フレームの左上隅の先頭のウィンドウから始まって、
右下隅のウィンドウ（フレームにミニバッファがあれば、
これはつねにミニバッファ用ウィンドウ）に達するまで下向き右向きに進み、
そして先頭へ戻ります。

      -- Function: frame-top-window frame
          この関数は、フレームFRAMEのもっとも上端のもっとも左端の
          先頭のウィンドウを返す。

        ある時点では、各フレームではたった1つのフレームが
"当該フレームで選択されている"のです。 このような区別の意味は、
フレームを選択するとそのようなウィンドウも選択されるということです。
フレームで現在選択されているフレームは
`frame-selected-window'で得られます。

      -- Function: frame-selected-window frame
          この関数は、フレームFRAMEで選択されている
          FRAME内のウィンドウを返す。

        逆に、`select-window'でEmacsのウィンドウを選ぶと、
それがそのフレームで選択されているウィンドウになります。 *note
Selecting Windows::。

        指定したフレームのウィンドウの1つを返す別の関数は
`minibuffer-window'です。 *Note Minibuffer Misc::。


File: elisp-ja,  Node: Minibuffers and Frames,  Next: Input Focus,  Prev: Frames and Windows,  Up: Frames

28.8 ミニバッファとフレーム
======================================

     通常、各フレームにはそれ独自のミニバッファ用ウィンドウが底にあり、
フレームが選択されているときにはいつもそれが使われます。
フレームにミニバッファがあれば、`minibuffer-window' （*note Minibuffer
Misc::）でそれを得られます。

        しかし、ミニバッファのないフレームを作ることもできます。
そのようなフレームでは、別のフレームのミニバッファ用ウィンドウを
使う必要があります。 そのようなフレームを作成するときには、
使用する（他のフレームの）ミニバッファを明示的に指定できます。
そうしないと、変数`default-minibuffer-frame'の値で指定される
フレームのミニバッファを使います。
その値は、ミニバッファを有したフレームである必要があります。

        ミニバッファ専用のフレームを使うときは、
ミニバッファで入力するときにそのフレームが
自動的に手前にくるようにしたいでしょう。
そうしたい場合には、変数`minibuffer-auto-raise'に`t'に設定します。
*Note Raising and Lowering::。

      -- Variable: default-minibuffer-frame
          この変数は、デフォルトで使うミニバッファ用ウィンドウのフレームを指定する。
          この変数は現在の端末につねにローカルであり、
          バッファローカルにはなりえない。 *note Multiple Displays::。


File: elisp-ja,  Node: Input Focus,  Next: Visibility of Frames,  Prev: Minibuffers and Frames,  Up: Frames

28.9 入力フォーカス
==========================

     ある時点では、Emacsの1つのフレームが"選択されているフレーム"
（selected frame）です。
選択されているウィンドウは選択されているフレームの中につねにあります。

      -- Function: selected-frame
          この関数は選択されているフレームを返す。

        マウスが入っているウィンドウにキーボード入力を振り向ける
ウィンドウシステムやウィンドウマネージャがあります。
ウィンドウに"フォーカスを置くために"、
明示的にクリックしたりコマンドを必要とするものもあります。
いずれであっても、Emacsはどのフレームにフォーカスがあるかを
自動的に追跡します。

        Lispプログラムからは、関数`select-frame'を呼ぶことで、
『一時的に』フレームを切り替えることもできます。
これは、ウィンドウシステムのフォーカスは変えません。
というよりは、プログラムで指定するまで
ウィンドウシステムの制御を回避します。

        文字端末を使っているときには、
選択されているフレームのみが端末に実際に表示されます。
フレームを切り替える唯一の方法は`switch-frame'であり、
それ以降に`switch-frame'を呼び出すまで切り替えた効果は持続します。
初期フレーム以外の各端末フレームには番号が付いていて、
選択されているフレームの番号がモード行内のバッファ名のまえに現れます
（*note Mode Line Variables::）。

      -- Function: select-frame frame
          この関数はフレームFRAMEを選択し、
          Xサーバーのフォーカスを一時的に無視する。
          FRAMEを選択している状態は、
          ユーザーが別のフレームを選択する動作を行うか
          再度この関数が呼ばれるまで持続する。

        サーバーやウィンドウマネジャーの要請にしたがって
フレームを選択するようにして、 Emacsはウィンドウシステムと協調します。
必要なときには"focus"イベントと呼ばれる特別な入力イベントを
生成することでこのようにします。
コマンドループは`handle-switch-frame'を呼び出すことで
イベント"focus"を処理します。 *Note Focus Events::。

      -- コマンド: handle-switch-frame frame
          この関数は、フレームFRAMEを選択することでフォーカスイベントを
          処理する。

          フォーカスイベントは、通常、このコマンドを起動することで処理される。
          それ以外の理由ではこれを呼び出さないこと。

      -- Function: redirect-frame-focus frame focus-frame
          この関数は、フォーカスをFRAMEからFOCUS-FRAMEへ振り向ける。
          つまり、以降の打鍵やイベントは、FOCUSではなく、
          FOCUS-FRAMEが受け取ることになる。
          そのようなイベントのあとでは、
          `last-event-frame'の値はFOCUS-FRAMEになる。
          また、FOCUSを指定したイベント`switch-frame'は、
          FOCUS-FRAMEを選ぶことになる。

          FOCUS-FRAMEが`nil'であると、FRAMEでの振り向けを取り消す。
          つまり、FRAMEはイベントをふたたび受けるようになる。

          フォーカスの振り向けの用途の1つは、
          ミニバッファを持たないフレームのためである。
          これらのフレームでは、別のフレームのミニバッファを使う。
          別のフレームのミニバッファを活性にすると、
          フォーカスを当該フレームへ振り向ける。
          これにより、ミニバッファを活性にしたフレームにマウスが入っていても、
          ミニバッファのフレームにフォーカスを置ける。

          フレームを選択してもフォーカスの振り向けを変更する。
          フレーム`foo'を選択しているときにフレーム`bar'を選択すると、
          `foo'への振り向けを`bar'へ振り向けるように変更する。
          これにより、`select-window'を使ってユーザーが
          別のフレームへ切り替えても、フォーカスの振り向けが正しく動作する。

          これは、フォーカスを自分自身へ振り向けているフレームは、
          フォーカスを振り向けていないフレームとは異なる扱いを受けることを意味する。
          `select-frame'は前者に影響するが後者には影響しない。

          `redirect-frame-focus'で変更するまで、振り向けは持続する。

      -- User Option: focus-follows-mouse
          このオプションは、ユーザーがマウスを動かしたときに
          ウィンドウマネージャがフォーカスを移動するかどうかをEmacsに伝える。
          `nil'以外であるとフォーカスが移動することを意味する。
          その場合、コマンド`other-frame'は、
          新たに選択されたフレームに適合するような位置にマウスを移動する。


File: elisp-ja,  Node: Visibility of Frames,  Next: Raising and Lowering,  Prev: Input Focus,  Up: Frames

28.10 フレームの可視性
==============================

     ウィンドウフレームは、"可視"、
"不可視"、"アイコンになっている"のいずれかです。
フレームが可視であると、その内容を見ることができます。
アイコンになっているとフレームの内容はスクリーンで見えませんが、
アイコンは見えます。
フレームが不可視であると、それはスクリーン上に見えず
アイコンでもありません。

        端末フレームは選択されているものだけが表示されるので、
端末フレームでは可視性は意味がありません。

      -- コマンド: make-frame-visible &optional frame
          この関数は、フレームFRAMEを可視にする。
          FRAMEを省略すると、選択されているフレームを可視にする。

      -- コマンド: make-frame-invisible &optional frame
          この関数は、フレームFRAMEを不可視にする。
          FRAMEを省略すると、選択されているフレームを不可視にする。

      -- コマンド: iconify-frame &optional frame
          この関数は、フレームFRAMEをアイコンにする。
          FRAMEを省略すると、選択されているフレームをアイコンにする。

      -- Function: frame-visible-p frame
          この関数は、フレームFRAMEの可視性を返す。
          その値は、FRAMEが可視ならば`t'、
          不可視ならば`nil'、アイコンになっていれば`icon'である。

        フレームの可視性は、フレームパラメータとしても得られます。
フレームパラメータとして読んだり変更できます。 *Note Window Frame
Parameters::。

        ユーザーは、ウィンドウマネージャを用いて
フレームをアイコンにしたりアイコンを開けます。
これは、Emacsが制御できるレベルよりしたで行われますが、
Emacsはそのような変更を追跡できるようにイベントを提供します。 *Note
Misc Events::。


File: elisp-ja,  Node: Raising and Lowering,  Next: Frame Configurations,  Prev: Visibility of Frames,  Up: Frames

28.11 フレームを手前にしたり奥へ置く
===================================================

     ほとんどのウィンドウシステムでは、机のたとえを使います。
つまり、スクリーンの面に垂直な方向を概念的な3軸目と考えて、
ウィンドウは積み重なっていて、
もっとも手前からもっとも奥に順序がついています。
2つのウィンドウが重なり合っているところでは、
手前のものがそのしたのものを隠しています。
もっとも奥にあるウィンドウであっても、
それに重なるウィンドウがなければ見ることができます。

        ウィンドウのこのような順序は固定されていません。
実際、ユーザーは順序を頻繁に変更します。
ウィンドウを"手前に置く"（raising）とは、
ウィンドウを積み重ねのもっとも上に移動することです。
ウィンドウを"奥に置く"（lowering）とは、
ウィンドウを積み重ねのもっとも下に移動することです。
この移動は概念的な3軸目に限り、
スクリーン上でのウィンドウの位置は変えません。

        Emacsのフレームを表すウィンドウは、つぎの関数で
手前へ置いたり奥へ置けます。

      -- コマンド: raise-frame &optional frame
          この関数は、フレームFRAMEを手前に置く
          （デフォルトは選択されているフレーム）。

      -- コマンド: lower-frame &optional frame
          この関数は、フレームFRAMEを奥に置く
          （デフォルトは選択されているフレーム）。

      -- User Option: minibuffer-auto-raise
          これが`nil'以外であると、ミニバッファが活性になると
          ミニバッファ用ウィンドウがあるフレームを手前に置く。

        フレームパラメータを使うと、フレームが
選択されると自動的に手前に置いたり（`auto-raise'）、
選択を止めると奥へ置け（`auto-lower'）ます。 *Note Window Frame
Parameters::。


File: elisp-ja,  Node: Frame Configurations,  Next: Mouse Tracking,  Prev: Raising and Lowering,  Up: Frames

28.12 フレーム構成
========================

     "フレーム構成"（frame configuration）は、
現在のフレームの配置、それらのすべての属性、それぞれのウィンドウ構成を
記録したものです。 （*note Window Configurations::。）

      -- Function: current-frame-configuration
          この関数は、現在のフレームの配置とそれらの内容を記述した
          フレーム構成のリストを返す。

      -- Function: set-frame-configuration configuration
          この関数は、CONFIGURATIONで記述されたフレームの状態に復元する。


File: elisp-ja,  Node: Mouse Tracking,  Next: Mouse Position,  Prev: Frame Configurations,  Up: Frames

28.13 マウスの追跡
========================

     マウスを"追跡"（track）できると有用なことがあります。
つまり、マウスがどこにあるかを表す指示子を表示して
マウスの移動に従って指示子を動かすのです。
効率よくマウスを追跡するには、マウスが実際に移動するまで待つ手段が必要です。

マウスを追跡する便利な方法は、マウスの移動を表すイベントを待つことです。
そうすれば、そのようなイベントを待てばマウスの移動を待てます。
さらに、発生しうるそれ以外の種類のイベントを扱うのも簡単です。
普通はマウスを永遠に追跡し続けたいのではなく
ボタンを離すなどの別のイベントを待ちたいのでしょうから、
これは有用です。

      -- Special Form: track-mouse body...
          このスペシャルフォームは、マウスモーションイベントを生成するようにして
          BODYを実行する。 典型的にはBODYでは`read-event'を使って
          モーションイベントを読み、それに従って表示を変更する。
          マウスモーションイベントの形式については、 *note Motion
          Events::。

          `track-mouse'の値はBODYの最後のフォームの値である。
          BODYは、ボタンを離したことを表すイベントや
          追跡を終えるべきイベントに出会うと戻るように設計すること。

        マウスの移動を追跡する普通の目的は、
現在の位置でボタンを押したり離すとなにが起こるかを
スクリーン上に示すことです。

        多くの場面では、テキスト属性`mouse-face'（*note Special
Properties::） を使えば、マウスを追跡する必要はなくなります。
これはとても低いレベルで動作し、
Lispレベルでマウスを追跡するより滑らかに動作します。


File: elisp-ja,  Node: Mouse Position,  Next: Pop-Up Menus,  Prev: Mouse Tracking,  Up: Frames

28.14 マウスの位置
========================

     関数`mouse-position'と`set-mouse-position'で、
マウスの現在位置を参照できます。

      -- Function: mouse-position
          この関数は、マウスの位置を表すものを返す。 その値は`(FRAME X
          . Y)'の形であり、
          XとYはフレームFRAMEの内側の左上隅を基準にした
          文字数で数えた位置を表す整数である。

      -- Function: set-mouse-position frame x y
          この関数は、フレームFRAME内でXとYの位置にマウスを移動する。
          引数XとYは整数であり、
          フレームFRAMEの内側の左上隅を基準にした文字数で数えた位置である。
          FRAMEが不可視であると、この関数はなにもしない。
          戻り値には意味はない。

      -- Function: mouse-pixel-position
          この関数は`mouse-position'に似ているが、
          文字単位ではなくピクセル単位で座標を返す。

      -- Function: set-mouse-pixel-position frame x y
          この関数は`set-mouse-position'のようにマウスを移動するが、
          XとYは文字単位でなくピクセル単位である。
          これらの座標はフレームの内側にある必要はない。

          FRAMEが不可視であると、この関数はなにもしない。
          戻り値には意味はない。


File: elisp-ja,  Node: Pop-Up Menus,  Next: Dialog Boxes,  Prev: Mouse Position,  Up: Frames

28.15 ポップアップメニュー
====================================

     ウィンドウシステムを使っているときには、
ユーザーがマウスで選択できるように
Lispプログラムからメニューをポップアップできます。

      -- Function: x-popup-menu position menu
          この関数はポップアップメニューを表示し、
          ユーザーが行った選択を表す指示子を返す。

          引数POSITIONは、スクリーンのどこにメニューを置くかを指定する。
          それはマウスのボタンイベント（ユーザーがボタンを押した場所にメニューを置く）か
          つぎの形のリストでもよい。

               ((XOFFSET YOFFSET) WINDOW)

          ここで、XOFFSETとYOFFSETは
          ウィンドウWINDOWのフレームの左上隅から測ったピクセル単位の座標である。

          POSITIONが`t'であるとマウスの現在位置を使うことを意味する。
          POSITIONが`nil'であると、 メニューを実際には表示せずに、
          MENUに指定してあるキーマップに等価なキーバインディングを
          あらかじめ計算することを意味する。

          引数MENUは、メニューに表示するものを指定する。
          それはキーマップかキーマップのリストである（*note Menu
          Keymaps::）。 あるいは、つぎの形でもよい。

               (TITLE PANE1 PANE2...)

          ここで、各ペインはつぎの形のリストである。

               (TITLE (LINE . ITEM)...)

          各LINEは文字列であり、
          各ITEMは対応するLINEが選ばれたときに返される値であること。

        *使用上の注意：*` '
メニューキーマップで定義したプレフィックスキーでできることには、
メニューを表示するために`x-popup-menu'を使わないこと。
メニューキーマップを使ってメニューを実装すると、 `C-h c'や`C-h
a'で当該メニューの個々の項目を見ることができ、
それらに対するヘルプを提供できる。
`x-popup-menu'を呼び出すコマンドを定義してメニューを実装すると、
ヘルプ機能には当該コマンドの内側でなにがなされるかわからないので、
メニューの項目に対するヘルプを提供できない。

マウスの移動でサブメニューを切り替えられるメニューバーの機構では、
`x-popup-menu'を呼び出すコマンドの定義を調べられません。
したがって、`x-popup-menu'を使ってサブメニューを実装すると、
それらはメニューバーに適応した動作をできません。
このために、メニューバーのすべてのサブメニューは、
親メニュー内のメニューキーマップとして実装してあり、
`x-popup-menu'は使っていません。 *Note Menu Bar::。

        メニューバーに内容が変化するサブメニューを使いたいときでも、
メニューキーマップを使って実装するべきです。
内容を変えるには、必要に応じてメニューキーの内容を更新するために
`menu-bar-update-hook'にフック関数を追加します。


File: elisp-ja,  Node: Dialog Boxes,  Next: Pointer Shapes,  Prev: Pop-Up Menus,  Up: Frames

28.16 対話ボックス
========================

     対話ボックスはポップアップメニューの変形です。
少々異なって見えますが、フレームの中央につねに現れ、
たった1つのレベルで1つのペインです。 対話ボックスの主な用途は、
ユーザーが『yes』、『no』、および他の少数の選択肢で答えるような
問い合わせを行うためです。 関数`y-or-n-p'と`yes-or-no-p'は、
マウスクリックで起動されたコマンドから呼ばれると
キーボードではなく対話ボックスを使います。

      -- Function: x-popup-dialog position contents
          この関数は、対話ボックスを表示し、
          ユーザーが選んだ選択肢を表す指示子を返す。
          引数CONTENTSは表示する選択肢を指定し、つぎの形である。

               (TITLE (STRING . VALUE)...)

          これは、`x-popup-menu'に対して単一のペインを指定するリストに似ている。

          戻り値は、選ばれた選択肢のVALUEである。

          リストの要素は、`(STRING . VALUE)'の形の
          コンスセルのかわりに単に文字列でもよい。
          そうすると、対話ボックスでは選択できなくなる。

          リストに`nil'が現れると、それは左側の項目と右側の項目を区切る。
          `nil'のまえの項目は左側に現れ、
          `nil'に続く項目は右側に現れる。
          リストに`nil'を含めなければ、項目のほぼ半分がそれぞれの側に現れる。

          対話ボックスはフレームの中央につねに現れ、
          引数POSITIONはそのフレームを指定する。
          可能な値は`x-popup-menu'と同様であるが、
          正確な座標は関係なくフレームだけが意味を持つ。

          場合によっては、Emacsは本当の対話ボックスを表示できない。
          そのときにはフレームの中央にポップアップメニューで同じ項目を表示する。


File: elisp-ja,  Node: Pointer Shapes,  Next: Window System Selections,  Prev: Dialog Boxes,  Up: Frames

28.17 ポインタの形状
===========================

     これらの変数は、Xウィンドウシステムを使っているときに
さまざまな場面で使用するマウスポインタの形状を指定します。

    `x-pointer-shape'
          この変数は、Emacsのフレーム内で普通に使うポインタ形状を指定する。

    `x-sensitive-text-pointer-shape'
          この変数は、マウスに反応するテキスト上にマウスがあるときに
          使用するポインタ形状を指定する。

        これらの変数は、新たに作成したフレームに影響します。
既存のフレームには通常は影響しません。
しかし、フレームのマウスの表示色を設定すると、
これらの変数の現在値に基づいてポインタ形状も更新します。 *Note Window
Frame Parameters::。

        これらのポインタ形状の指定に使える値は、
ファイル`lisp/term/x-win.el'で定義してあります。 それらの一覧を見るには
`M-x apropos <RET> x-pointer <RET>'を使います。


File: elisp-ja,  Node: Window System Selections,  Next: Font Names,  Prev: Pointer Shapes,  Up: Frames

28.18 ウィンドウシステムのセレクション
======================================================

     Xサーバーは、アプリケーションプログラムのあいだでデータを
転送するための"セレクション"（selection）の集まりを記録します。
さまざまなセレクションは、Emacsではシンボルで表した
"セレクション型"（selection type）で区別されます。
Emacsを含むXクライアントは、任意の型のセレクションを読んだり設定できます。

      -- Function: x-set-selection type data
          この関数は、Xサーバーに『セレクション』を設定する。
          これは2つの引数、セレクション型TYPEと
          それに割り当てる値DATAを取る。
          DATAが`nil'であると、当該セレクションを削除することを意味する。
          さもなければDATAは、文字列、
          整数（あるいは2つの数のコンスセルかリスト）、
          オーバレイ、同じバッファを指す2つのマーカのコンスセルのいずれかである。
          オーバレイやマーカの対は、
          オーバレイのテキストやマーカのあいだのテキストを表す。

          引数DATAは、ベクトルではない正しいセレクション値のベクトルでもよい。

          可能な各TYPEには型に依存した独自のセレクション値がある。
          TYPEの普通の値は`PRIMARY'か`SECONDARY'である。
          これらのシンボルは、Xウィンドウシステムの慣習に従って
          大文字の名前である。 デフォルトは`PRIMARY'である。

      -- Function: x-get-selection &optional type data-type
          この関数は、Emacsや他のXクライアントが設定したセレクションを参照する。
          これは2つの引数、TYPEとDATA-TYPEを取る。
          セレクション型TYPEのデフォルトは`PRIMARY'である。

          引数DATA-TYPEは、他のXクライアントから得た生データを
          Lispデータに変換するために使用するデータ変換の書式を指定する。
          意味のある値は、`TEXT'、`STRING'、
          `CHARACTER_POSITION'、`LINE_NUMBER'、`COLUMN_NUMBER'、
          `OWNER_OS'、`HOST_NAME'、`USER'、`CLASS'、
          `NAME'、`ATOM'、`INTEGER'である。
          （これらのシンボルは、Xウィンドウシステムの慣習に従って
          大文字の名前である。） DATA-TYPEのデフォルトは`STRING'である。

Xサーバーには、アプリケーションのあいだで移動するテキストや他のデータを
保存できる番号付きの"カットバッファ"（cut buffer）の集まりもあります。
カットバッファは廃れているとみなされますが、
それらを使っているXクライアント向けにEmacsはカットバッファを扱えます。

      -- Function: x-get-cut-buffer n
          この関数は、番号Nのカットバッファの内容を返す。

      -- Function: x-set-cut-buffer string
          Emacsが連続したキルをキルリングで順に下向きに移動するのと同様に、
          この関数は一連のカットバッファの値を順に下向きに移動してから
          文字列STRINGを最初のカットバッファ（番号0）に保存する。

      -- Variable: selection-coding-system
          この変数は、セレクション、クリップボード、カットバッファを
          読み書きするときに使うコーディングシステムを指定する。 *note
          Coding Systems::。 デフォルトは`compound-text'である。


File: elisp-ja,  Node: Font Names,  Next: Fontsets,  Prev: Window System Selections,  Up: Frames

28.19 フォント名の探索
==============================

      -- Function: x-list-font pattern &optional face frame maximum
          この関数は、パターンPATTERNに一致する
          利用可能なフォント名のリストを返す。
          省略可能な引数FACEとFRAMEを指定すると、
          FRAMEで現在オンになっているFACEと同じサイズのフォントに
          リストを制限する。

          引数PATTERNは文字列であること。
          これはワイルドカード文字を含んでいてもよい。
          `*'は任意の部分文字列に一致し、`?'は任意の1文字に一致する。
          フォント名とパターンの一致を取る際には、大文字小文字を区別しない。

          FACEとFRAMEを指定するときには、
          FACEはフェイス名（シンボル）であり、FRAMEはフレームであること。

          省略可能な引数MAXIMUMは、返すフォントの個数を制限する。
          これが`nil'以外であると、戻り値は最初のMAXIMUM個の
          一致したフォントに切り詰める。 MAXIMUMに小さな値を指定すると、
          多くのフォントに一致する場合ではこの関数の動作がだいぶ速くなる。


File: elisp-ja,  Node: Fontsets,  Next: Color Names,  Prev: Font Names,  Up: Frames

28.20 フォントセット
===========================

     "フォントセット"（fontset）は、フォントのリストであって、
各フォントが文字コードのある範囲に割り付けられています。
個々のフォントだけでは、Emacsが扱う文字集合の範囲全体を表示できませんが、
フォントセットならば可能です。
フォントセットにはフォントと同様に名前があり、
フレームやフェイス向けに『フォント』を指定するときの
フォント名のかわりにフォントセット名を使えます。
ここでは、Lispプログラムの制御のもとにフォントセットを定義することに
関する情報を述べます。

      -- Function: create-fontset-from-fontset-spec fontset-spec
               &optional style-variant-p noerror
          この関数は、指定文字列FONTSET-SPECに従って
          新たなフォントセットを定義する。 文字列はつぎの形であること。

               FONTPATTERN, [CHARSETNAME:FONTNAME]...

          コンマの前後の白文字は無視する。

          文字列の始めの部分FONTPATTERNは、
          最後の2つのフィールドが`fontset-ALIAS'であることを除いて、
          Xの標準フォント名であること。

          新たなフォントセットには2つの名前、つまり、長い名前と短い名前がある。
          長い名前はFONTPATTERNそのものである。
          短い名前は`fontset-ALIAS'である。
          どちらの名前でもフォントセットを参照できる。
          同じ名前のフォントセットがすでに存在する場合、
          NOERRORが`nil'であるとエラーを通知し、
          この関数はなにもしない。

          省略可能な引数STYLE-VARIANT-Pが`nil'以外であると、
          フォントセットのbold（太字）、italic（斜体）、bold-italic（太字斜体）の
          各変種も作成することを指示する。
          これらの変種のフォントセットには短い名前はなく、
          varfontpatternのboldやitalicを変更して作った長い名前だけである。

          指定文字列ではフォントセットで使うフォントも指定する。
          詳しくは下記参照。

        `CHARSET:FONT'という構成は、
特定の1つの文字集合向けに（このフォントセットで）使うフォントを指定します。
ここで、CHARSETは文字集合の名前であり、
FONTはその文字集合に使うフォントです。
この構成は、指定文字列で何回でも使えます。

        明示してない残りの文字集合向けには、
FONTPATTERNに基づいてEmacsがフォントを選びます。
つまり、`fontset-ALIAS'を1つの文字集合を指名する値で置き換えます。
ASCII文字集合向けには、 `fontset-ALIAS'を`ISO8859-1'で置き換えます。

これに加えて、いくつか連続したフィールドがワイルドカードであるなら、
Emacsはそれらを1つのワイルドカードにまとめます。
これは、自動的に拡大縮小したフォントの使用を避けるためです。
大きめのフォントを縮小したフォントは編集には使えません。
また、小さめのフォントを拡大したフォントも有用ではありません。
というのは、Emacsがそうするように、
もともと小さなフォントを使うほうがよいからです。

        したがって、FONTPATTERNがつぎのようであると、

          -*-fixed-medium-r-normal-*-24-*-*-*-*-*-fontset-24

     ASCII文字に対するフォント指定はつぎのようになります。

          -*-fixed-medium-r-normal-*-24-*-ISO8859-1

     また、Chinese
GB2312文字に対するフォント指定はつぎのようになります。

          -*-fixed-medium-r-normal-*-24-*-gb2312*-*

        上のフォント指定に一致する中国語フォントがないかもしれません。
多くのXの配布には、FAMILYフィールドが `song ti'か`fangsong
ti'の中国語フォントだけが含まれています。
そういった場合、`Fontset-N'をつぎのように指定します。

          Emacs.Fontset-0: -*-fixed-medium-r-normal-*-24-*-*-*-*-*-fontset-24,\
                  chinese-gb2312:-*-*-medium-r-normal-*-24-*-gb2312*-*

     そうすると、Chinese GB2312の文字を除くフォント指定では
FAMILYフィールドが`fixed'となり、 Chinese
GB2312の文字に対するフォント指定では FAMILYフィールドが`*'となります。


File: elisp-ja,  Node: Color Names,  Next: Resources,  Prev: Fontsets,  Up: Frames

28.21 表示色名
==================

      -- Function: x-color-defined-p color &optional frame
          この関数は、表示色名が意味のあるものかどうかを報告する。
          意味があれば`t'を返し、さもなければ`nil'を返す。
          引数FRAMEは、どのフレームで調べるかを指定する。
          FRAMEを省略したり`nil'であると、選択されているフレームを使う。

          この関数では、読者が使用しているディスプレイで
          当該表示色を実際に表示できるかどうかはわからない。
          どんな種類のディスプレイでも定義されていればどんな表示色でも
          問い合わせることができ、なんらかの結果を得られる。
          Xサーバーはこのように動作するのである。
          読者のディスプレイで表示色COLORを使えるかどうかを
          検査する近似方法はつぎのとおりである。

               (defun x-color-supported-p (color &optional frame)
                 (and (x-color-defined-p color frame)
                      (or (x-display-color-p frame)
                          (member color '("black" "white"))
                          (and (> (x-display-planes frame) 1)
                               (equal color "gray")))))

      -- Function: x-color-values color &optional frame
          この関数は、表示色COLORが理想的にはどのように見えるかを記述した値を返す。
          COLORが定義されていれば、その値は、赤の分量、緑の分量、青の分量を表す
          3つの整数のリストである。
          各整数の範囲は原理的には0から65535であるが、
          実際には65280を超えることはないようである。
          COLORが定義されていなければ、値は`nil'である。

               (x-color-values "black")
                    => (0 0 0)
               (x-color-values "white")
                    => (65280 65280 65280)
               (x-color-values "red")
                    => (65280 0 0)
               (x-color-values "pink")
                    => (65280 49152 51968)
               (x-color-values "hungry")
                    => nil

          フレームFRAMEのディスプレイに対する表示色の値を返す。
          FRAMEを省略したり`nil'であると、
          選択されているフレームのディスプレイに対する値を返す。


File: elisp-ja,  Node: Resources,  Next: Server Data,  Prev: Color Names,  Up: Frames

28.22 Xリソース
===================

      -- Function: x-get-resource attribute class &optional component
               subclass
          関数`x-get-resource'は、
          Xウィンドウのデフォルトのデータベースからリソースの値を取り出す。

          リソースは、"key"と"class"の組み合わせで添字付けされる。
          この関数は`INSTANCE.ATTRIBUTE'の形
          （INSTANCEはEmacsを起動した名前）のキーと
          クラスとして`Emacs.CLASS'を使って探索する。

          省略可能な引数COMPONENTとSUBCLASSは、それぞれ、
          キーとクラスに追加される。
          2つを指定するかまったく指定しないこと。 これらを指定すると、
          キーは`INSTANCE.COMPONENT.ATTRIBUTE'であり、
          クラスは`Emacs.CLASS.SUBCLASS'である。

      -- Variable: x-resource-class
          この変数は、`x-get-resource'が探すアプリケーション名を指定する。
          デフォルト値は`"Emacs"'である。
          `x-get-resource'を呼び出す周りでこの変数に別の文字列を束縛すれば、
          『Emacs』以外のアプリケーション名でXリソースを探せる。

        *Note Xリソース: (emacs)Resources X。


File: elisp-ja,  Node: Server Data,  Prev: Resources,  Up: Frames

28.23 Xサーバーに関するデータ
========================================

本節では、Emacsが使っているXディスプレイの能力や製造元に関する情報を
得るために使う関数について述べます。
これらの関数のそれぞれには、どのディスプレイを対象にするか
引数DISPLAYで指定できます。 引数DISPLAYは、ディスプレイ名か
フレーム（が表示されいるディスプレイを意味する）のいずれかです。
引数DISPLAYを省略したり`nil'であると、
選択されているフレームのディスプレイを使うことを意味します。

      -- Function: x-display-screens &optional display
          この関数は、ディスプレイに対応付けられているスクリーンの個数を返す。

      -- Function: x-server-version &optional display
          この関数は、ディスプレイで動作中のXサーバーの版番号のリストを返す。

      -- Function: x-server-vendor &optional display
          この関数は、Xサーバーソフトウェアの提供業者を返す。

      -- Function: x-display-pixel-height &optional display
          この関数はスクリーンのピクセル単位の高さを返す。

      -- Function: x-display-mm-height &optional display
          この関数はスクリーンのミリメートル単位の高さを返す。

      -- Function: x-display-pixel-width &optional display
          この関数はスクリーンのピクセル単位の幅を返す。

      -- Function: x-display-mm-width &optional display
          この関数はスクリーンのミリメートル単位の幅を返す。

      -- Function: x-display-backing-store &optional display
          この関数は、スクリーンのバッキングストア機能を返す。
          その値は、`always'、`when-mapped'、`not-useful'のシンボルの
          いずれかである。

      -- Function: x-display-save-under &optional display
          この関数は、ディスプレイにセーブアンダー機能があれば`nil'以外を返す。

      -- Function: x-display-planes &optional display
          この関数は、ディスプレイのプレイン数を返す。

      -- Function: x-display-visual-class &optional display
          この関数は、スクリーンのビジュアルクラスを返す。
          その値は、`static-gray'、`gray-scale'、
          `static-color'、`pseudo-color'、`true-color'、
          `direct-color'のシンボルのいずれかである。

      -- Function: x-display-grayscale-p &optional display
          この関数は、スクリーンで白黒の濃淡を表示できると`t'を返す。

      -- Function: x-display-color-p &optional display
          この関数は、スクリーンがカラースクリーンならば`t'を返す。

      -- Function: x-display-color-cells &optional display
          この関数はスクリーンで使えるカラーセルの個数を返す。


File: elisp-ja,  Node: Positions,  Next: Markers,  Prev: Frames,  Up: Top

29 バッファ内の位置
***************************

     バッファ内"位置"（position）は、
バッファ内のテキストの文字を添字付けします。
より正確にいえば、バッファ内位置は2つの文字のあいだの箇所
（あるいは、先頭文字ではそのまえ、最後の文字ではそのうしろ）を識別して、
指定位置のまえやうしろの文字を指定できるようにします。
しかし、しばしば位置『にある』文字といいますが、
これは位置の直後の文字を意味します。

        バッファ内位置は、通常、1から始まる整数で表しますが、
"マーカ"（marker）で表すこともできます。
マーカは特別なオブジェクトであり、 テキストを挿入したり削除しても
同じ周りの文字に留まるように自動的に再配置されます。 *Note Markers::。

     * Menu:

     * Point::         The special position where editing takes place.
     * Motion::        Changing point.
     * Excursions::    Temporary motion and buffer changes.
     * Narrowing::     Restricting editing to a portion of the buffer.


File: elisp-ja,  Node: Point,  Next: Motion,  Up: Positions

29.1 ポイント
=================

     "ポイント"（point）は、
自己挿入文字やテキスト挿入関数を含む多くの編集コマンドが使う
バッファ内の特別な位置です。
他のコマンドは、バッファ内の別の箇所で編集したり挿入できるように
ポイントをテキスト内で移動します。

        他のバッファ内位置と同様に、ポイントは文字そのものではなく、
2つの文字のあいだの箇所
（あるいは、先頭文字ではそのまえ、最後の文字ではそのうしろ）を指定します。
通常、端末では、ポイントの直後の文字に重ねてカーソルを表示します。
ポイントはカーソルがある文字のまえに実際にはあります。

        ポイントの値は、1からバッファのサイズ足す1です。
ナロイング（*note Narrowing::）していると、
ポイントはバッファの参照可能な
（バッファの端を含むかもしれない）範囲内に制限されます。

        各バッファには独自のポイント値があり、
それは他のバッファのポイント値とは独立です。
各ウィンドウにも独自のポイント値があり、
同じバッファを表示している他のウィンドウのポイント値とは独立です。
このようなわけで、同じバッファを表示しているさまざまなウィンドウで
異なるポイント値を持てるのです。
1つのウィンドウだけにバッファが表示されているときには、
バッファのポイントとウィンドウのポイントは、通常、同じ値であり、
それらを区別することはほとんど重要ではありません。 詳しくは、*Note
Window Point::。

      -- Function: point
          この関数はカレントバッファのポイント値を整数で返す。

               (point)
                    => 175

      -- Function: point-min
          この関数は、カレントバッファで参照可能なポイント値の最小値を返す。
          これは通常1であるが、
          ナロイングしているときには、ナロイングした領域の開始位置である。
          （*note Narrowing::。）

      -- Function: point-max
          この関数は、カレントバッファで参照可能なポイント値の最大値を返す。
          ナロイングしていなければ、これは`(1+ (buffer-size))'である。
          ナロイングしているときには、ナロイングした領域の終了位置である。
          （*note Narrowing::。）

      -- Function: buffer-end flag
          この関数は、FLAGが1未満であれば`(point-min)'を返し、
          さもなければ`(point-max)'を返す。 引数FLAGは整数であること。

      -- Function: buffer-size
          この関数は、カレントバッファ内の総文字数を返す。
          ナロイング（*note Narrowing::）していなければ、
          `point-max'はこの値より1大きな値を返す。

               (buffer-size)
                    => 35
               (point-max)
                    => 36


File: elisp-ja,  Node: Motion,  Next: Excursions,  Prev: Point,  Up: Positions

29.2 移動
===========

     移動関数は、現在のポイント値やバッファの先頭や末尾を基準にして、
あるいは、選択されているウィンドウの端を基準にして、
ポイント値を変更します。 *Note Point::。

     * Menu:

     * Character Motion::       Moving in terms of characters.
     * Word Motion::            Moving in terms of words.
     * Buffer End Motion::      Moving to the beginning or end of the buffer.
     * Text Lines::             Moving in terms of lines of text.
     * Screen Lines::           Moving in terms of lines as displayed.
     * List Motion::            Moving by parsing lists and sexps.
     * Skipping Characters::    Skipping characters belonging to a certain set.


File: elisp-ja,  Node: Character Motion,  Next: Word Motion,  Up: Motion

29.2.1 文字単位の移動
----------------------------

     これらの関数は、文字数に基づいてポイントを移動します。
`goto-char'が基本になる基本関数であり、他の関数はこれを使っています。

      -- コマンド: goto-char position
          この関数は、カレントバッファのポイント位置を値POSITIONとする。
          POSITIONが1未満であると、バッファの先頭にポイントを移動する。
          POSITIONがバッファの長さより大きい場合には、
          バッファの末尾にポイントを移動する。

          ナロイングしている場合であっても、
          POSITIONはバッファの先頭から数えるが、
          参照可能部分の外側にはポイントは移動できない。
          POSITIONが範囲外であると、
          `goto-char'は参照可能部分の先頭か末尾にポイントを移動する。

          この関数を対話的に呼び出すと、
          前置引数があればPOSITIONは数値前置引数である。
          さもなければミニバッファから読む。

          `goto-char'はPOSITIONを返す。

      -- コマンド: forward-char &optional count
          この関数は、前方へ、つまり、バッファの末尾に向けて
          （COUNTが負であれば、後方へ、つまり、バッファの先頭へ向けて）
          COUNT文字分ポイントを移動する。 バッファの先頭や末尾を越えて
          （ナロイングしているときには参照可能部分を越えて）
          ポイントを移動しようとすると、
          `beginning-of-buffer'か`end-of-buffer'のエラーコードで
          エラーを通知する。

          対話的に呼び出されると、COUNTは数値前置引数である。

      -- コマンド: backward-char &optional count
          この関数は、後方へ、つまり、バッファの先頭に向けて
          （COUNTが負であれば、前方へ、つまり、バッファの末尾へ向けて）
          COUNT文字分ポイントを移動する。 バッファの先頭や末尾を越えて
          （ナロイングしているときには参照可能部分を越えて）
          ポイントを移動しようとすると、
          `beginning-of-buffer'か`end-of-buffer'のエラーコードで
          エラーを通知する。

          対話的に呼び出されると、COUNTは数値前置引数である。


File: elisp-ja,  Node: Word Motion,  Next: Buffer End Motion,  Prev: Character Motion,  Up: Motion

29.2.2 単語単位の移動
----------------------------

     これらの単語を解析する関数は、
当該文字が単語の一部かどうかを判定するために構文テーブルを使います。
*Note Syntax Tables::。

      -- コマンド: forward-word count
          この関数は、前方へ（COUNTが負ならば後方へ）
          COUNT単語分ポイントを移動する。 『1単語分移動する』とは、
          単語構成文字を越えてから単語区切り文字（あるいはバッファの参照可能部分の
          境界）に出会うまでポイントを移動することを意味する。

          バッファの境界で止まらず（最後の単語は除く）に
          COUNT単語分移動できると、値は`t'である。
          さもなければ値は`nil'であり、ポイントはバッファの境界で止まる。

          対話的に呼び出されると、COUNTは数値前置引数である。

      -- コマンド: backward-word count
          この関数は`forward-word'と同様であるが、
          前方へではなく後方へ単語の先頭に出会うまで移動する。

          対話的に呼び出されると、COUNTは数値前置引数である。

          この関数は、プログラムではほとんど使われない。
          負の引数で`forward-word'を呼び出すほうが効率的だからである。

      -- Variable: words-include-escapes
          この変数は、`forward-word'とそれを使うもののふるまいに影響する。
          `nil'以外であると、『エスケープ』や『文字クォート』の
          構文クラスに属する文字も単語の一部とみなす。
          さもなければ、単語の一部とはみなさない。


File: elisp-ja,  Node: Buffer End Motion,  Next: Text Lines,  Prev: Word Motion,  Up: Motion

29.2.3 バッファの両端への移動
----------------------------------------

     バッファの先頭にポイントを移動するには、つぎのように書きます。

          (goto-char (point-min))

     同様に、バッファの末尾に移動するには、つぎのようにします。

          (goto-char (point-max))

        上のことを行うためにユーザーが使うコマンドが2つあります。
これらはマークを設定してエコー領域にメッセージを表示するので、
これらをLispプログラムからは使わないように警告しておきます。

      -- コマンド: beginning-of-buffer &optional n
          この関数は、バッファ（あるいはナロイングしているときには参照可能部分）
          の先頭にポイントを移動し、移動前の位置にマークを設定する。
          Nが`nil'以外であると、
          バッファの先頭から10分のNの箇所にポイントを移動する。

          対話的に呼び出すと、前置引数があればNは数値前置引数である。
          さもなければNのデフォルトは`nil'である。

          *警告：*` 'Lispプログラムではこの関数を使わないこと！

      -- コマンド: end-of-buffer &optional n
          この関数は、バッファ（あるいはナロイングしているときには参照可能部分）
          の末尾にポイントを移動し、移動前の位置にマークを設定する。
          Nが`nil'以外であると、
          バッファの末尾から10分のNの箇所にポイントを移動する。

          対話的に呼び出すと、前置引数があればNは数値前置引数である。
          さもなければNのデフォルトは`nil'である。

          *警告：*` 'Lispプログラムではこの関数を使わないこと！


File: elisp-ja,  Node: Text Lines,  Next: Screen Lines,  Prev: Buffer End Motion,  Up: Motion

29.2.4 テキスト行単位の移動
-------------------------------------

     テキスト行とは、改行文字で区切られたバッファの部分です。
改行文字はまえの行に属するとみなします。
最初のテキスト行がバッファの先頭から始まり、
バッファの末尾の文字が改行であってもなくても、
最後のテキスト行はバッファの末尾で終ります。
バッファをテキスト行に分割することは、
ウィンドウの幅、表示上の行の継続、タブやコントロール文字の表示方法には
影響されません。

      -- コマンド: goto-line line
          この関数は、バッファの先頭を1行目と数えてLINE行目の先頭に
          ポイントを移動する。
          LINEが1未満であると、バッファの先頭へポイントを移動する。
          LINEがバッファ内の行数より大きいと、
          バッファの末尾、つまり、_バッファの最後の行の末尾_にポイントを移動する。
          これは、`goto-line'が行頭にポイントを移動しない唯一の場面である。

          ナロイングしているときでも、
          LINEはバッファの先頭から数えるが、
          参照可能部分の外側にはポイントは移動しない。
          したがって、行番号が参照不可な部分を指定するときには、
          `goto-line'は参照可能部分の先頭か末尾へポイントを移動する。

          `goto-line'の戻り値は、
          （ナロイングを考慮せずにバッファ全体でみた）
          LINEと実際のポイントの移動先の行の行番号との差である。
          したがって、指定した行に達するまえにバッファの末尾に出会うと値は正である。
          バッファの実際の末尾にではなく参照可能部分の末尾に出会うと値は0である。

          対話的に呼び出すと、
          前置引数があればLINEは数値前置引数である。
          さもなければLINEをミニバッファから読む。

      -- コマンド: beginning-of-line &optional count
          この関数は、現在行の先頭にポイントを移動する。
          引数COUNTが`nil'でも1でもないと、
          COUNT-1行だけ前方へ移動してから行頭に移動する。

          バッファ（ナロイングしているときには参照可能部分）の末尾に達すると
          ポイントをそこへ移動する。 エラーは通知しない。

      -- コマンド: end-of-line &optional count
          この関数は、現在行の末尾にポイントを移動する。
          引数COUNTが`nil'でも1でもないと、
          COUNT-1行だけ前方へ移動してから行末に移動する。

          バッファ（ナロイングしているときには参照可能部分）の末尾に達すると
          ポイントをそこへ移動する。 エラーは通知しない。

      -- コマンド: forward-line &optional count
          この関数は、COUNT行前方の行頭にポイントを移動する。
          COUNTが負であると、 -COUNT行後方の行頭にポイントを移動する。
          COUNTが0であると、現在行の先頭にポイントを移動する。

          指定行数だけ移動するまえに
          バッファ（ナロイングしているときには参照可能部分）の先頭や末尾に達すると
          ポイントをそこへ移動する。 エラーは通知しない。

          `forward-line'は、 COUNTと実際に移動した行数の差を返す。
          3行しかないバッファの先頭で5行前方へ移動しようとすると、
          ポイントは最後の行の末尾で止まり、値は2になる。

          対話的に呼び出すと、COUNTは数値前置引数である。

      -- Function: count-lines start end
          この関数は、カレントバッファのSTARTとENDの
          あいだの部分にある行の行数を返す。
          STARTとENDが等しければ0を返す。
          さもなければ、STARTとENDが同じ行にある場合であっても
          少なくとも1を返す。
          というのは、それらのあいだのテキストは孤立しているとみなされ、
          空でなければ少なくとも1行はあるはずだからである。

          `count-lines'の使用例を示す。

               (defun current-line ()
                 "Return the vertical position of point..."
                 (+ (count-lines (window-start) (point))
                    (if (= (current-column) 0) 1 0)
                    -1))

        *note Near Point::の関数`bolp'や`eolp'も参照してください。
これらの関数はポイントを移動しませんが、ポイントがすでに行の先頭や末尾に
あるかどうかを検査します。


File: elisp-ja,  Node: Screen Lines,  Next: List Motion,  Prev: Text Lines,  Up: Motion

29.2.5 スクリーン行分の移動
-------------------------------------

前節の行単位の関数は、改行文字で区切られたテキスト行だけを数えます。
対照的に、これらの関数は、スクリーン上にどのようにテキストが現れるかで
定義されるスクリーン上の行を数えます。
テキスト行が選択されているウィンドウの幅に収まるだけ短ければ、
1テキスト行は1スクリーン行ですが、
しかし、それ以外では1テキスト行は複数のスクリーン行を占めます。

        テキスト行を複数のスクリーン行に継続せずに
スクリーン上で切り詰める場合もあります。
このような場合、`vertical-motion'は、
`forward-line'によく似たポイントの移動を行います。 *Note Truncation::。

与えられた文字列の幅は、各文字の見ためを制御するフラグに依存するので、
`vertical-motion'は、 テキストを収めたバッファや選択されているウィンドウ
（その幅や切り詰めフラグ、ウィンドウごとに異なりうる表示テーブルが
あるため）に依存して、特定のテキスト部分に対して異なったふるまいをします。
*Note Usual Display::。

これらの関数は、スクリーン行がどこで区切れるかを決定するためにテキストを走査
するので、走査する量に比例して時間がかかります。
読者がこれらを多用する意図があるときには、
読者のコードの効率を改善するキャッシュをEmacsが提供します。 *Note
cache-long-line-scans: Truncation。

      -- Function: vertical-motion count &optional window
          この関数は、ポイントを含むスクリーン行から
          COUNTスクリーン行数だけ下向きにポイントを移動する。
          COUNTが負であると上向きに移動する。

          `vertical-motion'は、ポイントを移動したスクリーン行数を返す。
          バッファの先頭や末尾に達すると、
          この値は絶対値ではCOUNTより小さい。

          ウィンドウWINDOWは、
          幅、水平スクロール、表示テーブルなどのパラメータを得るために使われる。
          しかし、WINDOWに別のバッファが表示されているとしても、
          `vertical-motion'はつねにカレントバッファに作用する。

      -- コマンド: move-to-window-line count
          この関数は、選択されているウィンドウに現在表示されているテキストに
          基づいてポイントを移動する。
          ウィンドウの先頭からCOUNTスクリーン行の先頭にポイントを移動する。
          COUNTが負であると、底（あるいはバッファの末尾がスクリーンの
          底より上にある場合にはバッファの最終行）から数えて
          -COUNTスクリーン行位置を指定する。

          COUNTが`nil'であると、
          ウィンドウの中央の行の先頭にポイントを移動する。 COUNT
          の絶対値がウィンドウのサイズよりも大きいときには、
          ウィンドウに十分な高さがあった場合に移動するであろう
          スクリーン行の箇所にポイントを移動する。
          そのため、スクロールして当該箇所がスクリーンに現れるように再表示する。

          対話的に呼び出されると、COUNTは数値前置引数である。

          戻り値は、ウィンドウの先頭行を0と数えて、移動先の行のウィンドウ行番号である。

      -- Function: compute-motion from frompos to topos width offsets
               window
          この関数は、スクリーン上での位置を計算しながらカレントバッファを走査する。
          バッファ内位置FROMがスクリーン座標FROMPOSに対応すると仮定して、
          FROMから前方へ向けてTOかTOPOSのどちらかに
          達するまでバッファを走査する。
          バッファ内の終了位置とスクリーン座標を返す。

          座標引数FROMPOSとTOPOSは、 `(HPOS .
          VPOS)'の形のコンスセルである。

          引数WIDTHは、テキストを表示できるコラム数であり、
          これは継続行の扱いに影響する。
          読者が選んだウィンドウに対して`window-width'が返した値、
          つまり、通常、`(window-width WINDOW)'を使う。

          引数OFFSETSは、`nil'であるか、 `(HSCROLL .
          TAB-OFFSET)'の形のコンスセルである。
          ここで、HSCROLLは左端に表示されていないコラム数であり、
          多くの場合は`window-hscroll'を呼び出して得た値を使う。
          一方、TAB-OFFSETはスクリーン上でのコラム番号と
          バッファ内でのコラム番号の差である。
          この値は、継続行においてまえのスクリーン行の幅が`tab-width'で終らない
          場合に0以外になる。 継続しない行ではつねに0である。

          ウィンドウWINDOWは、使用する表示テーブルを指定するためだけに使われる。
          WINDOWに表示されているバッファに関わらず、
          `compute-motion'はつねにカレントバッファに作用する。

          戻り値は、5要素のリストである。

               (POS VPOS HPOS PREVHPOS CONTIN)

          ここで、POSは走査を終えたバッファ内位置であり、
          VPOSは垂直方向のスクリーン位置、
          HPOSは水平方向のスクリーン位置である。

          結果のPREVHPOSは、POSから1文字分戻った箇所の水平位置である。
          この文字のあとで最終行が継続しているときには、
          結果のCONTINは`t'である。

          たとえば、あるウィンドウのLINEスクリーン行のCOLコラムに
          対応するバッファ内位置を探すには、
          FROMとしてウィンドウの表示開始位置、
          FROMPOSとしてウィンドウの左上隅の座標を渡します。
          TOにはバッファの`(point-max)'を渡して
          走査をバッファの参照可能部分のみに制限し、
          TOPOSとしてLINEとCOLを渡す。 つぎのように呼び出す。

               (defun coordinates-of-position (col line)
                 (car (compute-motion (window-start)
                                      '(0 . 0)
                                      (point-max)
                                      (cons col line)
                                      (window-width)
                                      (cons (window-hscroll) 0)
                                      (selected-window))))

          ミニバッファに対して`compute-motion'を使うときには、
          `minibuffer-prompt-width'を使って
          最初のスクリーン行の先頭の水平位置を得る必要がある。 *note
          Minibuffer Misc::。


File: elisp-ja,  Node: List Motion,  Next: Skipping Characters,  Prev: Screen Lines,  Up: Motion

29.2.6 式単位の移動
-------------------------

     ここでは、釣り合った括弧で囲まれた式
（Emacs内でそれらを単位に移動するときには"S式"（sexps）とも呼ばれる）を
扱う関数について述べます。
構文テーブルは、これらの関数がさまざまな文字を
どのように解釈するかを制御します。 *note Syntax
Tables::を参照してください。
S式やその一部を走査する下位レベルの基本関数については、 *Note Parsing
Expressions::。 ユーザーレベルのコマンドに関しては、 *note
リストとS式に対するコマンド: (emacs)List Commands.を参照してください。

      -- コマンド: forward-list arg
          この関数は、釣り合った括弧で囲まれたものをARG個前方へ飛び越えて移動する。
          （単語や文字列のクォート対などの他の構文要素は無視する。）

      -- コマンド: backward-list arg
          この関数は、釣り合った括弧で囲まれたものをARG個後方へ飛び越えて移動する。
          （単語や文字列のクォート対などの他の構文要素は無視する。）

      -- コマンド: up-list arg
          この関数は、前方へ向けてARG個の括弧のレベルを抜ける。
          負の引数では後方へ向けて浅いレベルへ移動する。

      -- コマンド: down-list arg
          この関数は、前方へ向けてARG個の括弧のレベルだけ深く入る。
          負の引数では後方へ向けて括弧の深い（-ARG）レベルへ移動する。

      -- コマンド: forward-sexp arg
          この関数は、ARG個の釣り合った式を前方へ向けて飛び越えて移動する。
          釣り合った式には、括弧で区切られたものに加えて、
          単語や文字列定数などの他の種類も含まれる。
          たとえばつぎのとおり。

               ---------- Buffer: foo ----------
               (concat-!- "foo " (car x) y z)
               ---------- Buffer: foo ----------

               (forward-sexp 3)
                    => nil

               ---------- Buffer: foo ----------
               (concat "foo " (car x) y-!- z)
               ---------- Buffer: foo ----------

      -- コマンド: backward-sexp arg
          この関数は、ARG個の釣り合った式を後方へ向けて飛び越えて移動する。

      -- コマンド: beginning-of-defun arg
          この関数は、前方へ向けてARG個目の関数定義の先頭へ移動する。
          ARGが負であると、後方へ向けて、
          関数定義の末尾ではなく関数定義の先頭へ移動する。

      -- コマンド: end-of-defun arg
          この関数は、前方へ向けてARG個目の関数定義の末尾へ移動する。
          ARGが負であると、後方へ向けて、
          関数定義の先頭ではなく関数定義の末尾へ移動する。

      -- User Option: defun-prompt-regexp
          この変数が`nil'以外であると、
          関数定義を始める開き括弧のまえに現れうるテキストを指定する正規表現を保持する。
          つまり、関数定義は、
          行の先頭がこの正規表現に一致するテキストで始まり、
          それに開き括弧の構文に属する文字が続く行で始まる。


File: elisp-ja,  Node: Skipping Characters,  Prev: List Motion,  Up: Motion

29.2.7 文字群の飛び越し
-------------------------------

つぎの2つの関数は、指定した種類の文字を飛び越えてポイントを移動します。
たとえば、白文字を飛び越すためにこれらはしばしば使われます。
関連する関数については、*note Motion and Syntax::を参照してください。

      -- Function: skip-chars-forward character-set &optional limit
          この関数は、指定した文字の集まりを飛び越えて、
          カレントバッファ内で前方にポイントを移動する。
          ポイントのあとの文字を調べ、
          その文字がCHARACTER-SETに一致するとポイントを進める。
          これをCHARACTER-SETに一致しない文字に達するまで繰り返す。
          この関数は飛び越えた文字の個数を返す。

          引数CHARACTER-SETは、正規表現の`[...]'の内側と同じであるが、
          `]'は特別扱いせず、`\'は`^'や`-'や`\'をクォートする。
          したがって、`"a-zA-Z"'はすべての英文字を飛び越えて
          最初の英文字でない文字のまえで止まる。
          `"^a-zA-Z"'は英文字でない文字を飛び越えて最初の英文字で止まる。
          *note Regular Expressions::。

          LIMITを指定すると（数かマーカであること）、
          ポイントを移動できるバッファ内の最大位置を指定する。
          ポイントは、LIMITで止まるかLIMITに達するまえに止まる。

          つぎの例では、ポイントは最初は`T'の直前に位置している。
          フォームを評価後には、ポイントはその行末
          （`hat'の`t'と改行のあいだ）に位置している。
          この関数は、すべての英文字と空白を飛び越えるが、改行は飛び越えない。

               ---------- Buffer: foo ----------
               I read "-!-The cat in the hat
               comes back" twice.
               ---------- Buffer: foo ----------

               (skip-chars-forward "a-zA-Z ")
                    => nil

               ---------- Buffer: foo ----------
               I read "The cat in the hat-!-
               comes back" twice.
               ---------- Buffer: foo ----------

      -- Function: skip-chars-backward character-set &optional limit
          この関数は、LIMITに達するまで、
          後方へ向かってCHARACTER-SETに一致する文字を飛び越えてポイントを移動する。
          これは`skip-chars-forward'と同様であるが、移動方向が異なる。

          移動距離を表す値を返す。 それは0以下の整数である。


File: elisp-ja,  Node: Excursions,  Next: Narrowing,  Prev: Motion,  Up: Positions

29.3 エクスカージョン
=============================

     プログラムの局所的な部分で『一時的に』ポイントを移動したり、
一時的にバッファを切り替えられるとしばしば有用です。
これを"エクスカージョン"（excursion、周遊）と呼び、
スペシャルフォーム`save-excursion'で行います。
この構文は、カレントバッファとそのポイントやマーカの値を保存し、
エクスカージョンの完了後にそれらを復元します。

        ウィンドウの構成を保存したり復元するフォームは、
別のところで述べてあります （*note Window Configurations::と*note Frame
Configurations::）。

      -- Special Form: save-excursion forms...
          スペシャルフォーム`save-excursion'は、
          カレントバッファの識別子とそのポイントやマーカの値を保存し、
          FORMSを評価し、最後に、
          バッファと保存しておいたポイントやマーカの値を復元する。
          `throw'やエラーによる異常脱出（*note Nonlocal
          Exits::）であっても、 これらの保存した値を復元する。

          スペシャルフォーム`save-excursion'は、
          プログラムの一部分だけでバッファやポイントを移動し
          プログラムの他の部分への影響を防ぐ標準的な方法である。
          EmacsのLispソースでは4000回以上も使われている。

          `save-excursion'は他のバッファのポイントやマークの値は保存しないので、
          他のバッファでの変更は`save-excursion'から抜けても持続する。

          同様に、`save-excursion'は、
          `switch-to-buffer'などの関数で変更された
          ウィンドウとバッファの対応関係は復元しない。
          これらの対応関係や選択されているウィンドウを復元する1つの方法は、
          `save-excursion'の内側で`save-window-excursion'を
          使うことである（*note Window Configurations::）。

          `save-excursion'の戻り値は、FORMSの最後の結果であるか、
          FORMSを与えなければ`nil'である。

               (save-excursion FORMS)
               ==
               (let ((old-buf (current-buffer))
                     (old-pnt (point-marker))
                     (old-mark (copy-marker (mark-marker))))
                 (unwind-protect
                     (progn FORMS)
                   (set-buffer old-buf)
                   (goto-char old-pnt)
                   (set-marker (mark-marker) old-mark)))

        *警告：*` '保存されたポイント値の箇所に
普通にテキストを挿入すると、すべてのマーカを再配置するように
保存されたポイント値を再配置する。
したがって、保存されたポイント値が復元されると、
ポイントは挿入されたテキストのまえに普通どおりにくる。

        `save-excursion'はマーカの位置を保存しますが、
バッファを変更する関数が`deactivate-mark'を行うことを防ぎませんから、
コマンドが終了するとマーカが不活性になってしまいます。 *Note The
Mark::。


File: elisp-ja,  Node: Narrowing,  Prev: Excursions,  Up: Positions

29.4 ナロイング
====================

     "ナロイング"（narrowing）とは、
Emacsの編集コマンドが参照できるテキストを
バッファの制限された文字の範囲に限定することです。
参照できるテキストのことをバッファの "参照可能部分"（accessible
portion）と呼びます。

ナロイングは、参照可能部分の先頭と末尾になる2つのバッファ内位置で指定します。
ほとんどの編集コマンドやほとんどのEmacs基本関数にとっては、
これらの位置はバッファの先頭や末尾の値を置き換えることになります。
ナロイングしていると、参照可能部分の外側のテキストは表示されませんし、
ポイントは参照可能部分の外側へは移動できません。

        通常はバッファの先頭から数える位置や行番号などの値は
ナロイングしていても同様に数えますが、
それらを使う関数は参照できないテキストを操作することを拒否します。

        バッファを保存するコマンドはナロイングの影響を受けません。
つまり、ナロイングに関係なくバッファ全体を保存します。

      -- コマンド: narrow-to-region start end
          この関数は、カレントバッファのSTARTで始まりENDで終る部分を
          参照可能部分にする。 どちらの引数も文字の位置であること。

          対話的に呼び出されると、STARTとENDは
          現在のリージョンの境界（ポイントとマークの小さいほうがさきにくる）である。

      -- コマンド: narrow-to-page move-count
          このコマンドは、カレントバッファの参照可能部分を
          現在のページのみを含むようにする。
          省略可能な第1引数MOVE-COUNTが`nil'以外であると、
          MOVE-COUNTページだけ前方か後方へ移動してから
          1ページ分にナロイングする。
          変数`page-delimiter'がページの開始箇所と終了箇所を指定する
          （*note Standard Regexps::）。

          対話的に呼び出されると、MOVE-COUNTは数値前置引数である。

      -- コマンド: widen
          この関数は、カレントバッファのナロイングを解除し、
          全体を参照できるようにする。
          これを"ワイドニング"（widening）と呼ぶ。
          これはつぎの式と等価である。

               (narrow-to-region 1 (1+ (buffer-size)))

      -- Special Form: save-restriction body...
          このスペシャルフォームは、現在の参照可能部分の境界を保存し、
          フォームBODYを評価し、最後に、保存した境界を復元して
          まえと同じナロイング状態（あるいはナロイングなし）に復元する。
          `throw'やエラーによる異常脱出（*note Nonlocal
          Exits::）であっても、 ナロイング状態を復元する。

          `save-restriction'の戻り値は、BODYの最後の結果であるか、
          BODYを与えなければ`nil'である。

          *注意：*` '構文`save-restriction'を使うときには
          まちがいやすい。 使うまえにこの説明全体を読むこと。

          BODYでカレントバッファを切り替えても
          `save-restriction'はもとのバッファ（バッファの制限を保存したバッファ）に
          制限を復元するが、もとのカレントバッファには戻さない。

          `save-restriction'はポイントやマークは復元_しない_。
          それには`save-excursion'を使う。
          `save-restriction'と`save-excursion'の両者を
          一緒に使うときには、`save-excursion'が先に（外側に）くること。
          さもないと、古いポイント値は一時的なナロイングが有効な状態で復元される。
          古いポイント値が一時的なナロイングの範囲外にあると正しく復元できない。

          スペシャルフォーム`save-restriction'は、
          参照可能部分の先頭と末尾をバッファの先頭と末尾からの距離として記録する。
          いいかえれば、参照可能部分の前後の参照できないテキストの量を記録する。

          この方法は、BODYでさらにナロイングしても正しい結果を生じる。
          しかし、BODYでワイドニングして保存されているナロイングの範囲外を
          変更すると`save-restriction'が混乱する。
          このようにしたいときには、
          `save-restriction'は正しい解法ではない。
          つぎのようにする必要がある。

               (let ((beg (point-min-marker))
                     (end (point-max-marker)))
                 (unwind-protect
                     (progn BODY)
                   (save-excursion
                     (set-buffer (marker-buffer beg))
                     (narrow-to-region beg end))))

          `save-restriction'の正しい使い方の簡単な例を示す。

               ---------- Buffer: foo ----------
               This is the contents of foo
               This is the contents of foo
               This is the contents of foo-!-
               ---------- Buffer: foo ----------

               (save-excursion
                 (save-restriction
                   (goto-char 1)
                   (forward-line 2)
                   (narrow-to-region 1 (point))
                   (goto-char (point-min))
                   (replace-string "foo" "bar")))

               ---------- Buffer: foo ----------
               This is the contents of bar
               This is the contents of bar
               This is the contents of foo-!-
               ---------- Buffer: foo ----------



File: elisp-ja,  Node: Markers,  Next: Text,  Prev: Positions,  Up: Top

30 マーカ
************

     "マーカ"（marker）とは、バッファ内位置をそれを取り巻くテキストを
基準に指定するために使われるLispオブジェクトです。
テキストが挿入されたり削除されると、
バッファの先頭からマーカまでの距離は自動的に変更され、
マーカは同じ前後の文字のあいだに留まります。

     * Menu:

     * Overview of Markers::      The components of a marker, and how it relocates.
     * Predicates on Markers::    Testing whether an object is a marker.
     * Creating Markers::         Making empty markers or markers at certain places.
     * Information from Markers:: Finding the marker's buffer or character position.
     * Marker Insertion Types::   Two ways a marker can relocate when you
                                    insert where it points.
     * Moving Markers::           Moving the marker to a new buffer or position.
     * The Mark::                 How ``the mark'' is implemented with a marker.
     * The Region::               How to access ``the region''.


File: elisp-ja,  Node: Overview of Markers,  Next: Predicates on Markers,  Up: Markers

30.1 マーカの概要
=======================

     マーカは、バッファとそのバッファ内での位置を指定します。
マーカは、位置を必要とする関数に対して位置を表すものとして使えます。
バッファ内の位置について詳しくは*Note Positions::。

マーカには2つの属性、つまり、マーカ位置とマーカバッファがあります。
マーカ位置は、当該バッファ内の位置としてのマーカに
（その時点で）等価な整数です。
しかし、マーカの生存期間中、マーカ位置の値はしばしば変化します。
バッファにテキストを挿入したり削除すると、マーカは再配置されます。
これは、バッファの任意の箇所で挿入したり削除したとしても、
2つの文字のあいだに置かれたマーカが
同じ文字のあいだに留まるようにするためです。
再配置によって、マーカに等価な整数は変わります。

        マーカ位置の周りのテキストを削除すると、
削除されたテキストの前後の文字のあいだにマーカは留まります。
マーカの位置にテキストを挿入すると、 `insert-before-markers'（*note
Insertion::）で挿入しない限り、 マーカの"挿入型"（insertion
type）（*note Marker Insertion Types::）に
依存して、マーカは挿入されたテキストのまえかうしろに留まります。

        バッファに対する挿入や削除では、
すべてのマーカを検査し、必要ならばマーカを再配置する必要があります。
マーカを多数抱えるバッファでは、このために処理が遅くなります。
そのため、マーカが不要であると確信したときには、
マーカがどこも指さないようにしておくのがよいです。
参照されていないマーカは最終的には（ガベッジコレクションで）回収されますが、
それまでは、マーカがどこかを指していると処理時間を浪費します。

        マーカ位置にはよく算術演算を施すので、
（`+'や`-'を含む）ほとんどの算術演算は 引数としてマーカを受け付けます。
そのような場合、マーカはその現在位置を表します。

マーカを作って位置を設定し、ポイントをマーカへ移動する例を示します。

          ;; どこも指していない新しいマーカを作る
          (setq m1 (make-marker))
               => #<marker in no buffer>

          ;; マーカm1の位置をカレントバッファの
          ;; 99番目と100番目の文字のあいだにする
          (set-marker m1 100)
               => #<marker at 100 in markers.texi>

          ;; バッファの先頭に1文字挿入する
          (goto-char (point-min))
               => 1
          (insert "Q")
               => nil

          ;; それにしたがって`m1'が更新される
          m1
               => #<marker at 101 in markers.texi>

          ;; 同じ位置を指す2つのマーカは`eq'ではないが
          ;; `equal'である
          (setq m2 (copy-marker m1))
               => #<marker at 101 in markers.texi>
          (eq m1 m2)
               => nil
          (equal m1 m2)
               => t

          ;; マーカを使い終ったら、どこも指していないようにする
          (set-marker m1 nil)
               => #<marker in no buffer>


File: elisp-ja,  Node: Predicates on Markers,  Next: Creating Markers,  Prev: Overview of Markers,  Up: Markers

30.2 マーカ向けの述語
=============================

     オブジェクトがマーカであるかどうかや、
オブジェクトが整数かマーカであるかどうかを検査できます。
マーカと整数の両者を扱う算術関数に関連して、 後者の検査は有用です。

      -- Function: markerp object
          この関数は、OBJECTがマーカであれば`t'を返し、
          さもなければ`nil'を返す。
          多くの関数がマーカや整数を受け付けるが、
          整数はマーカではないことに注意すること。

      -- Function: integer-or-marker-p object
          この関数は、OBJECTが整数かマーカであると`t'を返し、
          さもなければ`nil'を返す。

      -- Function: number-or-marker-p object
          この関数は、OBJECTが数（整数か浮動小数点数）かマーカであると
          `t'を返し、さもなければ`nil'を返す。


File: elisp-ja,  Node: Creating Markers,  Next: Information from Markers,  Prev: Predicates on Markers,  Up: Markers

30.3 マーカ作成関数
==========================

     新たにマーカを作成するときには、そのマーカが、
どこも指していない、現在のポイント位置を指している、
バッファの参照可能部分の先頭や末尾を指している、
別のマーカと同じ箇所を指しているのいずれかにできます。

      -- Function: make-marker
          この関数は、どこも指していない新たに作成したマーカを返す。

               (make-marker)
                    => #<marker in no buffer>

      -- Function: point-marker
          この関数は、カレントバッファの現在のポイント位置を
          指す新たに作成したマーカを返す。 *note Point::。
          例については、下記の`copy-marker'を参照。

      -- Function: point-min-marker
          この関数は、バッファの参照可能部分の先頭を指す新たに作成したマーカを返す。
          ナロイングしていなければ、これはバッファの先頭である。 *note
          Narrowing::。

      -- Function: point-max-marker
          この関数は、バッファの参照可能部分の末尾を指す新たに作成したマーカを返す。
          ナロイングしていなければ、これはバッファの末尾である。 *note
          Narrowing::。

          本章のソースファイル（の原文）を入れたバッファでの
          この関数と`point-min-marker'の例を示す。

               (point-min-marker)
                    => #<marker at 1 in markers.texi>
               (point-max-marker)
                    => #<marker at 15573 in markers.texi>

               (narrow-to-region 100 200)
                    => nil
               (point-min-marker)
                    => #<marker at 100 in markers.texi>
               (point-max-marker)
                    => #<marker at 200 in markers.texi>

      -- Function: copy-marker marker-or-integer &optional
               insertion-type
          引数としてマーカを渡されると、`copy-marker'は、
          MARKER-OR-INTEGERが指すのと同じ
          バッファとバッファ内位置を指す新たなマーカを返す。
          引数として整数を渡されると、`copy-marker'は、
          カレントバッファで位置MARKER-OR-INTEGERを指す新たなマーカを返す。

          新たなマーカの挿入型は引数INSERTION-TYPEで指定する。 *note
          Marker Insertion Types::。

          渡された整数引数が1未満であると、`copy-marker'は、
          カレントバッファでバッファの先頭を指す新たなマーカを返す。
          渡された整数引数がバッファの長さより大きいと、`copy-marker'は、
          バッファの末尾を指す新たなマーカを返す。

               (copy-marker 0)
                    => #<marker at 1 in markers.texi>

               (copy-marker 20000)
                    => #<marker at 7572 in markers.texi>

          MARKER-OR-INTEGERがマーカでも整数でもないと、エラーを通知する。

        2つの異なるマーカが、同じバッファの同じバッファ内位置であるか、
どちらもどこも指していないときには、
両者を（`eq'ではないが）`equal'とみなします。

          (setq p (point-marker))
               => #<marker at 2139 in markers.texi>

          (setq q (copy-marker p))
               => #<marker at 2139 in markers.texi>

          (eq p q)
               => nil

          (equal p q)
               => t


File: elisp-ja,  Node: Information from Markers,  Next: Marker Insertion Types,  Prev: Creating Markers,  Up: Markers

30.4 マーカの情報
=======================

本節では、マーカオブジェクトの構成要素を参照する関数について述べます。

      -- Function: marker-position marker
          この関数は、MARKERが指す位置を返す。
          あるいは、MARKERがどこも指していなければ`nil'を返す。

      -- Function: marker-buffer marker
          この関数は、MARKERが指すバッファを返す。
          あるいは、MARKERがどこも指していなければ`nil'を返す。

               (setq m (make-marker))
                    => #<marker in no buffer>
               (marker-position m)
                    => nil
               (marker-buffer m)
                    => nil

               (set-marker m 3770 (current-buffer))
                    => #<marker at 3770 in markers.texi>
               (marker-buffer m)
                    => #<buffer markers.texi>
               (marker-position m)
                    => 3770


File: elisp-ja,  Node: Marker Insertion Types,  Next: Moving Markers,  Prev: Information from Markers,  Up: Markers

30.5 マーカの挿入型
==========================

     マーカが指す箇所に直接テキストを挿入すると、
マーカの再配置方法には2つの可能性、つまり、
挿入したテキストのまえに留まるか、あとにくるかのどちらかです。
マーカの"挿入型"（insertion type）を設定することで、
あるマーカではどちらを選ぶか指定できます。
`insert-before-markers'を使うとマーカの挿入型は無視され、
マーカは挿入したテキストのうしろにつねに再配置されることに注意してください。

      -- Function: set-marker-insertion-type marker type
          この関数は、マーカMARKERの挿入型をTYPEとする。
          TYPEが`t'であると、
          テキストが挿入されるとMARKERはその位置へ進む。
          TYPEが`nil'であると、
          テキストが挿入されてもMARKERはその位置へ進まない。

      -- Function: marker-insertion-type marker
          この関数は、MARKERの現在の挿入型を報告する。


File: elisp-ja,  Node: Moving Markers,  Next: The Mark,  Prev: Marker Insertion Types,  Up: Markers

30.6 マーカ位置の移動
=============================

     本節では、既存のマーカの位置を変更する方法について述べます。
これを行うときには、読者のプログラムの外側で
当該マーカが使われているかどうか、
使われているときには移動による効果はなにかを確実に理解してください。
さもないと、Emacsの別の部分で混乱を生じるかもしれません。

      -- Function: set-marker marker position &optional buffer
          この関数は、BUFFERにおいてMARKERをPOSITIONへ移動する。
          BUFFERを与えないと、デフォルトはカレントバッファである。

          POSITIONが1未満であると、
          `set-marker'はMARKERをバッファの先頭へ移動する。
          POSITIONがバッファのサイズよりも大きいと、
          `set-marker'はMARKERをバッファの末尾へ移動する。
          POSITIONが`nil'であったりどこも指していないマーカであると、
          MARKERはどこも指さないようにする。

          戻り値はMARKERである。

               (setq m (point-marker))
                    => #<marker at 4714 in markers.texi>
               (set-marker m 55)
                    => #<marker at 55 in markers.texi>
               (setq b (get-buffer "foo"))
                    => #<buffer foo>
               (set-marker m 0 b)
                    => #<marker at 1 in foo>

      -- Function: move-marker marker position &optional buffer
          これは`set-marker'の別名である。


File: elisp-ja,  Node: The Mark,  Next: The Region,  Prev: Moving Markers,  Up: Markers

30.7 マーク
==============

     各バッファの1つの特別なマーカを"マーク"（mark）として区別します。
これは、`kill-region'や`indent-rigidly'などのコマンド向けに
ユーザーのために位置を記録するものです。
Lispプログラムでは、ユーザーが使う可能性のある値だけをマークに設定し、
プログラムの内部向けにはけっしてマークを使いません。
たとえば、コマンド`replace-regexp'は、
置換を行うまえのポイント値をマークに設定します。
置換を完了したあとに、ユーザーが手軽にまえの位置に戻れるようにするためです。

        多くのコマンドは、対話的に呼ばれるとポイントとマークのあいだの
テキストに作用するように設計されています。
読者がそのようなコマンドを書くときには、
マークを直接検査しないでください。
そのかわりに、`r'を指定した`interactive'を使います。 こうすると、
対話的に呼ばれるとポイントとマークの値がコマンドの引数に与えられますが、
別のLispプログラムからは引数を明示できます。 *Note Interactive Codes::。

        各バッファには、他のバッファのマークの値とは独立な
独自のマークの値があります。
バッファが作成されると、マークは存在しますがどこも指さない状態です。
これを『バッファのマークは欠如している』状態とみなします。

        バッファでいったんマークが『存在』するようになれば、
マークが存在しなくなることは普通はありません。
しかし、暫定マーク（transient-mark）モードをオンにすると、
マークが"不活性"になることはあります。
すべてのバッファでつねにバッファローカルな変数`mark-active'が
マークが活性かどうかを表します。
その値が`nil'以外であるとマークは活性です。
コマンドで`deactivate-mark'に`nil'以外の値を設定すると、
エディタコマンドループに戻ったときにマークを不活性にするようにできます
（ただし、暫定マーク（transient-mark）モードがオンの場合に限る）。

        暫定マーク（transient-mark）モードを使う主な目的は、
マークが活性であるとこのモードはリージョンを強調表示するからです。
*Note Display::。

        マークに加えて、各バッファには"マークリング"（mark ring）、
つまり、マークの以前の値を保持したリストがあります。
編集コマンドがマークを変更すると、
通常、編集コマンドはマークの古い値をマークリングに保存します。
変数`mark-ring-max'で、マークリングに収める要素の最大個数を指定します。
リストがこの長さに達すると、新たな要素を加えるたびに古い要素を削除します。

      -- Function: mark &optional force
          この関数は、カレントバッファのマーク位置を整数で返す。

          マークが不活性であると、通常、`mark'はエラーを通知する。
          しかし、FORCEが`nil'以外であると`mark'はマーク位置を返すが、
          当該バッファでマークが設定されたことがなければ`nil'を返す。

      -- Function: mark-marker
          この関数は、カレントバッファのマークを返す。
          これは、Emacs内部のマーク位置を記録したマーカそのものであり、コピーではない。
          したがって、このマーカの位置を変更すると、マークの位置に直接影響する。
          この効果を望まない限り、そのようにしないこと。

               (setq m (mark-marker))
                    => #<marker at 3420 in markers.texi>
               (set-marker m 100)
                    => #<marker at 100 in markers.texi>
               (mark-marker)
                    => #<marker at 100 in markers.texi>

          他のマーカと同様に、このマーカは任意のバッファでポイントを指すようにできる。
          マークが指しているバッファ以外のバッファ内位置を指すことは勧めない。
          そのようにすると、一貫性はあるが妙な結果を生じる。

      -- Function: set-mark position
          この関数は、位置POSITIONにマークを設定し、マークを活性にする。
          マークの古い値はマークリングに保存し_ない_。

          *注意：*` 'ユーザーにマークが移動したことを示し、かつ、
          まえのマーク位置を破棄したい場合にのみこの関数を使うこと。
          通常、新たにマークを設定したときには、
          古いマークを`mark-ring'に入れるべきである。
          この理由から、ほとんどのアプリケーションでは、
          `set-mark'ではなく`push-mark'と`pop-mark'を使うべきである。

          Emacs
          Lispの初心者プログラマは、誤った目的にマークを使いがちである。
          マークはユーザーの便宜のための位置を保存する。
          編集コマンドは、
          コマンドのユーザーレベルの機能の一部としてマークを変更する以外には、
          マークを変更してはならない。
          （変更する場合には、その効果を明文化しておくべきである。）
          Lispプログラムの内部で使う位置を記録するには、Lisp変数に保存する。
          たとえばつぎのようにする。

               (let ((beg (point)))
                 (forward-line 1)
                 (delete-region beg (point))).

      -- Function: push-mark &optional position nomsg activate
          この関数は、カレントバッファのマークをPOSITIONとし、
          以前のマークのコピーを`mark-ring'へ入れる。
          POSITIONが`nil'であると、ポイントの値を使う。
          `push-mark'は`nil'を返す。

          関数`push-mark'は、通常、マークを活性に_しない_。
          活性にするには引数ACTIVATEに`t'を指定する。

          NOMSGが`nil'であると、メッセージ`Mark set'を表示する。

      -- Function: pop-mark
          この関数は、`mark-ring'から先頭要素を取り出し、
          そのマークをカレントバッファの実際のマークとする。
          バッファのポイントは移動しない。
          また、`mark-ring'が空であるとなにもしない。
          マークを不活性にする。

          戻り値に意味はない。

      -- User Option: transient-mark-mode
          この変数が`nil'以外であると
          暫定マーク（transient-mark）モードがオンであるが、
          バッファを変更する各基本関数は`deactivate-mark'に設定する。
          つまり、バッファを変更するコマンドは、通常、マークを不活性にする。

      -- User Option: mark-even-if-inactive
          これが`nil'以外であると、
          LispプログラムやEmacsユーザーは、マークが不活性であってもマークを使える。
          このオプションは、暫定マーク（transient-mark）モードのふるまいに影響する。
          このオプションが`nil'以外であると、
          マークが不活性になるとリージョンの強調表示を止めるが、
          マークを使うコマンドはマークが活性であるものとして動作する。

      -- Variable: deactivate-mark
          編集コマンドがこの変数に`nil'以外を設定すると、
          エディタコマンドループは（暫定マーク（transient-mark）モードがオンであると）
          コマンドから戻るとマークを不活性にする。
          コマンドが終了したらマークを不活性にするために、
          バッファを変更するすべての基本関数は`deactivate-mark'に設定する。

      -- Function: deactivate-mark
          この関数は、暫定マーク（transient-mark）モードが
          オンであるとマークを不活性にする。 さもなければなにもしない。

      -- Variable: mark-active
          この変数が`nil'以外であると、マークは活性である。
          この変数は各バッファにおいてつねにバッファローカルである。

      -- Variable: activate-mark-hook
      -- Variable: deactivate-mark-hook
          これらのノーマルフックは、それぞれ、
          マークが活性になったとき、不活性になったときに実行される。
          マークが活性でありリージョンが変更されたときには、
          フック`activate-mark-hook'はコマンドの終りでも実行される。

      -- Variable: mark-ring
          このバッファローカルな変数の値は、
          カレントバッファで保存したマークを最新のものから順に並べたリストである。

               mark-ring
               => (#<marker at 11050 in markers.texi>
                   #<marker at 10832 in markers.texi>
                   ...)

      -- User Option: mark-ring-max
          この変数の値は、`mark-ring'の最大の大きさである。
          これより多くのマークを`mark-ring'に積むと、
          `push-mark'は新しいものを追加するときに古いものを削除する。


File: elisp-ja,  Node: The Region,  Prev: The Mark,  Up: Markers

30.8 リージョン
====================

ポイントとマークのあいだのテキストを"リージョン"（region）といいます。
さまざまな関数がポイントとマークで区切られたテキストに作用しますが、
リージョンそのものに特に関連した関数だけについてここで述べます。

      -- Function: region-beginning
          この関数は、リージョンの先頭の位置を（整数で）返す。
          これは、ポイントかマークの小さいほうの位置である。

          マークがどこも指していなければ、エラーを通知する。

      -- Function: region-end
          この関数は、リージョンの末尾の位置を（整数で）返す。
          これは、ポイントかマークの大きいほうの位置である。

          マークがどこも指していなければ、エラーを通知する。

        関数`region-beginning'や`region-end'を使う必要がある
プログラムはほとんどないはずです。
リージョンに作用するように設計されたコマンドは、
普通、`r'を指定した`interactive'を使って
リージョンの先頭と末尾をみつけます。
これにより、Lispプログラムからは引数として境界を明示的に指定できます。
（*Note Interactive Codes::。）


File: elisp-ja,  Node: Text,  Next: Non-ASCII Characters,  Prev: Markers,  Up: Top

31 テキスト
***************

     本章では、バッファ内のテキストを扱う関数について述べます。
それらのほとんどは、カレントバッファ内のテキストを
調べたり挿入したり削除しますが、しばしばポイント付近で行います。
多くは対話的に使えます。
テキストを変更するすべての関数は、変更を取り消せます（*note Undo::）。

        テキスト関連の多くの関数は、STARTとENDという名前の引数で渡された
2つのバッファ内位置で定義されるテキストの領域に作用します。
これらの引数は、マーカ（*note Markers::）であるか
文字の位置を表す数値（*note Positions::）である必要があります。
これらの引数の順番は関係なく、STARTが領域の終了位置で
ENDが開始位置であってもまったく問題ありません。
たとえば、`(delete-region 1 10)'と`(delete-region 10 1)'は同値です。
STARTやENDがバッファの参照可能部分の外側にあると
エラー`args-out-of-range'を通知します。
対話的な呼び出しでは、ポイントとマークをこれらの引数として使います。

        本章では、バッファ内の文字を（関係あるときには）
それらのテキスト属性を含めて『テキスト』と呼びます。

     * Menu:

     * Near Point::       Examining text in the vicinity of point.
     * Buffer Contents::  Examining text in a general fashion.
     * Comparing Text::   Comparing substrings of buffers.
     * Insertion::        Adding new text to a buffer.
     * Commands for Insertion::  User-level commands to insert text.
     * Deletion::         Removing text from a buffer.
     * User-Level Deletion::     User-level commands to delete text.
     * The Kill Ring::    Where removed text sometimes is saved for later use.
     * Undo::             Undoing changes to the text of a buffer.
     * Maintaining Undo:: How to enable and disable undo information.
     			How to control how much information is kept.
     * Filling::          Functions for explicit filling.
     * Margins::          How to specify margins for filling commands.
     * Adaptive Fill::    Adaptive Fill mode chooses a fill prefix from context.
     * Auto Filling::     How auto-fill mode is implemented to break lines.
     * Sorting::          Functions for sorting parts of the buffer.
     * Columns::          Computing horizontal positions, and using them.
     * Indentation::      Functions to insert or adjust indentation.
     * Case Changes::     Case conversion of parts of the buffer.
     * Text Properties::  Assigning Lisp property lists to text characters.
     * Substitution::     Replacing a given character wherever it appears.
     * Transposition::    Swapping two portions of a buffer.
     * Registers::        How registers are implemented.  Accessing the text or
                            position stored in a register.
     * Change Hooks::     Supplying functions to be run when text is changed.


File: elisp-ja,  Node: Near Point,  Next: Buffer Contents,  Up: Text

31.1 ポイント付近のテキストを調べる
==================================================

     多くの関数は、ポイント付近の文字を調べるためのものです。
ここでは、数個の単純な関数について述べます。 *note Regexp
Search::の`looking-at'も参照してください。

      -- Function: char-after &optional position
          この関数は、カレントバッファ内の位置POSITIONにある
          （つまり直後の）文字を返す。
          POSITIONがバッファの先頭のまえや末尾のうしろにあるなどして
          この目的に適した範囲の外側にあると、値は`nil'である。
          POSITIONのデフォルトはポイントである。

          つぎの例では、バッファの最初の文字は`@'であると仮定する。

               (char-to-string (char-after 1))
                    => "@"

      -- Function: char-before &optional position
          この関数は、カレントバッファ内の位置POSITIONのまえにある文字を返す。
          POSITIONがバッファの先頭のまえや末尾のうしろにあるなどして
          この目的に適した範囲の外側にあると、値は`nil'である。
          POSITIONのデフォルトはポイントである。

      -- Function: following-char
          この関数は、カレントバッファのポイントのうしろにある文字を返す。
          これは`(char-after (point))'と同様である。
          しかし、ポイントがバッファの末尾にあると、
          `following-char'は0を返す。

          ポイントはつねに文字のあいだにあり、
          端末のカーソルはポイントの直後の文字に重ねて表示されることに注意してほしい。
          したがって、`following-char'が返す文字は、
          カーソルが重なっている文字である。

          つぎの例では、ポイントは`a'と`c'のあいだにある。

               ---------- Buffer: foo ----------
               Gentlemen may cry ``Pea-!-ce! Peace!,''
               but there is no peace.
               ---------- Buffer: foo ----------

               (char-to-string (preceding-char))
                    => "a"
               (char-to-string (following-char))
                    => "c"

      -- Function: preceding-char
          この関数は、カレントバッファのポイントのまえの文字を返す。
          例については上記の`following-char'を参照。
          ポイントがバッファの先頭にあると、`preceding-char'は0を返す。

      -- Function: bobp
          この関数は、ポイントがバッファの先頭にあると`t'を返す。
          ナロイングしていると、これはバッファの参照可能部分の先頭を意味する。
          *note Point::の`point-min'も参照。

      -- Function: eobp
          この関数は、ポイントがバッファの末尾にあると`t'を返す。
          ナロイングしていると、これはバッファの参照可能部分の末尾を意味する。
          *note Point::の`point-max'も参照。

      -- Function: bolp
          この関数は、ポイントが行頭にあると`t'を返す。 *note Text
          Lines::。 バッファ（あるいはその参照可能部分）の先頭は、
          つねに行頭とみなす。

      -- Function: eolp
          この関数は、ポイントが行末にあると`t'を返す。 *note Text
          Lines::。 バッファ（あるいはその参照可能部分）の末尾は、
          つねに行末とみなす。


File: elisp-ja,  Node: Buffer Contents,  Next: Comparing Text,  Prev: Near Point,  Up: Text

31.2 バッファの内容を調べる
======================================

本節では、Lispプログラムでバッファ内の任意の部分のテキストを文字列に変換する
ための2つの関数について述べます。

      -- Function: buffer-substring start end
          この関数は、カレントバッファのSTARTとENDの位置で定義される
          領域のテキストのコピーを含んだ文字列を返す。
          引数がバッファの参照可能部分の内側の位置でないと、
          `buffer-substring'はエラー`args-out-of-range'を通知する。

          STARTがENDより小さい必要はなく、引数の順番はどちらでもよい。
          しかし、ほとんどの場合、小さい引数を先に書く。

          コピーされるテキストにテキスト属性がある場合、
          テキスト属性もそれが属する文字とともに文字列へコピーされる。
          *note Text Properties::。 しかし、バッファのオーバレイ（*note
          Overlays::）とそれらの属性は 無視されコピーされない。

               ---------- Buffer: foo ----------
               This is the contents of buffer foo

               ---------- Buffer: foo ----------

               (buffer-substring 1 10)
               => "This is t"
               (buffer-substring (point-max) 10)
               => "he contents of buffer foo
               "

      -- Function: buffer-substring-no-properties start end
          この関数は`buffer-substring'と同様であるが、
          テキスト属性をコピーせずに文字だけをコピーする点が異なる。
          *note Text Properties::。

      -- Function: buffer-string
          この関数は、カレントバッファの参照可能部分全体の内容を文字列として返す。
          これは、つぎと等価である。

               (buffer-substring (point-min) (point-max))

               ---------- Buffer: foo ----------
               This is the contents of buffer foo

               ---------- Buffer: foo ----------

               (buffer-string)
                    => "This is the contents of buffer foo
               "

      -- Function: thing-at-point thing
          ポイントの周りやそのうしろにあるTHINGを文字列として返す。

          引数THINGは、構文上の要素の種類を指定するシンボルである。
          可能な値は、`symbol'、`list'、`sexp'、
          `defun'、`filename'、`url'、`word'、`sentence'、
          `whitespace'、`line'、`page'などである。

               ---------- Buffer: foo ----------
               Gentlemen may cry ``Pea-!-ce! Peace!,''
               but there is no peace.
               ---------- Buffer: foo ----------

               (thing-at-point 'word)
                    => "Peace"
               (thing-at-point 'line)
                    => "Gentlemen may cry ``Peace! Peace!,''\n"
               (thing-at-point 'whitespace)
                    => nil


File: elisp-ja,  Node: Comparing Text,  Next: Insertion,  Prev: Buffer Contents,  Up: Text

31.3 テキストの比較
==========================

     この関数により、バッファ内のテキストの部分同士を
文字列にコピーせずに比較できます。

      -- Function: compare-buffer-substrings buffer1 start1 end1
               buffer2 start2 end2
          この関数は、同一バッファ内の2つの部分文字列、あるいは、
          異なる2つのバッファの部分文字列を比較する。
          始めの3つの引数は、バッファとそのバッファ内の2つの位置を与え、
          1つの部分文字列を指定する。
          残りの3つの引数も同様にして別の部分文字列を指定する。
          カレントバッファを表すために、
          BUFFER1とBUFFER2のいずれか、あるいは、
          両方に`nil'を指定できる。

          始めの文字列のほうが小さければ値は負であり、
          始めのほうが大きければ値は正であり、等しければ0である。
          結果の絶対値は、部分文字列の中で最初に異なる文字の添字足す1である。

          この関数は、`case-fold-search'が`nil'以外であると、
          文字の比較では大文字小文字を区別しない。
          テキスト属性はつねに無視する。

          カレントバッファにはテキスト`foobarbar
          haha!rara!'があるとする。
          すると、この例の2つの部分文字列は`rbar 'と`rara!'である。
          2番目の文字で最初の文字列のほうが大きいので、結果は2である。

               (compare-buffer-substring nil 6 11 nil 16 21)
                    => 2


File: elisp-ja,  Node: Insertion,  Next: Commands for Insertion,  Prev: Comparing Text,  Up: Text

31.4 テキストの挿入
==========================

"挿入"（insertion）とは、バッファに新たなテキストを追加することです。
挿入されたテキストはポイント位置に、つまり、
ポイントのまえの文字とポイントのあとの文字のあいだに入ります。
挿入されたテキストのまえにポイントを留める関数もあれば、
そのうしろに留める関数もあります。
前者を"ポイントのうしろへ"挿入と呼び、
後者を"ポイントのまえへ"挿入と呼びます。

        挿入により、挿入箇所よりうしろの位置を指すマーカは再配置されて
同じ周りの文字に留まります（*note Markers::）。
マーカが挿入箇所を指している場合には、 マーカの挿入型（*note Marker
Insertion Types::）に依存して、
挿入するとマーカが再配置されたりされなかったりします。
`insert-before-markers'などの特定の特殊な関数は、
マーカの挿入型に関わらず、 挿入されたテキストのうしろを指すように
そのようなすべてのマーカを再配置します。

カレントバッファが読み出し専用であると、挿入関数はエラーを通知します。

        これらの関数は、テキストの文字群をそれらの属性とともに
文字列からバッファへコピーします。
挿入された文字群は、コピーされるまえとまったく同じ属性を持ちます。
対照的に、文字列やバッファの一部ではない孤立した引数として
指定された文字群は、周りのテキストからテキスト属性を継承します。

        挿入関数は、文字列由来やバッファ由来のテキストの場合には、
マルチバイトバッファへ挿入するために
ユニバイトからマルチバイトへテキストを変換し、逆向きの変換も行います。
しかし、カレントバッファがたとえマルチバイトバッファであっても、
128から255のユニバイト文字コードはマルチバイト文字には変換しません。
*Note Converting Representations::。

      -- Function: insert &rest args
          この関数は、文字列や文字群ARGSをカレントバッファのポイント位置に挿入し、
          ポイントを先へ進める。
          いいかえれば、ポイントのまえにテキストを挿入する。
          ARGSが文字列でも文字でもないと、エラーを通知する。
          値は`nil'である。

      -- Function: insert-before-markers &rest args
          この関数は、文字列や文字群ARGSをカレントバッファのポイント位置に挿入し、
          ポイントを先へ進める。
          ARGSが文字列でも文字でもないと、エラーを通知する。
          値は`nil'である。

          挿入箇所を指していたマーカを挿入されたテキストのうしろを指すように再配置
          する点で、この関数は他の挿入関数と異なる。
          挿入箇所でオーバレイが始まるときには、
          挿入されたテキストはオーバレイの範囲外に出る。
          空でないオーバレイが挿入箇所で終るときには、
          挿入されたテキストはオーバレイの範囲内に入る。

      -- Function: insert-char character &optional count inherit
          この関数は、カレントバッファのポイントのまえに
          文字CHARACTERをCOUNT個挿入する。
          引数COUNTは数（`nil'は1を意味する）であり、
          CHARACTERは文字であること。 値は`nil'である。

          この関数は、カレントバッファがたとえマルチバイトバッファであっても、
          128から255のユニバイト文字コードはマルチバイト文字には変換しない。
          *note Converting Representations::。

          INHERITが`nil'以外であると、挿入された文字は、
          挿入箇所の前後の2つの文字からスティッキテキスト属性を継承する。

      -- Function: insert-buffer-substring from-buffer-or-name
               &optional start end
          この関数は、バッファFROM-BUFFER-OR-NAME（既存であること）の部分を
          カレントバッファのポイントのまえへ挿入する。
          挿入されるテキストはSTARTからENDまでの領域である。
          （これらの引数のデフォルトは、当該バッファの参照可能部分の先頭と末尾である。）
          この関数は`nil'を返す。

          この例では、バッファ`bar'をカレントバッファとしてフォームを実行する。
          バッファ`bar'は最初は空であると仮定する。

               ---------- Buffer: foo ----------
               We hold these truths to be self-evident, that all
               ---------- Buffer: foo ----------

               (insert-buffer-substring "foo" 1 20)
                    => nil

               ---------- Buffer: bar ----------
               We hold these truth-!-
               ---------- Buffer: bar ----------

挿入に加えて周りのテキストからテキスト属性を継承する他の関数については、
*Note Sticky Properties::。
字下げ関数が挿入した白文字もテキスト属性を継承します。


File: elisp-ja,  Node: Commands for Insertion,  Next: Deletion,  Prev: Insertion,  Up: Text

31.5 ユーザーレベルの挿入コマンド
===============================================

     本節では、テキストを挿入する上位レベルのコマンドについて述べます。
これらはLispプログラムでも有用ですが主にユーザー向けのコマンドです。

      -- コマンド: insert-buffer from-buffer-or-name
          このコマンドは、FROM-BUFFER-OR-NAME（既存であること）の全内容を
          カレントバッファのポイントのうしろに挿入する。
          挿入されたテキストのうしろにマークを置く。 値は`nil'である。

      -- コマンド: self-insert-command count
          このコマンドは、最後に打たれた文字を挿入する。
          ポイントのまえにCOUNT回挿入して`nil'を返す。
          ほとんどの印字文字はこのコマンドにバインドされている。
          普通の状況では、`self-insert-command'は
          Emacsにおいてもっとも頻繁に呼び出される関数であるが、
          プログラムではキーマップに登録する以外にはほとんど使わない。

          対話的に呼ばれると、COUNTは数値前置引数である。

          このコマンドは、挿入した文字が空白や改行であると、
          `auto-fill-function'が`nil'以外であると
          `auto-fill-function'を呼び出す （*note Auto Filling::）。

          このコマンドは、略語（abbrev）モードがオンであり、かつ、
          挿入した文字が単語構成構文でないと、略語展開を行う。 （*note
          Abbrevs::と*note Syntax Class Table::。）

          挿入した文字が閉じ括弧構文であるときに
          `blink-paren-function'を呼び出す責任も持つ （*note
          Blinking::）。

      -- コマンド: newline &optional number-of-newlines
          このコマンドは、カレントバッファのポイントのまえに改行を挿入する。
          NUMBER-OF-NEWLINESを指定すると、その個数だけ改行文字を挿入する。

          この関数は、現在のコラム番号が`fill-column'の値よりも大きく
          NUMBER-OF-NEWLINESが`nil'であると
          `auto-fill-function'を呼び出す。
          `auto-fill-function'の典型的な仕事は改行を挿入することである。
          ここでの全体としての効果は、改行を2つの異なる位置、つまり、
          ポイント位置と行のまえの箇所に挿入することである。
          `newline'は、NUMBER-OF-NEWLINESが`nil'以外であると
          自動詰め込みを行わない。

          このコマンドは、左端の余白が0以外であるとその分だけ字下げする。
          *note Margins::。

          戻り値は`nil'である。
          対話的に呼ばれると、COUNTは数値前置引数である。

      -- コマンド: split-line
          このコマンドは、行のポイントのうしろの部分を垂直に降ろして
          変更前の真下に行を移動することで現在行を分割する。
          関数`indent-to'を用いて、降ろした行の先頭に必要に応じて白文字を挿入する。

          プログラムではまったくこの関数を使わない。

      -- Variable: overwrite-mode
          この変数は、上書き（overwrite）モードがオンかどうかを制御する。
          この値は、`overwrite-mode-textual'、`overwrite-mode-binary'、
          `nil'のいずれかであること。
          `overwrite-mode-textual'は、テキストの上書きモード
          （改行とタブを特別に扱う）を指定し、
          `overwrite-mode-binary'は、バイナリの上書きモード
          （改行やタブも他の文字と同様に扱う）を指定する。


File: elisp-ja,  Node: Deletion,  Next: User-Level Deletion,  Prev: Commands for Insertion,  Up: Text

31.6 テキストの削除
==========================

     削除とは、バッファ内のテキストのある部分をキルリング （*note The
Kill Ring::）に保存せずに取りさることです。
削除したテキストはヤンクはできませんが、 アンドゥ機構（*note
Undo::）を使って再度挿入できます。
特別な場合にはキルリングにテキストを保存する削除関数もあります。

すべての削除関数はカレントバッファに作用し、`nil'の値を返します。

      -- コマンド: erase-buffer
          この関数は、カレントバッファから全テキストを削除して空にする。
          バッファが読み出し専用であると、エラー`buffer-read-only'を通知する。
          さもなければ、いっさい確認を取らずにテキストを削除する。
          `nil'を返す。

          バッファから多量のテキストを削除すると、通常、
          『バッファが縮小した』としてそのバッファの自動保存を禁止する。
          しかし、`erase-buffer'はこうしない。
          これまでのテキストと将来のテキストには関連がなく、
          これまでのテキストのサイズと比較すべきでないと考えるからである。

      -- コマンド: delete-region start end
          このコマンドは、STARTとENDで定義されるカレントバッファの
          テキストを削除する。 戻り値は`nil'である。
          削除された領域の内側にポイントがあると、
          その値は削除後にはSTARTになる。
          さもなければ、マーカと同様にポイントは
          周りのテキストに留まるように再配置される。

      -- コマンド: delete-char count &optional killp
          このコマンドは、ポイントの直後の、あるいは、
          COUNTが負であるとポイントの直前のCOUNT個の文字を削除する。
          KILLPが`nil'以外であると、
          削除した文字をキルリングに保存する。

          対話的に呼ばれると、COUNTは数値前置引数であり、
          KILLPは未処理の前置引数である。
          つまり、前置引数を指定すると、テキストをキルリングに保存する。
          前置引数を指定しないと1文字だけを削除するが、
          キルリングには保存しない。

          戻り値はつねに`nil'である。

      -- コマンド: delete-backward-char count &optional killp
          このコマンドは、ポイントの直前の、あるいは、
          COUNTが負であるとポイントの直後のCOUNT個の文字を削除する。
          KILLPが`nil'以外であると、
          削除した文字をキルリングに保存する。

          対話的に呼ばれると、COUNTは数値前置引数であり、
          KILLPは未処理の前置引数である。
          つまり、前置引数を指定すると、テキストをキルリングに保存する。
          前置引数を指定しないと1文字だけを削除するが、
          キルリングには保存しない。

          戻り値はつねに`nil'である。

      -- コマンド: backward-delete-char-untabify count &optional killp
          このコマンドは、タブを空白にかえながら後向きにCOUNT個の文字を削除する。
          つぎに削除する文字がタブであると、まずタブを配置を保つだけの等価な個数の
          空白に置換してから、タブのかわりにそれらの空白を削除する。
          KILLPが`nil'以外であると、このコマンドは
          削除した文字をキルリングに保存する。

          COUNTが正である場合に限って、タブを空白に変換する。
          COUNTが負であると、ポイントのうしろのちょうど
          -COUNT個の文字を削除する。

          対話的に呼ばれると、COUNTは数値前置引数であり、
          KILLPは未処理の前置引数である。
          つまり、前置引数を指定すると、テキストをキルリングに保存する。
          前置引数を指定しないと1文字だけを削除するが、
          キルリングには保存しない。

          戻り値はつねに`nil'である。

      -- User Option: backward-delete-char-untabify-method
          このオプションは、`backward-delete-char-untabify'での
          白文字の扱い方を指定する。
          可能な値は、タブを空白に変換してから空白を削除することを意味する
          デフォルトの`untabify'、
          1回の呼び出しでポイントのまえにある白文字をすべて削除することを意味する
          `hungry'、
          白文字に対して特別なことをしないことを意味する`nil'である。


File: elisp-ja,  Node: User-Level Deletion,  Next: The Kill Ring,  Prev: Deletion,  Up: Text

31.7 ユーザーレベルの削除コマンド
===============================================

     本節では、テキストを削除する上位レベルのコマンドについて述べます。
これらはLispプログラムでも有用ですが主にユーザー向けのコマンドです。

      -- コマンド: delete-horizontal-space
          この関数は、ポイントの周りの空白やタブをすべて削除する。
          `nil'を返す。

          つぎの例では、毎回ポイントを2番目と3番目の文字のあいだに置いて、
          各行につき1回ずつ`delete-horizontal-space'を計4回呼び出す。

               ---------- Buffer: foo ----------
               I -!-thought
               I -!-     thought
               We-!- thought
               Yo-!-u thought
               ---------- Buffer: foo ----------

               (delete-horizontal-space)   ; Four times.
                    => nil

               ---------- Buffer: foo ----------
               Ithought
               Ithought
               Wethought
               You thought
               ---------- Buffer: foo ----------

      -- コマンド: delete-indentation &optional join-following-p
          この関数は、ポイントがある行をそのまえの行に連結する。
          連結箇所の白文字は削除し、場合によっては空白1個に置き換える。
          JOIN-FOLLOWING-Pが`nil'以外であると、
          `delete-indentation'は、この行を後続の行に連結する。
          関数は`nil'を返す。

          詰め込み接頭辞があり、かつ、連結対象の2番目の行が
          その接頭辞で始まっている場合には、
          `delete-indentation'は連結するまえに詰め込み接頭辞を削除する。
          *note Margins::。

          以下の例では、ポイントは`events'で始まる行にあり、
          そのまえの行の行末に空白があっても違いはない。

               ---------- Buffer: foo ----------
               When in the course of human
               -!-    events, it becomes necessary
               ---------- Buffer: foo ----------

               (delete-indentation)
                    => nil

               ---------- Buffer: foo ----------
               When in the course of human-!- events, it becomes necessary
               ---------- Buffer: foo ----------

          行を連結したあと、 関数`fixup-whitespace'には、
          連結箇所に空白を置くかどうかを決定する責任がある。

      -- Function: fixup-whitespace
          この関数は、文脈に応じて、
          ポイントを囲む白文字すべてを1つの空白に置換するかまったくなくす。
          `nil'を返す。

          行の先頭や末尾では、空白の適切な量は0である。
          閉じ括弧構文の文字のまえや、
          開き括弧構文や式前置子構文の文字のうしろでも空白はないほうが適している。
          それ以外では、空白1個が適している。 *note Syntax Class
          Table::。

          以下の例では、最初の行の単語`spaces'のまえにポイントがあるときに
          最初に`fixup-whitespace'が呼ばれる。
          2度目に呼ばれるときには、ポイントは`('の直後にある。

               ---------- Buffer: foo ----------
               This has too many     -!-spaces
               This has too many spaces at the start of (-!-   this list)
               ---------- Buffer: foo ----------

               (fixup-whitespace)
                    => nil
               (fixup-whitespace)
                    => nil

               ---------- Buffer: foo ----------
               This has too many spaces
               This has too many spaces at the start of (this list)
               ---------- Buffer: foo ----------

      -- コマンド: just-one-space
          このコマンドは、ポイントの周りのすべての空白やタブを1個の空白に置き換える。
          `nil'を返す。

      -- コマンド: delete-blank-lines
          この関数は、ポイントを囲む空行を削除する。
          前後に複数の空行がある空行にポイントがある場合、
          1つの空行を残してそれ以外はすべて削除する。
          孤立した1つの空行にポイントがある場合には、その行を削除する。
          空行でない行にポイントがある場合には、
          その行のうしろにある空行をすべて削除する。

          空行とは、タブや空白のみから成る行と定義する。

          `delete-blank-lines'は`nil'を返す。


File: elisp-ja,  Node: The Kill Ring,  Next: Undo,  Prev: User-Level Deletion,  Up: Text

31.8 キルリング
====================

     "キル関数"は削除関数のようにテキストを削除しますが、
ユーザーが"ヤンク"（yank）で再度挿入できるように保存します。
これらの関数の多くは、その名前に`kill-'があります。
対照的に、`delete-'で始まる名前の関数は、
ヤンクできるようにテキストを保存しません（アンドゥはできる）。
それらは『削除』関数です。

        キルコマンドの多くは主に対話的に使うものであり、
ここではそれらについては述べません。
ここで述べるのは、そのようなコマンドを書くために使う関数についてです。
これらの関数は読者がテキストをキルするコマンドを書くために使えます。
Lisp関数において内部目的のためにテキストを削除する必要があるときには、
キルリングの内容を乱さないように普通は削除関数を用いるべきです。 *Note
Deletion::。

        キルしたテキストはあとでヤンクできるように "キルリング"（kill
ring）に保存されます。 これは、最後にキルしたテキストだけでなく、
最近キルしたものを多数保持するリストです。 これを『リング』と呼ぶのは、
要素が循環しているようにヤンクが扱うからです。
このリストは変数`kill-ring'に保持されていて、
リスト向けの通常の関数で操作できますが、
本節で述べるように、それをリングとして扱う特別な関数もあります。

        単語『キル』の使い方が不適当だと考える人々がいます。
『キル』したものを特に破壊_しない_操作を表すために使っているからです。
日常生活に照らしてみると、死は恒久的であり『キル』したものが
生き返ることはありません。 したがって、別の隠喩も提案されています。
たとえば、原稿を鋏で切り貼りすることに慣れていた前計算機世代の人々には
『カットリング』のほうが意味が通じるでしょう。
しかし、いまさら用語を変更するのは困難です。

     * Menu:

     * Kill Ring Concepts::     What text looks like in the kill ring.
     * Kill Functions::         Functions that kill text.
     * Yank Commands::          Commands that access the kill ring.
     * Low-Level Kill Ring::	   Functions and variables for kill ring access.
     * Internals of Kill Ring:: Variables that hold kill-ring data.


File: elisp-ja,  Node: Kill Ring Concepts,  Next: Kill Functions,  Up: The Kill Ring

31.8.1 キルリングの概念
-------------------------------

     キルリングは、もっとも最近にキルされたものを先頭にして、
キルされたテキストを文字列としてリストに記録します。
たとえば、短いキルリングはつぎのようになります。

          ("some text" "a different piece of text" "even older text")

     リストの長さが`kill-ring-max'に達すると、
新たな項目を追加すると自動的に最後の項目を削除します。

        キルコマンドが他のコマンドと混在する場合、
各キルコマンドはキルリングに新たな項目を追加します。
連続した複数のキルコマンドは、キルリングに1つの項目を作りあげ、
それを1個としてヤンクできます。
2番目以降の連続したキルコマンドは、最初のキルコマンドが作った
項目にテキストを追加していきます。

ヤンクでは、キルリングの1つの項目をリングの『先頭』として区別します。
リングの別の項目を『先頭』と指定することでリングを『回転』する
コマンドもあります。


File: elisp-ja,  Node: Kill Functions,  Next: Yank Commands,  Prev: Kill Ring Concepts,  Up: The Kill Ring

31.8.2 キル向けの関数
----------------------------

     `kill-region'は、テキストをキルするための普通のサブルーティンです。
この関数を呼び出す任意のコマンドは『キルコマンド』です
（その名前には`kill'があるはず）。
`kill-region'は、新たにキルされたテキストを
キルリングの先頭に新たな項目として追加したり、
もっとも最近の項目に加えます。
まえのコマンドがキルコマンドであるかどうかを
（`last-command'を使って）自動的に判定し、
もしそうならば、キルされたテキストをもっとも最近の項目に加えます。

      -- コマンド: kill-region start end
          この関数は、STARTとENDで定義される領域のテキストをキルする。
          テキストは削除されるが、テキスト属性とともにキルリングに保存される。
          値はつねに`nil'である。

          対話的に呼ばれると、STARTとENDはポイントとマークである。

          バッファが読み出し専用であると、
          `kill-region'はキルリングを同様に変更するが、
          バッファを変更せずにエラーを通知する。
          読み出し専用バッファからキルリングへテキストをコピーするために、
          ユーザーはすべてのキルコマンドを使えるのでこれは便利である。

      -- User Option: kill-read-only-ok
          このオプションが`nil'以外であると、
          `kill-region'は、バッファが読み出し専用であってもエラーとしない。
          そのかわりに、キルリングを更新しバッファは変更せずに戻る。

      -- コマンド: copy-region-as-kill start end
          このコマンドは、STARTとENDで定義される領域を
          （テキスト属性とともに）キルリングに保存するが、
          バッファからテキストを削除しない。 `nil'を返す。
          また、カーソルを一時的に移動してコピーしたテキストの範囲を示すか、
          あるいは、エコー領域にメッセージを表示する。

          このコマンドは`this-command'に`kill-region'を設定しないので、
          これ以降のキルコマンドはキルリングの同じ項目には加えない。

          Emacs 18版でも使うつもりがない限り、
          Lispプログラムからは`copy-region-as-kill'を呼ばないこと。
          Emacsの新しい版では、そのかわりに`kill-new'や`kill-append'を
          使うほうがよい。 *note Low-Level Kill Ring::。


File: elisp-ja,  Node: Yank Commands,  Next: Low-Level Kill Ring,  Prev: Kill Functions,  Up: The Kill Ring

31.8.3 ヤンク向けの関数
-------------------------------

"ヤンク"（yank）とは、キルリングからまえにキルされたテキストの項目を
再度挿入することです。

      -- コマンド: yank &optional arg
          このコマンドは、キルリングの先頭項目のテキストを
          ポイントのまえに挿入する。
          そのテキストの先頭にマークを末尾にポイントを置く。

          ARGがリスト（対話的な呼び出しではユーザーが数字文字なしに
          `C-u'を打ったとき）であると、`yank'は上に述べたように
          テキストを挿入するが、ヤンクしたテキストの先頭にポイントを
          末尾にマークを置く。

          ARGが数であると、`yank'はARG番目のもっとも最近に
          キルされたテキスト、つまり、キルリングリストのARG番目の項目を
          挿入する。

          `yank'はキルリングの内容を変更したり回転しない。 `nil'を返す。

      -- コマンド: yank-pop arg
          このコマンドは、キルリングからヤンクした項目を
          キルリングの別の項目で置き換える。

          これは`yank'や別の`yank-pop'の直後でのみ許される。
          そのような場合、リージョンにはヤンクしたばかりのテキストが含まれる。
          `yank-pop'はそのテキストを削除し、
          その位置にキルされた別のテキストを挿入する。
          削除したテキストはすでにキルリングのどこかにあるので、
          キルリングには追加しない。

          ARGが`nil'であると、キルリングの古い項目で置き換える。
          ARGが数であると、ARG番古いキルで置き換える。
          ARGが負であると、より最近のキルで置き換える。

          キルリング内でのキルの順番は、
          最古のもののつぎに最新のものがあり、
          最新のもののまえに最古のものがあるように折り返されている。

          戻り値はつねに`nil'である。


File: elisp-ja,  Node: Low-Level Kill Ring,  Next: Internals of Kill Ring,  Prev: Yank Commands,  Up: The Kill Ring

31.8.4 下位レベルのキルリング
----------------------------------------

これらの関数と変数は、下位レベルでキルリングを参照するためのものですが、
Lispプログラムで使っても便利です。
これらはウィンドウシステムのセレクション（*note Window System
Selections::） との相互作用の面倒をみてくれるからです。

      -- Function: current-kill n &optional do-not-move
          関数`current-kill'は、キルリングの『先頭』として区別する
          ヤンクポインタを（新しいキルから古いキルへ向けて）N個分回転し、
          リングのその位置のテキストを返す。

          省略可能な第2引数DO-NOT-MOVEが`nil'以外であると、
          `current-kill'は、ヤンクポインタは変更せずに、
          現在のヤンクポインタから数えてN番目のキルを返す。

          Nが0であると、もっとも最近のキルを要求することを表し、
          `current-kill'は、キルリングを調べるまえに
          （以下に述べる）`interprogram-paste-function'の値を呼び出す。

      -- Function: kill-new string
          この関数は、テキストSTRINGを新たな項目として
          キルリングの先頭に置く。 必要ならば最古の項目を破棄する。
          `interprogram-cut-function'（下記参照）の値も起動する。

      -- Function: kill-append string before-p
          この関数は、キルリングの先頭項目にテキストSTRINGを追加する。
          通常、STRINGはその項目の末尾に加わるが、
          BEFORE-Pが`nil'以外であるとその項目の先頭に加わる。
          この関数は、`interprogram-cut-function'（下記参照）の値も起動する。

      -- Variable: interprogram-paste-function
          この変数は、ウィンドウシステムを使っているときに
          別のプログラムからキルされたテキストを転送する方法を提供する。
          その値は、`nil'であるか、引数なしの関数であること。

          値が関数であると、
          『もっとも最近のキル』を得るために`current-kill'が呼び出す。
          関数が`nil'以外の値を返すと、
          その値は『もっとも最近のキル』として使われる。
          `nil'を返せば、`kill-ring'の先頭項目が使われる。

          このフックの普通の用途は、
          セレクションが別のアプリケーションに属する場合であっても、
          ウィンドウシステムの一次セレクションを
          もっとも最近のキルとして得ることである。 *note Window System
          Selections::。

      -- Variable: interprogram-cut-function
          この変数は、ウィンドウシステムを使っているときに
          キルされたテキストを別のプログラムへ転送する方法を提供する。
          その値は、`nil'であるか、引数なしの関数であること。

          値が関数であると、`kill-new'と`kill-append'が
          キルリングの新たな先頭項目を引数として呼び出す。

          このフックの普通の用途は、 新たにキルされたテキストを
          ウィンドウシステムの一次セレクションにすることである。 *note
          Window System Selections::。


File: elisp-ja,  Node: Internals of Kill Ring,  Prev: Low-Level Kill Ring,  Up: The Kill Ring

31.8.5 キルリングの内部
-------------------------------

変数`kill-ring'は、文字列のリストの形でキルリングの内容を保持します。
もっとも最近のキルがつねにリストの先頭にあります。

        変数`kill-ring-yank-pointer'は、
CARがつぎにヤンクすべきテキストであるような
キルリングリストの項目を指しています。
この変数がリングの『先頭』を識別するといいます。
`kill-ring-yank-pointer'を別の項目へ動かすことを
"キルリングを回転する"と呼びます。 ヤンクポインタを動かす関数は、
リストの末尾からリストの先頭へ折り返しその逆も行うので、
キルリングを『リング』と呼ぶのです。 リングの回転は仮想的なものであり、
`kill-ring'の値は変更しません。

        `kill-ring'も`kill-ring-yank-pointer'もLisp変数であり、
それらの値は普通のリストです。
`kill-ring-yank-pointer'の名前の単語『ポインタ』は、
つぎのヤンクコマンドで使うリストの項目を識別することが
変数の目的であることを表します。

        `kill-ring-yank-pointer'の値は、キルリングリストの
1つの項目とつねに`eq'です。 これが識別する項目は、その項目のCARです。
キルリングを変更するキルコマンドも、
`kill-ring'の値をこの変数の値とします。
その効果は、新たにキルされたテキストが先頭にくるように
リングを回転することです。

        キルリング`("some text" "a different piece of text" "yet older
text")'の
第2項目を変数`kill-ring-yank-pointer'が指しているようすをつぎに示します。

          kill-ring                  ---- kill-ring-yank-pointer
            |                       |
            |                       v
            |     --- ---          --- ---      --- ---
             --> |   |   |------> |   |   |--> |   |   |--> nil
                  --- ---          --- ---      --- ---
                   |                |            |
                   |                |            |
                   |                |             -->"yet older text"
                   |                |
                   |                 --> "a different piece of text"
                   |
                    --> "some text"

     `C-y'（`yank'）の直後に`M-y'（`yank-pop'）を使うと
この状態になります。

      -- Variable: kill-ring
          この変数は、もっとも最近にキルされたものを最初にして
          キルされたテキストを順に並べたリストを保持する。

      -- Variable: kill-ring-yank-pointer
          この変数の値は、キルリングのどの要素が
          ヤンクするためのリングの『先頭』であるかを表す。
          より正確には、その値は`kill-ring'のリストの一部であり、
          そのCARは`C-y'がヤンクするキルされた文字列である。

      -- User Option: kill-ring-max
          この変数の値は、末尾の要素が破棄されるまでに
          キルリングが増大できる最大の長さである。
          `kill-ring-max'のデフォルト値は30である。


File: elisp-ja,  Node: Undo,  Next: Maintaining Undo,  Prev: The Kill Ring,  Up: Text

31.9 アンドゥ
=================

ほとんどのバッファには、バッファのテキストに対する変更をアンドゥ（もとに戻す）
できるようにすべての変更を記録する "アンドゥリスト"（undo
list）があります。 （アンドゥリストのないバッファは、
Emacsがアンドゥは有用ではないと仮定する特殊目的のバッファである。）
バッファのテキストを変更するすべての基本関数は、
変数`buffer-undo-list'に収めたアンドゥリストの先頭に
自動的に要素を追加します。

      -- Variable: buffer-undo-list
          この変数の値は、カレントバッファのアンドゥリストである。
          値`t'はアンドゥ情報の記録を禁止する。

        アンドゥリストの要素として可能なものをつぎに示します。

    `POSITION'
          この種の要素は、まえのポイント値を記録する。
          この要素をアンドゥするとポイントをPOSITIONへ移動する。
          通常のカーソル移動では、いかなる種類のアンドゥ記録も作らないが、
          削除操作ではコマンド実行前のポイント位置を記録するためにこの項目を作る。

    `(BEG . END)'
          この種の要素は、挿入されたテキストを削除する方法を表す。
          挿入されたテキストはバッファのBEGからENDまでの範囲を占める。

    `(TEXT . POSITION)'
          この種の要素は、削除されたテキストを再度挿入する方法を表す。
          削除されたテキストそのものは文字列TEXTである。
          再度挿入する位置は`(abs POSITION)'である。

    `(t HIGH . LOW)'
          この種の要素は、未変更のバッファが変更されたことを表す。
          HIGHとLOWは2つの整数であり、それぞれ、
          まえに訪問したときや保存したときの訪問しているファイルの更新時刻の
          16ビットを記録している。
          `primitive-undo'はこれらの値を用いて、
          バッファを再度未変更と印を付けるかどうか判定する。
          ファイルの更新時刻がこれに一致するときにのみ再度未変更とする。

    `(nil PROPERTY VALUE BEG . END)'
          この種の要素は、テキスト属性の変更を記録する。
          変更をアンドゥするにはつぎのようにする。

               (put-text-property BEG END PROPERTY VALUE)

    `(MARKER . ADJUSTMENT)'
          この種の要素は、周りのテキストが削除されたために
          マーカMARKERを再配置し
          ADJUSTMENT文字分位置を移動したことを記録する。
          この要素をアンドゥすると、 MARKER - ADJUSTMENT文字に移動する。

    `nil'
          この要素は境界である。
          2つの境界のあいだの要素群を"変更グループ"（change
          group）と呼ぶ。
          通常、各変更グループは1つのキーボードコマンドに対応し、
          アンドゥコマンドはグループ全体を1個としてアンドゥする。

      -- Function: undo-boundary
          この関数は、アンドゥリストに境界要素を置く。
          アンドゥコマンドはそのような境界で停止し、
          連続したアンドゥコマンドはよりまえの境界までアンドゥする。
          この関数は`nil'を返す。

          エディタコマンドループは、
          各キー列を実行するまえにアンドゥの境界を自動的に作る。
          したがって、各アンドゥは、1つのコマンドの効果を普通は取り消す。
          自己挿入の入力文字は例外である。
          コマンドループはそのような最初の文字に境界を作り、
          つぎの19個の連続する自己挿入の入力文字では境界を作らず、
          20番目で境界を作るということを自己挿入の入力文字が続く限り行う。

          別のバッファでアンドゥ可能な変更を行うたびに
          バッファのすべての変更で境界を追加する。
          これは、各コマンドが変更した箇所で各バッファに境界を作ることを
          保証するためである。

          1つのコマンドの効果を複数に分けるためにこの関数を直接呼ぶことは有用である。
          たとえば、`query-replace'は各置換のあとで`undo-boundary'を呼び出し、
          ユーザーが個々の置換を1つ1つアンドゥできるようにする。

      -- Function: primitive-undo count list
          これは、アンドゥリストの要素をアンドゥする基本的な関数である。
          LISTの先頭のCOUNT個の要素をアンドゥし、LISTの残りを返す。
          この関数をLispで書くこともできるが、Cで書いたほうが便利である。

          `primitive-undo'は、バッファを変更すると
          バッファのアンドゥリストに要素を追加する。
          アンドゥコマンドは一連のアンドゥ操作を始めるときに
          アンドゥリストを保存して混乱を避ける。
          アンドゥ操作では、保存しておいた値を使い更新する。
          アンドゥによって追加される新たな要素はこの保存された値の一部ではないので、
          それらはアンドゥを続行しても干渉しない。


File: elisp-ja,  Node: Maintaining Undo,  Next: Filling,  Prev: Undo,  Up: Text

31.10 アンドゥリストの管理
====================================

     本節では、指定されたバッファでアンドゥ情報の記録をオン／オフする
方法について述べます。 また、アンドゥリストが大きくなりすぎないように
自動的に切り詰める方法についても説明します。

新たに作成されたバッファのアンドゥ情報の記録は普通は始めオンですが、
バッファ名が空白で始まる場合は最初からオフです。
つぎの2つの関数を使うか、読者自身が`buffer-undo-list'に設定すれば、
アンドゥ記録を明示的にオン／オフできます。

      -- コマンド: buffer-enable-undo &optional buffer-or-name
          このコマンドは、バッファBUFFER-OR-NAMEでのアンドゥ記録をオンにし、
          以降の変更を取り消せるようにする。
          引数を指定しないと、カレントバッファを使う。
          当該バッファでアンドゥ記録がすでにオンであると、
          この関数はなにもしない。 `nil'を返す。

          対話的に呼ばれると、BUFFER-OR-NAMEはカレントバッファである。
          他のバッファを指定できない。

      -- コマンド: buffer-disable-undo &optional buffer
      -- コマンド: buffer-flush-undo &optional buffer
          この関数はバッファBUFFERのアンドゥリストを破棄し、
          以降のアンドゥ情報の記録をオフにする。
          その結果、これ以前の変更も以降の変更も取り消すことはできない。
          BUFFERのアンドゥリストがすでにオフであると、
          この関数にはなんの効果もない。

          この関数は`nil'を返す。

          名前`buffer-flush-undo'は廃れているとはみなさないが、
          好ましい名前は`buffer-disable-undo'である。

        編集を続けるにしたがってアンドゥリストはどんどん長くなります。
これらがメモリを使い尽くさないように、
読者が設定した上限サイズにガベッジコレクションが切り詰めます。
（この目的においてアンドゥリストの『サイズ』は、
リストを構成するコンスセルの個数と削除された文字列の和である。）
2つの変数`undo-limit'と`undo-strong-limit'は、
許容できるサイズの範囲を制御します。

      -- Variable: undo-limit
          これはアンドゥリストの許容できるサイズの緩い制限である。
          このサイズを越える位置にある変更グループは保持される最古のものである。

      -- Variable: undo-strong-limit
          これはアンドゥリストの許容できるサイズの上限である。
          このサイズを越える位置にある変更グループは
          （これより古いものも含めて）削除される。
          例外が1つあり、最新の変更グループは
          それがどれほど大きくてもけっして破棄しない。


File: elisp-ja,  Node: Filling,  Next: Margins,  Prev: Maintaining Undo,  Up: Text

31.11 詰め込み
==================

     "詰め込み"（fill）とは、指定されている最大幅
（を越えず）にほぼ収まるように（行分け位置を移動して）
行の長さを調整することです。
さらに、行を"幅揃え"（justify）することもできます。
つまり、左右の両端や片側の余白をきちんと揃えるため
空白を挿入することです。 幅は変数`fill-column'で制御します。
読みやすいように、行は70コラム程度に収めるべきです。

        テキストを挿入するにつれて自動的にテキストを詰め込むには、
自動詰め込み（auto-fill）モード（*note Auto Filling::）を使いますが、
既存のテキストを変更しても正しくない詰め込み状態のまま放置されます。
したがって、そのようなテキストは明示的に詰め込む必要があります。

        本節のほとんどの関数が返す値には意味はありません。
詰め込みを行うすべての関数は、現在の左端余白、現在の右端余白、
現在の幅揃えスタイルに注意をはらいます（*note Margins::）。
現在の幅揃えスタイルが`none'であると、
詰め込み関数は実際にはなにもしません。

        詰め込み関数には引数JUSTIFYを取るものもあります。
それが`nil'以外であると、幅揃えの種類を指示します。
特定の幅揃えスタイルを指示するものは、
`left'、`right'、`full'、`center'です。 それが`t'であると、
テキストの当該部分には現在の幅揃えスタイルを用いることを意味します
（下記の`current-justification'を参照）。
これ以外の値は`full'として扱います。

        対話的に詰め込み関数を呼ぶときに前置引数を使うと、
JUSTIFYとして値`full'を暗に指示します。

      -- コマンド: fill-paragraph justify
          このコマンドは、ポイントがある段落、あるいは、ポイントのあとの段落を詰め込む。
          JUSTIFYが`nil'以外であると、各行の幅揃えも行う。
          段落の境界を探すために普通の段落移動コマンドを用いる。 *note
          段落: (emacs)Paragraphs.。

      -- コマンド: fill-region start end &optional justify nosqueeze
               to-eop
          このコマンドは、STARTからENDの領域内の各段落を詰め込む。
          JUSTIFYが`nil'以外であれば、幅揃えも行う。

          NOSQUEEZEが`nil'以外であると、
          行分け以外の白文字にはふれないことを意味する。
          TO-EOPが`nil'以外であると、 段落の末尾まで、あるいは、
          `use-hard-newlines'がオンならばつぎのハード改行（下記参照）までを
          詰め込むことを意味する。

          変数`paragraph-separate'は、段落の区別方法を制御する。 *note
          Standard Regexps::。

      -- コマンド: fill-individual-paragraphs start end &optional
               justify mail-flag
          このコマンドは、領域内の各段落を各段落の詰め込み接頭辞に従って詰め込む。
          したがって、段落の行が空白で字下げされていると、
          詰め込んだあとの段落も同じように字下げされる。

          最初の2つの引数STARTとENDは、
          詰め込むべき範囲の先頭と末尾である。
          3番目と4番目の引数、JUSTIFYとMAIL-FLAGは省略できる。
          JUSTIFYが`nil'以外であると、
          段落の詰め込みに加えて幅揃えも行う。
          MAIL-FLAGが`nil'以外であると、
          メイルメッセージなのでヘッダ行を詰め込まないことを意味する。

          通常、`fill-individual-paragraphs'は、
          字下げが変わると新しい段落の開始とみなす。
          `fill-individual-varying-indent'が`nil'以外であると、
          区切り行のみが段落を区切るとみなす。
          これは段落の先頭行と後続の行で字下げが異なる段落を処理できる。

      -- User Option: fill-individual-varying-indent
          この変数は、上に述べたように
          `fill-individual-paragraphs'の動作を変える。

      -- コマンド: fill-region-as-paragraph start end &optional justify
               nosqueeze squeeze-after
          このコマンドは、テキストの領域を1つの段落とみなして詰め込む。
          領域に複数の段落があると、段落のあいだの空行は取りさる。
          JUSTIFYが`nil'以外であると幅揃えも行う。

          対話的な呼び出しでは、前置引数で幅揃えを指示する。

          NOSQUEEZEが`nil'以外であると、
          行分け以外の白文字にはふれないことを意味する。
          SQUEEZE-AFTERが`nil'以外であると、 それは領域内の位置を表し、
          その位置よりまえにある空白を変更しないように指示する。

          適応型詰め込み（adaptive-fill）モードでは、
          デフォルトの詰め込み接頭辞を選ぶために
          このコマンドは`fill-context-prefix'を呼び出す。 *note
          Adaptive Fill::。

      -- コマンド: justify-current-line how eop nosqueeze
          このコマンドは、現在行の単語のあいだに空白を挿入し、
          ちょうど`fill-column'コラムで行が終るようにする。
          `nil'を返す。

          引数HOWが`nil'以外であると、 幅揃えスタイルを指定する。
          可能な値は、`left'、`right'、`full'、
          `center'、または、`none'である。
          `t'であると、指定されている幅揃えスタイルに従うことを意味する
          （下記の`current-justification'を参照）。
          `nil'は、幅揃えしないことを意味する。

          EOPが`nil'以外であると、
          `current-justification'が両端揃えを指定しているときには
          左端揃えを行うことを意味する。
          これは段落の最後の行に適用される。
          段落全体として両端揃えであっても、最後の行はそうすべきではない。

          NOSQUEEZEが`nil'以外であると、
          内側の白文字を変更しないことを意味する。

      -- User Option: default-justification
          この変数の値は、テキスト属性で幅揃えスタイルを指定していない
          テキストに対して用いる幅揃えスタイルを指定する。
          可能な値は、`left'、`right'、`full'、`center'、 `none'である。
          デフォルト値は`left'である。

      -- Function: current-justification
          この関数は、ポイントの周りのテキストを詰め込むときに使う
          正しい幅揃えスタイルを返す。

      -- User Option: sentence-end-double-space
          この変数が`nil'以外であると、
          直後に1つの空白を従えたピリオドを文末とみなさず、
          詰め込み関数はそのような箇所で行分けしない。

      -- Variable: fill-paragraph-function
          この変数は、段落の詰め込みに優先する方法をメジャーモードに与える。
          値が`nil'以外であると、
          `fill-paragraph'は詰め込み処理のためにこの関数を呼び出す。
          関数が`nil'以外の値を返すと、
          `fill-paragraph'は処理が完了したとみなして戻り値をただちに返す。

          この機能の普通の用途は、
          プログラム言語向けのモードでコメントを詰め込むためである。
          この関数で普通の方法で詰め込む必要がある場合には、つぎのようにする。

               (let ((fill-paragraph-function nil))
                 (fill-paragraph arg))

      -- Variable: use-hard-newlines
          この変数が`nil'以外であると、
          詰め込み関数は、テキスト属性`hard'を持つ改行を削除しない。
          これらの『ハード改行』は段落の区切りとして働く。


File: elisp-ja,  Node: Margins,  Next: Adaptive Fill,  Prev: Filling,  Up: Text

31.12 詰め込みのための余白
====================================

      -- User Option: fill-prefix
          このバッファローカルな変数は、普通のテキスト行の先頭に現れ、
          詰め込み時には無視すべきテキストの文字列（詰め込み接頭辞）を指定する。
          詰め込み接頭辞で始まらない行は段落の開始行とみなすため、
          詰め込み接頭辞のあとに余分に白文字があるとそれらも段落の開始行とみなす。
          詰め込み接頭辞で始まりそのあとに余分な白文字がない行は、
          いっしょに詰め込める普通のテキスト行である。

          左端余白がある場合には、左端余白のあとに詰め込み接頭辞が続く。

      -- User Option: fill-column
          このバッファローカルな変数は、詰め込んだ行の最大幅を指定する。
          この値は整数であり、コラム数であること。
          自動詰め込み（auto-fill）モード（*note Auto
          Filling::）を含めて
          すべての詰め込み／幅揃え／中央揃えを行うコマンドは、
          この変数に影響される。

          特に他人のために書いているテキストでは、
          `fill-column'を70未満にするべきである。
          さもないと、人によっては快適に読むには行が長すぎて、
          テキストが不恰好に見える。

      -- Variable: default-fill-column
          この変数の値は、バッファで`fill-column'の値を設定していない場合の
          `fill-column'のデフォルト値である。 これは`(default-value
          'fill-column)'と同じである。

          `default-fill-column'のデフォルト値は70である。

      -- コマンド: set-left-margin from to margin
          FROMからTOまでのテキストの 属性`left-margin'を値MARGINにする。
          自動詰め込み（auto-fill）モードがオンであると、
          このコマンドは、当該領域を再詰め込みして新たな余白に適合するようにする。

      -- コマンド: set-right-margin from to margin
          FROMからTOまでのテキストの
          属性`right-margin'を値MARGINにする。
          自動詰め込み（auto-fill）モードがオンであると、
          このコマンドは、当該領域を再詰め込みして新たな余白に適合するようにする。

      -- Function: current-left-margin
          この関数は、ポイントの周りのテキストを詰め込むときに使う
          正しい左端余白の値を返す。
          その値は、現在行の最初の文字の属性`left-margin'の値（なければ0）
          と変数`left-margin'の値の和である。

      -- Function: current-fill-column
          この関数は、ポイントの周りのテキストを詰め込むときに使う
          正しい詰め込み幅を返す。 その値は、変数`fill-column'の値から
          ポイント直後の文字の属性`right-margin'の値を引いたものである。

      -- コマンド: move-to-left-margin &optional n force
          この関数は、ポイントを現在行の左端余白へ移動する。
          移動先のコラム位置は関数`current-left-margin'を呼び出して決定する。
          引数Nが`nil'以外であると、
          `move-to-left-margin'はN-1先の行へまず移動する。

          FORCEが`nil'以外であると、
          行の字下げが左端余白の値に一致しないときには、
          字下げを修正することを指示する。

      -- Function: delete-to-left-margin from to
          この関数は、FROMからTOまでのテキストから
          左端余白分の字下げを取りさる。
          削除する字下げ量は、`current-left-margin'を呼び出して決定する。
          この関数が白文字以外を削除することは絶対にない。

      -- Function: indent-to-left-margin
          これは、基本（fundamental）モード、テキスト（text）モードなどが使う
          デフォルトの`indent-line-function'である。
          その効果は、変数`left-margin'の値で指定した位置から
          現在行が始まるように字下げを調整することである。
          それには白文字の挿入や削除が伴う。

      -- Variable: left-margin
          この変数は、左端余白コラムの起点を指定する。
          基本（fundamental）モードでは、`C-j'がこのコラム位置に字下げする。
          この変数に設定すると自動的にバッファローカルになる。

      -- Variable: fill-nobreak-predicate
          この変数は、特定の箇所では行分けしない方法をメジャーモードに提供する。
          その値は関数であること。
          この関数は、引数なしで行分け予定箇所にポイントを置いて呼び出される。
          この関数が`nil'以外を返すと、当該箇所では行分けしない。


File: elisp-ja,  Node: Adaptive Fill,  Next: Auto Filling,  Prev: Margins,  Up: Text

31.13 適応型詰め込み（adaptive-fill）モード
=======================================================

     適応型詰め込みモード（adaptive-fill）では、
詰め込むべき各段落のテキストから自動的に詰め込み接頭辞を選びます。

      -- User Option: adaptive-fill-mode
          この変数が`nil'以外であると、
          適応型詰め込みモード（adaptive-fill）がオンである。
          デフォルトでは`t'である。

      -- Function: fill-context-prefix from to
          この関数は適応型詰め込みモード（adaptive-fill）の中核を実装するものであり、
          FROMからTOのあいだのテキストに基づいて詰め込み接頭辞を選ぶ。
          以下に述べる変数に基づいて、段落の最初の2行を調べてこれを行う。

      -- User Option: adaptive-fill-regexp
          この変数は、適応型詰め込みモード（adaptive-fill）を制御する
          正規表現を保持する。
          適応型詰め込みモード（adaptive-fill）では、
          行の（あれば）左端余白の白文字のうしろから始まるテキストに対して
          この正規表現の一致を試みる。
          一致した文字群が当該行の詰め込み接頭辞の候補になる。

      -- User Option: adaptive-fill-first-line-regexp
          1行だけの段落において、詰め込み接頭辞の候補がこの正規表現に一致するか、
          `comment-start-skip'に一致すると、その候補を使う。
          さもなければ、同じ幅に相当する白文字をかわりに使う。

          1行だけの段落から選んだ詰め込み接頭辞が後続の行の段落の始まりである場合には、
          1行だけの段落からはけっして詰め込み接頭辞を選ばない。

      -- User Option: adaptive-fill-function
          この変数に関数を指定することで、
          詰め込み接頭辞のより複雑な自動選択方法を指定できる。
          この関数は、`adaptive-fill-regexp'の一致に失敗したときに、
          行の左端余白のうしろにポイントを置いて呼び出され、
          当該行に基づいて適切な詰め込み接頭辞を返すこと。
          それが`nil'を返すと、当該行には詰め込み接頭辞がないことを意味する。


File: elisp-ja,  Node: Auto Filling,  Next: Sorting,  Prev: Adaptive Fill,  Up: Text

31.14 自動詰め込み（auto-filling）モード
===================================================

     自動詰め込み（auto-filling）モードは、テキストを挿入するにつれて
自動的に行を詰め込むマイナモードです。
本節では、自動詰め込み（auto-filling）モードが使うフックについて述べます。
既存のテキストを詰め込んだり幅揃えするために
明示的に呼び出す関数については、*note Filling::を参照してください。

        自動詰め込み（auto-filling）モードでは、
テキストの一部を再詰め込む際の
余白や幅揃えスタイルを変更するための関数も使えるようにします。 *Note
Margins::。

      -- Variable: auto-fill-function
          この変数の値は、
          自己挿入される空白や改行のあとで呼び出されるべき
          （引数なしの）関数であること。
          これが`nil'であると、そのような場合に特別なことを行わない。

          自動詰め込み（auto-filling）モードがオンであると、
          `auto-fill-function'の値は`do-auto-fill'である。
          この関数の目的は、行分けの通常の方針を実装することである。

               Emacsの古い版では、この変数を`auto-fill-hook'と命名していたが、
               フックの標準的な慣習に従って呼ばれないため
               19版で`auto-fill-function'と改名した。

      -- Variable: normal-auto-fill-function
          この変数は、自動詰め込み（auto-filling）モードがオンになったとき／であるときに
          `auto-fill-function'として用いる関数を指定する。
          メジャーモードでは、この変数のバッファローカルな値に設定することで
          自動詰め込み（auto-filling）モードのふるまいを変更できる。


File: elisp-ja,  Node: Sorting,  Next: Columns,  Prev: Auto Filling,  Up: Text

31.15 テキストのソート
==============================

本節で述べるソート関数すべては、バッファ内のテキストを並べ替えます。
これは、リスト内の要素の順番を並べ替える関数`sort' （*note
Rearrangement::）と対照的です。
これらの関数が返す値には意味はありません。

      -- Function: sort-subr reverse nextrecfun endrecfun &optional
               startkeyfun endkeyfun
          この関数は、バッファ内のテキストをレコードに分割してソートする
          汎用のテキストソートルーティンである。
          本節のコマンドのほとんどは、この関数を用いる。

          `sort-subr'の動作方法を理解するためは、
          バッファの参照可能部分全体が "ソートレコード"（sort
          record）と呼ばれる
          重なり合いのない断片に分割されていると考える。
          レコードは連続しているかもしれないし、そうでないかもしれないが、
          けっして重なり合わない。
          各ソートレコードの一部分（あるいは全体）をソートキーとして区別する。
          ソートでは、ソートキーの順に並ぶようにレコードを並び替える。

          通常、レコードをソートキーの昇順に並べ替える。
          関数`sort-subr'の第1引数REVERSEが`nil'以外であると、
          ソートキーの降順にレコードを並べ替える。

          `sort-subr'のつぎの4つの引数は、
          ソートレコードをまたいでポイントを移動するために呼ばれる関数である。
          それらは、`sort-subr'で多数回呼び出される。

            1.
               NEXTRECFUNは、レコードの末尾にポイントを置いて呼び出される。
               この関数は、つぎのレコードの先頭にポイントを移動する。
               最初のレコードの先頭は、
               `sort-subr'を呼び出したときのポイント位置であると仮定する。
               したがって、`sort-subr'を呼び出すまえには、普通、
               バッファの先頭にポイントを移動しておくこと。

               この関数は、バッファの末尾にポイントを置いておくことで、
               ソートレコードがなくなったことを表せる。

            2. ENDRECFUNは、レコード内にポイントを置いて呼び出される。
               レコードの末尾にポイントを移動する。

            3. STARTKEYFUNは、レコードの先頭からソートキーの先頭へ
               ポイントを移動するために呼び出される。
               この引数は省略可能であり、省略するとレコード全体をソートキーとする。
               指定した場合、その関数は、ソートキーとして用いる`nil'以外の値を返すか、
               バッファのポイント位置からソートキーが始まることを表す`nil'を返すこと。
               後者の場合、ソートキーの末尾を探すためにENDKEYFUNが呼ばれる。

            4. ENDKEYFUNは、ソートキーの先頭からソートキーの末尾に
               ポイントを移動するために呼び出される。
               この引数は省略可能である。
               STARTKEYFUNが`nil'を返しこの引数が省略されている
               （あるいは`nil'である）と、ソートキーはレコードの末尾までである。
               STARTKEYFUNが`nil'以外の値を返すのであれば、
               ENDKEYFUNは必要ない。

          `sort-subr'の例として、 `sort-lines'の完全な関数定義を示す。

               ;; 説明文字列の始めの2行は、ユーザーが見るときには
               ;; 実質的には1行であることに注意
               (defun sort-lines (reverse beg end)
                 "Sort lines in region alphabetically;\
                argument means descending order.
               Called from a program, there are three arguments:
               REVERSE (non-nil means reverse order),\
                BEG and END (region to sort).
               The variable `sort-fold-case' determines\
                whether alphabetic case affects
               the sort order.
                 (interactive "P\nr")
                 (save-excursion
                   (save-restriction
                     (narrow-to-region beg end)
                     (goto-char (point-min))
                     (sort-subr reverse 'forward-line 'end-of-line))))

          ここで、`forward-line'はつぎのレコードの先頭にポイントを移動し、
          `end-of-line'はレコードの末尾にポイントを移動する。
          レコード全体をソートキーとして用いるため、
          引数STARTKEYFUNとENDKEYFUNは指定しない。

          関数`sort-paragraphs'もほぼ同様であるが、
          つぎのように`sort-subr'を呼び出す点が異なる。

               (sort-subr reverse
                          (function
                            (lambda ()
                              (while (and (not (eobp))
                                     (looking-at paragraph-separate))
                                (forward-line 1))))
                          'forward-paragraph)

          `sort-subr'から戻ったあとでは、
          ソートレコードを指しているマーカは意味のある位置を指していない。

      -- User Option: sort-fold-case
          この変数が`nil'以外であると、
          `sort-subr'や他のバッファソート関数は、
          文字列の比較において大文字小文字を区別しない。

      -- コマンド: sort-regexp-fields reverse record-regexp key-regexp
               start end
          このコマンドは、STARTとENDのあいだの領域を
          RECORD-REGEXPとKEY-REGEXPの指定に従って
          アルファベット順にソートする。
          REVERSEが負の整数であると、逆順にソートする。

          アルファベット順のソートとは、
          最初の文字同士、2番目の文字同士といった具合に
          2つのソートキーを比較することである。
          不一致がみつかると、ソートキーが等しくないことを意味し、
          最初の不一致箇所の文字が小さいほうのソートキーが小さい。
          個々の文字は、Emacsの文字集合における文字コードの数値に従って比較する。

          引数RECORD-REGEXPの値は、バッファをソートレコードに
          分割する方法を指定する。
          各レコードの末尾において、この正規表現を探索し
          それに一致したテキストをつぎのレコードとする。
          たとえば、正規表現`^.+$'は、
          少なくとも1つの文字のあとに改行があるような行に一致し、
          そのような行をソートレコードとする。
          正規表現の構文と意味については、*note Regular Expressions::。

          引数KEY-REGEXPの値は、
          レコードのどの部分がソートキーであるかを指定する。
          KEY-REGEXPは、レコード全体かその一部分に一致する。
          後者の場合、レコードの残りの部分は、レコードの並び替え順序には影響しないが、
          レコードをその新たな位置に移動するときにいっしょに移動される。

          引数KEY-REGEXPで
          RECORD-REGEXPの部分式に一致したテキストを参照してもよいし、
          独立した正規表現でもよい。

          KEY-REGEXPにはつぎの可能性がある。

         `\DIGIT'
               RECORD-REGEXPのDIGIT番目の
               括弧によるグループ化`\(...\)'に一致したテキストがソートキーである。

         `\&'
               レコード全体がソートキーである。

         正規表現
               `sort-regexp-fields'はレコード内でこの正規表現に一致するものを探す。
               一致がみつかれば、それがソートキーになる。
               レコード内でKEY-REGEXPに対する一致がみつからなければ、
               レコードを無視する。
               つまり、バッファ内での当該レコードの位置を変更しない。
               （別のレコードが周りに移動してくるかもしれない。）

          たとえば、領域内のすべての行を各行の`f'で始まる最初の単語で
          ソートするには、RECORD-REGEXPに`^.*$'、
          KEY-REGEXPに`\<f\w*\>'を指定する。
          つまり、つぎのような式になる。

               (sort-regexp-fields nil "^.*$" "\\<f\\w*\\>"
                                   (region-beginning)
                                   (region-end))

          `sort-regexp-fields'を対話的に呼び出すと、
          ミニバッファでRECORD-REGEXPとKEY-REGEXPを問い合わせる。

      -- コマンド: sort-lines reverse start end
          このコマンドは、STARTとENDのあいだの領域の行を
          アルファベット順にソートする。
          REVERSEが`nil'以外であると、逆順にソートする。

      -- コマンド: sort-paragraphs reverse start end
          このコマンドは、STARTとENDのあいだの領域の段落を
          アルファベット順にソートする。
          REVERSEが`nil'以外であると、逆順にソートする。

      -- コマンド: sort-pages reverse start end
          このコマンドは、STARTとENDのあいだの領域のページを
          アルファベット順にソートする。
          REVERSEが`nil'以外であると、逆順にソートする。

      -- コマンド: sort-fields field start end
          このコマンドは、STARTとENDのあいだの領域の行を
          各行のFIELD番目のフィールド同士をアルファベット順に比較してソートする。
          フィールドは白文字で区切られ、1から数える。
          FIELDが負であると、
          行末から-FIELD番目のフィールドでソートする。
          このコマンドは、表をソートするのに有用である。

      -- コマンド: sort-numeric-fields field start end
          このコマンドは、STARTとENDのあいだの領域の行を
          各行のFIELD番目のフィールド同士を数値として比較してソートする。
          領域内の各行の指定したフィールドには数があること。
          フィールドは白文字で区切られ、1から数える。
          FIELDが負であると、
          行末から-FIELD番目のフィールドでソートする。
          このコマンドは、表をソートするのに有用である。

      -- コマンド: sort-columns reverse &optional beg end
          このコマンドは、STARTとENDのあいだの領域の行を
          特定範囲のコラムをアルファベット順に比較してソートする。
          BEGとENDのコラム位置は、ソート対象のコラムの範囲を区切る。

          REVERSEが`nil'以外であると、逆順にソートする。

          このコマンドの普通でない点は、
          位置BEGを含む行全体と位置ENDを含む行全体も
          ソート対象の領域に含まれることである。

          `sort-columns'は、ユーティリティプログラム`sort'を使うため、
          タブ文字を含むテキストを正しく扱えない。 ソートするまえに`M-x
          untabify'を使ってタブを空白に変換すること。


File: elisp-ja,  Node: Columns,  Next: Indentation,  Prev: Sorting,  Up: Text

31.16 コラムを数える
===========================

     コラム関数は、（バッファの先頭から文字を数えた）文字位置を
（スクリーンの行頭から文字を数えた）コラム位置に変換します。

これらの関数は、各文字をそれがスクリーン上で占めるコラム数を基に数える。
つまり、`ctl-arrow'の値に依存してコントロール文字は、
2コラムか4コラム占めると数え、
タブ文字は、タブの開始コラムと`tab-width'の値に依存する
コラム数を占めると数えることを意味します。 *Note Usual Display::。

コラム番号の計算では、ウィンドウの幅や水平スクロール量を無視します。
その結果、コラム値は任意の大きさになりえます。
最初の（スクリーン左端の）コラムの番号は0です。

      -- Function: current-column
          この関数は、左端を0としてコラム数で数えたポイントの水平位置を返す。
          コラム位置は、現在行の先頭からポイント位置までの文字すべての
          表示上の表記の幅の総和である。

          `current-column'の使用例については、 *note Text
          Lines::の`count-lines'を参照。

      -- Function: move-to-column column &optional force
          この関数は、ポイントを現在行のCOLUMNへ移動する。
          COLUMNの計算では、現在行の先頭からポイント位置までの
          文字すべての表示上の表記の幅を考慮する。

          コラムCOLUMNが行末を越える場合、ポイントを行末へ移動する。
          COLUMNが負であると、ポイントを行頭へ移動する。

          コラムCOLUMNがタブなどの複数コラムを占める文字の中ほどにあるために
          そこへ移動できない場合には、
          ポイントを当該文字の末尾へ移動する。
          しかし、FORCEが`nil'以外であり COLUMNがタブの中ほどであると、
          コラムCOLUMNに正確に移動できるようにタブを空白に変換する。
          複数コラムを占めるその他の文字では、それらを分割する方法がないため、
          FORCEを指定しても変則的になる。

          コラムCOLUMNに到達できるほど行が長くない場合にも
          引数FORCEには効果がある。
          そのような場合、指定コラムに達するように行末に白文字を追加する。

          COLUMNが整数でないと、エラーを通知する。

          戻り値は、実際の移動先のコラム番号である。


File: elisp-ja,  Node: Indentation,  Next: Case Changes,  Prev: Columns,  Up: Text

31.17 字下げ
===============

     字下げ関数は、行頭の空白を調べたり、そこへ移動したり、
変更するために使います。 行の他の白文字を変更するものもあります。
コラム関数と字下げ関数は左端を0と数えます。

     * Menu:

     * Primitive Indent::      Functions used to count and insert indentation.
     * Mode-Specific Indent::  Customize indentation for different modes.
     * Region Indent::         Indent all the lines in a region.
     * Relative Indent::       Indent the current line based on previous lines.
     * Indent Tabs::           Adjustable, typewriter-like tab stops.
     * Motion by Indent::      Move to first non-blank character.


File: elisp-ja,  Node: Primitive Indent,  Next: Mode-Specific Indent,  Up: Indentation

31.17.1 字下げ基本関数
-----------------------------

本節では、字下げを数えたり挿入するために使われる基本関数について述べます。
後続の節の関数群は、これらの基本関数を使っています。
関連する関数については、*Note Width::。

      -- Function: current-indentation
          この関数は、現在行の字下げを返す。
          これは最初の白文字以外の文字の水平位置である。
          行全体が白文字や空である場合には、行末の水平位置を返す。

      -- コマンド: indent-to column &optional minimum
          この関数は、ポイント位置からCOLUMNに達するまでタブや空白で字下げする。
          MINIMUMを指定し`nil'以外であると、
          COLUMNを越える場合であっても最低MINIMUM個の空白を挿入する。
          さもなければ、ポイントがCOLUMNを越えている場合には、
          この関数はなにもしない。
          戻り値は、挿入した字下げが終る箇所のコラムである。

          挿入された白文字は周りの文字（普通は、まえの文字）からテキスト属性を継承する。
          *note Sticky Properties::。

      -- User Option: indent-tabs-mode
          この変数が`nil'以外であると、
          字下げ関数は空白に加えてタブも挿入する。
          さもなければ、空白のみを挿入する。
          この変数に設定すると、カレントバッファでバッファローカルになる。


File: elisp-ja,  Node: Mode-Specific Indent,  Next: Region Indent,  Prev: Primitive Indent,  Up: Indentation

31.17.2 メジャーモードの制御による字下げ
--------------------------------------------------------

     各メジャーモードの重要な機能は、
キー<TAB>を編集対象の言語に適した字下げにカスタマイズすることです。
本節では、キー<TAB>の機構とそれを制御する方法について述べます。
本節の関数は、予測できない値を返します。

      -- Variable: indent-line-function
          この変数の値は、現在行を字下げするために
          <TAB>（やさまざまなコマンド）が使う関数である。
          コマンド`indent-according-to-mode'は、
          この関数を呼ぶこと以上のことはしない。

          lispモードでは値はシンボル`lisp-indent-line'、
          Cモードでは`c-indent-line'、
          fortranモードでは`fortran-indent-line'である。
          標準的な字下げがない基本（fundamental）モード、
          テキスト（text）モード、他の多くのモードでは、
          値は`indent-to-left-margin'（デフォルト値）である

      -- コマンド: indent-according-to-mode
          このコマンドは、現在のメジャーモードに適した方法で現在行を字下げするために
          `indent-line-function'で指定される関数を呼び出す。

      -- コマンド: indent-for-tab-command
          このコマンドは、現在行を字下げするために
          `indent-line-function'で指定される関数を呼び出すが、
          その関数が`indent-to-left-margin'であると、
          かわりに`insert-tab'を呼び出す。
          （これはタブ文字を挿入する単純なコマンドである。）

      -- コマンド: newline-and-indent
          この関数は、改行を挿入してから、
          （改行を挿入したばかりの行に続く）新たな行を
          メジャーモードに基づいて字下げする。

          現在の`indent-line-function'を呼び出して字下げを行う。
          プログラム言語向けのモードでは、これは<TAB>が行うことと同じであるが、
          <TAB>がタブを挿入するテキスト向けのモードの一部では、
          `newline-and-indent'は`left-margin'で指定されたコラムに字下げする。

      -- コマンド: reindent-then-newline-and-indent
          このコマンドは、現在行を字下げし直し、ポイント位置に改行を挿入し、
          （改行を挿入したばかりの行に続く）新たな行を字下げする。

          このコマンドは、`indent-line-function'の現在の値を呼び出すことで、
          どちらの行も現在のメジャーモードに基づいて字下げする。
          プログラム言語向けのモードでは、これは<TAB>が行うことと同じであるが、
          <TAB>がタブを挿入するテキスト向けのモードの一部では、
          `reindent-then-newline-and-indent'は、
          `left-margin'で指定されるコラムに字下げする。


File: elisp-ja,  Node: Region Indent,  Next: Relative Indent,  Prev: Mode-Specific Indent,  Up: Indentation

31.17.3 領域全体の字下げ
--------------------------------

     本節では、領域内のすべての行を字下げするコマンドについて述べます。
これらは予測できない値を返します。

      -- コマンド: indent-region start end to-column
          このコマンドは、START（を含めて）と
          END（を含めない）のあいだで始まる空でない各行を字下げする。
          TO-COLUMNが`nil'であると、
          `indent-region'は、現在のモードの字下げ関数、
          つまり、`indent-line-function'の値を呼び出して、
          空でない各行を字下げする。

          TO-COLUMNが`nil'以外であると、
          それは字下げ先のコラム番号を指定する整数であること。
          すると、この関数は、白文字を追加するか削除して、
          各行を指定どおりに字下げする。

          詰め込み接頭辞がある場合、
          `indent-region'は詰め込み接頭辞で行を始めることで各行を字下げする。

      -- Variable: indent-region-function
          この変数の値は、`indent-region'の短縮版として利用可能な関数である。
          領域の開始位置と終了位置の2つの引数をとる。
          領域の行を1つ1つ字下げする場合と同じ結果を生じるが、
          より速く動作することを意図してこの関数を設計するべきである。

          値が`nil'であると短縮版はなく、
          `indent-region'が実際に1行ずつ処理する。

          短縮版関数はCモードやlispモードのようなモードで有用である。
          そのようなモードでは、`indent-line-function'で関数定義の始まりを
          走査する必要があり、これを各行に適用すると自乗の時間がかかる。
          短縮版では、字下げし終えた関数定義を通過するたびに
          走査情報を更新でき、これには線形時間かかるだけである。
          個々の行を高速に字下げできるモードでは、短縮版は必要ない。

          引数TO-COLUMNに`nil'以外を指定した`indent-region'には
          別の意味があり、この変数を使わない。

      -- コマンド: indent-rigidly start end count
          このコマンドは、START（を含めて）と
          END（を含めない）のあいだで始まる行すべてを
          コラム数COUNTだけ字下げする。
          これは、領域を1つの塊として動かしてその領域の『形を保つ』。
          このコマンドは、字下げしていないテキストの領域だけでなく、
          整形済みの領域を字下げするためにも有用である。

          たとえば、COUNTが3であると、
          このコマンドは指定した領域内の各行の行頭に3コラムの字下げを追加する。

          メイル（mail）モードでは、`C-c C-y'（`mail-yank-original'）が
          返信対象のメッセージからコピーしたテキストを字下げするために
          `indent-rigidly'を使っている。

      -- Function: indent-code-rigidly start end columns &optional
               nochange-regexp
          この関数は`indent-rigidly'と同様であるが、
          文字列やコメントで始まる行を変更しない点が異なる。

          さらに、（NOCHANGE-REGEXPが`nil'以外のとき）
          行の先頭がNOCHANGE-REGEXPに一致する場合にも行を変更しない。


File: elisp-ja,  Node: Relative Indent,  Next: Indent Tabs,  Prev: Region Indent,  Up: Indentation

31.17.4 先行行相対の字下げ
-----------------------------------

     本節では、先行する行の内容に基づいて現在行を字下げする2つの
コマンドについて述べます。

      -- コマンド: indent-relative &optional unindented-ok
          このコマンドは、空白でないまえの行のつぎの"字下げ位置"のコラムに
          達するまで、ポイント位置に白文字を挿入する。
          字下げ位置とは、白文字に続く白文字以外の文字である。
          つぎの字下げ位置とは、現在行のポイントのコラム位置より大きな
          最初の字下げ位置のことである。
          たとえば、テキスト行の白文字以外の最初の文字より左側で、
          その下の行にポイントがあると、
          白文字を挿入してそのコラム位置にポイントを移動する。

          空白でないまえの行に、つぎの字下げ位置（つまり、ポイント位置より
          大きなコラム）がないと、`indent-relative'は、
          （UNINDENTED-OKが`nil'以外であれば）なにもしないか、
          `tab-to-tab-stop'を呼び出す。
          したがって、まえのテキスト行が短くてその行末より右側で、
          その下の行にポイントがあると、このコマンドは、通常どおり、
          白文字を挿入してつぎのタブ位置へポイントを移動する。

          `indent-relative'の戻り値は予測できない。

          つぎの例では、ポイントは2行目の行頭にある。

                           This line is indented twelve spaces.
               -!-The quick brown fox jumped.

          式`(indent-relative nil)'を評価すると、つぎのようになる。

                           This line is indented twelve spaces.
                           -!-The quick brown fox jumped.

          つぎの例では、ポイントは`jumped'の`m'と`p'のあいだにある。

                           This line is indented twelve spaces.
               The quick brown fox jum-!-ped.

          式`(indent-relative nil)'を評価すると、つぎのようになる。

                           This line is indented twelve spaces.
               The quick brown fox jum  -!-ped.

      -- コマンド: indent-relative-maybe
          このコマンドは、引数UNINDENTED-OKに`t'を指定して
          `indent-relative'を呼び出すことで、
          まえの行と同様に字下げする。 戻り値は予測できない。

          空行でないまえの行に現在のコラム位置を越える字下げ位置がなければ、
          このコマンドはなにもしない。


File: elisp-ja,  Node: Indent Tabs,  Next: Motion by Indent,  Prev: Relative Indent,  Up: Indentation

31.17.5 調整可能な『タブストップ』
-----------------------------------------------

     本節では、ユーザー指定の『タブストップ』の機構と、
それを使ったり設定するための機構について説明します。
『タブストップ』という名前を使うのは、
この機構がタイプライタのタブストップに似た機能だからです。
この機能は、適切な個数の空白とタブ文字を挿入して
つぎのタブストップのコラムへ到達しますが、
バッファ内のタブ文字の表示に影響することはありません （*note Usual
Display::）。 テキスト（text）モードなどの少数のメジャーモードでのみ、
入力としての文字<TAB>がこのタブストップ機能を使います。

      -- コマンド: tab-to-tab-stop
          このコマンドは、`tab-stop-list'で定義されたつぎのタブストップコラムまで、
          ポイントのまえに空白やタブを挿入する。
          このリストで現在のコラム番号より大きな要素を探し、
          その要素を字下げ位置のコラムとして使う。
          そのような要素がなければ、このコマンドはないもしない。

      -- User Option: tab-stop-list
          この変数は、`tab-to-tab-stops'が使うタブストップコラムのリストである。
          それらの要素は、昇順の整数であること。
          タブストップコラムの間隔は、等間隔である必要はない。

          タブストップを対話的に編集するには`M-x edit-tab-stops'を使う。


File: elisp-ja,  Node: Motion by Indent,  Prev: Indent Tabs,  Up: Indentation

31.17.6 字下げに基づく移動コマンド
-----------------------------------------------

     これらのコマンドは、主に対話的に使うもので、
テキストの字下げに基づいて動作します。

      -- コマンド: back-to-indentation
          このコマンドは、現在行（ポイントが位置する行）の
          白文字でない最初の文字へポイントを移動する。 `nil'を返す。

      -- コマンド: backward-to-indentation arg
          このコマンドは、ARG行だけポイントを後方へ移動してから、
          当該行の白文字でない最初の文字へポイントを移動する。
          `nil'を返す。

      -- コマンド: forward-to-indentation arg
          このコマンドは、ARG行だけポイントを前方へ移動してから、
          当該行の白文字でない最初の文字へポイントを移動する。
          `nil'を返す。


File: elisp-ja,  Node: Case Changes,  Next: Text Properties,  Prev: Indentation,  Up: Text

31.18 大文字小文字の変更
=================================

     ここに述べる大文字小文字の変更コマンドは、
カレントバッファのテキストに作用します。
文字列や文字の大文字小文字を変換する関数については、 *Note Case
Conversion::。
どの文字が大文字でどの文字が小文字であり、それらをどのように変換するかを
カスタマイズする方法については、*Note Case Tables::。

      -- コマンド: capitalize-region start end
          この関数は、STARTとENDで定義される領域内の
          すべての単語をキャピタライズ（大文字で始まるように）する。
          つまり、各単語の最初の文字を大文字に、残りの文字を小文字に変換する。
          この関数は`nil'を返す。

          領域の端が単語の途中にあると、
          その単語の領域内の部分を1つの単語とみなす。

          `capitalize-region'を対話的に呼び出すと、
          STARTとENDはポイントとマークであり、小さいほうがさきにくる。

               ---------- Buffer: foo ----------
               This is the contents of the 5th foo.
               ---------- Buffer: foo ----------

               (capitalize-region 1 44)
               => nil

               ---------- Buffer: foo ----------
               This Is The Contents Of The 5th Foo.
               ---------- Buffer: foo ----------

      -- コマンド: downcase-region start end
          この関数は、STARTとENDで定義される領域内の
          すべての文字を小文字に変換する。 この関数は`nil'を返す。

          `downcase-region'を対話的に呼び出すと、
          STARTとENDはポイントとマークであり、小さいほうが先にくる。

      -- コマンド: upcase-region start end
          この関数は、STARTとENDで定義される領域内の
          すべての文字を大文字に変換する。 この関数は`nil'を返す。

          `upcase-region'を対話的に呼び出すと、
          STARTとENDはポイントとマークであり、小さいほうが先にくる。

      -- コマンド: capitalize-word count
          この関数は、ポイントのうしろのCOUNT個の単語を
          キャピタライズ（大文字で始まるように）し、ポイントをそれらの末尾に移動する。
          つまり、各単語の最初の文字を大文字に、残りの文字を小文字に変換する。
          COUNTが負であると、まえの-COUNT個の単語を
          大文字で始まるようにするが、ポイントは移動しない。
          値は`nil'である。

          ポイントが単語の途中にあると、単語を前方へ移動するときには
          ポイントよりまえにある単語の部分を無視する。
          単語の残りの部分を1つの単語として扱う。

          `capitalize-word'を対話的に呼び出すと、
          COUNTは数値前置引数である。

      -- コマンド: downcase-word count
          この関数は、ポイントのうしろのCOUNT個の単語を
          すべて小文字に替え、ポイントをそれらの末尾に移動する。
          COUNTが負であると、まえの-COUNT個の単語を
          変換するが、ポイントは移動しない。 値は`nil'である。

          `downcase-word'を対話的に呼び出すと、
          COUNTは数値前置引数である。

      -- コマンド: upcase-word count
          この関数は、ポイントのうしろのCOUNT個の単語を
          すべて大文字に替え、ポイントをそれらの末尾に移動する。
          COUNTが負であると、まえの-COUNT個の単語を
          変換するが、ポイントは移動しない。 値は`nil'である。

          `upcase-word'を対話的に呼び出すと、
          COUNTは数値前置引数である。


File: elisp-ja,  Node: Text Properties,  Next: Substitution,  Prev: Case Changes,  Up: Text

31.19 テキスト属性
========================

     シンボルの属性リスト（*note Property Lists::）のように、
バッファや文字列の各文字には"テキスト属性リスト" （text property
list）を持てます。 この属性は、（本節の原文のタイトルの）文字`T'や
`foo'の最初の`o'のような特定の箇所の特定の文字に属します。
同じ文字が異なる箇所に現れるとき、
一般にはそれぞれに異なる属性を持てます。

        各属性には、名前と値があります。
どちらも任意のLispオブジェクトでかまいませんが、
名前は普通はシンボルです。 属性リストを参照する普通の方法では、
名前を指定してそれに対応する値を問い合わせます。

        文字に属性`category'があるとき、
それを文字の"カテゴリ"（category）といいます。
それはシンボルであるべきです。
そのシンボルの属性が、文字の属性のデフォルトとして働きます。

        文字列とバッファのあいだでテキストをコピーすると、
文字とともにその属性も保たれます。
`substring'、`insert'、`buffer-substring'などの
さまざまな関数がそうします。

     * Menu:

     * Examining Properties::	Looking at the properties of one character.
     * Changing Properties::		Setting the properties of a range of text.
     * Property Search::		Searching for where a property changes value.
     * Special Properties::		Particular properties with special meanings.
     * Format Properties::           Properties for representing formatting of text.
     * Sticky Properties::           How inserted text gets properties from
                                       neighboring text.
     * Saving Properties::           Saving text properties in files, and reading
                                       them back.
     * Lazy Properties::             Computing text properties in a lazy fashion
                                       only when text is examined.
     * Clickable Text::              Using text properties to make regions of text
                                       do something when you click on them.
     * Not Intervals::		Why text properties do not use
     				  Lisp-visible text intervals.


File: elisp-ja,  Node: Examining Properties,  Next: Changing Properties,  Up: Text Properties

31.19.1 テキスト属性を調べる
--------------------------------------

     テキスト属性を調べるもっとも簡単な方法は、
特定の文字の特定の属性の値を問い合わせることです。
それには、`get-text-property'を使います。
文字の属性リスト全体を取得するには`text-properties-at'を使います。
複数の文字の属性を一度に調べるための関数については、 *Note Property
Search::。

        これらの関数は、文字列とバッファの両方を扱えます。
文字列内の位置は0から始まり、
バッファ内の位置は1から始まることに注意してください。

      -- Function: get-text-property pos prop &optional object
          この関数は、OBJECT（バッファか文字列）内の位置POSの
          うしろの1文字の属性PROPの値を返す。 引数OBJECTは省略でき、
          デフォルトはカレントバッファである。

          その文字に属性PROPがなくてもシンボルであるカテゴリがあれば、
          `get-text-property'は当該シンボルの属性PROPを返す。

      -- Function: get-char-property pos prop &optional object
          この関数は`get-text-property'に似ているが、
          まずオーバレイを調べてからテキスト属性を調べる。 *note
          Overlays::。

          引数OBJECTは、文字列、バッファ、ウィンドウのいずれかである。
          ウィンドウであると、そのウィンドウに表示しているバッファの
          テキスト属性とオーバレイを対象にするが、
          対象となるオーバレイはそのウィンドウに対して活性なものだけである。
          OBJECTがバッファであると、テキスト属性に加えて
          そのバッファのすべてのオーバレイを対象にする。
          OBJECTが文字列であると、
          文字列にはオーバレイはないので、テキスト属性のみを対象にする。

      -- Function: text-properties-at position &optional object
          この関数は、文字列やバッファであるOBJECT内の
          位置POSITIONにある1文字の属性リスト全体を返す。
          OBJECTが`nil'であると、デフォルトはカレントバッファである。

      -- Variable: default-text-properties
          この変数は、テキスト属性のデフォルト値を与える属性リストを保持する。
          直接的にもカテゴリシンボルを介して間接的にも
          文字に属性の値が指定されていないと、
          このリストに収めた値をかわりに使う。 つぎに例を示す。

               (setq default-text-properties '(foo 69))
               ;; 位置1の文字に属性がないことを保証する
               (set-text-properties 1 2 nil)
               ;; 問い合わせたときに見えるのはデフォルト値である
               (get-text-property 1 'foo)
                    => 69


File: elisp-ja,  Node: Changing Properties,  Next: Property Search,  Prev: Examining Properties,  Up: Text Properties

31.19.2 テキスト属性の変更
-----------------------------------

属性を変更する基本関数は、バッファや文字列の指定した範囲に作用します。
関数`set-text-properties'（本節の最後）は、
その範囲のテキストの属性リスト全体を設定します。
これは、名前で指定した特定の属性のみを追加／変更／削除するのに
しばしば有用です。

        テキスト属性はバッファ（や文字列）の一部分であるとみなされ、
スクリーン上でのバッファの見た目に影響するので、
バッファのテキスト属性を変更すると、
バッファには変更済みの印を付けます。
バッファのテキスト属性の変更もアンドゥ（*note Undo::）できます。

      -- Function: put-text-property start end prop value &optional
               object
          この関数は、文字列やバッファであるOBJECT内の
          STARTとENDのあいだのテキストの属性PROPの値を VALUEとする。
          OBJECTが`nil'であると、デフォルトはカレントバッファである。

      -- Function: add-text-properties start end props &optional object
          この関数は、文字列やバッファであるOBJECT内の
          STARTとENDのあいだのテキストの
          テキスト属性に追加／上書きする。
          OBJECTが`nil'であると、デフォルトはカレントバッファである。

          引数PROPSで追加する属性を指定する。 これは属性リスト（*note
          Property Lists::）の形であること。
          つまり、属性名とその値を交互に並べたリストであること。

          この関数が属性の値をどれか実際に変更したならば、戻り値は`t'である。
          さもなければ（PROPSが`nil'だったり、
          テキスト内の値と同じ値であると）`nil'である。

          たとえば、テキストのある範囲の属性`comment'と`face'を
          設定するにはつぎのようにする。

               (add-text-properties START END
                                    '(comment t face highlight))

      -- Function: remove-text-properties start end props &optional
               object
          この関数は、文字列やバッファであるOBJECT内の
          STARTとENDのあいだのテキストから
          指定したテキスト属性を削除する。
          OBJECTが`nil'であると、デフォルトはカレントバッファである。

          引数PROPSで削除する属性を指定する。 これは属性リスト（*note
          Property Lists::）の形であること。
          つまり、属性名とその値を交互に並べたリストであること。
          ただし、意味があるのは名前のみであり、その値は無視する。
          たとえば、属性`face'を削除するにはつぎのようにする。

               (remove-text-properties START END '(face nil))

          この関数が属性の値をどれか実際に変更したならば、戻り値は`t'である。
          さもなければ（PROPSが`nil'だったり、
          指定したテキスト内の文字にそれらのいずれの属性もなければ）
          `nil'である。

          特定のテキストからすべてのテキスト属性を削除するには、
          新たな属性リストとして`nil'を指定して
          `set-text-properties'を使う。

      -- Function: set-text-properties start end props &optional object
          この関数は、文字列やバッファであるOBJECT内の
          STARTとENDのあいだのテキストのテキスト属性を完全に置き換える。
          OBJECTが`nil'であると、 デフォルトはカレントバッファである。

          引数PROPSは新たな属性リストである。
          これは、属性名とその値を交互に並べたリストであること。

          `set-text-properties'から戻ると、
          指定した範囲のすべての文字は同一の属性を持つことになる。

          PROPSが`nil'であると、
          テキストの指定した範囲からすべての属性を削除する効果がある。
          たとえば、つぎのようにする。

               (set-text-properties START END nil)

        バッファからテキストをコピーするがその属性はコピーしない
関数`buffer-substring-no-properties'（*note Buffer Contents::）も
参照してください。


File: elisp-ja,  Node: Property Search,  Next: Special Properties,  Prev: Changing Properties,  Up: Text Properties

31.19.3 テキスト属性を探す関数
-----------------------------------------

     テキスト属性の典型的な用途では、
ほとんどの場合多くの連続した文字の1つの属性には同じ値があります。
1つずつ文字を調べるようにプログラムするよりは、
同じ属性値を持つテキストの塊を処理するほうがとても速いです。

        このために使える関数をここで説明します。
これらは属性値の比較に`eq'を使います。
OBJECTのデフォルトは、すべての場合でカレントバッファです。

高い効率のためには、これらの関数に引数LIMITを使うことが重要であり、
1つの属性を探す関数には特にあてはまります。
さもないと、読者が望む属性が変更されないような場合、
それらの関数はバッファの末尾まで走査して長い時間を費すことになります。

        これらの関数はポイントを移動しませんが、そのかわりに
位置（あるいは`nil'）を返します。
位置はつねに2つの文字のあいだにあることに注意してください。
これらの関数が返す位置は、異なる属性を持つ2つの文字のあいだです。

      -- Function: next-property-change pos &optional object limit
          この関数は、文字列やバッファであるOBJECT内の位置POSから
          テキスト属性のいずれかが異なるまでテキストを走査し、その変化する位置を返す。
          いいかえれば、POSの直後の文字のテキスト属性とは異なる
          属性を持つPOSのあとにある最初の文字の位置を返す。

          LIMITが`nil'以外であると、LIMITの位置で走査を終える。
          その箇所まで異なる属性がないと、
          `next-property-change'はLIMITを返す。

          LIMITが`nil'でありOBJECTの末尾まで属性に変化がないと、
          値は`nil'である。
          値が`nil'以外であると、それはPOSより大きいか等しい位置である。
          値がPOSに等しいのは、LIMITがPOSに等しい場合のみである。

          バッファからすべての属性が同じであるテキストの塊を
          走査する方法の例をつぎに示す。

               (while (not (eobp))
                 (let ((plist (text-properties-at (point)))
                       (next-change
                        (or (next-property-change (point) (current-buffer))
                            (point-max))))
                   ポイントからNEXT-CHANGEまでのテキストを処理する...
                   (goto-char next-change)))

      -- Function: next-single-property-change pos prop &optional
               object limit
          この関数は、文字列やバッファであるOBJECT内の位置POSから
          属性PROPが異なるまでテキストを走査し、その変化する位置を返す。
          いいかえれば、POSの直後の文字の属性PROPとは異なる
          属性PROPをもつPOSのあとにある最初の文字の位置を返す。

          LIMITが`nil'以外であると、LIMITの位置で走査を終える。
          その箇所まで異なる属性がないと、
          `next-single-property-change'はLIMITを返す。

          LIMITが`nil'でありOBJECTの末尾まで属性に変化がないと、
          値は`nil'である。
          値が`nil'以外であると、それはPOSより大きいか等しい位置である。
          値がPOSに等しいのは、LIMITがPOSに等しい場合のみである。

      -- Function: previous-property-change pos &optional object limit
          これは`next-property-change'と同様であるが、
          前方へではなくPOSから後方へ走査する。
          値が`nil'以外であると、それはPOSより小さいか等しい位置である。
          値がPOSに等しいのは、LIMITがPOSに等しい場合のみである。

      -- Function: previous-single-property-change pos prop &optional
               object limit
          これは`next-single-property-change'と同様であるが、
          前方へではなくPOSから後方へ走査する。
          値が`nil'以外であると、それはPOSより小さいか等しい位置である。
          値がPOSに等しいのは、LIMITがPOSに等しい場合のみである。

      -- Function: next-char-property-change position &optional limit
          これは`next-property-change'と同様であるが、
          テキスト属性に加えてオーバレイも対象にする。
          この関数はカレントバッファにのみ作用するため、
          OBJECTを表す引数はない。
          どちらかの属性が異なるつぎの位置を返す。

      -- Function: previous-char-property-change position &optional
               limit
          これは`next-char-property-change'と同様であるが、
          前方へではなくPOSから後方へ走査する。

      -- Function: text-property-any start end prop value &optional
               object
          STARTとENDのあいだに属性PROPの値がVALUEである
          文字が1つでもあれば、この関数は`nil'以外を返す。
          より正確には、そのような最初の文字の位置を返す。
          さもなければ`nil'を返す。

          省略可能な5番目の引数OBJECTは、走査すべき文字列やバッファを指定する。
          位置はOBJECTに相対である。
          OBJECTのデフォルトはカレントバッファである。

      -- Function: text-property-not-all start end prop value &optional
               object
          STARTとENDのあいだに属性PROPの値がVALUEでない
          文字が1つでもあれば、この関数は`nil'以外を返す。
          より正確には、そのような最初の文字の位置を返す。
          さもなければ`nil'を返す。

          省略可能な5番目の引数OBJECTは、走査すべき文字列やバッファを指定する。
          位置はOBJECTに相対である。
          OBJECTのデフォルトはカレントバッファである。


File: elisp-ja,  Node: Special Properties,  Next: Format Properties,  Prev: Property Search,  Up: Text Properties

31.19.4 特別な意味を持つ属性
--------------------------------------

     特別な組み込みの意味を持つテキスト属性名の一覧を以下に示します。
以降の節では、詰め込みや属性の継承を制御する特別な属性名も示します。
それ以外の名前には標準的な意味はないので、
読者はそれらを好きなように使ってかまいません。

    `category'
          文字に属性`category'があるとき、
          これを文字の"カテゴリ"（category）と呼ぶ。
          これはシンボルであること。
          そのシンボルの属性が、文字の属性のデフォルトとして働く。

    `face'
          テキストのフォントと表示色を制御するために属性`face'を使う。
          その値はフェイス名かフェイス名のリストである。
          詳しくは、*note Faces::。

          属性値がリストであると、その要素は、 `(foreground-color .
          COLOR-NAME)'や `(background-color . COLOR-NAME)'の形でもよい。
          これらの要素は、前景色だけや背景色だけを指定する。
          したがって、使用する各色を表すフェイスを作成する必要はない。

          テキストの内容に基づいて属性`face'を自動的に更新する方法に関しては、
          *note Font Lock Mode::。

    `mouse-face'
          マウスが文字の上やその近くにあると、属性`face'のかわりに
          属性`mouse-face'が使われる。 この目的において『近く』とは、
          文字とマウスの位置のあいだの
          属性`mouse-face'の値が同じであるすべてのテキストである。

    `local-map'
          属性`local-map'を用いることで、
          バッファ内のテキストの一部分に対して別のキーマップを指定できる。
          ポイントのうしろの文字のこの属性の値が`nil'以外であると、
          バッファのローカルマップのかわりにその値をキー探索に使う。
          属性値がシンボルであると、シンボルの関数定義をキーマップとして使う。
          *note Active Keymaps::。

    `syntax-table'
          属性`syntax-table'は、構文テーブルがこの文字に指定するものに優先する。
          *note Syntax Properties::。

    `read-only'
          文字に属性`read-only'があると、その文字を変更できない。
          変更するどのようなコマンドもエラーになる。

          挿入されるテキストがスティッキ性のために属性`read-only'を
          継承する場合には、読み出し専用文字のつぎにテキストを挿入するとエラーになる。
          したがって、スティッキ性を制御することで、
          読み出し専用テキストのつぎへのテキスト挿入を許すかどうかを制御できる。
          *note Sticky Properties::。

          属性を変更するとバッファを変更したとみなすため、
          特別なトリックを知らない限り、属性を`read-only'を削除できない。
          つまり、`inhibit-read-only'に`nil'以外の値を束縛して、
          属性を削除する。 *note Read Only Buffers::。

    `invisible'
          属性`invisible'が`nil'以外であると、
          その文字はスクリーンに表示されない。 詳しくは、*note
          Invisible Text::。

    `intangible'
          連続する文字に属性`intangible'の`nil'でない同じ値があると、
          それらのあいだにポイントを置けなくなる。
          前方に向けてこれらの文字の中にポイントを移動しようとすると、
          ポイントは実際にはそれらの末尾へ移動する。
          後方に向けてこれらの文字の中にポイントを移動しようとすると、
          ポイントは実際にはそれらの先頭へ移動する。

          変数`inhibit-point-motion-hooks'が`nil'以外であると、
          属性`intangible'は無視される。

    `modification-hooks'
          文字に属性`modification-hooks'がある場合、それは関数のリストであること。
          その文字の変更にはそれらの関数すべてが呼び出される。
          各関数は2つの引数、つまり、バッファの変更対象部分の先頭と末尾を受け取る。
          1つの操作で変更される一連の文字に同じ変更フック関数が現れる場合、
          関数が実際に何回呼ばれるか予測できないことに注意してほしい。

    `insert-in-front-hooks'
    `insert-behind-hooks'
          バッファにテキストを挿入する操作でも、
          挿入箇所のうしろの文字の属性`insert-in-front-hooks'と
          まえの文字の属性`insert-behind-hooks'に指定されている
          関数群を呼び出す。
          これらの関数は2つの引数、つまり、挿入されたテキストの先頭と末尾を受け取る。
          これらの関数が呼ばれるのは、実際の挿入操作を_終えてから_である。

          バッファ内のテキストを変更するときに呼び出される他のフックについては、
          *note Change Hooks::も参照。

    `point-entered'
    `point-left'
          特別な属性`point-entered'と`point-left'は、
          ポイント移動を報告するフック関数を保持する。
          ポイントが動くたびに、Emacsはこれらの2つの属性値、つまり、

             * 移動前のポイントのうしろの文字の属性`point-left'と

             * 移動後のポイントのうしろの文字の属性`point-entered'

          を比較する。 これら2つの値が異なれば、
          ポイントの古い値と新しい値の2つの引数で（`nil'でなければ）
          それぞれを呼び出す。

          同じことを移動前後のポイントのまえの文字についても行う。
          その結果、（同じかもしれない）`point-left'の関数を2回、かつ／あるいは、
          （同じかもしれない）`point-entered'の関数を2回実行する。
          いずれにしても、`point-left'の関数が最初に呼ばれ、
          そのあとで`point-entered'の関数が呼ばれる。

          これらの関数では、`char-after'を使って
          ポイントを移動せずにさまざまな箇所の文字を調べられる。
          ポイントの値が実際に変わったときにのみ、これらのフック関数が実行される。

      -- Variable: inhibit-point-motion-hooks
          この変数が`nil'以外であると、
          `point-left'と`point-entered'のフック関数は実行されなくなり、
          属性`intangible'の効果もなくなる。
          この変数はグローバルに設定せずに、`let'で束縛すること。


File: elisp-ja,  Node: Format Properties,  Next: Sticky Properties,  Prev: Special Properties,  Up: Text Properties

31.19.5 整形済みテキストの属性
-----------------------------------------

     これらのテキスト属性は、詰め込みコマンドのふるまいに影響します。
これらは整形済みのテキストを表現するために使われます。 *note
Filling::と*Note Margins::。

    `hard'
          改行文字にこの属性があると、『ハード』改行である。
          詰め込みコマンドは『ハード』改行を変更せず、
          それらをまたがって単語を移動しない。
          しかし、この属性は`use-hard-newlines'が
          `nil'以外の場合にのみ効果を持つ。

    `right-margin'
          テキストのこの部分を詰め込むための余分な右端余白を指定する。

    `left-margin'
          テキストのこの部分を詰め込むための余分な左端余白を指定する。

    `justification'
          テキストのこの部分を詰め込むための幅揃えスタイルを指定する。


File: elisp-ja,  Node: Sticky Properties,  Next: Saving Properties,  Prev: Format Properties,  Up: Text Properties

31.19.6 テキスト属性のスティッキ性
-----------------------------------------------

     自己挿入文字は、通常、先行する文字と同じ属性を持ちます。
これを属性の"継承"（inheritance）と呼びます。

        Lispプログラムでは、挿入基本関数を選べば、
継承して挿入したり継承せずに挿入できます。
`insert'などの普通のテキスト挿入関数は、 いかなる属性も継承しません。
これらは、挿入する文字列の属性をそのまま持ったテキストを挿入し、
それ以外の属性はありません。
キルリングなどのある文脈から別の文脈へテキストをコピーするプログラムには、
これは正しい動作です。
継承して挿入するには、本節で述べる特別な基本関数を使います。
自己挿入文字はこれらの基本関数を使っているので、属性を継承します。

        継承して挿入するとき、_どの_属性を継承するかは、
2つの特別な属性`front-sticky'と`rear-nonsticky'に依存します。

文字のうしろに挿入すると、その文字の"後続スティッキ"（rear-sticky）
である属性を継承します。
文字のまえに挿入すると、その文字の"先行スティッキ"（front-sticky）
である属性を継承します。
デフォルトでは、テキスト属性は先行スティッキではなく後続スティッキです。
したがって、デフォルトでは、まえの文字のすべての属性を継承して、
うしろの文字からはなにも継承しません。
特定の属性のスティッキ性を指定することで、異なるふるまいを指定できます。

        文字の属性`front-sticky'が`t'であると、
その文字のすべての属性は先行スティッキです。
属性`front-sticky'がリストであると、
リストに現れる名前のその文字の属性は先行スティッキです。
たとえば、文字の属性`front-sticky'の値が`(face read-only)'であると、
この文字のまえに挿入するとこの文字の属性`face'と`read-only'を
継承しますが、それ以外には継承しません。

        `rear-nonsticky'は反対の働きをします。
すべての属性はデフォルトでは後続スティッキですから、
属性`rear-nonsticky'はどの属性が 後続スティッキで_ない_かを指定します。
文字の属性`rear-nonsticky'が`t'であると、
その文字には後続スティッキである属性はありません。
属性`rear-nonsticky'がリストであると、 リストに名前が現れ_ない限り_、
属性は後続スティッキです。

        継承するようにテキストを挿入すると、
まえの文字からは後続スティッキであるすべての属性を継承し、
うしろの文字からは先行スティッキであるすべての属性を継承します。
両側の文字に異なるスティッキ性の同じ属性がある場合には、
まえの文字の属性が優先します。

        属性を継承してテキストを挿入する関数はつぎのとおりです。

      -- Function: insert-and-inherit &rest strings
          関数`insert'と同様に文字列STRINGSを挿入するが、
          前後のテキストから任意のスティッキ性の属性を継承する。

      -- Function: insert-before-markers-and-inherit &rest strings
          関数`insert-before-markers'と同様に文字列STRINGSを挿入するが、
          前後のテキストから任意のスティッキ性の属性を継承する。

        継承しない普通の挿入関数については、*Note Insertion::。


File: elisp-ja,  Node: Saving Properties,  Next: Lazy Properties,  Prev: Sticky Properties,  Up: Text Properties

31.19.7 テキスト属性をファイルへ保存する
--------------------------------------------------------

     つぎの2つのフックを使って、
テキスト属性を（テキストそのものとともに）ファイルに保存しておき、
ファイルを訪問したり挿入するときに同じテキスト属性を復元できます。

      -- Variable: write-region-annotate-functions
          この変数の値は、ファイルへ書き込むテキストに対する注記の形で
          テキスト属性を符号化するために`write-region'が呼び出す関数の
          リストである。 *note Writing to Files::。

          リスト内の各関数は2つの引数、つまり、
          書き込む領域の先頭と末尾で呼び出される。
          これらの関数はバッファの内容を変更しないこと。
          そのかわりに、バッファのテキストに加えてファイルに書き込むべき
          注記を表すリストを返すべきである。

          各関数は、`(POSITION . STRING)'の形の要素から成る
          リストを返すべきである。
          ここで、POSITIONは書き込まれるテキスト内の相対位置を指定する整数、
          STRINGはそこへ追加する注記である。

          これらの関数が返す各リストは、POSITIONの昇順になっている必要がある。
          複数の関数があると、`write-region'は
          リストを破壊的に併合して1つのソートしたリストにする。

          `write-region'がバッファからファイルにテキストを実際に書くときに、
          指定された注記を対応する位置に混在させる。
          バッファを変更せずにこれらすべてを行う。

      -- Variable: after-insert-file-functions
          この変数は、`insert-file-contents'がファイルの内容を挿入してから
          呼び出す関数のリストを保持する。
          これらの関数は挿入されたテキストで注記を走査し、
          それらが表すテキスト属性にそれらを変換する。

          各関数は1つの引数、つまり、挿入されたテキストの長さで呼ばれ、
          ポイントは挿入されたテキストの先頭を表す。
          関数は当該テキストで注記を走査して注記を削除し、
          注記が指定するテキスト属性を作成する。
          関数は、変更を反映した挿入されたテキストの更新された長さを返すこと。
          関数が返した値がつぎの関数の引数になる。

          これらの関数は、挿入されたテキストの先頭にポイントをつねに戻すこと。

          `after-insert-file-functions'の意図された用途は、
          テキスト表現の注記を実際のテキスト属性に変換することである。
          しかし、別の使い方も可能である。

        これらのフックを使ってファイルにテキスト属性を保存したり復元する
Lispプログラムを書いて、さまざまなデータ書式を試して
よいものをみつけるようにお願いします。
最終的には、Emacsに取り込める良質で汎用の拡張を
ユーザーが作り出すことを願っています。

        テキスト属性の名前や値として任意のLispオブジェクトを
処理しないように忠告しておきます。
そのような汎用のプログラムは書くのが難しく動作が遅くなりがちです。
そのかわりに、適当に柔軟性があり符号化が難しくないデータ型の集合を選びます。

        関連する機能については、*Note Format Conversion::。


File: elisp-ja,  Node: Lazy Properties,  Next: Clickable Text,  Prev: Saving Properties,  Up: Text Properties

31.19.8 テキスト属性の遅延計算
-----------------------------------------

     バッファ内のすべてのテキストのテキスト属性を計算するかわりに、
必要になった時点でテキストの一部分のテキスト属性を計算するようにできます。

        バッファからテキスト属性とともにテキストを取り出す基本関数は、
`buffer-substring'です。
属性を調べるまえに、この関数はアブノーマルフック
`buffer-access-fontify-functions'を実行します。

      -- Variable: buffer-access-fontify-functions
          この変数は、テキスト属性を計算する関数のリストを保持する。
          `buffer-substring'がバッファの一部分からテキストとテキスト属性を
          コピーするまえに、この関数はこのリスト内の関数すべてを呼び出す。
          各関数は、バッファの参照される範囲を指定する2つの引数を受け取る。
          （バッファはつねにカレントバッファである。）

        関数`buffer-substring-no-properties'は
テキスト属性を無視するので、これらの関数を呼び出しません。

バッファの同じ部分に対してフック関数が複数回呼び出されるのを防ぐには、
変数`buffer-access-fontified-property'を使います。

      -- Variable: buffer-access-fontified-property
          この変数の値が`nil'以外であると、
          それはテキスト属性の名前として使われるシンボルである。
          そのテキスト属性に対する`nil'以外の値は、
          『この文字の他のテキスト属性はすでに計算済みである』ことを意味する。

          `buffer-substring'に指定された範囲のすべての文字において、
          この属性に対して`nil'以外の値があると、 `buffer-substring'は
          `buffer-access-fontify-functions'の関数を呼び出さない。
          それらの文字にはすでに正しいテキスト属性があるとみなし、
          それらにすでにある属性をコピーする。

          この機能を使う普通の方法は、
          `buffer-access-fontify-functions'の関数が
          他の属性ととともにこの属性をそれらが操作した文字に追加する。
          そうすれば、同じテキストに対して何回も呼び出されるのを防ぐことができる。


File: elisp-ja,  Node: Clickable Text,  Next: Not Intervals,  Prev: Lazy Properties,  Up: Text Properties

31.19.9 クリック可能なテキストを定義する
--------------------------------------------------------

     バッファ内に"クリック可能なテキスト"（clickable
text）を設定するには 2つの方法があります。
これは典型的には2つの部分から成ります。
つまり、マウスが重なるとテキストを強調表示し、
テキストのその部分をクリックすると
マウスボタンがなんらかの処理を行うようにします。

        強調表示はテキスト属性`mouse-face'で行います。
diredでの方法を例として示します。

          (condition-case nil
              (if (dired-move-to-filename)
                  (put-text-property (point)
                                     (save-excursion
                                       (dired-move-to-end-of-filename)
                                       (point))
                                     'mouse-face 'highlight))
            (error nil))

     `put-text-property'の最初の2つの引数は、
テキストの先頭と末尾を指定します。

        このテキストをクリックしたときにマウスになにかをさせるようにする
普通の方法は、メジャーモードのキーマップで`mouse-2'を定義することです。
クリック可能なテキストをクリックしたかどうかの検査は、
コマンド定義で行われます。 diredではつぎのようにしています。

          (defun dired-mouse-find-file-other-window (event)
            "In dired, visit the file or directory name you click on."
            (interactive "e")
            (let (file)
              (save-excursion
                (set-buffer (window-buffer (posn-window (event-end event))))
                (save-excursion
                  (goto-char (posn-point (event-end event)))
                  (setq file (dired-get-filename))))
              (select-window (posn-window (event-end event)))
              (find-file-other-window (file-name-sans-versions file t))))

     外側の`save-excursion'は、カレントバッファが変わることを防ぎます。
内側のは、クリックしたバッファのポイントを恒久的に変更することを防ぎます。
この例では、diredは関数`dired-get-filename'を用いて、
イベントの位置に基づいて訪問すべきファイルを決定します。

        メジャーモードのマウスコマンドを定義するかわりに、
テキスト属性`local-map'を使って、
クリック可能なテキストそのものにキーバインディングを定義することもできます。

          (let ((map (make-sparse-keymap)))
            (define-key-binding map [mouse-2] 'operate-this-button)
            (put-text-property (point)
                               (save-excursion
                                 (dired-move-to-end-of-filename)
                                 (point))
                               'local-map map))

     この方法では、テキストのさまざまなクリック可能な部分に
異なるコマンドを定義できます。 さらに、バッファの残りの部分に対しては、
メジャーモードの定義（やグローバルな定義）がそのまま有効です。


File: elisp-ja,  Node: Not Intervals,  Prev: Clickable Text,  Up: Text Properties

31.19.10 テキスト属性が範囲でない理由
---------------------------------------------------

     バッファ内のテキストに属性を付加できるエディタのなかには、
ユーザーにテキスト内の『範囲』を指定させ、
その範囲に属性を付加するものがあります。
このようなエディタでは、ユーザーやプログラマが
個々の範囲の先頭と末尾を決定できます。
テキスト変更に伴うある種の矛盾するようなふるまいを避けるために、
熟考の結果Emacs
Lispでは別の種類のインターフェイスを提供することにしました。

        複数の範囲に細分することが意味を持つならば、
ある属性の1つの範囲があるだけのバッファと、
その同じテキストをその同じ属性の2つの範囲にしてあるバッファとを
区別できるはずです。

1つの範囲だけを持つバッファにおいて、そのテキストの一部をキルしたとします。
バッファに残っているテキストは1つの範囲であり、
キルリング（とアンドゥリスト）内のコピーは1つの別の範囲になります。
そしてキルされたテキストをヤンクして戻すと、
同じ属性を持つ2つの範囲ができます。
つまり、編集すると、1つの範囲と2つの範囲の区別を保存できなくなります。

        テキストを挿入すると2つの範囲を融合することで
この問題を『修正』したとします。
バッファにもともと1つの範囲しかなければ、うまくいきます。
しかし、同じ属性の範囲が連続して2つある場合に、
一方の範囲をキルしてからヤンクして戻したとします。
別の場面では救いになる同じ属性の範囲を融合する機能が、
ここではトラブルを引き起こします。
つまり、ヤンクすると1つの範囲になってしまいます。
ここでも、編集すると、1つの範囲と2つの範囲の区別を保存できなくなります。

        2つの範囲の境界にテキストを挿入する場合でも、
満足できる解決方法がない問題を提起します。

        しかし、『この文字の属性はなにか』といった形の問いに対して
一貫したふるまいをするような編集にするのは簡単です。
そのために、これらが唯一の意味ある問いかけであると判断したのです。
範囲の先頭と末尾を問うようなものは実装してありません。

        実用上は、明示的な範囲の境界のかわりに、
テキスト属性を探索する関数を普通は使えます。
それらの関数は、可能な場合にはつねに範囲は融合されると仮定して
範囲の境界を探すと考えることができます。 *Note Property Search::。

        Emacsには表示機能として明示的な範囲もあります。 *note
Overlays::を参照してください。


File: elisp-ja,  Node: Substitution,  Next: Transposition,  Prev: Text Properties,  Up: Text

31.20 文字コードの置換
==============================

つぎの関数は、指定した領域内の文字をそれらの文字コードに基づいて置き換えます。

      -- Function: subst-char-in-region start end old-char new-char
               &optional noundo
          この関数は、カレントバッファのSTARTとENDで定義される領域の
          すべての文字OLD-CHARを文字NEW-CHARに置き換える。

          NOUNDOが`nil'以外であると、
          `subst-char-in-region'はアンドゥ用の変更を記録せず、
          バッファに変更済みの印も付けない。
          この機能は、選択表示（*note Selective
          Display::）の制御に使われている。

          `subst-char-in-region'はポイントを移動せず、 `nil'を返す。

               ---------- Buffer: foo ----------
               This is the contents of the buffer before.
               ---------- Buffer: foo ----------

               (subst-char-in-region 1 20 ?i ?X)
                    => nil

               ---------- Buffer: foo ----------
               ThXs Xs the contents of the buffer before.
               ---------- Buffer: foo ----------

      -- Function: translate-region start end table
          この関数は、バッファのSTARTとENDのあいだの文字に変換表を適用する。

          変換表TABLEは文字列であり、 `(aref TABLE OCHAR)'は、
          OCHARに対応する変換した文字を与える。
          TABLEの長さが256未満であると、
          TABLEの長さより大きなコードの文字は変換によっては変更されない。

          `translate-region'の戻り値は、
          変換によって実際に変更した文字の個数を返す。
          これには、変換表で自分自身に変換された文字は数えない。


File: elisp-ja,  Node: Registers,  Next: Change Hooks,  Prev: Transposition,  Up: Text

31.21 レジスタ
==================

レジスタは、Emacsの編集においてさまざまな種類の値を保持できる変数の一種です。
各レジスタには1文字の名前が付いています。
すべてのASCII文字とそれらのメタ変種（ただし`C-g'を除く）を
レジスタの名前に使えます。 したがって、255個のレジスタを使えます。
Emacs Lispでは、レジスタ名でレジスタを区別します。

      -- Variable: register-alist
          この変数は、`(NAME . CONTENTS)'の形の要素の連想リストである。
          通常、使用中のEmacsの各レジスタに対して1つの要素がある。

          オブジェクトNAMEは、レジスタを識別する文字（整数）である。

        レジスタの内容（CONTENTS）に可能な型はいくつかあります。

    数
          数そのものを表す。
          `insert-register'がレジスタ内で数をみつけると10進数に変換する。

    マーカ
          マーカはジャンプ先のバッファ内位置を表す。

    文字列
          文字列はレジスタに保存されたテキストである。

    矩形領域
          矩形領域は文字列のリストで表現される。

    `(WINDOW-CONFIGURATION POSITION)'
          これは、1つのフレームに復元するウィンドウ構成と
          カレントバッファでのポイントの移動先を表す。

    `(FRAME-CONFIGURATION POSITION)'
          これは、復元するフレーム構成とカレントバッファでのポイントの移動先を表す。

    (file FILENAME)
          訪問すべきファイルを表す。
          この値にジャンプするとファイルFILENAMEを訪問する。

    (file-query FILENAME POSITION)
          これは、訪問すべきファイルとその中での位置を表す。
          この値にジャンプするとファイルFILENAMEを訪問し
          バッファ内位置POSITIONへ移動する。
          この種の位置を復元すると、まずユーザーに確認を取る。

        本節の関数は、明記してない場合には予測できない値を返します。

      -- Function: get-register reg
          この関数は、レジスタREGの内容、
          あるいは、内容がなければ`nil'を返す。

      -- Function: set-register reg value
          この関数は、レジスタREGの内容をVALUEとする。
          レジスタには任意の値を設定できるが、他のレジスタ関数は
          特定のデータ型を期待する。 戻り値はVALUEである。

      -- コマンド: view-register reg
          このコマンドは、レジスタREGになにが入っているかを表示する。

      -- コマンド: insert-register reg &optional beforep
          このコマンドはレジスタREGの内容をカレントバッファに挿入する。

          通常、このコマンドは挿入したテキストのまえにポイントを置き、
          そのあとにマークを置く。
          しかし、省略可能な2番目の引数BEFOREPが`nil'以外であると、
          まえにマークを置きあとにポイントを置く。
          この関数を対話的に呼び出すときに前置引数を指定すれば、
          2番目の引数BEFOREPに`nil'以外を渡せる。

          レジスタに矩形領域が含まれる場合、
          ポイント位置に矩形領域の左上隅がくるように挿入される。
          つまり、テキストは現在行とそのしたの連続する行に挿入される。

          保存したテキスト（文字列）や矩形領域（リスト）以外がレジスタに入っていると、
          現状では有用なことは起こらない。
          将来これは変更されるであろう。


File: elisp-ja,  Node: Transposition,  Next: Registers,  Prev: Substitution,  Up: Text

31.22 テキストの転置
===========================

     つぎのサブルーティンは転置コマンドで使われます。

      -- Function: transpose-regions start1 end1 start2 end2 &optional
               leave-markers
          この関数は、バッファの重なり合わない2つの部分を入れ換える。
          引数START1とEND1で一方の部分の境界を指定し、
          引数START2とEND2で他方の部分の境界を指定する。

          通常、`transpose-regions'は転置したテキスト内のマーカを再配置する。
          つまり、2つの転置部分の一方の内側を指していたマーカは
          その部分とともに移動して、新しい位置で同じ2つの文字のあいだに留まる。
          しかし、LEAVE-MARKERSが`nil'以外であると、
          `transpose-regions'はこれを行わず、
          すべてのマーカは再配置されない。


File: elisp-ja,  Node: Change Hooks,  Prev: Registers,  Up: Text

31.23 変更フック
=====================

     これらのフックにより、すべてのバッファ
（それらをバッファローカルにしておけば特定のバッファ）における
すべての変更を知るようにできます。
テキストの特定部分の変更を検出する方法については、 *note Special
Properties::も参照してください。

        これらのフックに使う関数において正規表現を使う場合には、
マッチデータを保存し復元する必要があります。
さもないと、それらを呼び出す編集操作と奇妙な干渉を引き起こします。

      -- Variable: before-change-functions
          この変数は、バッファを変更するまえに呼び出すべき関数のリストを保持する。
          各関数は2つの引数、つまり、整数で表した変更対象の領域の先頭と末尾を受け取る。
          変更対象のバッファはつねにカレントバッファである。

      -- Variable: after-change-functions
          この変数は、バッファを変更したあとに呼び出すべき関数のリストを保持する。
          各関数は3つの引数、つまり、変更されたばかりの領域の先頭と末尾、
          変更前に存在していたテキストの長さを受け取る。
          3つの引数はすべて整数である。
          変更対象のバッファはつねにカレントバッファである。

          古いテキストの長さは、変更前のそのテキストの先頭と末尾の
          バッファ内位置の差である。
          変更済みのテキストの長さは、単純に始めの2つの引数の差である。

      -- Macro: combine-after-change-calls body...
          このマクロは通常どおりBODYを実行するが、
          一連の変更に対して安全と思えるときには、
          `after-change-functions'の関数を一度だけ呼び出す。

          プログラムからバッファの同じ部分でテキスト変更を複数回行う場合、
          プログラムの当該部分の周りでマクロ`combine-after-change-calls'を使うと、
          フック`after-change-functions'を使用してるときには
          動作がかなり速くなりうる。
          最終的にフック`after-change-functions'が呼ばれると、
          `combine-after-change-calls'の本体で行った変更すべてを含むような
          バッファ部分が引数に指定される。

          *警告：*` '
          フォーム`combine-after-change-calls'の本体の内側では
          `after-change-functions'と`after-change-function'の値を
          変更しないこと。

          *注意：*` '
          変更がバッファの広く分散した部分に行われるときにもこれは動作するが、
          推奨できない。
          非効率なふるまいをするようなフック関数があるからである。

      -- Variable: before-change-function
          この廃れた変数は、任意のバッファの変更を行うまえに
          呼ばれる1つの関数を保持する
          （`nil'ならばそのような関数はなし）。
          `before-change-functions'の関数と同様に呼ばれる。

      -- Variable: after-change-function
          この廃れた変数は、任意のバッファの変更を行ったあとに
          呼ばれる1つの関数を保持する
          （`nil'ならばそのような関数はなし）。
          `after-change-functions'の関数と同様に呼ばれる。

上の4つの変数は、これらの関数が実行中には一時的に`nil'に束縛されます。
つまり、これらの関数の1つがバッファを変更しても、
その変更ではこれらの関数を呼び出しません。
フック関数においてこれらの関数を実行するような変更を行いたい場合には、
フック関数でこれらの変数をそれらの通常の値に束縛し直します。

        この保護的な機構の1つの不便な帰結は、
`after-change-functions'や`before-change-functions'には、
その変数の値を変更する関数を持てないことです。
しかし、これは本当の制限ではありません。
それらの関数で実行すべき関数のリストを変更したければ、
単純に1つの定まった関数をフックに追加し、
その関数では呼び出すべき別の関数を指定する別の変数を調べます。
つぎのようにします。

          (setq my-own-after-change-functions nil)
          (defun indirect-after-change-function (beg end len)
            (let ((list my-own-after-change-functions))
              (while list
                (funcall (car list) beg end len)
                (setq list (cdr list)))))

          (add-hooks 'after-change-functions
                     'indirect-after-change-function)

      -- Variable: first-change-hook
          この変数は、未変更状態のバッファを変更するたびに実行される
          ノーマルフックである。



File: elisp-ja,  Node: Non-ASCII Characters,  Next: Searching and Matching,  Prev: Text,  Up: Top

32 非ASCII文字
*****************

     本章では、非ASCIIに関連する特別なことがらと
それらが文字列やバッファにどのように保存されるかについて述べます。

     * Menu:

     * Text Representations::
     * Converting Representations::
     * Selecting a Representation::
     * Character Codes::
     * Character Sets::
     * Chars and Bytes::
     * Splitting Characters::
     * Scanning Charsets::
     * Translation of Characters::
     * Coding Systems::
     * Input Methods::


File: elisp-ja,  Node: Text Representations,  Next: Converting Representations,  Up: Non-ASCII Characters

32.1 テキスト表現
=======================

     Emacsには2つの"テキスト表現"、つまり、
文字列やバッファでテキストを表す方法が2つあります。
これらは、"ユニバイト"（unibyte）と
"マルチバイト"（multibyte）と呼ばれます。
各文字列や各バッファでは、これらの2つの表現の一方を使います。
ほとんどの目的には、Emacsがこれらのあいだで適切に変換するので、
読者はこれらの表現に関しては無視できます。
Lispプログラムでは、これらの違いに注意する必要がしばしばあります。

        ユニバイト表現では、各文字は1バイトを占め、
そのため、可能な文字コードの範囲は0から255です。
コード0から127はASCII文字です。 コード128から255は非ASCII文字集合の1つ
（変数`nonascii-insert-offset'に設定して文字集合を選べる）
に使われます。

        マルチバイト表現では、1文字は1バイト以上を占め、
そのため、Emacsの文字コードの範囲全体を格納できるのです。
マルチバイト文字の最初のバイトはつねに128から159（8進数で0200から0237）の
範囲にあります。 これらの値を"リーディングコード"（leading
code）と呼びます。
マルチバイト文字の2バイト以降はつねに160から255（8進数で0240から0377）の
範囲にあります。 これらの値を"トレイリングコード"（trailing
code）と呼びます。

        バッファでは、変数`enable-multibyte-characters'の
バッファローカルな値が使用する表現を指定します。
文字列の表現は、文字列を作成するときの文字列の内容に基づいて決定されます。

      -- Variable: enable-multibyte-characters
          この変数は、バッファのテキスト表現を指定する。
          これが`nil'以外であると、バッファはマルチバイトテキストを保持する。
          さもなければユニバイトテキストを保持する。

          この変数に直接設定することはできない。
          そのかわりに、バッファの表現を変更するには、
          関数`set-buffer-multibyte'を使う。

      -- Variable: default-enable-multibyte-characters
          この変数の値は、 `(default-value
          'enable-multibyte-characters)'に完全に等価であり、
          この変数に設定するとデフォルト値を変更する。
          バッファの`enable-multibyte-characters'のローカルな束縛に設定することは
          許されていないが、デフォルト値を変更することは可能であり、
          そうしても既存のバッファには影響しないので理にかなっている。

          コマンド行オプション`--unibyte'は、
          起動時の早い段階でデフォルト値に`nil'を設定することで役目を果たす。

      -- Function: multibyte-string-p string
          文字列STRINGにマルチバイト文字が含まれると`t'を返す。


File: elisp-ja,  Node: Converting Representations,  Next: Selecting a Representation,  Prev: Text Representations,  Up: Non-ASCII Characters

32.2 テキスト表現の変換
================================

     Emacsはユニバイトテキストをマルチバイトに変換できます。
マルチバイトテキストをユニバイトにも変換できますが、
この変換では情報が欠落します。
バッファにテキストを挿入するとき、あるいは、
複数の文字列から1つの文字列にテキストを収めるときに、
一般にこれらの変換が行われます。
文字列の内容をどちらかの表現に明示的にも変換できます。

        Emacsは、文字列を作成するときにはその内容に基づいて
文字列の表現を選びます。
一般則は、ユニバイトテキストを他のマルチバイトテキストに組み入れるときには
ユニバイトテキストをマルチバイトテキストに変換します。
マルチバイト表現のほうが汎用であり、
ユニバイトテキストのどんな文字でも保持できるからです。

        バッファにテキストを挿入するときには、Emacsは、
当該バッファの`enable-multibyte-characters'の指定に従った
バッファの表現にテキストを変換します。
特に、ユニバイトバッファにマルチバイトテキストを挿入するときには、
マルチバイトテキスト内のすべての文字を一般には保存できなくても、
Emacsはテキストをユニバイトに変換します。
自然な代替案はバッファ内容をマルチバイトに変換することですが、
これは受け入れられません。
バッファの表現はユーザーが選択したものであり自動的には無視できないからです。

        ユニバイトテキストをマルチバイトテキストに変換しても
ASCII文字は無変更であり、128から159も同様です。
160から255の非ASCIIについては、
各文字に`nonascii-insert-offset'の値を加算することで変換します。
この変数に設定すると、ユニバイト文字がどの文字集合に対応するかを指定できます
（*note Character Sets::）。 たとえば、`nonascii-insert-offset'が `(-
(make-char 'latin-iso8859-1) 128)'の2048であると、
非ASCIIのユニバイトはLatin 1に対応します。 `(- (make-char
'greek-iso8859-7) 128)'の2688であると、 ギリシャ文字に対応します。

        マルチバイトテキストをユニバイトに変換するのは簡単で、
各文字コードと255の論理積をとります。 `nonascii-insert-offset'に
文字集合の始まりに対応する合理的な値が設定されていれば、
この変換は逆変換になります。
つまり、ユニバイトテキストをマルチバイトに変換し、
それをユニバイトに戻すともとのユニバイトテキストになります。

      -- Variable: nonascii-insert-offset
          この変数は、ユニバイトテキストをマルチバイトに変換するときに
          非ASCII文字に加算する値を指定する。
          これは、128から255のユニバイトの非ASCIIの範囲の文字を挿入する
          `self-insert-command'にも適用される。
          しかし、関数`insert-char'はこの変換を行わない。

          文字集合CSを選択する正しい値は、 `(- (make-char CS)
          128)'である。 `nonascii-insert-offset'の値が0であると、
          実際の変換には0ではなくLatin 1文字集合に対する値を使う。

      -- Variable: nonascii-translation-table
          この変数は、`nonascii-insert-offset'のより一般的な代替を提供する。
          128から255の範囲の各コードをマルチバイト文字に変換する方法を
          独立して指定するために使える。
          その値はベクトルか`nil'であること。
          これが`nil'以外であると、`nonascii-insert-offset'に優先する。

      -- Function: string-make-unibyte string
          この関数は、STRINGのテキストがすでにユニバイトでなければ
          ユニバイト表現に変換してから結果を返す。
          STRINGがユニバイトであれば無変更で返す。

      -- Function: string-make-multibyte string
          この関数は、STRINGのテキストがすでにマルチバイトでなければ
          マルチバイト表現に変換してから結果を返す。
          STRINGがマルチバイトであれば無変更で返す。


File: elisp-ja,  Node: Selecting a Representation,  Next: Character Codes,  Prev: Converting Representations,  Up: Non-ASCII Characters

32.3 表現の選択
====================

     既存のバッファや文字列がユニバイトであるときに
マルチバイトとして調べたり、その逆のように調べるのが
有用なこともあります

      -- Function: set-buffer-multibyte multibyte
          カレントバッファの表現方法を設定する。
          MULTIBYTEが`nil'以外であると、バッファはマルチバイトになる。
          MULTIBYTEが`nil'であると、バッファはユニバイトになる。

          この関数は、バイト列としてみたバッファ内容を変更しない。
          その結果、文字として見たときの内容を変更できる。
          マルチバイト表現では1文字とみなされる2バイトの列は、
          ユニバイト表現では2文字になる。

          この関数は、`enable-multibyte-characters'に
          どちらの表現を使用しているかを記録する。
          さらに（オーバレイ、テキスト属性、マーカなどの）バッファ内のさまざまな
          データを調整して、それ以前と同様に同じテキストに及ぶようにする。

      -- Function: string-as-unibyte string
          この関数は、各バイトを1文字とみなして
          STRINGと同じバイトの文字列を返す。
          つまり、値にはSTRINGより多くの文字が含まれることがある。

          STRINGがすでにユニバイトであると、 値はSTRINGそのものである。

      -- Function: string-as-multibyte string
          この関数は、マルチバイトの各列を1文字とみなして
          STRINGと同じバイトの文字列を返す。
          つまり、値にはSTRINGより少ない文字が含まれることがある。

          STRINGがすでにマルチバイトであると、
          値はSTRINGそのものである。


File: elisp-ja,  Node: Character Codes,  Next: Character Sets,  Prev: Selecting a Representation,  Up: Non-ASCII Characters

32.4 文字コード
====================

     ユニバイトとマルチバイトのテキスト表現では、
異なる文字コードを使っています。
ユニバイト表現において正しい文字コードは0から255の範囲であり、
これらの値は1バイトに収まります。
マルチバイト表現において正しい文字コードは0から524287の範囲ですが、
この範囲のすべての値が正しいとは限りません。 特に、値128から255は
（『生のバイト』にはありうる。*note Explicit Encoding::）、
マルチバイトテキストでは正しくありません。
0から127のASCIIコードのみが、どちらの表現でも完全に正しいのです。

      -- Function: char-valid-p charcode
          この関数は、CHARCODEが2つのテキスト表現のどちらか一方で
          正しければ`t'を返す。

               (char-valid-p 65)
                    => t
               (char-valid-p 256)
                    => nil
               (char-valid-p 2248)
                    => t


File: elisp-ja,  Node: Character Sets,  Next: Chars and Bytes,  Prev: Character Codes,  Up: Non-ASCII Characters

32.5 文字集合
=================

     Emacsは文字をさまざまな"文字集合"（character set）に分類します。
文字集合にはシンボルである名前があります。
各文字はたった1つの文字集合に属します。

        一般に、異なる文字体系ごとに1つの文字集合があります。
たとえば、`latin-iso8859-1'は1つの文字集合であり、
`greek-iso8859-7'は別の文字集合であり、 `ascii'も別の文字集合です。
Emacsの1つの文字集合には最大9025個の文字を保持できます。
したがって、論理的には1つの文字集合にまとめられる文字群を、
複数の文字集合に分割する場合もあります。 たとえば、Big
5として一般には知られている中国文字の1つの集合は、
Emacsの2つの文字集合、`chinese-big5-1'と`chinese-big5-2'に
分割されます。

      -- Function: charsetp object
          OBJECTが文字集合の名前のシンボルであれば`t'を返す。
          さもなければ`nil'を返す。

      -- Function: charset-list
          この関数は、定義されているすべての文字集合の名前のリストを返す。

      -- Function: char-charset character
          この関数は文字CHARACTERが属する文字集合の名前を返す。


File: elisp-ja,  Node: Chars and Bytes,  Next: Splitting Characters,  Prev: Character Sets,  Up: Non-ASCII Characters

32.6 文字とバイト
=======================

     マルチバイト表現では、各文字は1バイトかそれ以上のバイトを占めます。
各文字集合には、通常は1バイト長か2バイト長の "導入列"（introduction
sequence）があります （例外：ASCIIの導入列は0バイト長である）。
導入列は、文字集合の任意の文字のバイト列の始まりです。
文字のバイト列の残りの部分は、同じ文字集合内で他の文字とその文字を区別します。
文字集合に依存して、区別するためのバイトは1バイトか2バイトです。
そのようなバイト数を文字集合の"次元"（dimension）と呼びます。

      -- Function: charset-dimension charset
          この関数は、文字集合CHARSETの次元を返す。
          現在、次元はつねに1か2である。

文字集合の導入列のバイト長を判定するもっとも簡単な方法はつぎのとおりです。

          (- (char-bytes (make-char CHARSET))
             (charset-dimension CHARSET))


File: elisp-ja,  Node: Splitting Characters,  Next: Scanning Charsets,  Prev: Chars and Bytes,  Up: Non-ASCII Characters

32.7 文字の分割
====================

本節の関数は、文字とそれを表現するために用いられるバイト値のあいだの
変換を行います。
ほとんどの目的に関しては、Emacsが必要に応じて自動的に行うため、
文字を表現するためのバイト列を扱う必要はありません。

      -- Function: char-bytes character
          この関数は、文字CHARACTERを表現するために必要なバイト数を返す。
          これは、文字CHARACTERが属する文字集合だけに依存し、
          その文字集合（*note Character
          Sets::）の次元とその導入列の和に等しい。

               (char-bytes 2248)
                    => 2
               (char-bytes 65)
                    => 1
               (char-bytes 192)
                    => 1

          マルチバイト表現とユニバイト表現のどちらに対しても
          この関数で正しい結果を得られるのは、
          2つの表現で用いられる非ASCII文字コードに重なりがないからである。

      -- Function: split-char character
          文字CHARACTERの文字集合の名前に続けて、
          その文字集合でCHARACTERを識別する1バイトか2バイトの値（整数）から
          成るリストを返す。 バイト値の個数はその文字集合の次元である。

               (split-char 2248)
                    => (latin-iso8859-1 72)
               (split-char 65)
                    => (ascii 65)

          ユニバイトの非ASCII文字は、 文字集合`ascii'の一部とみなす。

               (split-char 192)
                    => (ascii 192)

      -- Function: make-char charset &rest byte-values
          この関数は、文字集合CHARSETにおいて
          BYTE-VALUESで識別される文字を返す。
          これは、`split-char'のほぼ逆関数にあたる。
          通常、文字集合CHARSETの次元に応じて、
          1つか2つのBYTE-VALUESを指定する。 たとえばつぎのとおり。

               (make-char 'latin-iso8859-1 72)
                    => 2248

        BYTE-VALUESを指定せずに`make-char'を呼び出すと、
その結果は文字集合CHARSETを代表する "汎用文字"（generic
character）である。
汎用文字は整数であるが、文字としてバッファに挿入するには
正しく_ない_ものである。
1つの文字集合全体を表すために`char-table-range'で使える （*note
Char-Tables::）。 `char-valid-p'は汎用文字に対しては`nil'を返す。
たとえばつぎのとおり。

          (make-char 'latin-iso8859-1)
               => 2176
          (char-valid-p 2176)
               => nil
          (split-char 2176)
               => (latin-iso8859-1 0)


File: elisp-ja,  Node: Scanning Charsets,  Next: Translation of Characters,  Prev: Splitting Characters,  Up: Non-ASCII Characters

32.8 文字集合の走査
==========================

     バッファや文字列の一部分にどの文字集合が現れるかを
調べられると有用なことがあります。
その1つの用途は、当該テキストすべてを表現する能力がある
コーディングシステム（*note Coding Systems::）を探すことです。

      -- Function: find-charset-region beg end &optional translation
          この関数は、カレントバッファのBEGとENDのあいだに
          現れる文字集合のリストを返す。

          省略可能な引数TRANSLATIONは、
          テキストを走査するときに使用する変換表を指定する （*note
          Translation of Characters::）。
          これが`nil'以外であると、領域内の各文字をこの表を介して変換し、
          戻り値は、バッファ内の実際の文字のかわりに変換した文字に関する情報を与える。

      -- Function: find-charset-string string &optional translation
          この関数は、文字列STRINGに現れる文字集合のリストを返す。

          省略可能な引数TRANSLATIONは変換表を指定する。
          上記の`find-charset-region'を参照。


File: elisp-ja,  Node: Translation of Characters,  Next: Coding Systems,  Prev: Scanning Charsets,  Up: Non-ASCII Characters

32.9 文字の変換
====================

     "変換表"（translation table）は、文字群を文字群へ対応付けます。
これらの表は、符号化と復号化、他の目的に使われます。
独自の変換表を指定するコーディングシステムもあります。
他のすべてのコーディングシステムに適用される
デフォルトの変換表もあります。

      -- Function: make-translation-table translations
          この関数は、引数TRANSLATIONSに基づいた変換表を返す。
          引数TRANSLATIONSの各要素は、 `(FROM . TO)'の形であり、
          文字FROMをTOへ変換することを意味する。

          1つの文字集合全体を同じ次元の別の文字集合へ対応付けることも可能である。
          それには、FROMに（文字集合を表す）汎用文字を指定する （*note
          Splitting Characters::）。
          この場合、TOも、同じ次元の別の文字集合の汎用文字であること。
          こうすると、この変換表は、FROMの文字集合の各文字を
          TOの文字集合の対応する文字へ変換する。

復号化では、もとの復号化結果の文字に変換表による変換を適用します。
コーディングシステムに属性`character-translation-table-for-decode'が
あれば、これは使用する変換表を指定します。
さもなければ、`standard-character-translation-table-for-decode'が
`nil'以外であれば、復号化ではその表を使います。

        符号化では、バッファ内の文字に変換表による変換を適用し、
変換結果を実際に符号化します。
コーディングシステムに属性`character-translation-table-for-encode'が
あれば、これは使用する変換表を指定します。
さもなければ、変数`standard-character-translation-table-for-encode'が
使用する変換表を指定します。

      -- Variable: standard-character-translation-table-for-decode
          これは、変換表を指定しないコーディングシステムに対する
          復号化時のデフォルトの変換表である。

      -- Variable: standard-character-translation-table-for-encode
          これは、変換表を指定しないコーディングシステムに対する
          符号化時のデフォルトの変換表である。


File: elisp-ja,  Node: Coding Systems,  Next: Input Methods,  Prev: Translation of Characters,  Up: Non-ASCII Characters

32.10 コーディングシステム
====================================

     Emacsがファイルを読み書きしたり、
Emacsがサブプロセスへテキストを送ったり
サブプロセスからテキストを受け取るときには、
"コーディングシステム"（coding system）で指定される
文字コード変換と行末変換を行います。

     * Menu:

     * Coding System Basics::
     * Encoding and I/O::
     * Lisp and Coding Systems::
     * User-Chosen Coding Systems::
     * Default Coding Systems::
     * Specifying Coding Systems::
     * Explicit Encoding::
     * Terminal I/O Encoding::
     * MS-DOS File Types::


File: elisp-ja,  Node: Coding System Basics,  Next: Encoding and I/O,  Up: Coding Systems

32.10.1 コーディングシステムの基本概念
-----------------------------------------------------

     "文字コード変換"（character code conversion）とは、
Emacsの内部で使用する符号と他の符号とのあいだでの変換のことです。
Emacsでは、相互に変換できる多くの異なる符号を扱えます。
たとえば、Emacsは、Latin 1、Latin 2、Latin 3、Latin 4、Latin 5、 ISO
2022のいくつかの変種を相互に変換できます。
同じ文字集合に対する異なる符号を扱うこともできます。
たとえば、キリル（ロシア語）文字に対しては
ISO、Alternativnyj、KOI8の3つのコーディングシステムがあります。

ほとんどのコーディングシステムでは変換する文字コードを特定しますが、
指定せずにデータに基づいて発見的手法で選ぶものもあります。

        "行末変換"（end of line conversion）は、
ファイル内の行の終りを表すさまざまなシステムで
使われている3つの異なる慣習を扱います。
UNIXの慣習では、行送り文字（改行文字とも呼ぶ）を使います。
DOSの慣習では、行末には復帰と行送りの2文字の列を使います。
Macの慣習では、復帰のみを使います。

        `latin-1'のような"基底コーディングシステム"（base coding
system） では、行末変換を指定せずにデータに基づいて選びます。
`latin-1-unix'、`latin-1-dos'、`latin-1-mac'のような
"変種コーディングシステム"（variant coding system）では、
明示的に行末変換も指定します。 ほとんどの基底コーディングシステムには、
`-unix'、`-dos'、`-mac'を付加して作られる名前の
対応する3つの変種があります。

        コーディングシステム`raw-text'は
文字コード変換を行わない特別なもので、
このコーディングシステムで訪問したバッファはユニバイトバッファになります。
行末変換も指定しないので内容に基づいて決定でき、
行末変換を指定する3つの変種もあります。
`no-conversion'は`raw-text-unix'に等価であり、
文字コードも行末も変換しないことを指定します。

        コーディングシステム`emacs-mule'は、
Emacs内部での符号でデータを表現することを指定します。
これは、コード変換を行わないという意味では`raw-text'に似ていますが、
結果がマルチバイトデータになる点が異なります。

      -- Function: coding-system-get coding-system property
          この関数は、コーディングシステムCODING-SYSTEMの指定した属性を返す。
          コーディングシステムのほとんどの属性は内部目的用であるが、
          読者が有用と思うものが1つ、`mime-charset'がある。
          この属性の値は、当該コーディングシステムで読み書きする
          文字コード向けのMIMEに使用する名前である。

               (coding-system-get 'iso-latin-1 'mime-charset)
                    => iso-8859-1
               (coding-system-get 'iso-2022-cn 'mime-charset)
                    => iso-2022-cn
               (coding-system-get 'cyrillic-koi8 'mime-charset)
                    => koi8-r

          属性`mime-charset'の値は、
          コーディングシステムの別名としても定義されている。


File: elisp-ja,  Node: Encoding and I/O,  Next: Lisp and Coding Systems,  Prev: Coding System Basics,  Up: Coding Systems

32.10.2 符号化と入出力
-----------------------------

     コーディングシステムの主目的は、ファイルの読み書きに使うことです。
関数`insert-file-contents'はファイルのデータを復号化するために
コーディングシステムを使い、
`write-region'はバッファ内容を符号化するために
コーディングシステムを使います。

        使用するコーディングシステムを明示する（*note Specifying Coding
Systems::） こともできるし、 デフォルトの機構（*note Default Coding
Systems::）を暗に使うこともできます。
しかし、これらの方式ではすべきことを完全に指定しきれないこともあります。
たとえば、`undefined'のようなコーディングシステムを選んで、
データに基づいて文字コード変換を行うようにするかもしれません。
そのような場合、コーディングシステムの選択は
入出力操作によって完了します。
しばしば、選択されたコーディングシステムをあとで知りたくなります。

      -- Variable: buffer-file-coding-system
          この変数は、カレントバッファで訪問するときに使用した
          コーディングシステムを記録する。
          これは、バッファを保存したり、
          `write-region'でバッファの一部を書くときに使われる。
          これらの操作において、ユーザーに別のコーディングシステムを指定するように
          問い合わせた場合には、`buffer-file-coding-system'は
          指定された別のコーディングシステムに更新される。

      -- Variable: save-buffer-coding-system
          この変数は、`write-region'には使わないが、
          バッファを保存するために使うコーディングシステムを指定する。
          バッファを保存する際に、ユーザーに別のコーディングシステムを指定するように
          問い合わせ、かつ、`save-buffer-coding-system'を用いている場合には、
          これは指定された別のコーディングシステムに更新される。

      -- Variable: last-coding-system-used
          ファイルやサブプロセスに対する入出力操作では、
          使用したコーディングシステム名をこの変数に設定する。
          明示的に符号化／復号化する関数（*note Explicit Encoding::）も
          この変数に設定する。

          *警告：*` '
          サブプロセスから出力を受け取るとこの変数が設定されるため、
          Emacsが待つたびに変化する可能性がある。
          したがって、読者の興味がある値を保存するような関数を呼び出した直後に
          その値をコピーして使うこと。

        変数`selection-coding-system'は、
ウィンドウシステムのセレクションを符号化する方法を指定します。 *Note
Window System Selections::。


File: elisp-ja,  Node: Lisp and Coding Systems,  Next: User-Chosen Coding Systems,  Prev: Encoding and I/O,  Up: Coding Systems

32.10.3 Lispにおけるコーディングシステム
------------------------------------------------------

     コーディングシステムを扱うLispの機能について述べます。

      -- Function: coding-system-list &optional base-only
          この関数は、すべてのコーディングシステム名（シンボル）のリストを返す。
          BASE-ONLYが`nil'以外であると、
          値には基底コーディングシステムのみを含める。
          さもなければ、値には変種コーディングシステムも含まれる。

      -- Function: coding-system-p object
          この関数は、OBJECTがコーディングシステム名であると`t'を返す。

      -- Function: check-coding-system coding-system
          この関数は、CODING-SYSTEMの正当性を調べる。
          正しいものならばCODING-SYSTEMを返す。
          さもなければ、条件`coding-system-error'付きのエラーを通知する。

      -- Function: coding-system-change-eol-conversion coding-system
               eol-type
          この関数は、CODING-SYSTEMに類似のコーディングシステムを返すが、
          `eol-type'で指定された行末変換のものである。
          EOL-TYPEは、`unix'、`dos'、`mac'、`nil'の いずれかであること。
          `nil'であると、返されたコーディングシステムは、
          データから行末変換を決定する。

      -- Function: coding-system-change-text-conversion eol-coding
               text-coding
          この関数は、行末変換にEOL-CODINGを使い、
          テキストの変換にTEXT-CODINGを使っているコーディングシステムを返す。
          TEXT-CODINGが`nil'であると、
          `undecided'かEOL-CODINGに応じた`undecided'の変種の1つを返す。

      -- Function: find-coding-systems-region from to
          この関数は、FROMとTOのあいだのテキストの符号化に使用できる
          コーディングシステムのリストを返す。
          リスト内のすべてのコーディングシステムは、当該部分のテキストの
          どんなマルチバイト文字も安全に符号化できる。

          テキストにマルチバイト文字が含まれない場合、
          関数はリスト`(undecided)'を返す。

      -- Function: find-coding-systems-string string
          この関数は、文字列STRINGのテキストの符号化に使用できる
          コーディングシステムのリストを返す。
          リスト内のすべてのコーディングシステムは、STRINGの
          どんなマルチバイト文字も安全に符号化できる。
          テキストにマルチバイト文字が含まれない場合、
          これはリスト`(undecided)'を返す。

      -- Function: find-coding-systems-for-charsets charsets
          この関数は、リストCHARSETS内のすべての文字集合の符号化に使用できる
          コーディングシステムのリストを返す。

      -- Function: detect-coding-region start end &optional highest
          この関数は、STARTからENDまでのテキストを復号化する
          もっともらしいコーディングシステムを選ぶ。
          このテキストは『生のバイト』（*note Explicit
          Encoding::）であること。

          この関数は、通常、走査したテキストの復号化を扱える
          コーディングシステムのリストを返す。
          それらは優先順位の降順に並ぶ。
          しかし、HIGHESTが`nil'以外であると、
          戻り値はもっとも順位の高い1つのコーディングシステムである。

          領域にASCII文字だけが含まれる場合、
          値は`undecided'か`(undecided)'である。

      -- Function: detect-coding-string string highest
          この関数は`detect-coding-region'と同様であるが、
          バッファ内のバイトのかわりに文字列STRINGの内容に作用する。

        サブプロセスとの入出力に使用されるコーディングシステムを
調べたり設定する方法については、*Note Process Information::。


File: elisp-ja,  Node: User-Chosen Coding Systems,  Next: Default Coding Systems,  Prev: Lisp and Coding Systems,  Up: Coding Systems

32.10.4 ユーザー指定のコーディングシステム
-----------------------------------------------------------

      -- Function: select-safe-coding-system from to &optional
               preferred-coding-system
          この関数はFROMとTOのあいだのテキストを符号化する
          コーディングシステムを選ぶが、
          必要ならばユーザーに問い合わせる。

          省略可能な引数PREFERRED-CODING-SYSTEMは、
          最初に試すコーディングシステムを指定する。
          それが指定領域のテキストを処理できるならば、それを使う。
          この引数を省略すると、
          `buffer-file-coding-system'のカレントバッファでの値をまず試す。

          領域内にPREFERRED-CODING-SYSTEMで符号化できない
          マルチバイト文字がある場合、
          この関数は、当該テキストを符号化可能なコーディングシステム一覧から
          ユーザーに選択してもらい、ユーザーが選択したものを返す。

          特殊機能：` 'FROMが文字列であると、
          文字列を調べる対象とし、TOは無視する。

補完を用いてユーザーにコーディングシステムを指定させるために使える
2つの関数はつぎのとおりです。 *Note Completion::。

      -- Function: read-coding-system prompt &optional default
          この関数は、文字列PROMPTをプロンプトとして
          ミニバッファを使ってコーディングシステムを読み取り、
          コーディングシステム名をシンボルとして返す。
          ユーザーの入力が空であると、
          DEFAULTは返すべきコーディングシステムを指定する。
          それはシンボルか文字列であること。

      -- Function: read-non-nil-coding-system prompt
          この関数は、文字列PROMPTをプロンプトとして
          ミニバッファを使ってコーディングシステムを読み取り、
          コーディングシステム名をシンボルとして返す。
          ユーザーが空を入力しようとすると再度問い合わせる。 *note
          Coding Systems::。


File: elisp-ja,  Node: Default Coding Systems,  Next: Specifying Coding Systems,  Prev: User-Chosen Coding Systems,  Up: Coding Systems

32.10.5 デフォルトのコーディングシステム
--------------------------------------------------------

     本節では、特定のファイルや特定のサブプログラムを実行するときの
デフォルトのコーディングシステムを指定する変数と、
それらを使った入出力操作を行う関数について述べます。

これらの変数の目的は、読者が望むデフォルトをいったんこれらに設定しておけば、
再度変更する必要がないようにすることです。
Lispプログラムの特定の操作向けに特定のコーディングシステムを指定するには、
これらの変数を変更しないでください。
かわりに、`coding-system-for-read'や`coding-system-for-write'を
使って上書きします（*note Specifying Coding Systems::）。

      -- Variable: file-coding-system-alist
          この変数は、特定のファイルの読み書きに使用する
          コーディングシステムを指定する連想リストである。
          各要素は`(PATTERN . CODING)'の形であり、
          PATTERNは特定のファイル名に一致する正規表現である。
          PATTERNに一致するファイル名に当該要素を適用する。

          要素のCDR、CODINGはコーディングシステムであるか、
          2つのコーディングシステムを収めたコンスセルであるか、
          関数シンボルであること。
          CODINGがコーディングシステムであると、
          ファイルの読み書きの両方にそのコーディングシステムを使う。
          CODINGが2つのコーディングシステムを収めたコンスセルであると、
          そのCARは復号化に使うコーディングシステムを指定し、
          そのCDRは符号化に使うコーディングシステムを指定する。

          CODINGが関数シンボルであると、
          その関数は、コーディングシステムか、
          2つのコーディングシステムを収めたコンスセルを返すこと。
          その値は上に述べたように使われる。

      -- Variable: process-coding-system-alist
          この変数は、サブプロセスで実行しているプログラムに依存して
          サブプロセスに使うコーディングシステムを指定する連想リストである。
          `file-coding-system-alist'と同様に働くが、
          PATTERNはサブプロセスを始めるために用いたプログラム名に対して
          一致を取る点が異なる。
          この連想リストに指定したコーディングシステムは、
          サブプロセスとの入出力に使用するコーディングシステムの初期化に用いれるが、
          `set-process-coding-system'を使って、
          あとで別のコーディングシステムを指定できる。

        *警告：*` '
データからコーディングシステムを決定する`undecided'のような
コーディングシステムは、非同期サブプロセスの出力に対しては
完全に信頼性のある動作はできない。
これは、Emacsが非同期サブプロセスの出力が
到着するたびに一塊で処理するからである。
コーディングシステムが文字コード変換や行末変換を未指定にしていると、
Emacsは1つの塊から正しい変換を検出しようと試みるが、
これがつねに動作するとは限らない。

        したがって、非同期サブプロセスでは、可能な限り
文字コード変換と行末変換の両方を指定したコーディングシステムを使います。
つまり、`undecided'や`latin-1'などではなく、
`latin-1-unix'のようなものを使います。

      -- Variable: network-coding-system-alist
          この変数は、ネットワークストリームに使用するコーディングシステムを
          指定する連想リストである。
          `file-coding-system-alist'と同様に働くが、
          要素内のPATTERNはポート番号か正規表現である点が異なる。
          それが正規表現であると、ネットワークストリームを開くために
          使用したネットワークサービス名に対して一致をとる。

      -- Variable: default-process-coding-system
          この変数は、なにも指定されていないサブプロセス（やネットワークストリーム）
          の入出力に使用するコーディングシステムを指定する。

          値は、`(INPUT-CODING . OUTPUT-CODING)'の形の
          コンスセルであること。
          ここで、INPUT-CODINGはサブプロセスからの入力に適用され、
          OUTPUT-CODINGはそれへの出力に適用される。

      -- Function: find-operation-coding-system operation &rest
               arguments
          この関数は、ARGUMENTSを指定してOPERATIONを行うときに
          （デフォルトで）使用されるコーディングシステムを返す。
          その値はつぎの形である。

               (DECODING-SYSTEM ENCODING-SYSTEM)

          第1要素DECODING-SYSTEMは
          （OPERATIONが復号化を行う場合には）復号化に用いる
          コーディングシステムであり、 ENCODING-SYSTEMは
          （OPERATIONが符号化を行う場合には）符号化に用いる
          コーディングシステムである。

          引数OPERATIONは、Emacsの入出力基本関数の
          `insert-file-contents'、`write-region'、`call-process'、
          `call-process-region'、`start-process'、
          `open-network-stream'のいずれかであること。

          残りの引数は、これらの入出力基本関数に指定するであろう引数と同じであること。
          基本関数に依存して、引数の1つを"対象"として選ぶ。
          たとえば、OPERATIONがファイル入出力を行う場合、
          ファイル名を指定する引数が対象である。
          サブプロセスの基本関数では、プロセス名が対象である。
          `open-network-stream'では、サービス名やポート番号が対象である。

          この関数は、OPERATIONに応じて当該対象を
          `file-coding-system-alist'や `process-coding-system-alist'や
          `network-coding-system-alist'で探す。 *note Default Coding
          Systems::。


File: elisp-ja,  Node: Specifying Coding Systems,  Next: Explicit Encoding,  Prev: Default Coding Systems,  Up: Coding Systems

32.10.6 1つの操作向けにコーディングシステムを指定する
---------------------------------------------------------------------------

     変数`coding-system-for-read'と／や`coding-system-for-write'を
束縛することで、特定の1つの操作向けのコーディングシステムを指定できます。

      -- Variable: coding-system-for-read
          この変数が`nil'以外であると、
          ファイルを読むときや同期プロセスからの入力に用いる
          コーディングシステムを指定する。

          これは非同期プロセスやネットワークストリームにも適用されるが、
          異なった方法で適用される。
          サブプロセスを開始したりネットワークストリームを開いたときの
          `coding-system-for-read'の値は、
          そのサブプロセスやネットワークストリームの入力の復号化方法を指定する。
          変更されない限り、そのサブプロセスやネットワークストリームに
          対して使われ続ける。

          この変数の正しい使い方は、特定の入出力操作に対して
          `let'で束縛することである。
          そのグローバルな値は通常は`nil'であり、
          グローバルにこれ以外の値を設定するべきではない。
          この変数の正しい使い方の例をつぎに示す。

               ;; 文字コード変換せずにファイルから読む
               ;; CRLFが行末を表すと仮定する
               (let ((coding-system-for-write 'emacs-mule-dos))
                 (insert-file-contents filename))

          その値が`nil'以外であると、 `coding-system-for-read'は、
          `file-coding-system-alist'、
          `process-coding-system-alist'、`network-coding-system-alist'、
          を含めて入力に用いるコーディングシステムの
          他のすべての指定方法に優先する。

      -- Variable: coding-system-for-write
          これは`coding-system-for-read'と同様に働くが、
          入力ではなく出力に適用される点が異なる。
          ファイル、サブプロセス、ネットワーク接続へ書くことに影響する。

          `call-process-region'と`start-process'のように、
          1つの操作で入力と出力を行うときには、
          `coding-system-for-read'と`coding-system-for-write'の
          両方が影響する。

      -- Variable: inhibit-eol-conversion
          この変数が`nil'以外であると、
          コーディングシステムでなにが指定されていようと行末変換を行わない。
          これは、Emacsの入出力とサブプロセスのすべての基本関数、
          明示的な符号化／復号化関数（*note Explicit
          Encoding::）に適用される。


File: elisp-ja,  Node: Explicit Encoding,  Next: Terminal I/O Encoding,  Prev: Specifying Coding Systems,  Up: Coding Systems

32.10.7 明示的な符号化と復号化
-----------------------------------------

     Emacsへ／からテキストを転送するすべての操作には、
テキストを符号化したり復号化するコーディングシステムを使う能力があります。
本節に述べる関数を用いてテキストを明示的に符号化したり復号化できます。

符号化の結果と復号化する入力は、通常のEmacsのテキストではありません。
それらは『生のバイト』、つまり、外部ファイルと同じ方法で
テキストを表現するバイト列です。
バッファに生のバイトが収められている場合、
`set-buffer-multibyte'（*note Selecting a Representation::）を用いて
バッファはユニバイト表現であると印を付けるのがもっとも自然ですが、
これは必須ではありません。
バッファの内容が単に一時的に生のバイトであるときには、
バッファはマルチバイトのままにしておきます。
バッファ内容を復号化すれば正しくなります。

明示的に復号化するためにバッファに生のバイトを入れる普通の方法は、
`insert-file-contents-literally'（*note Reading from Files::）で
ファイルから読むか、
`find-file-noselect'でファイルを訪問するときに引数RAWFILEに
`nil'以外を指定します。

テキストの明示的な符号化で得た結果である生のバイトを使う普通の方法は、
ファイルやプロセスへそれらをコピーします。
たとえば、`write-region'（*note Writing to Files::）でそれらを書くには、
`coding-system-for-write'に`no-conversion'を束縛して
`write-region'の符号化を抑制します。

        生のバイトには、正しいマルチバイト文字に
余分なトレイリングコードが付いたように見える長すぎるバイト列が
含まれる場合があります。
ほとんどの目的には、バッファや文字列のそのような列をEmacsは1文字として扱い、
その文字コードを調べるとマルチバイト文字の列に対応した値を得るはずです。
余分なバイト列は無視されます。 このふるまいは透明性がよくありませんが、
生のバイトはEmacsの限定された場面でのみ使われ、実用上の問題は回避できます。

      -- Function: encode-coding-region start end coding-system
          この関数は、コーディングシステムCODING-SYSTEMに従って
          STARTからENDのテキストを符号化する。
          符号化結果はバッファ内のもとのテキストを置き換える。
          符号化結果は『生のバイト』であるが、
          マルチバイトであったバッファはマルチバイトのままである。

      -- Function: encode-coding-string string coding-system
          この関数は、コーディングシステムCODING-SYSTEMに従って
          文字列STRINGのテキストを符号化する。
          符号化したテキストを含む新たな文字列を返す。
          符号化結果は『生のバイト』のユニバイト文字列である。

      -- Function: decode-coding-region start end coding-system
          この関数は、コーディングシステムCODING-SYSTEMに従って
          STARTからENDのテキストを復号化する。
          復号化結果はバッファ内のもとのテキストを置き換える。
          明示的な復号化が有用であるためには、
          復号化前のテキストは『生のバイト』であること。

      -- Function: decode-coding-string string coding-system
          この関数は、コーディングシステムCODING-SYSTEMに従って
          文字列STRINGのテキストを復号化する。
          復号化したテキストを含む新たな文字列を返す。
          明示的な復号化が有用であるためには、
          復号化前のSTRINGの内容は『生のバイト』であること。


File: elisp-ja,  Node: Terminal I/O Encoding,  Next: MS-DOS File Types,  Prev: Explicit Encoding,  Up: Coding Systems

32.10.8 端末入出力の符号化
-----------------------------------

     Emacsは、コーディングシステムを用いてキーボード入力を復号化したり、
端末出力を符号化できます。
Latin-1などの特定の符号を用いてテキストを送信したり表示する
端末に対しては、これは有用です。 Emacsは、端末に対する符号化や復号化では
`last-coding-system-used'に設定しません。

      -- Function: keyboard-coding-system
          この関数は、キーボード入力の復号化に用いている
          コーディングシステムを返す。
          コーディングシステムを使用していなければ`nil'を返す。

      -- Function: set-keyboard-coding-system coding-system
          この関数は、キーボード入力の復号化に使用するコーディングシステムとして
          CODING-SYSTEMを指定する。 CODING-SYSTEMが`nil'であると、
          キーボード入力に復号化を用いないことを意味する。

      -- Function: terminal-coding-system
          この関数は、端末出力の符号化に用いている
          コーディングシステムを返す。
          コーディングシステムを使用していなければ`nil'を返す。

      -- Function: set-terminal-coding-system coding-system
          この関数は、端末出力の符号化に使用するコーディングシステムとして
          CODING-SYSTEMを指定する。 CODING-SYSTEMが`nil'であると、
          端末出力に符号化を用いないことを意味する。


File: elisp-ja,  Node: MS-DOS File Types,  Prev: Terminal I/O Encoding,  Up: Coding Systems

32.10.9 MS-DOSのファイル型
--------------------------------

     MS-DOSやMS-Windows上のEmacsは、
特定のファイル名をテキストファイルやバイナリファイルとして認識します。
『バイナリファイル』とは、必ずしも文字を意味しないバイト値のファイルです。
Emacsは、バイナリファイルに対しては行末変換や文字コード変換を行いません。
一方、その名前から『テキストファイル』と印が付いた
新規ファイルを作成すると、EmacsはDOSの行末変換を行います。

      -- Variable: buffer-file-type
          この変数は、各バッファで自動的にバッファローカルになり、
          バッファで訪問したファイルのファイル型を記録する。
          バッファが`buffer-file-coding-system'で
          コーディングシステムを指定しない場合、
          バッファ内容を書き出すときに用いるコーディングシステムを
          この変数を用いて決定する。
          テキストに対しては`nil'、バイナリに対して`t'であること。
          これが`t'であると、コーディングシステムは`no-conversion'である。
          さもなければ、`undecided-dos'を用いる。

          通常、この変数はファイルを訪問すると設定される。
          いかなる変換も行わずにファイルを訪問すると`nil'に設定される。

      -- User Option: file-name-buffer-file-type-alist
          この変数は、テキスト／バイナリファイルを認識するための連想リストを保持する。
          各要素は(REGEXP . TYPE)の形である。
          ここで、REGEXPはファイル名に対して一致をとり、
          TYPEは、テキストファイルでは`nil'、
          バイナリファイルでは`t'、あるいは、
          どちらであるかを計算するために呼び出す関数である。
          それが関数であると、1つの引数（ファイル名）で呼ばれ、
          `t'か`nil'を返すこと。

          MS-DOSやMS-Windowsで動作しているEmacsは、
          この連想リストを調べて、ファイルを読む際に使用する
          コーディングシステムを決定する。
          テキストファイルでは`undecided-dos'が使われる。
          バイナリファイルでは`no-conversion'が使われる。

          指定したファイルがこの連想リストの要素に一致しないと、
          `default-buffer-file-type'がファイルの扱い方を指定する。

      -- User Option: default-buffer-file-type
          この変数は、`file-name-buffer-file-type-alist'が指定しない型の
          ファイルの扱い方を指定する。

          この変数が`nil'以外であると、そのようなファイルはバイナリとして扱われ、
          コーディングシステム`no-conversion'を用いる。
          さもなければそれらに対して特別なことを行わずに、
          Emacsの通常のとおりにファイル内容からコーディングシステムを決定する。


File: elisp-ja,  Node: Input Methods,  Prev: Coding Systems,  Up: Non-ASCII Characters

32.11 入力方式
==================

     "入力方式"（input method）は、
キーボードから非ASCII文字を入力する簡便な方法を提供します。
プログラムが読み取るための非ASCII文字の符号変換を行う
コーディングシステムと異なり、
入力方式は人間向けのコマンドを提供します。
（テキストを入力するための入力方式の使い方については、 *note 入力方式:
(emacs)Input Methods.。）
入力方式の定義方法については本書ではまだ明文化してありませんが、
ここではそれらの使い方について述べます。

        各入力方式には名前があります。 それは現在のところ文字列ですが、
将来は入力方式名としてシンボルも使えるようになります。

      -- Variable: current-input-method
          この変数は、カレントバッファで現在活性な入力方式の名前を保持する。
          （この変数に設定すると自動的にバッファローカルになる。）
          `nil'であると、バッファでは入力方式が活性ではない。

      -- Variable: default-input-method
          この変数は、入力方式を選ぶコマンド向けのデフォルトの入力方式を保持する。
          `current-input-method'と異なり、この変数は通常はグローバルである。

      -- Function: set-input-method input-method
          この関数は、カレントバッファにおいて
          入力方式INPUT-METHODを活性にする。
          `default-input-method'にもINPUT-METHODを設定する。
          INPUT-METHODが`nil'であると、
          この関数はカレントバッファの入力方式を不活性にする。

      -- Function: read-input-method-name prompt &optional default
               inhibit-null
          この関数は、プロンプトPROMPTを用いてミニバッファで入力方式名を読む。
          DEFAULTが`nil'以外であると、
          ユーザーが空の入力をするとデフォルトでこれを返す。
          しかし、INHIBIT-NULLが`nil'以外であると、
          空の入力はエラーを通知する。

          戻り値は文字列である。

      -- Variable: input-method-alist
          この変数は、使用可能なすべての入力方式を定義する。
          各要素は1つの入力方式を定義し、つぎの形であること。

               (INPUT-METHOD LANGUAGE-ENV ACTIVATE-FUNC
                TITLE DESCRIPTION ARGS...)

          ここで、INPUT-METHODは入力方式名であり文字列である。
          LANGUAGE-ENVも別の文字列であり当該入力方式を
          推奨する言語環境の名前である。
          （これは説明文目的のためだけである。）

          TITLEは、この入力方式が活性である場合に
          モード行に表示される文字列である。
          DESCRIPTIONはこの入力方式と何向きであるかを
          説明する文字列である。

          ACTIVATE-FUNCは、この入力方式を活性にするために呼び出す関数である。
          ARGSがあればACTIVATE-FUNCへの引数として渡される。
          つまり、ACTIVATE-FUNCの引数はINPUT-METHODとARGSである。

        入力方式に対する基本的なインターフェイスは
変数`input-method-function'を介して行います。 *Note Reading One
Event::。


File: elisp-ja,  Node: Searching and Matching,  Next: Syntax Tables,  Prev: Non-ASCII Characters,  Up: Top

33 探索と一致
******************

     GNU Emacsにはバッファから指定したテキストを探す方法が2つあります。
文字列そのものを正確に探索するのと正規表現の探索です。
正規表現の探索のあとでは、
正規表現全体やそのさまざまな部分に一致したテキストを表す
"マッチデータ"（match data）を調べることができます。

     * Menu:

     * String Search::         Search for an exact match.
     * Regular Expressions::   Describing classes of strings.
     * Regexp Search::         Searching for a match for a regexp.
     * POSIX Regexps::         Searching POSIX-style for the longest match.
     * Search and Replace::	  Internals of `query-replace'.
     * Match Data::            Finding out which part of the text matched
                                 various parts of a regexp, after regexp search.
     * Searching and Case::    Case-independent or case-significant searching.
     * Standard Regexps::      Useful regexps for finding sentences, pages,...

        `skip-chars...'などの関数もある種の探索を行います。 *Note
Skipping Characters::。


File: elisp-ja,  Node: String Search,  Next: Regular Expressions,  Up: Searching and Matching

33.1 文字列の探索
=======================

     これらは、バッファ内のテキストを探索するための基本関数です。
これらはプログラムで使うことを意図していますが、
対話的に呼び出すこともできます。
その場合、探索文字列を問い合わせてきますが、
LIMITとNOERRORは`nil'に、REPEATは1に設定されます。

        これらの探索関数は、バッファがマルチバイトであると
探索文字列をマルチバイトに変換します。
バッファがユニバイトであると探索文字列をユニバイトに変換します。 *Note
Text Representations::。

      -- コマンド: search-forward string &optional limit noerror repeat
          この関数は、ポイントから前方へ向けて文字列STRINGに
          ちょうど一致するものを探す。
          それに成功すれば、ポイントをみつけた出現箇所の末尾に移動し、
          ポイントの新たな値を返す。
          一致がみつからなければ、戻り値と副作用はNOERRORに依存する（下記参照）。

          つぎの例では、ポイントは始めは行頭にある。
          そして`(search-forward "fox")'は`fox'の最後の文字のうしろに
          ポイントを移動する。

               ---------- Buffer: foo ----------
               -!-The quick brown fox jumped over the lazy dog.
               ---------- Buffer: foo ----------

               (search-forward "fox")
                    => 20

               ---------- Buffer: foo ----------
               The quick brown fox-!- jumped over the lazy dog.
               ---------- Buffer: foo ----------

          引数LIMITは探索の上限を指定する。
          （カレントバッファ内の位置であること。）
          その位置を越える箇所での一致は受け入れない。
          LIMITを省略したり`nil'であると、
          デフォルトは、バッファの参照可能部分の末尾である。

          探索に失敗した場合の動作は、NOERRORの値に依存する。
          NOERRORが`nil'であると、 エラー`search-failed'を通知する。
          NOERRORが`t'であると、
          `search-forward'は`nil'を返しなにもしない。
          NOERRORが`nil'でも`t'でもないと、
          `search-forward'はポイントを上限位置へ移動して`nil'を返す。
          （この場合にもポイントの新たな値を返すほうが一貫性があるが、
          値`nil'に依存しているプログラムがある。）

          REPEATを指定してあると（正の数であること）、
          その回数だけ探索を繰り返す（一致箇所の末尾を新たな探索の開始位置とする）。
          連続してこれらの探索に成功すると関数は成功し、
          ポイントを移動してその新たな値を返す。
          さもなければ探索は失敗である。

      -- コマンド: search-backward string &optional limit noerror repeat
          この関数は、ポイントから後方へ向けてSTRINGを探索する。
          `search-forward'と同様であるが、後方へ向けて探索し
          一致箇所の先頭にポイントを置く点が異なる。

      -- コマンド: word-search-forward string &optional limit noerror
               repeat
          この関数は、ポイントから前方へ向けてSTRINGに一致する『単語』を探索する。
          一致をみつけると、一致箇所の末尾にポイントを設定し
          ポイントの新たな値を返す。

          単語の一致では、STRINGを単語の列とみなし、
          それらを区切る句読点は無視する。
          バッファ内の同じ単語の列を探す。
          バッファ内の各単語は別々になっている必要があるが
          （単語`ball'を探索すると単語`balls'には一致しない）、
          句読点や空白の詳細は無視される （`ball boy'を探索すると`ball.
          Boy!'に一致する）。

          つぎの例では、ポイントは始めはバッファの先頭にある。
          探索するとポイントは`y'と`!'のあいだに移動する。

               ---------- Buffer: foo ----------
               -!-He said "Please!  Find
               the ball boy!"
               ---------- Buffer: foo ----------

               (word-search-forward "Please find the ball, boy.")
                    => 35

               ---------- Buffer: foo ----------
               He said "Please!  Find
               the ball boy-!-!"
               ---------- Buffer: foo ----------

          LIMITが`nil'以外（カレントバッファ内の位置）であると、
          それは探索の上限を指定する。
          みつかった一致箇所はその位置を越えてはならない。

          NOERRORが`nil'であると、
          探索に失敗するとエラー`word-search-failed'を通知する。
          NOERRORが`t'であると、 エラーを通知するかわりに`nil'を返す。
          NOERRORが`nil'でも`t'でもないと、
          ポイントをLIMIT（あるいはバッファの末尾）へ移動して`nil'を返す。

          REPEATが`nil'以外であると、 その回数だけ探索を繰り返す。
          ポイントは最後の一致箇所の末尾へ置かれる。

      -- コマンド: word-search-backward string &optional limit noerror
               repeat
          この関数はポイントから後方へ向けてSTRINGに一致する単語を探索する。
          この関数は`word-search-forward'と同様であるが、
          後方へ向けて探索し一致箇所の先頭にポイントを置く点が異なる。


File: elisp-ja,  Node: Regular Expressions,  Next: Regexp Search,  Prev: String Search,  Up: Searching and Matching

33.2 正規表現
=================

     "正規表現"（regular expression、略して"regexp"）は、
文字列の（無限の可能性もある）集合を表すパターンです。
正規表現への一致を探すことは、非常に強力な操作です。
本節では、正規表現の書き方を説明します。
続く節では、それらを探索する方法を説明します。

     * Menu:

     * Syntax of Regexps::       Rules for writing regular expressions.
     * Regexp Example::          Illustrates regular expression syntax.


File: elisp-ja,  Node: Syntax of Regexps,  Next: Regexp Example,  Up: Regular Expressions

33.2.1 正規表現の構文
----------------------------

     正規表現では、数個の文字が特別な構成であり、残りは"普通"です。
普通の文字は、その文字だけに一致する単純な正規表現です。
特別な文字は、`.'、`*'、`+'、 `?'、`['、`]'、`^'、`$'、`\'であり、
将来新たな文字が定義されることはありません。
正規表現に現れるこれら以外の文字は、 まえに`\'がない限り普通の文字です。

        たとえば、`f'は特別な文字ではないので普通の文字です。
ですから、`f'は文字列`f'だけに一致する正規表現です。
（これは文字列`ff'には一致しない。）
同様に、`o'は`o'だけに一致する正規表現です。

        任意の2つの正規表現AとBを連結できます。
その結果は、Aが文字列の始めの部分に一致し、かつ、
Bがその文字列の残りに一致するときにその文字列に一致する
正規表現になります。

        簡単な例として、正規表現 `f'と`o'を連結して
正規表現`fo'を得られます。 これは文字列`fo'だけに一致します。
これは明らかですね。
より強力なことをするには、特別な文字の1つを使う必要があります。
それらの一覧を以下に示します。

    `.' （ピリオド）
          特別な文字であり、改行以外の任意の1文字に一致する。
          連結を使って`a.b'のような正規表現を作れる。
          これは、`a'で始まり`b'で終る任意の3文字の文字列に一致する。

    `*'
          単独では構成要素ではない。
          直前の正規表現を可能な限り反復することを意味する後置演算子である。
          すなわち、`o*'は（`o'が存在しない場合も含めて）
          任意個の`o'に一致する。

          `*'はつねに先行する_最小_の正規表現に適用される。
          したがって、`fo*'は`fo'を繰り返すのではなく、 `o'を繰り返す。
          この正規表現は`f'、`fo'、`foo'などに一致する。

          `*'を用いた構成の一致を処理するときには、
          ただちに得られる限りの反復回数に展開される。
          そうしてから、残りのパターンを処理する。
          一致に失敗するとバックトラック（後戻り）が発生して、
          `*'を用いた構成の反復回数を減らして
          パターンの残りの部分が一致できるようにする。
          たとえば、文字列`caaar'に対して
          `ca*ar'を一致させることを考えてみる。
          始めに、`a*'を3つの`a'すべてに一致させようとする。
          しかし、残りのパターンが`ar'なのに`r'しか残っていないため、
          この試みは失敗する。
          そこで、つぎは`a*'を`a'2つだけに一致させる。
          こうすると、残りの正規表現も正しく一致する。

          入れ子にした反復演算子がバックトラックのループを指定する場合、
          それはとても遅くなる。 たとえば、正規表現`\(x+y*\)*a'を
          `xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz'の列に一致させると
          最終的に失敗するまで何時間も費してしまう。
          遅さの原因は、Emacsは35個の`x'をグループに分ける各方法を
          すべて試してからでないとそれらが一致しないことを結論できないからである。
          読者の正規表現が素早く動作することを保証するために、
          入れ子になった繰り返しを注意深く調べること。

    `+'
          `*'に似た後置演算子だが、
          直前の正規表現に1回以上一致する必要がある。
          たとえば、`ca+r'は、文字列`car'や`caaaar'には一致するが、
          文字列`cr'には一致ない。
          一方、`ca*r'の場合は、上記の3つすべてに一致する。

    `?'
          `*'に似た後置演算子だが、
          直前の正規表現に1回だけ一致するか、あるいは、1回も一致しない。
          たとえば、`ca?r'は、`car'や`cr'に一致するが、
          他のものには一致しない。

    `[ ... ]'
          `['で始まり`]'で終る"文字選択"を表す。 もっとも単純な場合は、
          この2つの中括弧のあいだにある文字の1つ1つがこの文字選択に一致する。

          したがって、`[ad]'は、`a'1文字か`d'1文字のどちらにも一致する。
          `[ad]*'は、`a'と`d'だけから成る
          （空の文字列を含む）任意の文字列に一致する。
          このことから、`c[ad]*r'は、
          `cr'、`car'、`cdr'、`caddaar'などに一致することがわかる。

          文字選択には、文字範囲の指定を含めることもでき、
          始めの文字と終りの文字のあいだに`-'を書く。
          つまり、`[a-z]'はすべてのASCII小英文字に一致する。
          範囲指定と個々の文字を自由に織り混ぜてよく、
          `[a-z$%.]'のように書ける。
          これは、任意のASCII小英文字、`$'、`%'、ピリオドに一致する。

          正規表現`[\200-\377]'で
          すべての非ASCII文字につねに一致するとは限らない。
          ユニバイト（*note Text Representations::）のバッファや文字列を
          探索するときにはうまく働くが、マルチバイトのバッファや文字列では
          多くの非ASCII文字のコードは8進数0377より大きいために働かない。
          しかし、正規表現`[^\000-\177]'は、
          ASCII文字のみを除外しているため、
          マルチバイト表現でもユニバイト表現でもすべての非ASCII文字に一致する。

          範囲指定の始めと終りは同じ文字集合（*note Character Sets::）に
          属している必要がある。 したがって、`[a-\x8e0]'は正しくない。
          `a'はASCII文字集合に属し、
          文字0x8e0（グレーブアクセント付き`a'）は
          EmacsのLatin-1の文字集合に属しているからである。

          正規表現の普通の特別な文字は、文字選択の内側では特別ではないことに注意。
          文字選択の内側では、まったく別の文字の集まり、
          `]'、`-'、`^'が特別である。

          文字選択に`]'を含めるには、
          `]'を最初の文字として指定する必要がある。
          たとえば、`[]a]'は、`]'や`a'に一致する。
          `-'を含めるには、`-'を文字選択の最初の文字か
          最後の文字として書くか、範囲指定のあとに置く。
          したがって、`[]-]'は、`]'と`-'の両方に一致する。

          文字選択に`^'を含めるには、`^'を文字選択の2番目以降に置く。

    `[^ ... ]'
          `[^'は"文字選択の補集合"の始まりを意味し、
          指定した文字を除く任意の文字に一致する。
          すなわち、`[^a-z0-9A-Z]'は、
          英文字と数字文字を_除く_すべての文字に一致する。

          `^'は文字選択の先頭になければ文字選択では特別な意味を持たない。
          `^'に続く文字は先頭にあるものとして扱われる
          （いいかえれば、ここでは`-'や`]'は特別な意味を持たない）。

          文字選択の補集合は、一致しない文字として改行を指定しない限り、
          改行にも一致する。
          この点は、`grep'のようなプログラムでの正規表現の扱い方と対照的である。

    `^'
          空の文字列に一致する特別な文字であり、
          一致を取る対象のテキストの行頭のみに一致する。
          それ以外では、一致に失敗する。
          したがって、`^foo'は、行頭にある`foo'に一致する。

          バッファのかわりに文字列と一致を取るときには、
          `^'は文字列の先頭や改行文字`\n'のうしろに一致する。

    `$'
          `^'と同様だが行末のみに一致する。 したがって、`x+$'は、
          行末にある1文字以上の`x'から成る文字列に一致する。

          バッファのかわりに文字列と一致を取るときには、
          `$'は文字列の末尾や改行文字`\n'のまえに一致する。

    `\'
          2つの機能がある。
          （`\'を含む）特別な文字をクォートする（意味を抑える）ことと、
          特別な構成を導入することである。

          `\'は特別な文字をクォートするので、
          `\$'は文字`$'だけに一致する正規表現、
          `\['は文字`['だけに一致する正規表現、 といった具合になる。

          `\'にはLisp文字列の入力構文（*note String Type::）でも
          特別な意味があり、`\'でクォートする必要があることに注意してほしい。
          たとえば、文字`\'に一致する正規表現は`\\'である。
          文字群`\\'を含むLisp文字列を書くには、各`\'をクォートするために
          `\'が必要である。
          したがって、`\'に一致する正規表現の入力構文は`"\\\\"'である。

        *注意：*` '従来との互換性のために、
特別な文字がそれらの特別な意味をなしえない文脈で使われた場合には、
普通の文字として扱われる。
たとえば、`*foo'では、`*'の対象となる正規表現が直前にないため、
`*'は普通の文字として扱われる。
このようなふるまいに依存することはよいことではない。
特別な文字は書く位置に関係なくクォートするべきである。

        多くの場合、任意の文字を伴う`\'はその文字だけに一致します。
しかし、いくつか例外があって、
`\'で始まる2文字列が特別な意味を持つ場合があります。
（2文字目にくる文字は、
単独で使った場合にはつねに普通の文字として扱われる。）
以下に`\'の構成を示します。

    `\|'
          選択肢を指定する。 `\|'をあいだに伴った2つの正規表現AとBは、
          AかBのいずれかに一致する文字列に一致する正規表現となる。

          したがって、`foo\|bar'は、`foo'や`bar'に一致するが、
          それ以外の文字列には一致しない。

          `\|'は、周囲にある適用しうる正規表現の中でも最大のものに適用される。
          `\|'によるグループ化を制限するのは、 これを囲む`\( ...
          \)'によるグループ化だけである。

          何度`\|'を使っても処理できるだけの十分なバックトラック能力がある。

    `\( ... \)'
          以下の3つの目的を果たすグループ化のための構成。

            1. 他の操作に使うために一連の選択肢`\|'を括る。
               したがって、`\(foo\|bar\)x'は、
               `foox'か`barx'のいずれかに一致する。

            2. 後置演算子、`*'、`+'、`?'を適用できるように、
               複雑な正規表現を括る。 したがって、`ba\(na\)*'は、
               `bananana'のように、（0個以上の）任意個の
               文字列`na'に一致する。

            3. あとで参照できるように、一致した部分文字列を記録する。

          最後の使い方は、括弧によるグループ化という考え方から
          派生したものではない。 同一の`\( ...
          \)'構成に与えた2つめの別の機能である。
          実用上、これら2つの意味が混同されることはないからである。
          この機能をつぎに説明する。

    `\DIGIT'
          D番目に現れた`\( ... \)'に一致したテキストと
          同じテキストに一致する。

          いいかえれば、一致を処理するときには、 `\( ...
          \)'構成の末尾に達すると、
          この構成に一致したテキストの始めと終りを記録する。
          そして、正規表現のそれよりうしろでは、 『D番目に現れた`\( ...
          \)'に一致したテキスト』という意味で
          それがなんであろうと`\'に続けて数字Dを使える。

          1つの正規表現内に現れる最初の9個の`\( ...
          \)'に一致する文字列には、
          正規表現中で開き括弧が現れた順に、1から9までの番号を割り振る。
          そのため、`\1'から`\9'で、 対応する`\( ...
          \)'に一致したテキストを参照できる。

          たとえば、`\(.*\)\1'は、改行を含まない文字列で、かつ、
          前半と後半が同一である文字列に一致する。
          `\(.*\)'は前半部分に一致し、それはどのようなものでもかまわない。
          一方、それに続く`\1'は、
          前半部分とまったく同じテキストに一致しなければならない。

    `\w'
          任意の単語構成文字に一致する。
          エディタの構文テーブルによってこの文字が決まる。 *note Syntax
          Tables::。

    `\W'
          単語構成文字以外の文字に一致する。

    `\sCODE'
          構文コードがCODEである文字だけに一致する。
          ここで、CODEは構文コードを表す文字である。
          つまり、`w'は単語構成要素を、
          `-'は白文字を、`('は開き括弧を表すといった具合である。
          白文字の構文を表すには、`-'か空白のいずれかを使う。
          構文コードとそれらを表す文字の一覧については、 *note Syntax
          Class Table::。

    `\SCODE'
          構文がCODEでない任意の文字に一致する。

        つぎの正規表現は空の文字列に一致します。
つまりこれらは文字を使用しませんが、
これらが一致するかどうか文脈に依存します。

    `\`'
          空の文字列に一致するが、
          一致対象であるバッファや文字列の先頭に限る。

    `\''
          空の文字列に一致するが、
          一致対象であるバッファや文字列の末尾に限る。

    `\='
          空の文字列に一致するが、ポイント位置に限る。
          （文字列に対する一致ではこの構文は定義されない。）

    `\b'
          空の文字列に一致するが、単語の先頭や末尾に限る。
          したがって、`\bfoo\b'は、単語として独立して現れる`foo'に一致する。
          `\bballs?\b'は、単語として独立して現れる
          `ball'や`balls'に一致する。

          `\b'は、 バッファの先頭や末尾にあるテキストとは無関係に、
          バッファの先頭や末尾にも一致する。

    `\B'
          空の文字列に一致するが、単語の先頭や末尾_以外_に限る。

    `\<'
          空の文字列に一致するが、単語の先頭に限る。
          `\<'はバッファの先頭にも一致するが、単語構成文字が続く場合に限る。

    `\>'
          空の文字列に一致するが、単語の末尾に限る。
          `\>'はバッファの末尾にも一致するが、
          単語構成文字で終了している場合に限る。

        任意の文字列が正しい正規表現ではありません。
たとえば、（`[]]'のような少数の例外を除けば）
角括弧が対応していない文字列は正しくありませんし、
1つの`\'で終る文字列も正しくありません。
不正な正規表現を探索関数に渡すと、
エラー`invalid-regexp'が通知されます。

      -- Function: regexp-quote string
          この関数は、STRINGだけに正確に一致する正規表現の文字列を返す。
          これにより、正規表現を必要とする関数を呼び出すときに
          この文字列だけに正確に一致できる。

               (regexp-quote "^The cat$")
                    => "\\^The cat\\$"

          `regexp-quote'の用途の1つは、
          正規表現で記述された文脈に正確に一致する文字列を組み合わせることである。
          たとえば、つぎは、白文字で囲まれたSTRINGの値で表される文字列を探索する。

               (re-search-forward
                (concat "\\s-" (regexp-quote string) "\\s-"))

      -- Function: regexp-opt strings &optional paren
          この関数は、文字列STRINGSのいずれかに一致する
          効率よい正規表現を返す。
          これは、たとえばフォントロック（font-lock）モードなどで、
          可能な限り高速な一致や探索を行う必要がある場合に有用である。

          省略可能な引数PARENが`nil'以外であると、
          返される正規表現はつねに少なくとも1つの括弧によるグループ構文で囲まれる。

          つぎの`regexp-opt'の簡略版定義は、
          実際の値に等価な（ただしそれほど効率よくない）正規表現を生成する。

               (defun regexp-opt (strings paren)
                 (let ((open-paren (if paren "\\(" ""))
                       (close-paren (if paren "\\)" "")))
                   (concat open-paren
                           (mapconcat 'regexp-quote strings "\\|")
                           close-paren)))

      -- Function: regexp-opt-depth regexp
          この関数は、varregexp内のグループ化構文（括弧で括った式）の
          総個数を返す。


File: elisp-ja,  Node: Regexp Example,  Prev: Syntax of Regexps,  Up: Regular Expressions

33.2.2 複雑な正規表現の例
----------------------------------

     ここでは、任意個数の白文字を伴った文末を認識するために
Emacsで使われている複雑な正規表現について述べます。
それは変数`sentence-end'の値です。

        まず、タブ文字と空白を区別するためにLisp構文の文字列として
正規表現を示します。 文字列定数はダブルクォートで始まり終ります。
`\"'は文字列の一部としてのダブルクォート、
`\\'は文字列の一部としてのバックスラッシュ、
`\t'はタブ、`\n'は改行を表します。

          "[.?!][]\"')}]*\\($\\| $\\|\t\\|  \\)[ \t\n]*"

     対照的に、変数`sentence-end'を評価するとつぎのように
なっているはずです。

          sentence-end
               => "[.?!][]\"')}]*\\($\\| $\\|  \\|  \\)[
          ]*"

     この出力では、タブと改行はそれ自身として現れています。

この正規表現には、連続してつぎのような4つの部分が含まれています。

    `[.?!]'
          パターンの最初の部分は、3つの文字、ピリオド、疑問符、感嘆符の
          いずれかに一致する文字選択である。
          一致部分はこれらの3つの文字の1つで始まる必要がある。

    `[]\"')}]*'
          パターンの2番目の部分は、ピリオド、疑問符、感嘆符のいずれかに続く、
          任意の閉じ括弧やクォーテーションマークの0個以上の繰り返しに一致する。
          `\"'は、文字列内のダブルクォートを表すLisp構文である。
          最後の`*'は、直前の正規表現（この場合は文字選択）を
          0回以上繰り返すことを表す。

    `\\($\\| $\\|\t\\|  \\)'
          パターンの3番目の部分は、文末に続く白文字、
          つまり、（空白を伴うかもしれない）行末、1つのタブ、2つの空白の
          いずれかに一致する。
          2つのバックスラッシュは、括弧や縦棒を正規表現の構文にする。
          括弧はグループを区切り、縦棒は選択肢を区切る。
          ドル記号は行末に一致するために用いている。

    `[ \t\n]*'
          パターンの最後の部分は、
          文末に最低限必要な白文字より余計な白文字に一致する。


File: elisp-ja,  Node: Regexp Search,  Next: POSIX Regexps,  Prev: Regular Expressions,  Up: Searching and Matching

33.3 正規表現の探索
==========================

     GNU Emacsでは、正規表現に一致するつぎの部分を
インクリメンタルにもそうでなくも探せます。
インクリメンタルサーチコマンドについては、 *note 正規表現探索:
(emacs)Regexp Search.を 参照してください。
ここでは、プログラムで有用な探索関数のみについて述べます。
基本的なものは`re-search-forward'です。

        これらの探索関数は、バッファがマルチバイトであれば
正規表現をマルチバイトに変換します。
バッファがユニバイトであれば、正規表現をユニバイトに変換します。 *Note
Text Representations::。

      -- コマンド: re-search-forward regexp &optional limit noerror
               repeat
          この関数は、カレントバッファにおいて前方へ向けて
          正規表現REGEXPに一致するテキストの文字列を探索する。
          関数はREGEXPに一致しないテキストはすべて飛び越え、
          みつけた一致箇所の末尾へポイントを置く。
          ポイントの新たな値を返す。

          LIMITが`nil'以外（カレントバッファ内の位置であること）であると、
          探索の上限を表す。
          その位置を越える箇所での一致は受け入れない。

          REPEATを指定してあると（正の数であること）、
          その回数だけ探索を繰り返す（一致箇所の末尾を新たな探索の開始位置とする）。
          連続してこれらの探索に成功すると関数は成功し、
          ポイントを移動してその新たな値を返す。
          さもなければ探索は失敗である。

          関数が失敗した場合の動作は、NOERRORの値に依存する。
          NOERRORが`nil'であると、 エラー`search-failed'を通知する。
          NOERRORが`t'であると、
          `re-search-forward'はなにもせずに`nil'を返す。
          NOERRORが`nil'でも`t'でもないと、
          `re-search-forward'はポイントをLIMIT（あるいはバッファの末尾）へ
          移動して`nil'を返す。

          つぎの例では、ポイントは始めは`T'のまえにある。
          探索を呼び出すと、ポイントは当該行の末尾
          （`hat'の`t'と改行のあいだ）へ移動する。

               ---------- Buffer: foo ----------
               I read "-!-The cat in the hat
               comes back" twice.
               ---------- Buffer: foo ----------

               (re-search-forward "[a-z]+" nil t 5)
                    => 27

               ---------- Buffer: foo ----------
               I read "The cat in the hat-!-
               comes back" twice.
               ---------- Buffer: foo ----------

      -- コマンド: re-search-backward regexp &optional limit noerror
               repeat
          この関数は、カレントバッファにおいて後方へ向けて
          正規表現REGEXPに一致するテキストの文字列を探索し、
          みつけた一致箇所の先頭へポイントを置く。

          この関数は`re-search-forward'に類似したものであるが、
          単純な鏡像ではない。 `re-search-forward'は、一致箇所の先頭が
          開始位置に可能な限り近い一致箇所を探す。
          `re-search-backward'が完全な鏡像であれば、
          一致箇所の末尾が可能な限り近い一致箇所を探す。
          しかし、実際には、一致箇所の先頭が可能な限り近い一致箇所を探す。
          これは、正規表現との一致をとる処理は、
          指定開始位置において先頭から末尾へ向けてつねに行われるからである。

          `re-search-forward'の完全な鏡像には、
          正規表現の一致を末尾から先頭へ向けて行う特別な機能が必要である。
          それを実装する手間をかけるほどの価値はない。

      -- Function: string-match regexp string &optional start
          この関数は、文字列STRINGにおいて正規表現REGEXPに一致した
          最初の箇所の添字を返す。 あるいは、一致がなければ`nil'を返す。
          STARTが`nil'以外であると、
          STRINGの指定した添字から探索を始める。

          たとえばつぎのとおりである。

               (string-match
                "quick" "The quick brown fox jumped quickly.")
                    => 4
               (string-match
                "quick" "The quick brown fox jumped quickly." 8)
                    => 27

          文字列の最初の文字の添字は0であり、
          2番目の文字の添字は1であるといった具合になる。

          この関数から戻ったあとでは、
          一致箇所を越えた最初の文字の添字は`(match-end 0)'で得られる。
          *note Match Data::。

               (string-match
                "quick" "The quick brown fox jumped quickly." 8)
                    => 27

               (match-end 0)
                    => 32

      -- Function: looking-at regexp
          この関数は、カレントバッファ内のポイントの直後のテキストが
          正規表現REGEXPに一致するかどうかを調べる。
          ここで『直後』とは、開始位置は固定されていて、
          ポイントのうしろの最初の文字で始まる場合にのみ探索は成功する。
          結果は、一致すれば`t'であり、さもなければ`nil'である。

          この関数はポイントを移動しないが、マッチデータを更新する。
          `match-beginning'や`match-end'を使ってマッチデータを参照できる。

          つぎの例では、ポイントは`T'の直前にある。
          ポイントがこれ以外の場所にあると結果は`nil'になる。

               ---------- Buffer: foo ----------
               I read "-!-The cat in the hat
               comes back" twice.
               ---------- Buffer: foo ----------

               (looking-at "The cat in the hat$")
                    => t


File: elisp-ja,  Node: POSIX Regexps,  Next: Search and Replace,  Prev: Regexp Search,  Up: Searching and Matching

33.4 POSIXの正規表現探索
===============================

     普通の正規表現関数は、`\|'や反復構文を扱うために必要なときには
バックトラックしますが、これを行い続けるのは
_なんらか_の一致をみつけるまでです。
みつけてしまえば、それらは成功してみつけた最初の一致を報告します。

        本節では、正規表現の一致に関するPOSIX規格で規定された
完全なバックトラックを行う代替の探索関数について述べます。
それらはすべての可能性を試し尽くしすべての一致箇所を探し終える
までバックトラックを継続してます。
そのため、POSIXで要求されるとおりの最長の一致を報告できるのです。
これは動作がとても遅いですから、最長一致が本当に必要な場合に限って
これらの関数を使ってください。

      -- Function: posix-search-forward regexp &optional limit noerror
               repeat
          これは`re-search-forward'と同様であるが、
          正規表現の一致に関するPOSIX規格で規定された完全なバックトラックを行う。

      -- Function: posix-search-backward regexp &optional limit noerror
               repeat
          これは`re-search-backward'と同様であるが、
          正規表現の一致に関するPOSIX規格で規定された完全なバックトラックを行う。

      -- Function: posix-looking-at regexp
          これは`looking-at'と同様であるが、
          正規表現の一致に関するPOSIX規格で規定された完全なバックトラックを行う。

      -- Function: posix-string-match regexp string &optional start
          これは`string-match'と同様であるが、
          正規表現の一致に関するPOSIX規格で規定された完全なバックトラックを行う。


File: elisp-ja,  Node: Search and Replace,  Next: Match Data,  Prev: POSIX Regexps,  Up: Searching and Matching

33.5 探索と置換
====================

      -- Function: perform-replace from-string replacements query-flag
               regexp-flag delimited-flag &optional repeat-count map
          この関数は、`query-replace'と関連するコマンドの中身である。
          FROM-STRINGの出現を探しだし、それらの一部やすべてを置き換える。
          QUERY-FLAGが`nil'であると、すべての出現を置換する。
          さもなければ、1つ1つユーザーにどうするかを問い合わせる。

          REGEXP-FLAGが`nil'以外であると、
          FROM-STRINGを正規表現として扱う。
          さもなければ、その字面とおりに一致する。
          DELIMITED-FLAGが`nil'以外であると、
          単語区切りで囲まれたもののみを対象にする。

          引数REPLACEMENTSは、出現を置き換えるものを指定する。
          それが文字列であれば、その文字列を使う。
          文字列のリストでもよく、要素を巡回して使う。

          REPEAT-COUNTが`nil'以外であれば、整数であること。
          これは、REPLACEMENTSのリスト内の各文字列を
          つぎに進めるまえに何回使用するかを指定する。

          通常、キーマップ`query-replace-map'で、
          可能なユーザーの応答を定義する。 引数MAPが`nil'以外であれば、
          `query-replace-map'のかわりに使うキーマップである。

      -- Variable: query-replace-map
          この変数は、`y-or-n-p'や`map-y-or-n-p'に加えて、
          `query-replace'や関連する関数に対する
          正しいユーザー応答を定義する特別なキーマップを保持する。
          2つの意味で普通のものではない。

             * 『キーバインディング』はコマンドではなく、
               このキーマップを用いる関数にのみ意味がある単なるシンボルである。

             * プレフィックスキーは扱えない。
               各キーバインディングは単一イベントのキー列である必要がある。
               これは、関数では入力を得るために`read-key-sequence'を使わずに、
               『自前』でイベントを読み取り探索するからである。

`query-replace-map'向けの意味のある『バインディング』をつぎに示します。
`query-replace'と関連するものだけに意味のあるものもあります。

    `act'
          当該動作を行う、いいかえれば『yes』。

    `skip'
          この問いに対する動作は行わない、いいかえれば『no』。

    `exit'
          この問いには『no』で答え、
          残りの応答も『no』と仮定して一連の問いを止める。

    `act-and-exit'
          この問いには『yes』で答え、
          残りの応答は『no』と仮定して一連の問いを止める。

    `act-and-show'
          この問いには『yes』で答えるが、結果を表示する。
          つぎの問いへは進まない。

    `automatic'
          この問いと以降の一連の問いに『yes』で答え、
          これ以降ユーザーに問い合わせない。

    `backup'
          問いに答えたまえの箇所へ戻る。

    `edit'
          この問いに対処するために、通常の動作のかわりに再帰編集に入る。

    `delete-and-edit'
          対象のテキストを削除してから、
          それを置き換えるために再帰編集に入る。

    `recenter'
          ウィンドウの中央に位置決めして再表示してから、
          同じ問いを問い直す。

    `quit'
          ただちに中断する。
          `y-or-n-p'と関連する関数でのみ、この応答を用いる。

    `help'
          ヘルプを表示してから、再度問い直す。


File: elisp-ja,  Node: Match Data,  Next: Searching and Case,  Prev: Search and Replace,  Up: Searching and Matching

33.6 マッチデータ
=======================

     Emacsは、正規表現の探索中に捜し出したテキスト断片の開始／終了位置を
記録しています。
つまり、たとえば、rmailメッセージ内で日付のような複雑なパターンを
探索してから、パターンの制御をもとに一致した一部分を取り出せるのです。

マッチデータは、通常、もっとも最近に行った探索のみを記述するので、
あとで使用したい探索とそのマッチデータを使うあいだに、
不注意に別の探索を行わないように注意してください。
あいだで探索を行う必要がある場合には、その周りで
マッチデータを保存／復元してそれらが上書きされないようにします。

     * Menu:

     * Replacing Match::	  Replacing a substring that was matched.
     * Simple Match Data::     Accessing single items of match data,
     			    such as where a particular subexpression started.
     * Entire Match Data::     Accessing the entire match data at once, as a list.
     * Saving Match Data::     Saving and restoring the match data.


File: elisp-ja,  Node: Replacing Match,  Next: Simple Match Data,  Up: Match Data

33.6.1 一致したテキストの置換
----------------------------------------

     この関数は、最後の探索で一致したテキストをREPLACEMENTで置換します。

      -- Function: replace-match replacement &optional fixedcase
               literal string subexp
          この関数は、最後の探索で一致したバッファ内（あるいは文字列STRING）の
          テキストを置換する。 当該テキストをREPLACEMENTで置き換える。

          バッファで最後に探索を行った場合には、
          STRINGに`nil'を指定すること。
          そうすると、`replace-match'はバッファを編集することで置換を行い、
          置換したテキストの末尾にポイントを置き`t'を返す。

          文字列で探索した場合には、STRINGに同じ文字列を渡すこと。
          そうすると、`replace-match'は新たな文字列を構築することで
          置換を行い、新たな文字列を返す。

          FIXEDCASEが`nil'以外であると、
          置換テキストの大文字小文字は変更しない。
          さもなければ、置換テキストの大文字小文字は、
          対象テキストの大文字小文字に応じて変換される。
          元テキストがすべて大文字であると、置換テキストも大文字に変換される。
          元テキストの最初の単語が大文字で始まっていると、
          置換テキストの最初の単語も大文字で始める。
          元テキストが1単語のみであり、しかも、その単語が大文字1文字であると、
          `replace-match'はすべてが大文字ではなく大文字で始まるとみなす。

          `case-replace'が`nil'であると、
          FIXED-CASEの値に関わらず、大文字小文字変換を行わない。 *note
          Searching and Case::。

          LITERALが`nil'以外であると、
          必要に応じて大文字小文字変換は行うものの
          REPLACEMENTをそのまま挿入する。
          それが`nil'（デフォルト）であると、 文字`\'を特別に扱う。
          REPLACEMENTに`\'が現れるときには、
          つぎの列のいずれかであること。

         `\&'
               `\&'は置換対象のテキスト全体を表す。

         `\N'
               Nを数字文字とすると`\N'は、
               もとの正規表現内のN番目の部分式に一致したテキストを表す。
               部分式とは、`\(...\)'で囲んでグループ化した式である。

         `\\'
               `\\'は置換テキスト内で1つの`\'を表す。

          SUBEXPが`nil'以外であると、
          一致箇所全体ではなく正規表現のSUBEXP番目の部分式に
          一致した箇所のみを置換することを指示する。 たとえば、`foo
          \(ba*r\)'に一致させたあとで、
          SUBEXPに1を指定して`replace-match'を呼び出すと、
          `\(ba*r\)'に一致したテキストのみを置換することを意味する。


File: elisp-ja,  Node: Simple Match Data,  Next: Entire Match Data,  Prev: Replacing Match,  Up: Match Data

33.6.2 マッチデータの簡単な参照
-------------------------------------------

     本節では、最後の探索や一致操作において
なにに一致したのかを調べるためのマッチデータの使い方を説明します。

一致したテキスト全体や正規表現の括弧で括った特定の部分式に一致した
テキストを調べることができます。
以下の関数の引数COUNTでどれかを指定します。
COUNTがゼロであれば、一致全体を調べることになります。
COUNTが正であれば、望みの部分式を指定します。

        正規表現の部分式は、エスケープした括弧`\(...\)'でグループ化した
式であることに注意してください。
COUNT番目の部分式は、正規表現全体の先頭から
`\('の出現を数えてみつけます。
最初の部分式は1、つぎは2、といった具合です。
部分式は正規表現だけにあります。
単純な文字列探索のあとでは、利用可能な情報は一致全体に関するものだけです。

探索に失敗すると、マッチデータを変更することもしないこともあります。
過去には探索に失敗しても変更しなかったのですが、 将来そうなります。

      -- Function: match-string count &optional in-string
          この関数は、最後の探索や一致操作で一致したテキストを文字列として返す。
          COUNTがゼロであるとテキスト全体を返す。
          COUNTが正であれば、COUNT番目の括弧で囲んだ部分式に対応する
          部分のみを返す。
          COUNTが範囲を越えていたり、当該部分式に一致するものがない場合には、
          値は`nil'である。

          最後の探索や一致操作を`string-match'で文字列に対して行った場合には、
          引数IN-STRINGとして同じ文字列を渡すこと。
          バッファの探索や一致のあとでは、IN-STRINGを省略するか
          `nil'を渡すこと。
          ただし、`match-string'を呼び出すときのカレントバッファが
          探索を行ったときのバッファであること。

      -- Function: match-string-no-properties count
          この関数は`match-string'と同様であるが、
          結果にはテキスト属性を含まない。

      -- Function: match-beginning count
          この関数は、最後の正規表現探索やその部分式に一致したテキストの開始位置を返す。

          COUNTがゼロであると、値は一致全体の開始位置である。
          さもなければ、COUNTは正規表現内の部分式を指定し、
          関数の値は当該部分式に一致した部分の開始位置である。

          一致に利用されなかった選択肢`\|'内の部分式に対しては、
          値は`nil'である。

      -- Function: match-end count
          この関数は`match-beginning'と同様であるが、
          一致箇所の開始位置ではなく終了位置を返す点が異なる。

        コメントでテキスト内の位置を示しながら
マッチデータの利用例を示します。

          (string-match "\\(qu\\)\\(ick\\)"
                        "The quick fox jumped quickly.")
                        ;0123456789
               => 4

          (match-string 0 "The quick fox jumped quickly.")
               => "quick"
          (match-string 1 "The quick fox jumped quickly.")
               => "qu"
          (match-string 2 "The quick fox jumped quickly.")
               => "ick"

          (match-beginning 1)       ; 一致箇所`qu'の先頭は
               => 4                 ;   添字4

          (match-beginning 2)       ; 一致箇所`ick'の先頭は
               => 6                 ;   添字6

          (match-end 1)             ; 一致箇所`qu'の末尾は
               => 6                 ;   添字6

          (match-end 2)             ; 一致箇所`ick'の末尾は
               => 9                 ;   添字9

        別の例も示します。 ポイントは始めは行頭にあります。
探索によって、ポイントは空白と単語`in'のあいだに移動します。
一致箇所全体の先頭はバッファの9番目の文字（`T'）であり、
最初の部分式の一致箇所の先頭は13番目の文字（`c'）です。

          (list
            (re-search-forward "The \\(cat \\)")
            (match-beginning 0)
            (match-beginning 1))
              => (9 9 13)

          ---------- Buffer: foo ----------
          I read "The cat -!-in the hat comes back" twice.
                  ^   ^
                  9  13
          ---------- Buffer: foo ----------

     （この例では、返される添字はバッファ内位置であり、
バッファの最初の文字を1と数える。）


File: elisp-ja,  Node: Entire Match Data,  Next: Saving Match Data,  Prev: Simple Match Data,  Up: Match Data

33.6.3 マッチデータ全体を参照する
----------------------------------------------

     関数`match-data'と`set-match-data'は、
マッチデータ全体を一度に読んだり書いたりします。

      -- Function: match-data
          この関数は、最後の探索で一致したテキストに関するすべての情報を収めた
          新たに構築したリストを返す。
          要素0が式全体に一致した部分の先頭位置であり、
          要素1が式全体に一致した部分の終了位置である。
          つぎの2つの要素は最初の部分式に一致した部分の先頭／終了位置、
          といった具合である。 一般に、要素 番号2N は`(match-beginning
          N)'に対応し、 要素 番号2N + 1 は`(match-end N)'に対応する。

          バッファで行った一致ではすべての要素はマーカか`nil'であり、
          `string-match'により文字列で行った一致では
          すべての要素は整数か`nil'である。

          探索関数の呼び出しとその探索結果としてのマッチデータを参照するための
          `match-data'の呼び出しのあいだには、
          別の探索があってはならない。

               (match-data)
                    =>  (#<marker at 9 in foo>
                         #<marker at 17 in foo>
                         #<marker at 13 in foo>
                         #<marker at 17 in foo>)

      -- Function: set-match-data match-list
          この関数は、MATCH-LISTの要素からマッチデータを設定する。
          MATCH-LISTは、以前に`match-data'の呼び出しで得たリストであること。

          MATCH-LISTが存在しないバッファを指していても、エラーにはならない。
          無意味な情報をマッチデータに設定するが、害にはならない。

          `store-match-data'はほぼ廃れている`set-match-data'の別名である。


File: elisp-ja,  Node: Saving Match Data,  Prev: Entire Match Data,  Up: Match Data

33.6.4 マッチデータの保存と復元
-------------------------------------------

     探索を行う可能性がある関数を呼び出す場合、
あとで使うためにそれ以前の探索によるマッチデータを保存したいときには、
当該関数の呼び出しの周りでマッチデータを保存し復元する必要があります。
つぎの例は、マッチデータを保存し損なった場合に生じる問題点を
示しています。

          (re-search-forward "The \\(cat \\)")
               => 48
          (foo)                   ; `foo'はさらに
                                  ;   探索する
          (match-end 0)
               => 61              ; 予期しない結果。48でない！

        マッチデータの保存と復元は`save-match-data'で行えます。

      -- Macro: save-match-data body...
          このマクロは、周りのマッチデータを保存し復元して、
          BODYを実行する。

        スペシャルフォーム`save-match-data'の効果をまねるために
`match-data'とともに`set-match-data'を使うこともできます。
つぎのようにします。

          (let ((data (match-data)))
            (unwind-protect
                ...   ; もとのマッチデータを変更しても大丈夫
              (set-match-data data)))

        プロセスフィルタ関数（*note Filter Functions::）や
プロセスの番兵（*note Sentinels::）を実行するときには、
Emacsは自動的にマッチデータを保存し復元します。


File: elisp-ja,  Node: Searching and Case,  Next: Standard Regexps,  Prev: Match Data,  Up: Searching and Matching

33.7 探索と大文字小文字
================================

デフォルトでは、Emacsの探索は探索対象テキストの大文字小文字を区別しません。
`FOO'を探す指定を行うと、 `Foo'や`foo'にも一致するとみなします。
これは、正規表現にも適用されます。
したがって、`[aB]'は、`a'や`A'や`b'や`B'に一致します。

        この機能を望まないときには、
変数`case-fold-search'に`nil'を設定します。
すると、すべての文字は大文字小文字を保ってそのとおりに一致します。
これはバッファローカルな変数ですから、
変数を変更してもカレントバッファだけに影響します。 （*note Intro to
Buffer-Local::。）
あるいは、`default-case-fold-search'の値を変更します。
これは、`case-fold-search'を書き変えていないバッファ向けの
デフォルト値です。

        ユーザーレベルのインクリメンタルサーチ機能では、
大文字小文字の区別は異なった扱い方をします。
小英文字を与えるとその大文字にも一致しますが、
大英文字を与えると大文字のみに一致します。
しかし、これはLispコードで使用している探索関数には
まったく関係ありません。

      -- User Option: case-replace
          この変数は、置換関数が大文字小文字を保存するかどうかを決定する。
          変数が`nil'であると、置換テキストをそのまま使うことを意味する。
          `nil'以外の値であると、置換対象のテキストに応じて
          置換テキストの大文字小文字を変換することを意味する。

          この変数が実際に効果を発揮するのは関数`replace-match'においてである。
          *note Replacing Match::。

      -- User Option: case-fold-search
          このバッファローカルな変数は、
          大文字小文字を区別して探索するかどうかを決定する。
          変数が`nil'であると大文字小文字を区別する。
          さもなければ大文字小文字を区別しない。

      -- Variable: default-case-fold-search
          この変数の値は、`case-fold-search'を書き変えていないバッファ向けの
          デフォルト値である。 これは`(default-value
          'case-fold-search)'と同じである。


File: elisp-ja,  Node: Standard Regexps,  Prev: Searching and Case,  Up: Searching and Matching

33.8 編集に用いられる標準的な正規表現
=====================================================

     本節では、編集上の特定目的に用いられる正規表現を保持している
変数について述べます。

      -- Variable: page-delimiter
          これは、ページを区切る行頭を記述した正規表現である。
          デフォルト値は、`"^\014"'（つまり、`"^^L"'すなわち`"^\C-l"'）
          である。 これはページ送り文字で始まる行に一致する。

        つぎの2つの正規表現は、つねに行の先頭から一致が
始まると仮定しては_いけません_。
一致の開始位置を固定する`^'を使うべきではありません。
ほとんどの場合、段落コマンドは行の先頭でのみ一致を検査しますから、
`^'は不必要であることを意味します。
幅0以外の左端余白があると、段落コマンドは左端余白のうしろからの一致を
受け入れます。 そのような場合、`^'は誤りです。
しかし、左端余白をけっして使わないモードならば、 `^'は無害です。

      -- Variable: paragraph-separate
          これは、段落を区切る行の始まりを認識するための正規表現である。
          （これを変更したら、`paragraph-start'も変更すること。）
          デフォルト値は`"[ \t\f]*$"'であり、
          （左端余白に続く）空白やタブやページ送りだけから成る行に一致する。

      -- Variable: paragraph-start
          これは、段落を始める行や区切る行の始まりを認識するための正規表現である。
          デフォルト値は`"[ \t\n\f]"'であり、
          （左端余白に続く）空白やタブやページ送りだけから成る行に一致する。

      -- Variable: sentence-end
          これは、文末を記述する正規表現である。
          （これに関わらず、段落の区切りも文末である。）
          デフォルト値はつぎのとおりである。

               "[.?!][]\"')}]*\\($\\| $\\|\t\\| \\)[ \t\n]*"

          これは、ピリオド、疑問符、感嘆符のいずれかのあとに
          閉じ括弧文字が続き（なくてもよい）、
          タブや空白や改行が続くことを意味する。

          この正規表現の詳しい説明は、*note Regexp Example::を参照。



File: elisp-ja,  Node: Syntax Tables,  Next: Abbrevs,  Prev: Searching and Matching,  Up: Top

34 構文テーブル
*********************

     "構文テーブル"（syntax table）は、
各文字の構文的なテキスト上の機能を指定します。
この情報は、"構文解析関数"や複雑な移動を行うコマンドなどが
単語やシンボルなどの構文要素がどこで始まりどこで終るかを調べるために使います。
現在の構文テーブルが、本章の関数に加えて、 単語単位の移動関数（*note
Word Motion::）、 リスト単位の移動関数（*note List
Motion::）の意味を制御します。

     * Menu:

     * Basics: Syntax Basics.     Basic concepts of syntax tables.
     * Desc: Syntax Descriptors.  How characters are classified.
     * Syntax Table Functions::   How to create, examine and alter syntax tables.
     * Syntax Properties::        Overriding syntax with text properties.
     * Motion and Syntax::	     Moving over characters with certain syntaxes.
     * Parsing Expressions::      Parsing balanced expressions
                                     using the syntax table.
     * Standard Syntax Tables::   Syntax tables used by various major modes.
     * Syntax Table Internals::   How syntax table information is stored.
     * Categories::               Another way of classifying character syntax.


File: elisp-ja,  Node: Syntax Basics,  Next: Syntax Descriptors,  Up: Syntax Tables

34.1 構文テーブルの概念
================================

     "構文テーブル"（syntax table）は、
バッファ内の各文字の構文上の用途に関する情報をEmacsに与えます。
この情報は、"構文解析関数"や複雑な移動を行うコマンドなどが
単語やシンボルなどの構文要素がどこで始まりどこで終るかを調べるために使います。
現在の構文テーブルが、本章の関数に加えて、 単語単位の移動関数（*note
Word Motion::）、 リスト単位の移動関数（*note List
Motion::）の意味を制御します。

     構文テーブルは文字テーブル（*note Char-Tables::）です。
Cで添字付けられる要素は、コードがCである文字について記述します。
要素の値は、当該文字の構文上の機能を符号化したリストです。

        構文テーブルは、テキスト内を動き回るためにのみ使われ、
EmacsのLispリーダはこれを使いません。 Emacs
LispがLisp式を読むときには、組み込みの構文規則を使います。
（入力構文を再定義する方法を与えるLispシステムもあるが、
単純であるようにEacs Lispではこの機能を省くことにした。）

        各バッファには独自のメジャーモードがあり、
各メジャーモードはさまざまな文字の構文クラスを独自に扱います。
たとえば、lispモードでは文字`;'はコメントを始めますが、
Cモードでは文を終らせます。 このような多様性を扱うために、
Emacsは各バッファごとにローカルな構文テーブルを選びます。
典型的には、各メジャーモードに独自の構文テーブルがあり、
そのモードを使っているバッファに当該構文テーブルをインストールします。
この構文テーブルを変更すると、
同じモードのバッファだけでなく将来そのモードになったバッファでも
構文を変更してしまいます。
類似したモードでは1つの構文テーブルを共有することがあります。
構文テーブルの設定方法の例については、*Note Example Major Modes::。

        構文テーブルでは、標準の構文テーブルから文字のデータを継承し、
一方でその他の文字に独自の指定を行えます。 構文クラスの『継承』とは、
『標準の構文テーブルから当該文字の構文を引き継ぐ』ことです。
ある文字に対して標準の構文を変更すると、
それを継承するすべての構文テーブルに影響します。

      -- Function: syntax-table-p object
          この関数は、OBJECTが構文テーブルならば`t'を返す。


File: elisp-ja,  Node: Syntax Descriptors,  Next: Syntax Table Functions,  Prev: Syntax Basics,  Up: Syntax Tables

34.2 構文記述子
====================

     本節では、文字の構文を指定する構文クラスと構文フラグ、
それらを"構文記述子"（syntax descriptor）としてどのように
表現するかについて述べます。 構文記述子はLisp文字列であり、
望みの構文を指定するために`modify-syntax-entry'に渡します。

        構文テーブルは、各文字の構文クラスを指定します。
ある構文テーブルでの文字のクラスと
他の構文テーブルでの当該文字のクラスとのあいだにはなんの関係も必要ありません。

        各クラスはニーモニック文字（指定子）で区別します。
ニーモニック文字は、
クラスを指定する必要があるときにクラス名として働きます。
通常、指定子の文字は当該クラスによく現れるものです。
しかしながら、指定子としての意味は不変で、その文字の現在の構文とは独立です。

        構文記述子は、構文クラス、（括弧のクラスの場合にのみ使われる）
釣り合う文字、フラグを指定するLisp文字列です。
最初の文字は、構文クラスを指定する文字（指定子）です。
2番目の文字はその文字に釣り合う文字ですが、使用しない場合には空白です。
そのあとに望みのフラグが続きます。
釣り合う文字やフラグが必要なければ、文字1つだけで十分です。

        たとえば、Cモードにおける文字`*'の構文記述子は
`. 23'（句読点、釣り合う文字なし、
コメント開始の2番目の文字、コメント終了の最初の文字）であり、
`/'は`. 14'（句読点、釣り合う文字なし、
コメント開始の最初の文字、コメント終了の2番目の文字）です。

     * Menu:

     * Syntax Class Table::      Table of syntax classes.
     * Syntax Flags::            Additional flags each character can have.


File: elisp-ja,  Node: Syntax Class Table,  Next: Syntax Flags,  Up: Syntax Descriptors

34.2.1 構文クラス一覧
----------------------------

     以下の一覧は、構文クラス、そのクラスを表す文字（指定子）、
そのクラスの意味、その使用例です。

      -- 構文クラス: 白文字（whitespace character）
          "白文字"（` 'か`-'で指定）は、 シンボルや単語を互いに区切る。
          典型的には、白文字には他の構文上の意味はなく、
          複数個の白文字は1つの白文字と構文的には等価である。
          ほとんどすべてのメジャーモードでは、
          空白、タブ、改行、ページ送りは白文字である。

      -- 構文クラス: 単語構成文字（word constituent）
          "単語構成文字"（`w'で指定）は普通の英単語の一部分であり、
          典型的には、プログラムの変数やコマンド名に使われる。
          すべての大英文字、小英文字、数字文字は、典型的には単語構成文字である。

      -- 構文クラス: シンボル構成文字（symbol constituent）
          "シンボル構成文字"（`_'で指定）は、
          単語構成文字に加えて、変数やコマンド名に使われる追加の文字である。
          たとえば、英単語の一部分ではないがシンボル名に使える特定の文字を指定
          するために、Lispモードではシンボル構成文字クラスを使う。
          このような文字は`$&*+-_<>'である。
          標準のCでは、単語構成文字でなくてシンボルに使える唯一の文字は
          下線（`_'）である。

      -- 構文クラス: 句読点文字（punctuation character）
          "句読点文字"（`.'で指定）は、 英文の句読点として使われたり、
          プログラム言語でシンボルを区切るために使われる文字である。
          emacs-lispモードを含むほとんどのプログラム言語向けモードでは、
          シンボル構成文字でも単語構成文字でもない少数の文字には別の用途があるため、
          このクラスの文字はない。

      -- 構文クラス: 開き括弧文字（open parenthesis character）
      -- 構文クラス: 閉じ括弧文字（close parenthesis character）
          開き／閉じ"括弧文字"は、文や式を囲む相異なる対として使われる文字である。
          そのようなグループ化は、開き括弧文字で始まり閉じ括弧文字で終る。
          各開き括弧文字は特定の閉じ括弧文字に対応し、その逆もいえる。
          Emacsは、通常、閉じ括弧文字を挿入すると
          対応する開き括弧文字を短時間指し示す。 *note Blinking::。

          開き括弧文字クラスは`('で指定し、
          閉じ括弧文字クラスは`)'で指定する。

          英文向けのテキスト（text）モードとCモードでは、
          括弧の対は、`()'、`[]'、`{}'である。 Emacs
          Lispでは、リストとベクトルの区切り（`()'と`[]'）は、
          括弧文字としてクラス分けされる。

      -- 構文クラス: 文字列クォート（string quote）
          "文字列クォート文字"（`"'で指定）は、
          LispやCを含む多くの言語で文字列定数を区切るために使われる。
          同じ文字列クォート文字が文字列の最初と最後に現れる。

          Emacsの構文解析機能では、文字列を1つの字句とみなす。
          文字列内の文字の普通の構文的な意味は抑制される。

          lisp向けのモードには文字列クォート文字が2つ、
          ダブルクォート（`"'）と縦棒（`|'）がある。 `|'はEmacs
          Lispでは使わないがCommon Lispで使う。
          Cにも2つの文字列クォート文字、
          文字列用のダブルクォートと文字定数用のシングルクォート（`''）がある。

          英文はプログラム言語ではないので、英文には文字列クォート文字はない。
          英文でも引用符は用いるが、その内側の文字の普通の構文的な属性を
          抑制したくないのである。

      -- 構文クラス: エスケープ（escape）
          "エスケープ文字"（`\'で指定）は、
          Cの文字列や文字定数で使われるようなエスケープシーケンスを開始する。
          CとLispでは、文字`\'はこのクラスに属する。
          （Cではこの文字は文字列の内側だけで使われるが、
          Cモードでつねにこのように扱っても問題ないことがわかった。）

          `words-include-escapes'が`nil'以外であると、
          このクラスの文字は単語の一部分と解釈される。 *note Word
          Motion::。

      -- 構文クラス: 文字クォート（character quote）
          "文字クォート文字"（`/'で指定）は、
          後続の1文字をクォートし、通常の構文上の意味を抑制する。
          直後の1文字のみに影響するという点で、エスケープ文字と異なる。

          `words-include-escapes'が`nil'以外であると、
          このクラスの文字は単語の一部分と解釈される。 *note Word
          Motion::。

          このクラスは、TeXモードのバックスラッシュに使われる。

      -- 構文クラス: 対になった区切り（paired delimiter）
          "対になった区切り文字"（`$'）は文字列クォート文字と同様であるが、
          区切り文字のあいだにある文字の構文上の属性を抑制しない点が異なる。
          現在、対になった区切りはTeXモードのみで使い、
          数学モードに出入りする`$'である。

      -- 構文クラス: 式前置子（expression prefix）
          "式前置演算子"（`''）は、式のまえに現れると
          式の一部であるとみなされる構文上の演算子に使われる。
          lisp向けのモードでは、（クォートする）アポストロフ`''、
          （マクロで使う）コンマ`,'、
          （ある種のデータの入力構文に使われる）`#'の文字がそうである。

      -- 構文クラス: コメント開始（comment starter）
      -- 構文クラス: コメント終了（comment ender）
          "コメント開始"文字と"コメント終了"文字は、
          さまざまな言語でコメントを区切るために用いられる。
          これらのクラスは、それぞれ、`<'と`>'で指定する。

          英文にはコメント文字はない。
          Lispでは、セミコロン（`;'）でコメントが始まり、
          改行かページ送りで終る。

      -- 構文クラス: 継承（inherit）
          この構文クラスは特定の構文を指定しない。
          標準の構文テーブルで当該文字の構文を探す指定である。
          この構文クラスは`@'で指定する。

      -- 構文クラス: 汎用コメント区切り（generic comment delimiter）
          "汎用コメント区切り"文字は、特別な種類のコメントを
          始めて終える文字である。 _任意の_汎用コメント区切り文字は
          _任意の_汎用コメント区切り文字に対応するが、
          普通のコメント開始文字／コメント終了文字には対応しない。
          汎用コメント区切り文字同士のみで対応する。

          この構文クラスは、主にテキスト属性`syntax-table' （*note
          Syntax Properties::）で使うことを意図したものである。
          任意の範囲の文字がコメントを形成すると印を付けるには、
          その範囲の先頭と末尾の文字にそれらが汎用コメント区切りであることを
          識別する属性`syntax-table'を与える。

      -- 構文クラス: 汎用文字列区切り（generic string delimiter）
          "汎用文字列区切り"文字は、文字列を始めて終える。
          このクラスは文字列クォートクラスと異なり、
          汎用文字列区切りは他の汎用文字列区切りに対応し、
          普通の文字列クォート文字には対応しない。

          この構文クラスは、主にテキスト属性`syntax-table' （*note
          Syntax Properties::）で使うことを意図したものである。
          任意の範囲の文字が文字列定数を形成すると印を付けるには、
          その範囲の先頭と末尾の文字にそれらが汎用文字列区切りであることを
          識別する属性`syntax-table'を与える。


File: elisp-ja,  Node: Syntax Flags,  Prev: Syntax Class Table,  Up: Syntax Descriptors

34.2.2 構文フラグ
----------------------

構文テーブルの各文字には、構文クラスに加えて、フラグも指定できます。
文字`1'、`2'、`3'、`4'、`b'、`p'で
表現される6つの可能なフラグがあります。

`p'を除くすべてのフラグは、複数の文字から成るコメント区切りの記述に
使います。
数字フラグは、当該文字のクラスで表される構文上の属性に_加えて_、
コメント列の一部分でもあることを示します。
フラグはクラスや他のフラグとは独立であり、
Cモードの`*'のような文字のためにあります。
Cモードの`*'は、句読点文字である_とともに_、
コメント開始列の2番目の文字`/*'_でも_あり、
コメント終了列の最初の文字`*/'_でも_あります。

        文字Cに対して可能なフラグとそれらの意味を以下に示します。

        * `1'は、Cが2文字のコメント開始列を始めることを意味する。

        * `2'は、Cがそのような列の2番目の文字であることを意味する。

        * `3'は、Cが2文字のコメント終了列を始めることを意味する。

        * `4'は、Cがそのような列の2番目の文字であることを意味する。

        * `b'は、コメント区切りとしてのCが
          もう1つの『b』形式のコメントに属することを意味する。

          Emacsでは、任意の1つの構文テーブルで2つの形式のコメントを同時に扱える。
          これはC++のためである。
          コメント構文の各形式には、独自の開始列と独自の終了列がある。
          各コメントはどちらか1つの形式である必要がある。
          したがって、『b』形式のコメント開始列で始まるものは、
          『b』形式のコメント終了列で終る必要がある。

          2つのコメント開始列は同じ文字で始まる必要があり、2文字目のみが異なる。
          『b』形式のコメント開始列の2番目の文字にフラグ`b'を付ける。

          （1文字か2文字の）コメント終了列は、
          その最初の文字にフラグ`b'が付いていると『b』形式に適用する。
          さもなければ『a』形式に適用する。

          C++向けの適切なコメント構文の設定はつぎのとおりである。

         `/'
               `124b'

         `*'
               `23'

         newline
               `>b'

          これは4つのコメント区切り列を定義する。

         `/*'
               2文字目の`*'にはフラグ`b'がないので、
               これは『a』形式のコメント開始列である。

         `//'
               2文字目の`/'にはフラグ`b'があるので、
               これは『b』形式のコメント開始列である。

         `*/'
               2文字目の`*'にはフラグ`b'がないので、
               これは『a』形式のコメント終了列である。

         newline
               改行にはフラグ`b'があるので、
               これは『b』形式のコメント終了列である。

        * `p'は、Lisp構文向けの追加の『前置文字』を示す。
          これらの文字は式のあいだに現れるときには白文字として扱う。
          式の内側に現れると、それらの通常の構文コードに従って扱われる。

          関数`backward-prefix-chars'は後方へ向けて移動するときには、
          構文クラスが式前置子（`''）である文字に加えて
          これらの文字も飛び越す。 *note Motion and Syntax::。


File: elisp-ja,  Node: Syntax Table Functions,  Next: Syntax Properties,  Prev: Syntax Descriptors,  Up: Syntax Tables

34.3 構文テーブル向け関数
===================================

本節では、構文テーブルを作成／参照／変更するための関数について述べます。

      -- Function: make-syntax-table
          この関数は、新たな構文テーブルを作成する。
          英文字やコントロール文字の構文は標準の構文テーブルから継承する。
          他の文字の構文は標準の構文テーブルからコピーする。

          ほとんどのメジャーモードの構文テーブルはこのように作成する。

      -- Function: copy-syntax-table &optional table
          この関数は、構文テーブルTABLEのコピーを作成しそれを返す。
          TABLEを指定しないと（あるいは`nil'）、
          現在の構文テーブルのコピーを返す。
          TABLEが構文テーブルでないとエラーを通知する。

      -- コマンド: modify-syntax-entry char syntax-descriptor &optional
               table
          この関数は、文字CHARの構文指定を
          構文記述子SYNTAX-DESCRIPTORとする。
          構文テーブルTABLEにおいてのみ構文を変更し、
          他の構文テーブルは変更しない。
          TABLEのデフォルトはカレントバッファの構文テーブルである。
          SYNTAX-DESCRIPTORで望みの構文を指定する。
          これは、クラス指定子で始まり、
          必要に応じて釣り合う文字とフラグを含む文字列である。 *note
          Syntax Descriptors::。

          この関数はつねに`nil'を返す。
          当該構文テーブルにおけるこの文字に対する古い構文情報は破棄される。

          構文記述子の最初の文字が12個の構文クラス指定子の1つでないとエラーを通知する。
          CHARが文字でなくてもエラーを通知する。

          【例】

               ;; 空白文字をクラス白文字にする
               (modify-syntax-entry ?\  " ")
                    => nil

               ;; `$'を開き括弧文字にする
               ;;   対応する閉じる文字は`^'である
               (modify-syntax-entry ?$ "(^")
                    => nil

               ;; `^'を閉じ括弧文字にする
               ;;   対応する開く文字は$である
               (modify-syntax-entry ?^ ")$")
                    => nil

               ;; `/'を句読点文字にする
               ;;   コメント開始列の最初の文字、および、
               ;;   コメント終了列の2番目の文字にもする
               ;;   これはCモードで用いられる
               (modify-syntax-entry ?/ ". 14")
                    => nil

      -- Function: char-syntax character
          この関数は、文字CHARACTERの構文クラスを指定子で表したもので返す。
          これは構文クラス_のみ_を返し、釣り合う文字や構文フラグは返さない。

          CHARが文字でないとエラーを通知する。

          つぎの例はCモードにあてはまる。
          最初の例は、空白の構文クラスが（空白で表現される）白文字であることを示す。
          2番目の例は、`/'の構文が句読点であることを示す。
          これは、この文字がコメント開始／終了の一部分でもあることは示さない。
          3番目の例は、開き括弧は開き括弧クラスであることを示す。
          これは、この文字に釣り合う文字が`)'であることは示さない。

               (string (char-syntax ?\ ))
                    => " "

               (string (char-syntax ?/))
                    => "."

               (string (char-syntax ?\())
                    => "("

          ここでは、`char-syntax'が返す文字を
          見やすくするために`string'を用いた。

      -- Function: set-syntax-table table
          この関数は、TABLEをカレントバッファの構文テーブルにする。
          TABLEを返す。

      -- Function: syntax-table
          この関数は、現在の構文テーブル、つまり、
          カレントバッファの構文テーブルを返す。


File: elisp-ja,  Node: Syntax Properties,  Next: Motion and Syntax,  Prev: Syntax Table Functions,  Up: Syntax Tables

34.4 構文属性
=================

言語の構文を指定するに十分なほど構文テーブルに柔軟性がないときには、
バッファ内の特定の文字の出現に対して構文テーブルに優先する
テキスト属性`syntax-table'を指定できます。 *Note Text Properties::。

        テキスト属性`syntax-table'の正しい値はつぎのとおりです。

    SYNTAX-TABLE
          属性値が構文テーブルであると、
          文字のこの出現に対する構文を判定するために
          カレントバッファの構文テーブルのかわりにこのテーブルを用いる。

    `(SYNTAX-CODE . MATCHING-CHAR)'
          この形のコンスセルは、文字のこの出現の構文を指定する。

    `nil'
          属性が`nil'であると、通常どおり、
          現在の構文テーブルから文字の構文を判定する。

      -- Variable: parse-sexp-lookup-properties
          これが`nil'以外であると、
          構文を解析する関数は、テキスト属性による構文指定に注意を払う。
          さもなければ、現在の構文テーブルのみを用いる。


File: elisp-ja,  Node: Motion and Syntax,  Next: Parsing Expressions,  Prev: Syntax Properties,  Up: Syntax Tables

34.5 移動と構文
====================

     本節では、特定の構文クラスを持つ文字を越えて移動するための
関数について述べます。

      -- Function: skip-syntax-forward syntaxes &optional limit
          この関数は、SYNTAXESで指定される構文クラスを持つ文字を越えて
          ポイントを前方へ向けて移動する。
          バッファの末尾、（指定されていれば）LIMITの位置、
          飛び越さない文字のいずれかに出会うと停止する。
          戻り値は移動距離であり非負整数である。

      -- Function: skip-syntax-backward syntaxes &optional limit
          この関数は、SYNTAXESで指定される構文クラスである文字を越えて
          ポイントを後方へ向けて移動する。
          バッファの先頭、（指定されていれば）LIMITの位置、
          飛び越さない文字のいずれかに出会うと停止する。

          戻り値は移動距離である。 それはゼロか負の整数である。

      -- Function: backward-prefix-chars
          この関数は、式前置子構文の文字を飛び越えてポイントを後方へ向けて移動する。
          式前置子クラスやフラグ`p'を持つ文字を飛び越す。


File: elisp-ja,  Node: Parsing Expressions,  Next: Standard Syntax Tables,  Prev: Motion and Syntax,  Up: Syntax Tables

34.6 釣り合った式の解析
================================

     ここでは、括弧が対になっている"S式"（sexp）とも呼ばれる
釣り合った式を解析したり走査する関数について述べます。
構文テーブルで文字の解釈を制御することで、
LispモードではLispの式に対して、CモードではCの式に対して
これらの関数を用いることができます。
釣り合った式を飛び越えて移動するための便利な上位レベルの関数については、
*Note List Motion::。

      -- Function: parse-partial-sexp start limit &optional
               target-depth stop-before state stop-comment
          この関数は、カレントバッファのSTARTから始まるS式を解析するが、
          LIMITを越えては走査しない。 位置LIMITで止まるか、
          以下に述べる条件が満たされると解析を停止し、当該箇所にポイントを置く。
          ポイントを置いた箇所での解析状況を表す値を返す。

          STATEが`nil'であると、 位置STARTは、関数定義の先頭のような
          括弧の構造のトップレベルであると仮定する。
          あるいは、構造の途中から解析を再開したい場合もある。
          それには、解析の初期状態を引数STATEに指定する必要がある。

          3番目の引数TARGET-DEPTHが`nil'以外であると、
          括弧の深さがTARGET-DEPTHに等しくなると解析を停止する。
          深さは0、あるいは、STATEで指定された値から始まる。

          4番目の引数STOP-BEFOREが`nil'以外であると、
          S式を始める文字に出会うと解析を停止する。
          STOP-COMMENTが`nil'以外であると、
          コメントの始まりに出会うと解析を停止する。
          STOP-COMMENTがシンボル`syntax-table'であると、
          コメントや文字列の始まり、コメントや文字列の終りのいずれかに
          出会ったあとで解析を停止する。

          5番目の引数STATEは9要素のリストであり、
          以下に述べるようにこの関数の値と同じ形である。
          （9番目の最後の要素は省いてもよい。）
          `parse-partial-sexp'の呼び出しの戻り値を、
          別の`parse-partial-sexp'の呼び出しの解析状態の初期値に使ってよい。

          結果は、解析の最終状態を記述した9要素のリストである。

            0. 0から数えた括弧の深さ。

            1. ポイントを停止した箇所を含むもっとも内側の括弧式の開始位置。
               なければ`nil'。

            2. 閉じている最後の完全な部分式の開始位置。 なければ`nil'。

            3. 文字列の内側であると`nil'以外である。
               より正確には、これは文字列を終える文字である。
               あるいは、汎用文字列区切り文字で終えるときには`t'である。

            4. （どちらかの形式の）コメントの内側であると`t'である。

            5. ポイントがクォート文字の直後であると`t'である。

            6. この解析中に出会った最小の括弧の深さ。

            7. どの形式のコメントが活性であるかを表す。
               『a』形式であると`nil'、 『b』形式であると`t'、
               汎用コメント区切り文字で終るコメントの場合には`syntax-table'である。

            8. 文字列やコメントの開始位置。
               コメントの内側であるときにはこれはコメントの開始位置であり、
               文字列の内側であるときにはこれは文字列の開始位置である。
               文字列やコメントの外側では、この要素は`nil'である。

          引数STATEでは、要素0、3、4、5、7は重要である。

          この関数は、入れ子にあった括弧を持つ言語向けに
          字下げを計算するためにしばしば用いられる。

      -- Function: scan-lists from count depth
          この関数は、位置FROMから前方へ向けてCOUNT個の
          釣り合った括弧のグループを走査する。
          走査を停止した位置を返す。
          COUNTが負であると、後方へ向けて走査する。

          DEPTHが0以外であると、括弧の深さをその値から数え始める。
          停止箇所の候補位置は、括弧の深さが0になる箇所である。
          `scan-lists'は、そのような箇所をCOUNT回数えてから停止する。
          したがって、DEPTHに正の値を指定すると、
          括弧のレベルをDEPTHレベルだけ抜けることを意味する。

          `parse-sexp-ignore-comments'が`nil'以外であると、
          コメントを無視して走査する。

          走査がバッファ（あるいはその参照可能部分）の先頭や末尾に達し、
          深さが0でないと、エラーを通知する。
          深さは0であるが指定個数だけ数えてない場合には、`nil'を返す。

      -- Function: scan-sexps from count
          この関数は、位置FROMから前方へ向けてCOUNT個のS式を走査する。
          走査を終えた位置を返す。
          COUNTが負であると、後方へ向けて移動する。

          `parse-sexp-ignore-comments'が`nil'以外であると、
          コメントを無視して走査する。

          走査が括弧によるグループの途中で
          バッファ（あるいはその参照可能部分）の先頭や末尾に達すると、
          エラーを通知する。
          指定個数だけ数えるまえに括弧によるグループのあいだで
          先頭や末尾に達した場合は`nil'を返す。

      -- Variable: parse-sexp-ignore-comments
          値が`nil'以外であると、
          本節の関数や`forward-sexp'は、コメントを白文字として扱う。

          Emacsの古い版では、コメントの終了が`*/'のような形であり、かつ、
          コメントの終了と思える場合にのみ、この機能は動作した。
          改行でコメントを終える言語では、改行すべてがコメントの終りではないために、
          この変数を`nil'にする必要があった。
          このような制限事項はすでにない。

        `forward-comment'を使うと、
1つのコメントや複数のコメントを飛び越えて前後に移動できます。

      -- Function: forward-comment count
          この関数は、ポイントを前方へ向けて（COUNTが負ならば後方へ向けて）
          COUNT個のコメントを飛び越えて移動する。
          コメントか白文字以外のものに出会うと停止し、当該箇所にポイントを置く。
          COUNT個だけ数えたあとにももちろん停止する。

        ポイントに続くすべてのコメントと白文字を飛び越えるには、
`(forward-comment (buffer-size))'を使います。
バッファ内のコメントの個数は`(buffer-size)'を越えるはずがないので、
引数に使うには`(buffer-size)'はよいものです。


File: elisp-ja,  Node: Standard Syntax Tables,  Next: Syntax Table Internals,  Prev: Parsing Expressions,  Up: Syntax Tables

34.7 標準的な構文テーブル
===================================

Emacsのほとんどのメジャーモードにはそれ独自の構文テーブルがあります。
それらのいくつかをつぎに示します。

      -- Function: standard-syntax-table
          この関数は、基本（fundamental）モードで使用する構文テーブルである
          標準の構文テーブルを返す。

      -- Variable: text-mode-syntax-table
          この変数の値は、テキスト（text）モードで使用する構文テーブルである。

      -- Variable: c-mode-syntax-table
          この変数の値は、Cモードのバッファ向けの構文テーブルである。

      -- Variable: emacs-lisp-mode-syntax-table
          この変数の値は、編集コマンドがemacs-lispモードで使用する構文テーブルである。
          （これはLispの関数`read'にはなんの効果もない。）


File: elisp-ja,  Node: Syntax Table Internals,  Next: Categories,  Prev: Standard Syntax Tables,  Up: Syntax Tables

34.8 構文テーブルの内部
================================

     Lispプログラムでは普通は構文テーブルの要素を直接には操作しません。
Lispレベルの構文テーブル関数は、 普通は構文記述子（*note Syntax
Descriptors::）を操作します。 ですが、内部形式を明文化しておきます。

        構文テーブルの各要素は、`(SYNTAX-CODE . MATCHING-CHAR)'の
形のコンスセルです。
CARのSYNTAX-CODEは、構文クラスと構文フラグを符号化する整数です。
釣り合う文字を指定してあると、 CDRのMATCHING-CHARは`nil'以外です。

        つぎの表は、各構文クラスに対応するSYNTAX-CODEの値です。

         整数 クラス          整数 クラス          整数 クラス
         0    whitespace      5    close           10    character
                              parenthesis          quote
         　  白文字           　  閉じ括弧         　  文字クォート
         1    punctuation     6    expression      11    comment-start
                              prefix               
         　  句読点           　  式前置子         　  コメント開始
         2    word            7    string quote    12    comment-end
         　  単語             　  文字列クォート   　  コメント終了
         3    symbol          8    paired          13    inherit
                              delimiter            
         　  シンボル         　  対になった区切り 　  継承
         4    open            9    escape          14    comment-fence
         parenthesis                               
         　  開き括弧         　  エスケープ       　  コメント区切り
         15   string-fence                         
         　  文字列区切り                          

        たとえば、`('の普通の構文値は、`(4 . 41)'です。
（41は`)'の文字コード。）

フラグは、最下位ビットから16番目のビットから始まる上位ビットに符号化します。
つぎの表は、各構文フラグとそれに対応する2の巾です。

         フラグ 2の巾         フラグ 2の巾         フラグ 2の巾
         `1'    `(lsh 1 16)'  `3'    `(lsh 1 18)'  `p'    `(lsh 1 20)'
         `2'    `(lsh 1 17)'  `4'    `(lsh 1 19)'  `b'    `(lsh 1 21)'


File: elisp-ja,  Node: Categories,  Prev: Syntax Table Internals,  Up: Syntax Tables

34.9 カテゴリ
=================

     "カテゴリ"（category）は、文字を構文的に分類する別の方法です。
必要に応じて複数のカテゴリを定義できて、
そうすると各文字に1つか複数のカテゴリを独立に設定できます。
構文クラスと異なり、カテゴリは互いに排他的ではありません。
1つの文字が複数のカテゴリに属することは普通にあります。

        各バッファには"カテゴリテーブル"（category table）があり、
どのカテゴリが定義済みでどの文字がどのカテゴリに属するかを記録しています。
各カテゴリテーブルはそれ独自のカテゴリ群を定義しますが、
それらは標準のカテゴリテーブルをコピーして普通は初期化されます。
そのため、すべてのモードで標準のカテゴリを使えます。

        各カテゴリには名前があり、それは` 'から`~'までの
範囲のASCII印字文字です。
`define-category'でカテゴリを定義するときにその名前を指定します。

        カテゴリテーブルは実際には文字テーブル（*note
Char-Tables::）です。 カテゴリテーブルの添字Cの要素は、
"カテゴリ集合"（category set）です。
これはブールベクトルであり、文字Cが属するカテゴリ群を表します。
このカテゴリ集合において、添字CATの要素が`t'であると、
CATは集合の要素であることを意味し、
当該文字CはカテゴリCATに属することを意味します。

      -- Function: define-category char docstring &optional table
          この関数は、名前をCHAR、説明文字列をDOCSTRINGとして
          新たなカテゴリを定義する。

          新たなカテゴリは、カテゴリテーブルTABLEに対して定義される。
          TABLEのデフォルトは、カレントバッファのカテゴリテーブルである。

      -- Function: category-docstring category &optional table
          この関数は、カテゴリテーブルTABLEのカテゴリCATEGORYの
          説明文字列を返す。

               (category-docstring ?a)
                    => "ASCII"
               (category-docstring ?l)
                    => "Latin"

      -- Function: get-unused-category table
          この関数は、カテゴリテーブルTABLEで現在定義されていない
          新たなカテゴリ名（文字）を返す。
          TABLEにおいて可能なすべてのカテゴリが使用済みであると`nil'を返す。

      -- Function: category-table
          この関数は、カレントバッファのカテゴリテーブルを返す。

      -- Function: category-table-p object
          この関数は、OBJECTがカテゴリテーブルであると`t'を返し、
          さもなければ`nil'を返す。

      -- Function: standard-category-table
          この関数は、標準のカテゴリテーブルを返す。

      -- Function: copy-category-table &optional table
          この関数は、カテゴリテーブルTABLEのコピーを作成しそれを返す。
          TABLEを指定しない（あるいは`nil'）と、
          現在のカテゴリテーブルのコピーを返す。
          TABLEがカテゴリテーブルでないとエラーを通知する。

      -- Function: set-category-table table
          この関数は、カレントバッファのカテゴリテーブルをTABLEとする。
          TABLEを返す。

      -- Function: make-category-set categories
          この関数は、新たなカテゴリ集合、つまり、
          文字列CATEGORIESに指定したカテゴリで
          内容を初期化したブールベクトルを返す。
          CATEGORIESの要素はカテゴリ名であること。
          新たなカテゴリ集合では、CATEGORIESの各カテゴリに対しては`t'を
          それ以外のカテゴリに対しては`nil'を設定する。

               (make-category-set "al")
                    => #&128"\0\0\0\0\0\0\0\0\0\0\0\0\2\20\0\0"

      -- Function: char-category-set char
          この関数は、文字CHARに対するカテゴリ集合を返す。
          これは、文字CHARが属するカテゴリ群を記録したブールベクトルである。
          関数`char-category-set'は、カテゴリテーブルに
          存在する同じブールベクトルを返すため、新たな領域を割り付けない。

               (char-category-set ?a)
                    => #&128"\0\0\0\0\0\0\0\0\0\0\0\0\2\20\0\0"

      -- Function: category-set-mnemonics category-set
          この関数は、カテゴリ集合CATEGORY-SETを
          この集合に属するすべてのカテゴリの名前からなる文字列に変換する。

               (category-set-mnemonics (char-category-set ?a))
                    => "al"

      -- Function: modify-category-entry character category &optional
               table reset
          この関数は、カテゴリテーブルTABLE（デフォルトはカレントバッファの
          カテゴリテーブル）内の文字CHARACTERのカテゴリ集合を変更する。

          普通、カテゴリ集合にCATEGORYを追加して変更する。
          しかし、RESETが`nil'以外であるとCATEGORYを削除する。



File: elisp-ja,  Node: Abbrevs,  Next: Processes,  Prev: Syntax Tables,  Up: Top

35 略語と略語の展開 _(2003/10/30)_
******************************************

     "略語"(abbrev) とは、より長い文字列へ展開される文字の列のことです。
ユーザーが略語の文字列を挿入すると、その展開形に自動的に置換されます。
これにより打鍵量を省けます。

        現在有効な略語の集まりは、"略語表"(abbrev table)
に記録されています。 各バッファにはローカルな略語表がありますが、
通常、同じメジャーモードのすべてのバッファは 1 つの略語表を共有します。
グローバルな略語表もあります。 通常、両方を使います。

略語表は、各略語に対するシンボルを収めたオブジェクト配列として表現されます。
シンボルの名前が略語です。
その値は展開形であり、その関数定義は展開を行うフック関数です。
その属性リストのセルには略語を展開した回数である利用回数が入ります。
それらのシンボルは、通常のオブジェクト配列にはインターンされませんから、
Lisp 式を読み取った結果には、それらはけっして現れません。
実際、略語を扱うコード以外では、それらはけっして使われません。
したがって、それらをかなり非標準的に使っても安全です。 *Note Creating
Symbols::。

        ユーザーレベルの略語コマンドについては、 *note 略語の利用法:
(emacs)Abbrevs.を参照してください。

     * Menu:

     * Abbrev Mode::                 Setting up Emacs for abbreviation.
     * Tables: Abbrev Tables.        Creating and working with abbrev tables.
     * Defining Abbrevs::            Specifying abbreviations and their expansions.
     * Files: Abbrev Files.          Saving abbrevs in files.
     * Expansion: Abbrev Expansion.  Controlling expansion; expansion subroutines.
     * Standard Abbrev Tables::      Abbrev tables used by various major modes.


File: elisp-ja,  Node: Abbrev Mode,  Next: Abbrev Tables,  Prev: Abbrevs,  Up: Abbrevs

35.1 略語 (abbrev) モードの設定 _(2003/10/30)_
======================================================

     略語 (abbrev) モードは、変数`abbrev-mode'の値で制御される
マイナモードです。

      -- Variable: abbrev-mode
          この変数の値が`nil'以外であると、
          バッファに略語が挿入されると自動的に展開するようになる。
          値が`nil'であると、略語を定義することはできるが、
          自動的には展開されない。

          この変数は設定されると自動的にバッファローカルになる。

      -- Variable: default-abbrev-mode
          これは、`abbrev-mode'を上書きしていないバッファ向けの
          `abbrev-mode'の値である。 これは`(default-value
          'abbrev-mode)'と同じである。


File: elisp-ja,  Node: Abbrev Tables,  Next: Defining Abbrevs,  Prev: Abbrev Mode,  Up: Abbrevs

35.2 略語表 _(2003/10/30)_
=============================

     本節では、略語表の作成方法と扱い方について述べます。

      -- Function: make-abbrev-table
          この関数は、新たな空の略語表、つまり、
          シンボルを含まないオブジェクト配列を作成して返す。
          この値はゼロで埋められたベクトルである。

      -- Function: clear-abbrev-table table
          この関数は、略語表TABLE内のすべての略語を未定義にして略語表を空にする。
          関数はいつも`nil'を返す。

      -- Function: define-abbrev-table tabname definitions
          この関数は、TABNAME(シンボル) を略語表の名前として定義する。
          つまり、この変数としての値は略語表になる。
          DEFINITIONSに従って略語表に略語を定義する。
          ここで、DEFINITIONSは `(ABBREVNAME EXPANSION HOOK
          USECOUNT)'の形の 要素から成るリストである。
          戻り値はつねに`nil'である。

      -- Variable: abbrev-table-name-list
          その値が略語表であるシンボルのリストである。
          `define-abbrev-table'は、新たな略語表の名前をこのリストに追加する。

      -- Function: insert-abbrev-table-description name &optional human
          この関数は、NAMEで指名される略語表の記述をポイントのまえに挿入する。
          引数NAMEは、その値が略語表であるシンボルである。
          戻り値はつねに`nil'である。

          HUMANが`nil'以外であると、この記述は人間向けである。
          さもなければ、この記述は Lisp 式、つまり、
          NAMEの現在の定義どおりにNAMEを定義するような
          `define-abbrev-table'の呼び出しである。


File: elisp-ja,  Node: Defining Abbrevs,  Next: Abbrev Files,  Prev: Abbrev Tables,  Up: Abbrevs

35.3 略語を定義する _(2003/10/30)_
=========================================

     これらの関数は、指定した略語表に略語を定義します。
`define-abbrev'は下位レベルの基本的な関数ですが、
`add-abbrev'はユーザーに情報を問い合わせるコマンドが使います。

      -- Function: add-abbrev table type arg
          この関数は、ユーザーからの情報に基づいて
          略語表TABLEに略語を追加する。
          引数TYPEは、この略語の種類を英語で表した文字列である
          (典型的には、`"global"'や`"mode-specific"'。)
          この文字列はユーザーへのプロンプトに使われる。
          引数ARGは、展開形の単語数である。

          戻り値は、新たな略語を内部的に表現するシンボルであるか、
          既存の略語を再定義することをユーザーが拒否したときには`nil'である。

      -- Function: define-abbrev table name expansion &optional hook
               count
          略語 (NAME)
          をEXPANSIONに展開し，HOOKを呼び出すように定義する。
          また，オプションであるCOUNTの値は abbrev
          での展開回数の初期値となる．指定 されなければ 0 となる．

          戻り値は、 Emacs 内部で略語を表現するシンボルを返すが、
          その名前はNAMEである。

          引数NAMEは文字列であること。
          引数EXPANSIONは、普通は、目的の展開形 (文字列) であるが、
          略語を未定義にするには`nil'である。
          これが文字列でも`nil'でもなければ、
          略語を『展開する』ときにはHOOKだけを実行する。

          引数HOOKは、関数か`nil'である。 HOOKが`nil'以外であると、
          略語をEXPANSIONに置換し終えてから引数なしで呼ばれる。
          HOOKが呼ばれるときには、 ポイントはEXPANSIONの直後に置かれる。

          略語の利用回数は 0 に初期化される。

      -- User Option: only-global-abbrevs
          この変数が`nil'以外であると、
          ユーザーはグローバルな略語だけを使う意図があることを表す。
          モード固有の略語を定義するコマンドに対して、
          グローバルな略語を定義するように指示する。
          この変数は本節の関数のふるまいを変えることはないが、
          それらを呼び出す側でこの変数を検査している。


File: elisp-ja,  Node: Abbrev Files,  Next: Abbrev Expansion,  Prev: Defining Abbrevs,  Up: Abbrevs

35.4 略語をファイルに保存する _(2003/10/30)_
========================================================

     略語定義を保存したファイルは、実際には、 Lisp
コードのファイルです。 略語は、同じ内容の同じ略語表を定義する Lisp
プログラムの形で保存されます。 したがって、ファイルは`load'(*note How
Programs Do Loading::) で ロードできます。
しかし、関数`quietly-read-abbrev-file'がより便利なインターフェイスを
提供します。

        `save-some-buffers'などのユーザーレベルの機能では、
ここに述べた変数の制御のもとで、略語をファイルに自動的に保存できます。

      -- User Option: abbrev-file-name
          これは、略語を読み込んだり保存するデフォルトのファイル名である。

      -- Function: quietly-read-abbrev-file &optional filename
          この関数は、`write-abbrev-file'で書いておいた
          ファイルFILENAMEから、略語定義を読み取る。
          FILENAMEが省略されるか，`nil'であると、
          `abbrev-file-name'で指定されるファイルを使う。
          `save-abbrevs'に`t'を設定して、変更は保存されるようにする。

          この関数はいっさいメッセージを表示しない。 `nil'を返す。

      -- User Option: save-abbrevs
          `save-abbrev'が`nil'以外の値であると、 Emacs
          はファイルを保存するときに略語も保存する。
          `abbrev-file-name'が略語を保存するファイルを指定する。

      -- Variable: abbrevs-changed
          略語を定義したり変更すると、この変数は`nil'以外に設定される。
          これは、読者の略語を保存する機会を与えるために、 Emacs
          のさまざまなコマンドに対するフラグとして働く。

      -- コマンド: write-abbrev-file &optional filename
          ロードすると同じ略語を定義するような Lisp プログラムの形で、
          ファイルFILENAMEにすべての略語表のすべての略語定義を保存する。
          もしファイル名 (FILENAME) が省略されるか nil であると，
          `abbrev-file-name'で設定したファイルに保存される．
          また，この関数は`nil'を返す。


File: elisp-ja,  Node: Abbrev Expansion,  Next: Standard Abbrev Tables,  Prev: Abbrev Files,  Up: Abbrevs

35.5 略語の探索と展開 _(2003/10/30)_
============================================

     通常、略語は、`self-insert-command'を含む特定の対話的なコマンドに
よって展開されます。
本節では、データのやりとりに使う変数に加えて、そのようなコマンドを書くために
使用するサブルーティンについて述べます。

      -- Function: abbrev-symbol abbrev &optional table
          この関数は、名前ABBREVの略語を表すシンボルを返す。
          そのような略語が定義されていなければ、戻り値は`nil'である。
          省略可能な第 2 引数TABLEは、探索対象の略語表である。
          TABLEが`nil'であると、
          この関数は、まずカレントバッファのローカルな略語表を試し、
          つぎにグローバルな略語表を試す。

      -- Function: abbrev-expansion abbrev &optional table
          この関数は、ABBREVが
          (カレントバッファで使用される略語表での定義どおりに)
          展開されるであろう文字列を返す。
          省略可能な引数TABLEは、`abbrev-symbol'と同様に、
          使用する略語表を指定する。

      -- コマンド: expand-abbrev
          このコマンドは、ポイントのまえの略語をあれば展開する。
          略語の直後にポイントがない場合、このコマンドはなにもしない。
          このコマンドは、展開を行えば展開前の文字を返し、
          さもなければ`nil'を返す。


      -- コマンド: abbrev-prefix-mark &optional arg
          現在のポイント位置を略語の開始位置としてマークする。
          つぎに`expand-abbrev'を呼び出すと、
          通常どおりにポイントのまえの単語を使うかわりに、 ここから
          (その時点での) ポイントまでのテキストを略語として展開する。

      -- User Option: abbrev-all-caps
          これが`nil'以外であると、
          大文字だけで入力された略語を大文字だけで展開する。
          さもなければ、大文字だけで入力された略語は、
          展開形の各単語を大文字で始めるように展開される。

      -- Variable: abbrev-start-location
          これは、`expand-abbrev'がつぎに展開する略語の開始位置として使う
          バッファ内位置である。
          (`nil'であると、そのかわりにポイントのまえの単語を使う意味である。)
          `expand-abbrev'が呼び出されるたびに、
          `abbrev-start-location'は`nil'に設定される。
          この変数は、`abbrev-prefix-mark'でも設定される。

      -- Variable: abbrev-start-location-buffer
          この変数の値は、`abbrev-start-location'が設定されたバッファである。
          別のバッファで略語を展開しようとすると`abbrev-start-location'は
          クリアされる。 この変数は`abbrev-prefix-mark'が設定する。

      -- Variable: last-abbrev
          これは、もっとも最近に略語展開された`abbrev-symbol'
          (略語を表すシンボル) である。
          この情報は、コマンド`unexpand-abbrev'向けに
          `expand-abbrev'が残す (*note 略語展開の制御: (emacs)Expanding
          Abbrevs.)  。

      -- Variable: last-abbrev-location
          これは、もっとも最近に略語展開した箇所である。
          これは、コマンド`unexpand-abbrev'向けに
          `expand-abbrev'が残した情報を保持する。

      -- Variable: last-abbrev-text
          これは、もっとも最近に略語展開したときの (あれば)
          大文字小文字変換後の 展開形のテキストである。
          略語展開を取り消すと、この値は`nil'である。
          これは、コマンド`unexpand-abbrev'向けに
          `expand-abbrev'が残した情報を保持する。

      -- Variable: pre-abbrev-expand-hook
          これは、任意の略語を展開する直前に順に実行される関数を
          収めたノーマルフックである。 *note Hooks::。
          ノーマルフックなので、フック関数は引数を受け取らない。
          しかし、バッファでポイントのまえを調べることで
          展開すべき略語をみつけることができる。
          また，このフックは`expand-abbrev'が実行する最初の処理であるため，展開される
          語を探す前に現在の展開表を変更することもできる．

        以下のコード例は、`pre-abbrev-expand-hook'の使い方を示します。
ユーザーが略語を句読点文字で終えると、フック関数が確認を求めます。
したがって、このフックにより、ユーザーは展開の可否を決定でき、
了承しなかったときには展開を止められます。

          (add-hook 'pre-abbrev-expand-hook 'query-if-not-space)

          ;; この関数は、`pre-abbrev-expand-hook'が起動する

          ;; ユーザーが略語を空白で終えると、この関数はなにもしない
          ;; (つまり、略語を展開できるように戻る)
          ;; ユーザーがその他の文字を入力したら、
          ;; この関数は展開するかどうかを問い合わせる

          ;; ユーザーがプロンプトに`y'で答えたら、
          ;; (関数`not'を使っているので) この関数は`nil'を返すが
          ;; 問題ない。戻り値は展開には影響しない

          (defun query-if-not-space ()
            (if (/= ?\  (preceding-char))
                (if (not (y-or-n-p "Do you want to expand this abbrev? "))
                    (error "Not expanding this abbrev"))))


File: elisp-ja,  Node: Standard Abbrev Tables,  Prev: Abbrev Expansion,  Up: Abbrevs

35.6 標準の略語表 _(2003/10/30)_
======================================

     Emacs にあらかじめロードされるメジャーモード向けの
略語表を保持する変数一覧を示します。

      -- Variable: global-abbrev-table
          これは、モードに依存しない略語向けの略語表である。
          これに定義された略語は、すべてのバッファに適用される。
          各バッファにはローカルな略語表もあり、
          それらの略語定義はグローバルな略語表の略語定義に優先する。

      -- Variable: local-abbrev-table
          このバッファローカルな変数の値は カレントバッファの
          (モード固有の) 略語表である。

      -- Variable: fundamental-mode-abbrev-table
          これは、基本 (fundamental)
          モードで使われるローカルな略語表である。 いいかえれば、基本
          (fundamental) モードであるすべてのバッファの
          ローカルな略語表である。

      -- Variable: text-mode-abbrev-table
          これは、テキスト (text)
          モードで使われるローカルな略語表である。

      -- Variable: lisp-mode-abbrev-table
          これは、 lisp モードと emacs-lisp
          モードで使われるローカルな略語表である。


File: elisp-ja,  Node: Processes,  Next: Display,  Prev: Abbrevs,  Up: Top

36 プロセス
***************

     オペレーティングシステムの用語では、
"プロセス"（process）とは、プログラムを実行する空間のことです。
Emacsはプロセスとして動いています。 Emacs Lispのプログラムでは、
独自のプロセスとして他のプログラムを起動できます。
それらは、Emacsプロセスの"サブプロセス"（subprocess）とか
"子プロセス"（child process）と呼ばれ、
Emacsプロセスはそれらの"親プロセス"（parent process）です。

        Emacsのサブプロセスは、それを作成する方法に依存して、
"同期"（synchronous）であるか"非同期"（asynchronous）です。
同期サブプロセスを作成すると、
Lispプログラムは実行を継続するまえにそのサブプロセスの終了を待ちます。
非同期サブプロセスを作成すると、それはLispプログラムと並行して動作します。
この種のサブプロセスは、Emacs内部ではやはり『プロセス』と呼ばれる
Lispオブジェクトで表現されます。
Lispプログラムはこのオブジェクトを用いて
サブプロセスと通信したりそれを制御できます。
たとえば、シグナルを送ったり、状態情報を取得したり、
プロセスからの出力を受け取ったり、プロセスへ入力を送れます。

      -- Function: processp object
          この関数は、OBJECTがプロセスであれば`t'を返し、
          さもなければ`nil'を返す。

     * Menu:

     * Subprocess Creation::      Functions that start subprocesses.
     * Shell Arguments::          Quoting an argument to pass it to a shell.
     * Synchronous Processes::    Details of using synchronous subprocesses.
     * Asynchronous Processes::   Starting up an asynchronous subprocess.
     * Deleting Processes::       Eliminating an asynchronous subprocess.
     * Process Information::      Accessing run-status and other attributes.
     * Input to Processes::       Sending input to an asynchronous subprocess.
     * Signals to Processes::     Stopping, continuing or interrupting
                                    an asynchronous subprocess.
     * Output from Processes::    Collecting output from an asynchronous subprocess.
     * Sentinels::                Sentinels run when process run-status changes.
     * Transaction Queues::	     Transaction-based communication with subprocesses.
     * Network::                  Opening network connections.


File: elisp-ja,  Node: Subprocess Creation,  Next: Shell Arguments,  Up: Processes

36.1 サブプロセス作成関数
===================================

プログラムを実行するために新たなサブプロセスを作る関数が3つあります。
その1つ`start-process'は、非同期プロセスを作成して
プロセスオブジェクトを返します（*note Asynchronous Processes::）。
残りの2つ、`call-process'と`call-process-region'は
同期プロセスを作成しますが、プロセスオブジェクトは返しません （*note
Synchronous Processes::）。

        同期／非同期プロセスについては以下の節に述べます。
3つの関数の呼び出し方は類似しているので、
ここではそれらに共通な引数について述べます。

        いずれの場合でも、関数の引数PROGRAMは、
実行すべきプログラムを指定します。
そのファイルがみつからなかったり実行できないと、 エラーを通知します。
ファイル名が相対名であると、
変数`exec-path'は探索すべきディレクトリのリストを保持しています。
Emacsは起動時に環境変数`PATH'の値に基づいて`exec-path'を 初期化します。
`~'、`.'、`..'のファイル名の標準的な書き方は、
`exec-path'でも普通どおりに解釈されますが、
（`$HOME'などの）環境変数の置換は認識しません。
それには`substitute-in-file-name'を使います （*note File Name
Expansion::）。

        サブプロセスを作成する各関数には、
プログラムの標準出力の受け取り場所を指定する
引数BUFFER-OR-NAMEがあります。
これはバッファかバッファ名である必要があります。
バッファ名であると、そのバッファが既存でなければ新たに作成します。
`nil'でもかまいませんが、その場合、
フィルタ関数で処理しない限り出力を破棄します。 （*note Filter
Functions::と*note Read and Print::）。
通常、複数のプロセスの出力を同じバッファへは送らないようにします。
それらの出力がでたらめに混ざってしまうからです。

        サブプロセスを作成する3つの関数すべてに、
`&rest'引数であるARGSがあります。 ARGSはすべてが文字列である必要があり、
それぞれを区切ってコマンド行引数としてPROGRAMに与えられます。
引数全体を指定されたプログラムへ直接渡すため、
これらの引数ではワイルドカード文字や他のシェル構文の特別な意味はありません。

        *注意*：` '引数PROGRAMにはプログラムの名前だけを指定し、
コマンド行引数はいっさい指定しない。 コマンド行引数はARGSで与えること。

        サブプロセスのカレントディレクトリは
`default-directory'の値で決まります（*note File Name Expansion::）。

        サブプロセスはEmacsから環境変数を継承しますが、
優先するものを`process-environment'で指定できます。 *Note System
Environment::。

      -- Variable: exec-directory
          この変数の値は、Emaccsが起動することを意図した GNU
          Emacsとともに配布されたプログラム群を収めたディレクトリ名
          （文字列）である。
          プログラム`movemail'はそのようなプログラムの例であり、
          inboxから新たなメイルを取り出すためにrmailが利用する。

      -- User Option: exec-path
          この変数の値は、サブプロセスで実行するプログラムを探索する
          ディレクトリのリストである。
          各要素はディレクトリ名（文字列）であるか、
          デフォルトディレクトリ（つまり`default-directory'の値）
          を意味する`nil'である。 

          引数PROGRAMが絶対ファイル名でないと、
          `call-process'と`start-process'は `exec-path'の値を使う。


File: elisp-ja,  Node: Shell Arguments,  Next: Synchronous Processes,  Prev: Subprocess Creation,  Up: Processes

36.2 シェル引数
====================

     Lispプログラムから、
ユーザーが指定したファイル名を含んだコマンドを指定して
シェルを実行する必要がときどきあります。
これらのプログラムでは、任意の正しいファイル名を扱える必要があります。
しかし、シェルは、特定の文字がファイル名として現れると特別に扱うので、
そのような文字がシェルに混乱をもたらします。
そのような文字を扱うには、関数`shell-quote-argument'を使います。

      -- Function: shell-quote-argument argument
          この関数は、ARGUMENTを実際の内容とする
          シェル構文で表した引数を文字列で返す。
          この戻り値をシェルコマンドに連結し、
          実行のためにシェルに渡しても問題を生じないはずである。

          この関数が行うことの詳細は読者のオペレーティングシステムに依存する。
          この関数は通常のシェル構文に合うように設計してある。
          非標準のシェルを使う場合には、この関数を再定義する必要があろう。
          MS-DOSでは、この関数はARGUMENTを無変更で返す。
          MS-DOSのシェルにはクォートの機能がないため、
          これは本当は正しいことではないが最良のことである。

               ;; つぎの例はGNUとUNIXシステムのふるまいである
               (shell-quote-argument "foo > bar")
                    => "foo\\ \\>\\ bar"

          シェルコマンドを作る`shell-quote-argument'の使用例をつぎに示す。

               (concat "diff -c "
                       (shell-quote-argument oldfile)
                       " "
                       (shell-quote-argument newfile))


File: elisp-ja,  Node: Synchronous Processes,  Next: Asynchronous Processes,  Prev: Shell Arguments,  Up: Processes

36.3 同期プロセスの作成
================================

     "同期プロセス"（synchronous process）を作成すると、
Emacsは実行を続行するまえにそのプロセスが終了するのを待ちます。
diredはその例です。
`ls'を同期プロセスで実行し、その出力を少々修正します。
プロセスは同期なので、Emacsがなにかを行おうとするまえに
ディレクトリ一覧全部がバッファに届きます。

        Emacsは同期サブプロセスの終了を待ちますが、
ユーザーは`C-g'と打って中断できます。
`C-g'はまずシグナル`SIGINT'でサブプロセスをキルしようとしますが、
中断を完了するまえにサブプロセスが終了するのを待ちます。
その期間にユーザーがさらに`C-g'を打つと、
`SIGKILL'でサブプロセスを即座にキルし、ただちに中断を完了します。 *Note
Quitting::。

        同期サブプロセス作成関数は、
そのプロセスがどのように終了したかを表すものを返します。

        同期サブプロセスからの出力は、ファイルから読むテキストと同様に、
コーディングシステムを用いて一般には復号化します。
`call-process-region'がサブプロセスへ送る入力は、
ファイルへ書くテキストと同様に、
コーディングシステムを用いて符号化します。 *Note Coding Systems::。

      -- Function: call-process program &optional infile destination
               display &rest args
          この関数は、別のプロセスでPROGRAMを呼び出し、
          それが終了するのを待つ。

          INFILEが`nil'でなければ プロセスへの標準入力はINFILEであるが、
          さもなければ`/dev/null'である。
          引数DESTINATIONでプロセスの出力先をつぎのように指定する。

         バッファ
               このバッファのポイントのまえに出力を挿入する。
               これにはプロセスの標準出力と標準エラーの両者を含む。

         文字列
               文字列で指定した名前のバッファのポイントのまえに出力を挿入する。

         `t'
               カレントバッファのポイントのまえに出力を挿入する。

         `nil'
               出力を破棄する。

         0
               出力を破棄し、サブプロセスの終了を待たずにただちに戻る。

               この場合、このプロセスはEmacsと並行して動作するので真のサブプロセスではない。
               しかし、この関数から戻るとEmacsはサブプロセスの処理を本質的には終えたと
               いう意味で同期プロセスと考えることができる。

         `(REAL-DESTINATION ERROR-DESTINATION)'
               標準出力と標準エラーを分離し、
               REAL-DESTINATIONの指定に従って通常の出力を扱い、
               ERROR-DESTINATIONに従ってエラー出力を処理する。
               ERROR-DESTINATIONが`nil'であるとエラー出力を破棄し、
               `t'であると通常の出力に混ぜ、
               文字列であるとその名前のファイルにエラー出力を振り向ける。

               エラー出力を入れるバッファを直接に指定することはできない。
               それを実装するのは難しすぎる。
               しかし、エラー出力を一時ファイルへ送ってから
               そのファイルをバッファに挿入すれば、同じ効果を得られる。

          DISPLAYが`nil'以外であると、`call-process'は、
          出力が挿入されるとバッファを再表示する。
          （しかし、コーディングシステムとして実際のデータから
          コーディングシステムを推定する`undecided'を指定していると、
          非ASCII文字に出会うと再表示を継続できない場合もある。
          これを修正するのが困難である根本的な理由がある。）
          さもなければ、関数`call-process'は再表示しないので、
          Emacsが通常の過程でそのバッファを再表示するまでは、
          スクリーン上で結果は見えない。

          残りの引数ARGSは、プログラムに対する
          コマンド行引数を指定する文字列である。

          （待たないように指示しない限り）`call-process'が返す値は、
          プロセスの終了理由を表す。 数でサブプロセスの終了状態を表し、
          0は成功、それ以外の値は失敗を意味する。
          プロセスがシグナルで終了すると、
          `call-process'はシグナルを記述する文字列を返す。

          つぎの例では、バッファ`foo'がカレントである。

               (call-process "pwd" nil t)
                    => nil

               ---------- Buffer: foo ----------
               /usr/user/lewis/manual
               ---------- Buffer: foo ----------

               (call-process "grep" nil "bar" nil "lewis" "/etc/passwd")
                    => nil

               ---------- Buffer: bar ----------
               lewis:5LTsHm66CSWKg:398:21:Bil Lewis:/user/lewis:/bin/csh

               ---------- Buffer: bar ----------

          `insert-directory'の定義にある`call-process'の
          よい使用例をつぎに示す。

               (call-process insert-directory-program nil t nil SWITCHES
                             (if full-directory-p
                                 (concat (file-name-as-directory file) ".")
                               file))

      -- Function: call-process-region start end program &optional
               delete destination display &rest args
          この関数は、PROGRAMを動かすプロセスの標準入力として
          STARTとENDのあいだのテキストを送る。
          DELETEが`nil'以外であると、送ったテキストを削除する。
          これは、カレントバッファに送った入力のかわりに出力を挿入することを
          意味するDESTINATIONが`t'であるときに有用である。

          引数DESTINATIONとDISPLAYは、
          サブプロセスからの出力をどのように扱い、
          出力か到着するたびに表示を更新するかどうかを制御する。
          詳しくは、上記の`call-process'の記述を参照。
          DESTINATIONが整数0であると、
          `call-process-region'は、サブプロセスの終了を待たずに
          出力を破棄してただちに`nil'を返す。

          残りの引数ARGSは、プログラムに対する
          コマンド行引数を指定する文字列である。

          `call-process-region'の戻り値は`call-process'と同様であり、
          待たずに戻るように指示すると`nil'であり、
          さもなければサブプロセスの終了状態を表す数か文字列である。

          つぎの例では、
          バッファ`foo'の始めの5文字（単語`input'）を標準入力として
          ユーティリティ`cat'を実行するために`call-process-region'を使う。
          `cat'は、標準入力を標準出力へコピーする。
          引数DESTINATIONが`t'であるので、
          出力はカレントバッファに挿入される。

               ---------- Buffer: foo ----------
               input-!-
               ---------- Buffer: foo ----------

               (call-process-region 1 6 "cat" nil t)
                    => nil

               ---------- Buffer: foo ----------
               inputinput-!-
               ---------- Buffer: foo ----------

          コマンド`shell-command-on-region'は、
          つぎのように`call-process-region'を使う。

               (call-process-region
                start end
                shell-file-name      ; プログラムの名前
                nil                  ; リージョンを削除しない
                buffer               ; 出力は`buffer'へ入れる
                nil                  ; 出力中は再表示しない
                "-c" command)        ; シェルに対する引数

      -- Function: shell-command-to-string command
          この関数は、シェルコマンドとしてCOMMAND（文字列）を実行し、
          コマンドの出力を文字列として返す。


File: elisp-ja,  Node: Asynchronous Processes,  Next: Deleting Processes,  Prev: Synchronous Processes,  Up: Processes

36.4 非同期プロセスの作成
===================================

     "非同期プロセス"を作成すると、Emacsとサブプロセスの両者は
ただちに動作を継続します。 そしてプロセスはEmacsと並行に動作し、
両者は以下の節に述べる関数を用いて互いに通信できます。
しかし、通信は部分的に非同期です。
特定の関数を呼び出したときにだけEmacsはプロセスへデータを送り、
Emacsが入力待ちか時間待ちをしているときにだけ
プロセスからの出力を受け取れます。

        ここでは、非同期プロセスの作成方法について述べます。

      -- Function: start-process name buffer-or-name program &rest args
          この関数は、新たな非同期サブプロセスを作成し、
          そのプロセスでプログラムPROGRAMを走らせる。
          Lispにおいて新たなサブプロセスを表すプロセスオブジェクトを返す。
          引数NAMEはプロセスオブジェクトの名前を指定する。
          その名前のプロセスがすでに存在すると、
          名前を一意にするために（`<1>'などを付加して）NAMEを修正する。
          バッファBUFFER-OR-NAMEは、そのプロセスに対応付けるバッファである。

          残りの引数ARGSは、プログラムに対する
          コマンド行引数を指定する文字列である。

          つぎの例では、最初のプロセスは動き始めると
          100秒間（休止ではなく）動作する。
          そのあいだに2番目のプロセスを動かし始めると、
          一意であるためにそれには名前`my-process<1>'が与えられる。
          2番目のプロセスは、最初のプロセスが終了するまえに
          バッファ`foo'にディレクトリ一覧を挿入する。
          2番目のプロセスが終了するとそれを表すメッセージがバッファに挿入される。
          しばらくして最初のプロセスが終了すると、
          別のメッセージがバッファに挿入される。

               (start-process "my-process" "foo" "sleep" "100")
                    => #<process my-process>

               (start-process "my-process" "foo" "ls" "-l" "/user/lewis/bin")
                    => #<process my-process<1>>

               ---------- Buffer: foo ----------
               total 2
               lrwxrwxrwx  1 lewis     14 Jul 22 10:12 gnuemacs --> /emacs
               -rwxrwxrwx  1 lewis     19 Jul 30 21:02 lemon

               Process my-process<1> finished

               Process my-process finished
               ---------- Buffer: foo ----------

      -- Function: start-process-shell-command name buffer-or-name
               command &rest command-args
          この関数は`start-process'と同様であるが、
          指定したコマンドを実行するためにシェルを用いる点が異なる。
          引数COMMANDはシェルコマンドの名前であり、
          COMMAND-ARGSはそのシェルコマンドに対する引数である。
          変数`shell-file-name'は、使用するシェルを指定する。

          `start-process'で直接にではなく
          シェルを介してプログラムを実行すると、
          引数のワイルドカードなどのシェルの機能を利用できる。
          つまり、ユーザー指定の任意のファイル名をコマンドに入れる場合には、
          まえもって`shell-quote-argument'でクォートし、
          ファイル名内のシェルの特別な文字が
          そのような特別な意味を持た_ない_ようにする。 *note Shell
          Arguments::。

      -- Variable: process-connection-type
          この変数は、非同期サブプロセスとの通信に用いる装置の型を制御する。
          これが`nil'以外であると疑似端末PTYを利用できる場合にはそれを用る。
          さもなければパイプを用いる。

          シェル（shell）モードなどのユーザーに見えるプロセス向けには、
          パイプでは不可能なプロセスとその子プロセスとのあいだで
          ジョブ制御（`C-c'、`C-z'など）を許すので
          疑似端末PTYが望ましい。
          プログラムの内部目的向けに使われるサブプロセスでは、
          効率的なパイプを用いるほうがよい。
          また、多くのシステムでは疑似端末PTYの総数には制約があり、
          それらを浪費しないほうがよい。

          `process-connection-type'の値は
          `start-process'を呼び出したときに使われる。
          したがって、`start-process'の呼び出しの周りでこの変数を束縛することで、
          1つのサブプロセスに対する通信方法を指定できる。

               (let ((process-connection-type nil))  ; パイプを使う
                 (start-process ...))

          サブプロセスが実際にはパイプか疑似端末PTYのどちらを
          使っているかを調べるには、関数`process-tty-name'を使う
          （*note Process Information::）。


File: elisp-ja,  Node: Deleting Processes,  Next: Process Information,  Prev: Asynchronous Processes,  Up: Processes

36.5 プロセスの削除
==========================

     "プロセスを削除する"とは、サブプロセスからEmacsをただちに切り離し、
サブプロセスを活性なプロセスリストから取り除くことです。
サブプロセスへシグナルを送ってサブプロセスを終了させますが、
ただちに終了するとは保証されません。
プロセスオブジェクトを指すLispオブジェクトがある限り、
プロセスオブジェクトは存在し続けます。
プロセスマークは以前と同様に同じ場所
（プロセスからの出力をバッファに挿入した箇所）を指し続けます。

        プロセスはいつでも明示的に削除できます。
プロセスは終了後に自動的に削除されますが、
終了後ただちにではありません。
終了したプロセスが自動的に削除されるまえに明示的に削除しても無害です。

      -- User Option: delete-exited-processes
          この変数は、（`exit'を呼び出すかシグナルのために）終了した
          プロセスの自動削除を制御する。
          `nil'であると、ユーザーが`list-processes'を
          実行するまで存在し続ける。
          さもなければ、終了後にただちに削除する。

      -- Function: delete-process name
          この関数は、NAMEに対応付けられたプロセスを
          シグナル`SIGHUP'でキルし削除する。
          引数は、プロセス、プロセス名、バッファ、バッファ名のいずれかである。

               (delete-process "*shell*")
                    => nil

      -- Function: process-kill-without-query process &optional do-query
          この関数は、Emacsを終了するときにプロセスPROCESSが動作中であると、
          ユーザーに問い合わせるかどうかを指定する。
          DO-QUERYが`nil'であると、プロセスを黙って削除する。
          さもなければ、Emacsはプロセスのキルに関して問い合わせる。

          問い合わせるようにしてあったプロセスであると戻り値は`t'であり、
          さもなければ戻り値は`nil'である。
          新たに作成されたプロセスは、つねに問い合わせ用になっている。

               (process-kill-without-query (get-process "shell"))
                    => t


File: elisp-ja,  Node: Process Information,  Next: Input to Processes,  Prev: Deleting Processes,  Up: Processes

36.6 プロセス情報
=======================

     プロセスに関する情報を返す関数がいくつかあります。
`list-processes'は対話的利用のためにあります。

      -- コマンド: list-processes
          このコマンドは、活性なすべてのプロセスの一覧を表示する。
          さらに、`Exited'や`Signaled'である状態の
          プロセスをすべて削除する。 `nil'を返す。

      -- Function: process-list
          この関数は、削除されていないすべてのプロセスのリストを返す。

               (process-list)
                    => (#<process display-time> #<process shell>)

      -- Function: get-process name
          この関数はNAMEという名前のプロセスを返す。
          あるいは、そのようなプロセスがなければ`nil'を返す。
          NAMEが文字列でないとエラーを通知する。

               (get-process "shell")
                    => #<process shell>

      -- Function: process-command process
          この関数は、プロセスPROCESSを始動するために実行したコマンドを返す。
          これは文字列のリストであり、
          最初の文字列は実行されたプログラム、
          残りの文字列はそのプログラムに与えた引数である。

               (process-command (get-process "shell"))
                    => ("/bin/csh" "-i")

      -- Function: process-id process
          この関数は、プロセスPROCESSのプロセス番号PIDを返す。
          これは同じ計算機上で動いている他のすべてのプロセスと
          プロセスPROCESSを区別するための整数である。
          プロセスのPIDは、プロセスを始動したときに
          オペレーティングシステムのカーネルが選び、
          プロセスが終了するまで変わらない。

      -- Function: process-name process
          この関数はプロセスPROCESSの名前を返す。

      -- Function: process-contact process
          この関数は、通常の子プロセスに対しては`t'を返し、
          ネットワーク接続に対しては`(HOSTNAME SERVICE)'を返す （*note
          Network::）。

      -- Function: process-status process-name
          この関数は、PROCESS-NAMEの状態をシンボルとして返す。
          引数PROCESS-NAMEは、プロセス、バッファ、プロセス名（文字列）、
          バッファ名（文字列）のいずれかであること。

          実際のサブプロセスに対して可能な値はつぎのとおり。

         `run'
               実行中のプロセスである。

         `stop'
               一時停止しているが継続可能である。

         `exit'
               終了したプロセス。

         `signal'
               致命的なシグナルを受け取ったプロセスである。

         `open'
               ネットワーク接続を開いている。

         `closed'
               ネットワーク接続は閉じている。
               接続をいったん閉じるとそれを再度開くことはできないが、
               同じ接続先へ新たな接続を開くことはできる。

         `nil'
               PROCESS-NAMEは既存プロセスの名前ではない。

               (process-status "shell")
                    => run
               (process-status (get-buffer "*shell*"))
                    => run
               x
                    => #<process xx<1>>
               (process-status x)
                    => exit

          ネットワーク接続では、`process-status'は
          シンボル`open'か`closed'のいずれかを返す。
          後者は、相手側が接続を閉じたか
          Emacsが`delete-process'を行ったことを表す。

      -- Function: process-exit-status process
          この関数は、プロセスPROCESSの終了状態か、
          プロセスをキルしたシグナル番号を返す。
          （どちらであるかを判定するには、`process-status'の結果を用いる。）
          PROCESSが終了していないと値は0である。

      -- Function: process-tty-name process
          この関数は、プロセスPROCESSがEmacsとの通信に用いている端末名を返す。
          あるいは、端末のかわりにパイプを用いていれば`nil'を返す
          （*note Asynchronous
          Processes::の`process-connection-type'を参照）。

      -- Function: process-coding-system process
          この関数は、プロセスPROCESSからの出力を
          復号化するために用いているコーディングシステムと、
          PROCESSへの入力を符号化するために用いている
          コーディングシステムを記述するコンスセルを返す。

               (CODING-SYSTEM-FOR-DECODING . CODING-SYSTEM-FOR-ENCODING)

      -- Function: set-process-coding-system process decoding-system
               encoding-system
          この関数は、プロセスPROCESSからの以降の出力および入力に用いる
          コーディングシステムを指定する。
          サブプロセスから出力の復号化にはDECODING-SYSTEMを使い、
          サブプロセスの入力の符号化にはENCODING-SYSTEMを使う。


File: elisp-ja,  Node: Input to Processes,  Next: Signals to Processes,  Prev: Process Information,  Up: Processes

36.7 プロセスへ入力を送る
===================================

     本節の関数を用いてEmacsが入力を送ると、
非同期プロセスは入力を受け取ります。
入力の送先であるプロセスと、送るべき入力データを指定する必要があります。
そのデータは、サブプロセスの『標準入力』に現れます。

        疑似端末PTYのバッファ付き入力の容量に上限がある
オペレーティングシステムもあります。
そのようなシステムでは、Emacsは他の文字に混ぜて定期的にEOFを送り、
文字が流れるように強制します。
ほとんどのプログラムでは、このようなEOFは無害なはずです。

        ファイルに書き込むテキストと同様に、
サブプロセスの入力は、サブプロセスがそれを受け取るまえに
コーディングシステムを用いて普通は符号化されます。
`set-process-coding-system'で 使用するコーディングシステムを指定できます
（*note Process Information::）。
さもなければ、`coding-system-for-write'が
`nil'以外であればこれを使います。
それ以外ではデフォルトの機構で決まるものを使います （*note Default
Coding Systems::）。

      -- Function: process-send-string process-name string
          この関数は、文字列STRINGの内容を
          標準入力としてプロセスPROCESS-NAMEに送る。
          引数PROCESS-NAMEは、プロセスかプロセス名であること。
          これが`nil'であると、カレントバッファのプロセスを用いる。

          関数は`nil'を返す。

               (process-send-string "shell<1>" "ls\n")
                    => nil


               ---------- Buffer: *shell* ----------
               ...
               introduction.texi               syntax-tables.texi~
               introduction.texi~              text.texi
               introduction.txt                text.texi~
               ...
               ---------- Buffer: *shell* ----------

      -- コマンド: process-send-region process-name start end
          この関数は、STARTとENDで定義される領域内のテキストを
          標準入力としてプロセスPROCESS-NAMEへ送る。
          PROCESS-NAMEはプロセスかプロセス名であること。
          （`nil'であると、カレントバッファのプロセスを使う。）

          STARTとENDのどちらかが
          カレントバッファ内の位置を表す整数でもマーカでもないと、
          エラーを通知する。
          （どちらが大きな数であるかは重要ではない。）

      -- Function: process-send-eof &optional process-name
          この関数は、プロセスPROCESS-NAMEが入力で
          「ファイルの終りEOF」を見るようにする。
          EOFはそれまでに送ったテキストのあとにある。

          PROCESS-NAMEを指定しなかったり`nil'であると、
          この関数はカレントバッファのプロセスにEOFを送る。
          カレントバッファにプロセスがないとエラーを通知する。

          関数はPROCESS-NAMEを返す。

               (process-send-eof "shell")
                    => "shell"


File: elisp-ja,  Node: Signals to Processes,  Next: Output from Processes,  Prev: Input to Processes,  Up: Processes

36.8 プロセスにシグナルを送る
=========================================

     サブプロセスに"シグナルを送る"ことは、
サブプロセスの動作に割り込む一方法です。
それぞれ独自の意味を持つ異なるシグナルがいくつかあります。
一連のシグナルとそれらの名前は、オペレーティングシステムが定義します。
たとえば、シグナル`SIGINT'は、ユーザーが`C-c'を打った、
あるいは、それと同様なことが起こったことを意味します。

        各シグナルには、サブプロセスに対する標準的な効果があります。
ほとんどのシグナルはサブプロセスをキルしますが、
その実行を一時停止したり再開するものもあります。
プログラムがシグナルを処理している場合には、
シグナルの効果を一般的に述べることはできません。

        本節の関数を呼び出してシグナルを明示的に送ることができます。
また、Emacsは特定の場面で自動的にシグナルを送ります。
バッファを削除すると、そのバッファに対応付けられているすべての
プロセスにシグナル`SIGHUP'を送ります。
Emacsを終了するときには、動作しているすべてのサブプロセスに
シグナル`SIGHUP'を送ります。
（`SIGHUP'は、ユーザーが電話を切ったことを普通は表すシグナル。）

        シグナルを送る各関数は、省略可能な2つの引数、
PROCESS-NAMEとCURRENT-GROUPを受け付けます。

        引数PROCESS-NAMEは、プロセス、プロセス名、`nil'のいずれかです。
これが`nil'であると、カレントバッファに対応付けられているプロセスが
デフォルトになります。
PROCESS-NAMEがプロセスを指定しないとエラーを通知します。

        引数CURRENT-GROUPは、Emacsのサブプロセスとして
ジョブ制御可能なシェルを実行しているときに違いが現れるフラグです。
これが`nil'以外であると、
Emacsがサブプロセスとの通信に用いている端末の現在のプロセスグループに
シグナルを送ります。 プロセスがジョブ制御可能なシェルであると、
これはシェルの現在のサブジョブ (1) であることを意味します。
`nil'であると、Emacsのサブプロセスの直接のプロセスグループに
シグナルを送ります。
プロセスがジョブ制御可能なシェルであると、これはシェルそのものです。

オペレーティングシステムはパイプではプロセスグループを扱わないため、
サブプロセスとの通信にパイプを用いている場合には、
フラグCURRENT-GROUPには効果はありません。
同じ理由で、パイプを用いている場合には
ジョブ制御可能なシェル（のジョブ制御機能）は働きません。 *note
Asynchronous Processes::の `process-connection-type'を参照してください。

      -- Function: interrupt-process &optional process-name
               current-group
          この関数は、プロセスPROCESS-NAMEに
          シグナル`SIGINT'を送って割り込む。
          Emacsの外側では、『割り込み文字』（普通、`C-c'であるシステムもあり、
          その他のシステムでは`DEL'）を打つとこのシグナルを送る。
          引数CURRENT-GROUPが`nil'以外であると、
          この関数は、Emacsがサブプロセスと通信している端末上で
          『`C-c'を打つ』と考えることができる。

      -- Function: kill-process &optional process-name current-group
          この関数は、プロセスPROCESS-NAMEに
          シグナル`SIGKILL'を送ってキルする。
          このシグナルはサブプロセスを即座にキルし、
          サブプロセスはこれを処理できない。

      -- Function: quit-process &optional process-name current-group
          この関数は、プロセスPROCESS-NAMEにシグナル`SIGQUIT'を送る。
          このシグナルは、『中断文字』
          （Emacsの外側では普通は`C-b'や`C-\'）が
          送るシグナルと同じものである。

      -- Function: stop-process &optional process-name current-group
          この関数は、プロセスPROCESS-NAMEに
          シグナル`SIGTSTP'を送って一時停止させる。
          その実行を再開させるには`continue-process'を使う。

          Emacsの外側でジョブ制御可能なシステムでは、
          『一時停止文字』（普通は`C-z'）が普通はこのシグナルを送る。
          CURRENT-GROUPが`nil'以外であると、
          この関数は、Emacsがサブプロセスと通信している端末上で
          『`C-z'を打つ』と考えることができる。

      -- Function: continue-process &optional process-name current-group
          この関数は、プロセスPROCESSに
          シグナル`SIGTCONT'を送って実行を再開させる。
          以前に一時停止させられたPROCESSを再開する。

      -- Function: signal-process pid signal
          この関数は、必ずしもEmacsの子プロセスではない
          プロセスPIDにシグナルを送る。
          引数SIGNALは、送るべきシグナルを整数で指定する。

        ---------- Footnotes ----------

        (1) 【訳注】シェルのもとで動いているプロセス群


File: elisp-ja,  Node: Output from Processes,  Next: Sentinels,  Prev: Signals to Processes,  Up: Processes

36.9 プロセスからの出力を受け取る
===============================================

     サブプロセスが標準出力に書く出力を受け取る方法は2つあります。
プロセスに対応付けられたバッファに出力を挿入するか、
あるいは、"フィルタ関数"（filter function）と呼ばれる関数を
出力に対して作用させます。
プロセスにバッファもフィルタ関数もなければ、その出力は破棄します。

        サブプロセスからの出力は、Emacsが待っている、つまり、
端末入力を読んでいるとき、 `sit-for'や`sleep-for'を実行中のとき（*note
Waiting::）、 `accept-process-output'（*note Accepting
Output::）を実行中のときに だけ到着します。
これにより、並行プログラムを普通は悩ますような
タイミングエラーの問題を最小に抑えます。
たとえば、安全にプロセスを作成してから、
バッファかフィルタ関数を指定できます。
この処理の途中で待つような基本関数を呼び出さなければ、
出力は到着しません。

        ファイルから読むテキストと同様に、
サブプロセスの出力は、バッファやフィルタ関数が受け取るまえに
コーディングシステムを用いて普通は復号化します。
`set-process-coding-system'で 使用するコーディングシステムを指定できます
（*note Process Information::）。
さもなければ、`coding-system-for-read'が
`nil'以外であればこれを使います。
それ以外ではデフォルトの機構で決まるものを使います （*note Default
Coding Systems::）。

        *警告：*` '
データからコーディングシステムを決定する`undecided'のような
コーディングシステムは、非同期サブプロセスの出力に対しては
完全に信頼性のある動作はできない。
これは、Emacsが非同期サブプロセスの出力が
到着するたびに一塊で処理するからである。
Emacsは1つの塊から正しい変換を検出しようと試みるが、
これがつねに動作するとは限らない。 したがって、可能な限り
文字コード変換と行末変換の両方を指定したコーディングシステムを使う。
つまり、`undecided'や`latin-1'などではなく、
`latin-1-unix'のようなものを使う。

     * Menu:

     * Process Buffers::       If no filter, output is put in a buffer.
     * Filter Functions::      Filter functions accept output from the process.
     * Accepting Output::      Explicitly permitting subprocess output.
                                 Waiting for subprocess output.


File: elisp-ja,  Node: Process Buffers,  Next: Filter Functions,  Up: Output from Processes

36.9.1 プロセスバッファ
-------------------------------

     プロセスには"対応付けられたバッファ"が（普通は）あります。
そのバッファはEmacsの普通のバッファであり、2つの目的に使われます。
プロセスからの出力を保存することと、
プロセスがキルされたことを判定するためです。
バッファを用いてそれを操作しているプロセスを識別することもできます。
普通は1つのバッファに1つのプロセスを対応付けるからです。
プロセスの多くの応用では、プロセスへ送る入力を編集するために
バッファを使いますが、これはEmacs Lispに組み込まれたことではありません。

        プロセスにフィルタ関数（*note Filter Functions::）がなければ、
その出力は対応付けられたバッファに挿入されます。
出力の挿入位置は`process-mark'で決定され、
`process-mark'は挿入したばかりのテキストの末尾を
指すように更新されます。
`process-mark'は普通はバッファの末尾にありますが、
つねにそうであるとは限りません。

      -- Function: process-buffer process
          この関数は、プロセスPROCESSに対応付けられているバッファを返す。

               (process-buffer (get-process "shell"))
                    => #<buffer *shell*>

      -- Function: process-mark process
          この関数は、プロセスPROCESSからの出力を挿入する箇所を指定する
          PROCESSのプロセスマーカを返す。

          PROCESSにバッファがなければ、
          `process-mark'はどこも指していないマーカである。

          バッファにプロセス出力を挿入する際には、
          挿入箇所を決定するためにこのマーカを使用し、
          挿入したテキストの末尾を指すようにこのマーカを更新する。
          これにより、出力の連続した塊を順に挿入できるのである。

          バッファに出力を直接挿入する場合と同様に、
          フィルタ関数はこのマーカを扱うべきである。
          `process-mark'を用いたフィルタ関数の好例は、以下の節にある。

          プロセスへ送るためにユーザーがプロセスバッファに
          入力することが予想されるときは、
          プロセスマーカは新たな入力とそれ以前の出力を区切る。

      -- Function: set-process-buffer process buffer
          この関数は、プロセスPROCESSにバッファBUFFERを対応付ける。
          BUFFERが`nil'であると、
          プロセスに対応付けられたバッファはない。

      -- Function: get-buffer-process buffer-or-name
          この関数はBUFFER-OR-NAMEに対応付けられたプロセスを返す。
          バッファに複数のプロセスが対応付けられている場合には、
          それらの1つを選ぶ。
          （現状では、もっとも最近に作られたプロセスを選ぶ。）
          同じバッファに複数のプロセスを対応付けることは一般にはよくない。

               (get-buffer-process "*shell*")
                    => #<process shell>

          プロセスのバッファを削除すると、
          サブプロセスにシグナル`SIGHUP'を送ってプロセスを削除する
          （*note Signals to Processes::）。


File: elisp-ja,  Node: Filter Functions,  Next: Accepting Output,  Prev: Process Buffers,  Up: Output from Processes

36.9.2 プロセスフィルタ関数
-------------------------------------

     プロセスの"フィルタ関数"（filter function）は、
対応付けられたプロセスからの標準出力を受け取る関数です。
プロセスにフィルタがあると、そのプロセスからの_すべて_の出力は
フィルタに渡されます。 プロセスにフィルタがない場合に限って、
プロセスからの出力向けにプロセスバッファを直接使います。

        フィルタ関数は、Emacsがなにかを待っているときにのみ呼ばれます。
そのような期間にのみプロセスの出力が到着するからです。
Emacsが待つのは、端末入力を読んでいるとき、
`sit-for'や`sleep-for'を実行中のとき（*note Waiting::）、
`accept-process-output'（*note Accepting Output::）を実行中のときです。

        フィルタ関数は2つの引数、
対応付けられたプロセスとそのプロセスから受け取ったばかりの出力である文字列を
受け取ります。 関数は出力に対してなにを行ってもかまいません。

        フィルタ関数の内側では中断は普通は禁止されています。
さもないと、コマンドレベルで打った`C-g'の効果や、
ユーザーコマンドを中断するために打った`C-g'の効果は予測できません。
フィルタ関数の内側で中断を行いたい場合には、
`inhibit-quit'に`nil'を束縛します。 *Note Quitting::。

フィルタ関数の実行中にエラーが発生するとそのエラーは自動的に捕捉され、
フィルタ関数を始動したときに動いていた
プログラムの実行を停止しないようにします。
しかし、`debug-on-error'が`nil'以外であると、 エラーを捕捉しません。
これにより、Lispデバッガでフィルタ関数をデバッグできます。 *Note
Debugger::。

        多くのフィルタ関数は、ときどきあるいはつねに、
プロセスのバッファにテキストを挿入します。
これはフィルタ関数がないときのEmacsの動作を模倣するものです。
そのようなフィルタ関数では、対象のバッファに挿入するために
`set-buffer'を使う必要があります。
カレントバッファをなかば恒久的に切り替えないように、
これらのフィルタ関数はカレントバッファを記録／復元する必要があります。
プロセスマーカを更新し、必要に応じてポイントの値も更新します。
これらはつぎのように行います。

          (defun ordinary-insertion-filter (proc string)
            (with-current-buffer (process-buffer proc)
              (let ((moving (= (point) (process-mark proc))))
                (save-excursion
                  ;; テキストを挿入し、プロセスマーカを進める
                  (goto-char (process-mark proc))
                  (insert string)
                  (set-marker (process-mark proc) (point)))
                (if moving (goto-char (process-mark proc))))))

     カレントバッファを記録／復元するために`save-excursion'ではなく
`with-current-buffer'を使うのは、
2番目の`goto-char'の呼び出しで行うポイントの移動効果を
有効にするためです。

        新たにテキストが到着するたびにプロセスバッファが見えるように
フィルタ関数で強制するには、
つぎのような行を`with-current-buffer'の直前に入れます。

          (display-buffer (process-buffer proc))

ポイント位置に関わらずに新たな出力の末尾にポイントを移動するには、
変数`moving'を削除して、 無条件に`goto-char'を呼び出します。

Emacsの初期の版では、正規表現を探索したり一致処理するフィルタ関数では、
マッチデータを明示的に保存／復元する必要がありました。
今のEmacsは、フィルタ関数に対してはこれを自動的に行いますから、
フィルタ関数で明示的に行う必要はありません。 *Note Match Data::。

        プロセスのバッファに出力を書き込むフィルタ関数は、
そのバッファが有効であるかどうかを検査するべきです。
無効なバッファに挿入しようとするとエラーになります。
バッファが無効であれば、 式`(buffer-name (process-buffer PROCESS))'
を実行すると`nil'を返します。

        関数に渡される出力は任意のサイズの塊できます。
同じ出力を2回生成するプログラムは、
あるときには一度に200文字の塊を1つ送る場合もあれば、
40文字の塊を5つ送る場合もあります。
サブプロセスの出力から特定のテキスト文字列を探すフィルタでは、
そのような文字列が2つかそれ以上の出力の塊に分割される場合も
扱えるようにします。

      -- Function: set-process-filter process filter
          この関数は、プロセスPROCESSにフィルタ関数FILTERを指定する。
          FILTERが`nil'であると、プロセスにフィルタはない。

      -- Function: process-filter process
          この関数は、プロセスPROCESSのフィルタ関数を返す。
          あるいは、フィルタ関数がなければ`nil'を返す。

        フィルタ関数の使用例をつぎに示します。

          (defun keep-output (process output)
             (setq kept (cons output kept)))
               => keep-output
          (setq kept nil)
               => nil
          (set-process-filter (get-process "shell") 'keep-output)
               => keep-output
          (process-send-string "shell" "ls ~/other\n")
               => nil
          kept
               => ("lewis@slug[8] % "
          "FINAL-W87-SHORT.MSS    backup.otl              kolstad.mss~
          address.txt             backup.psf              kolstad.psf
          backup.bib~             david.mss               resume-Dec-86.mss~
          backup.err              david.psf               resume-Dec.psf
          backup.mss              dland                   syllabus.mss
          "
          "#backups.mss#          backup.mss~             kolstad.mss
          ")


File: elisp-ja,  Node: Accepting Output,  Prev: Filter Functions,  Up: Output from Processes

36.9.3 プロセスからの出力を受け取る
-------------------------------------------------

     非同期サブプロセスからの出力は、 Emacsが時間待ちや端末入力などの
なんらかの外部事象を待っているときにのみ到着します。
Lispプログラムから特定の場面で出力の到着を明示的に許したり、
プロセスの出力が到着するのを待つことができると有用なことがあります。

      -- Function: accept-process-output &optional process seconds
               millisec
          この関数は、Emacsにプロセスからの未処理の出力を読み取ることを許す。
          その出力は、対応付けられたバッファに挿入されるか、
          フィルタ関数に与えられる。 PROCESSが`nil'以外であると、
          この関数は、PROCESSからなんらかの出力を得るまで戻らない。

          引数SECONDSとMILLISECは、時間切れを指定する。
          前者は秒単位の時間、後者はミリ秒単位の時間を指定する。
          指定された2つの時間は合計され、
          任意のサブプロセスの出力を受け取ったどうかに関わらず、
          その時間だけ経過すると`accept-process-output'は戻ってくる。

          引数SECONDSは整数である必要はない。
          浮動小数点数であると、この関数は秒未満の時間も待つ。
          秒未満を扱えないシステムもある。
          そのようなシステムでは、SECONDSを切り下げる。

          すべてのオペレーティングシステムで秒未満を扱えるわけではない。
          扱えないシステムでMILLISECにゼロ以外を指定すると
          エラーになる。

          関数`accept-process-output'は、 出力を得ると`nil'以外を返す。
          あるいは、出力が到着するまえに時間切れすると`nil'を返す。


File: elisp-ja,  Node: Sentinels,  Next: Transaction Queues,  Prev: Output from Processes,  Up: Processes

36.10 番兵：プロセスの状態変化の検出
===================================================

     "プロセスの番兵"（process sentinel）は、
プロセスを終了／一時停止／継続させる
（Emacsが送ったかプロセス自身の動作によって生起した）シグナルを含めて
対応付けられたプロセスの状態が任意の理由で変化したときに
呼び出される関数です。
プロセスの番兵は、プロセスが終了しても呼び出されます。
番兵は2つの引数、事象が発生したプロセスと
事象の種類を記述する文字列を受け取ります。

        事象を記述する文字列はつぎのとおりです。

        * `"finished\n"'.

        * `"exited abnormally with code EXITCODE\n"'.

        * `"NAME-OF-SIGNAL\n"'.

        * `"NAME-OF-SIGNAL (core dumped)\n"'.

        番兵はEmacsが（たとえば、端末入力や時間経過、プロセスの出力を）
待っているときにのみ実行されます。
他のLispプログラムの実行途中で無秩序に番兵を実行した場合に起こる
タイミングエラーを回避するためです。 `sit-for'や`sleep-for'（*note
Waiting::）、あるいは、 `accept-process-output'（*note Accepting
Output::）を
呼び出すとプログラムは待ちに入り、番兵が動けることになります。
Emacsは、コマンドループで入力を読むときにも番兵の実行を許します。

        番兵の内側では中断は普通は禁止されています。
さもないと、コマンドレベルで打った`C-g'の効果や、
ユーザーコマンドを中断するために打った`C-g'の効果は予測できません。
番兵の内側で中断を行いたい場合には、 `inhibit-quit'に`nil'を束縛します。
*Note Quitting::。

        プロセスのバッファに出力を書き込む番兵は、
そのバッファが有効であるかどうかを検査するべきです。
無効なバッファに挿入しようとするとエラーになります。
バッファが無効であれば、 式`(buffer-name (process-buffer PROCESS))'
を実行すると`nil'を返します。

        番兵の実行中にエラーが発生するとそのエラーは自動的に捕捉され、
番兵を始動したときに動いていた
プログラムの実行を停止しないようにします。
しかし、`debug-on-error'が`nil'以外であると、 エラーを捕捉しません。
これにより、Lispデバッガで番兵をデバッグできます。 *Note Debugger::。

        Emacsの初期の版では、正規表現を探索したり一致処理する番兵では、
マッチデータを明示的に保存／復元する必要がありました。
今のEmacsは、番兵に対してはこれを自動的に行いますから、
番兵で明示的に行う必要はありません。 *Note Match Data::。

      -- Function: set-process-sentinel process sentinel
          この関数は、プロセスPROCESSに番兵SENTINELを対応付ける。
          SENTINELが`nil'であると、プロセスに番兵はない。
          番兵がない場合のデフォルトのふるまいは、
          プロセス状態が変化するとプロセスのバッファにメッセージを挿入する。

               (defun msg-me (process event)
                  (princ
                    (format "Process: %s had the event `%s'" process event)))
               (set-process-sentinel (get-process "shell") 'msg-me)
                    => msg-me
               (kill-process (get-process "shell"))
                    -| Process: #<process shell> had the event `killed'
                    => #<process shell>

      -- Function: process-sentinel process
          この関数は、プロセスPROCESSの番兵を返すか、
          番兵がなければ`nil'を返す。

      -- Function: waiting-for-user-input-p
          番兵やフィルタ関数が動作中にこの関数を呼び出すと、
          番兵やフィルタ関数を呼び出したときにEmacsがユーザーからの
          キーボード入力を待ってると`nil'以外を返し、
          それ以外では`nil'を返す。


File: elisp-ja,  Node: Transaction Queues,  Next: Network,  Prev: Sentinels,  Up: Processes

36.11 トランザクションキュー
=======================================

     トランザクションを用いたサブプロセスとの通信に
"トランザクションキュー"（transaction queue）を使えます。
まず`tq-create'を用いて、
指定したプロセスとの通信用トランザクションキューを作成します。
そして、トランザクションを送るために`tq-enqueue'を呼び出します。

      -- Function: tq-create process
          この関数は、プロセスPROCESSとの通信用トランザクションキューを
          作成して返す。
          引数PROCESSは、バイトストリームを送受信できる機能を
          有するサブプロセスであること。
          つまり、子プロセスであるか、別のマシン上の可能性もある
          サーバーへのTCP接続である。

      -- Function: tq-enqueue queue question regexp closure fn
          この関数はキューQUEUEにトランザクションを送る。
          キューを指定することは、
          通信相手のサブプロセスを指定する効果がある。

          引数QUESTIONは、トランザクションを始める送出メッセージである。
          引数FNは、対応する応答が戻ってきたときに呼び出す関数である。
          その関数は2つの引数、CLOSUREと受け取った応答で呼び出される。

          引数REGEXPは、1つの応答だけに一致する正規表現である。
          `tq-enqueue'が応答の末尾を判定するために使う。

          `tq-enqueue'の戻り値そのものに意味はない。

      -- Function: tq-close queue
          未処理のトランザクションすべてが完了するのを待ち、
          接続や子プロセスを終了して、
          トランザクションキューQUEUEを終える。

        トランザクションキューはフィルタ関数を用いて実装してあります。
*Note Filter Functions::。


File: elisp-ja,  Node: Network,  Prev: Transaction Queues,  Up: Processes

36.12 ネットワーク接続
==============================

     Emacs
Lispプログラムは、同一マシンや別のマシン上の他のプロセスに対して
TCPネットワーク接続を開くことができます。
ネットワーク接続は、サブプロセスと同様にLispが扱い、
プロセスオブジェクトとして表現されます。
しかし、通信相手のプロセスはEmacsプロセスの子プロセスではありませんから、
キルしたりシグナルを送ることはできません。
データの送受信のみが可能です。 `delete-process'は接続を閉じますが、
もう一方の端のプロセスをキルしません。
そのプロセスは、接続が閉じた場合の動作を判断する必要があります。

        ネットワーク接続を表すプロセスオブジェクトと
サブプロセスを表すプロセスオブジェクトとは、
関数`process-status'を使って区別できます。
この関数は、ネットワーク接続に対しては `open'か`closed'をつねに返し、
本当のサブプロセスに対してはこれらのいずれの値もけっして返しません。
*Note Process Information::。

      -- Function: open-network-stream name buffer-or-name host service
          この関数は、ホストのサーバーに対するTCP接続を開く。
          接続を表すプロセスオブジェクトを返す。

          引数NAMEは、プロセスオブジェクトに付ける名前を指定する。
          必要に応じて一意にするために修正される。

          引数BUFFER-OR-NAMEは、接続に対応付けるバッファである。
          出力を扱うフィルタ関数を指定しない限り、
          接続からの出力はそのバッファに挿入される。
          BUFFER-OR-NAMEが`nil'であると、
          接続にはバッファを対応付けないことを意味する。

          引数HOSTとSERVICEは、接続先を指定する。
          HOSTはホスト名（文字列）であり、
          SERVICEは定義済みのネットワークサービス（文字列）か
          ポート番号（整数）である。


File: elisp-ja,  Node: Display,  Next: Calendar,  Prev: Processes,  Up: Top

37 Emacsの画面表示
***********************

     本章では、Emacsがユーザーに提示する画面表示に関連する
さまざまな機能について述べます。

     * Menu:

     * Refresh Screen::      Clearing the screen and redrawing everything on it.
     * Truncation::          Folding or wrapping long text lines.
     * The Echo Area::       Where messages are displayed.
     * Invisible Text::      Hiding part of the buffer text.
     * Selective Display::   Hiding part of the buffer text (the old way).
     * Overlay Arrow::       Display of an arrow to indicate position.
     * Temporary Displays::  Displays that go away automatically.
     * Overlays::		Use overlays to highlight parts of the buffer.
     * Width::               How wide is a character or string.
     * Faces::		A face defines a graphics appearance: font, color, etc.
     * Blinking::            How Emacs shows the matching open parenthesis.
     * Inverse Video::	Specifying how the screen looks.
     * Usual Display::	The usual conventions for displaying nonprinting chars.
     * Display Tables::	How to specify other conventions.
     * Beeping::             Audible signal to the user.
     * Window Systems::      Which window system is being used.


File: elisp-ja,  Node: Refresh Screen,  Next: Truncation,  Up: Display

37.1 スクリーン全体の再表示
======================================

     関数`redraw-frame'は、指定したフレーム（*note Frames::）の
内容全体を再表示します。

      -- Function: redraw-frame frame
          この関数は、フレームFRAMEをクリアしてから再表示する。

        より強力なのは`redraw-display'です。

      -- コマンド: redraw-display
          この関数は、すべての可視フレームをクリアしてから再表示する。

        ユーザー入力の処理のほうが再表示より絶対的に優先します。
入力があるときにこれらの関数を呼び出してもただちにはなにもしませんが、
入力をすべて処理し終えてから再表示します。

        通常、Emacsを停止したり再開しても スクリーン全体を再表示します。
Emacsのようなディスプレイ向けプログラムと通常の逐次表示向けに、
表示内容を個別に記録できる端末エミュレータもあります。
そのような端末を使っているときには、
再開時の再表示を禁止した場合もあります。

      -- Variable: no-redraw-on-reenter
          この変数は、停止後に再開したあとで、
          スクリーン全体を再表示するかどうかを制御する。
          `nil'以外であると再描画の必要はないことを意味し、
          `nil'であると再描画が必要であることを意味する。
          デフォルトは`nil'である。


File: elisp-ja,  Node: Truncation,  Next: The Echo Area,  Prev: Refresh Screen,  Up: Display

37.2 表示の切り詰め
==========================

     テキスト行がウィンドウの右端を越えていると、
その行をつぎのスクリーン行へ継続するか、 スクリーン行1行に切り詰めます。
長いテキスト行を表示するために使われる追加のスクリーン行を
"継続"行と呼びます。
通常、ウィンドウの最右端のコラムに現れる`$'で切り詰めたことを示し、
`\'でつぎの行に『折り返した』こと、
つまり、"継続している"行であることを示します。
（表示テーブルで別の文字を指定できる。 *note Display Tables::を参照。）

        継続することと詰め込みは別のことです。
継続はスクリーン上だけのことであり、バッファ内容は変わりません。
また、継続では単語の境界ではなく、正確にスクリーンの右端で
行を分けます。 *Note Filling::。

      -- User Option: truncate-lines
          このバッファローカルな変数は、
          ウィンドウの右端を越える行をどのように表示するかを制御する。
          デフォルトは`nil'であり継続を意味する。
          値が`nil'以外であると、そのような行を切り詰める。

          変数`truncate-partial-width-windows'が`nil'以外であると、
          （フレーム内で）左右に並んだウィンドウでは、
          `truncate-lines'の値に関わらずつねに切り詰る。

      -- User Option: default-truncate-lines
          この変数は、`truncate-lines'のバッファローカルな値を持たない
          バッファ向けの`truncate-lines'のデフォルト値である。

      -- User Option: truncate-partial-width-windows
          この変数は、左右に並んだウィンドウ（*note Splitting
          Windows::）において、
          ウィンドウの右端を越える行の表示を制御する。
          `nil'以外であると、そのような行を切り詰める。
          さもなければ、`truncate-lines'に従って表示する。

        ウィンドウで水平方向にスクロールしている（*note Horizontal
Scrolling::）と、 強制的に切り詰めます。

        継続や切り詰めを表す文字は、表示テーブルを使って変更できます。
*Note Display Tables::。

バッファに_とても_長い行があるときにそれらの表示に継続行を使うと、
それによりEmacsの再表示が遅くなります。
コラム計算や字下げ関数も遅くなります。
そのような場合には、`cache-long-line-scans'に`t'を
設定するのがよいです。

      -- Variable: cache-long-line-scans
          この変数が`nil'以外であると、
          字下げ／移動関数とEmacsの再表示において、
          バッファを走査した結果をキャッシュし、
          バッファが変更されていないときには
          キャッシュを調べてバッファの対象領域の再走査を回避する。

          キャッシュするようにすると、短い行の処理が多少遅くなる。

          この変数は、すべてのバッファで自動的にバッファローカルである。


File: elisp-ja,  Node: The Echo Area,  Next: Invisible Text,  Prev: Truncation,  Up: Display

37.3 エコー領域
====================

     "エコー領域"（echo area）は、
基本関数`message'でメッセージを表示したり、
打鍵を表示するために使われます。 （活性な）ミニバッファはエコー領域と
同じスクリーン上の位置に現れますが、
エコー領域とミニバッファは同じものではありません。 `GNU Emacs
マニュアル'には、
エコー領域とミニバッファがスクリーンの同じ箇所を使う際の
衝突を回避する規則が述べてあります （*note ミニバッファ:
(emacs)Minibuffer.）。 エラーメッセージもエコー領域に現れます。 *Note
Errors::。

        エコー領域に表示するには、 ストリーム（*note Output
Functions::）として
`t'を指定したLisp表示関数を使うか、あるいはつぎのようにします。

      -- Function: message string &rest arguments
          この関数は、エコー領域に1行のメッセージを表示する。
          引数STRINGは、言語Cの`printf'の制御文字列と同様である。
          書式指定について詳しくは、*note String Conversion::の
          `format'を参照。 `message'は構築した文字列を返す。

          バッチモードでは、`message'はメッセージテキストと改行を
          標準エラーストリームへ出力する。

          STRINGが`nil'であると、 `message'はエコー領域をクリアする。
          ミニバッファが活性であると、
          これによりミニバッファの内容がスクリーンにただちに表示される。

               (message "Minibuffer depth is %d."
                        (minibuffer-depth))
                -| Minibuffer depth is 0.
               => "Minibuffer depth is 0."

               ---------- Echo Area ----------
               Minibuffer depth is 0.
               ---------- Echo Area ----------

      -- Function: message-or-box string &rest arguments
          この関数は`message'と同様にメッセージを表示するが、
          エコー領域のかわりに対話ボックスを使うこともある。
          この関数がマウスを用いて起動されたコマンドから呼ばれたとき、
          より正確には、`last-nonmenu-event'（*note Command Loop
          Info::）が `nil'かリストのいずれかであると、
          メッセージを表示するために対話ボックスかポップアップメニューを用いる。
          さもなければエコー領域を用いる。
          （これは、同様な決定をくだす`y-or-n-p'の判定条件と同じである。
          *note Yes-or-No Queries::。）

          呼び出しの周りで`last-nonmenu-event'に適切な値を束縛することで、
          マウスを使うかエコー領域を使うか強制できる。

      -- Function: message-box string &rest arguments
          この関数は`message'と同様にメッセージを表示するが、
          可能な限り対話ボックス（やポップアップメニュー）を使う。
          対話ボックスやポップアップメニューを扱えない端末などで
          これらを使用できない場合には、
          `message-box'は`message'と同様にエコー領域を使う。

      -- Function: current-message
          この関数は、エコー領域に現在表示されているメッセージを返す。
          なければ`nil'を返す。

      -- Variable: cursor-in-echo-area
          この変数は、エコー領域にメッセージを表示しているときに
          カーソルをどこに表示するかを制御する。
          `nil'以外であると、メッセージの末尾にカーソルを表示する。
          さもなければ、エコー領域にではなく、ポイント位置にカーソルを表示する。

          この値は普通は`nil'である。
          Lispプログラムはこれに`t'を短い期間だけ束縛する。

      -- Variable: echo-area-clear-hook
          このノーマルフックは、`(message nil)'や他の理由で
          エコー領域をクリアするたびに実行される。

        エコー領域に表示したほとんどすべてのメッセージは
バッファ`*Messages*'にも記録されます。

      -- User Option: message-log-max
          この変数は、バッファ`*Messages*'に保持する行数を指定する。
          値`t'は、保持する行数を制限しないことを意味する。
          値`nil'は、メッセージをまったく記録しないことを意味する。
          メッセージを表示しつつそれを記録しないようにするには
          つぎのようにする。

               (let (message-log-max)
                 (message ...))

      -- Variable: echo-keystrokes
          この変数は、コマンド文字を表示するまでの経過時間を決定する。
          この値は整数であり、表示し始めるまでに待つ秒数を指定する。
          ユーザーが（`C-x'などの）プレフィックスキーを打ってから
          つぎを打つまでにこの秒数だけ遅れがあると、
          プレフィックスキーをエコー領域に表示する。
          （いったんキー列の表示を始めると、
          同じキー列の以降の文字すべてを表示する。）

          値がゼロであると、コマンド入力を表示しない。


File: elisp-ja,  Node: Invisible Text,  Next: Selective Display,  Prev: The Echo Area,  Up: Display

37.4 不可視なテキスト
=============================

     属性`invisible'で文字群を"不可視"にできます。
つまり、それらをスクリーンに表示されないようにするのです。
テキスト属性（*note Text Properties::）か オーバレイの属性（*note
Overlays::）を使います。

        もっとも単純な場合、
属性`invisible'が`nil'以外であると文字は見えなくなります。
これはデフォルトの場合、つまり、
`buffer-invisibility-spec'のデフォルト値を変更していない場合であり、
このようにして属性`invisible'は動作します。

        より一般的には、変数`buffer-invisibility-spec'を使って、
属性`invisible'のどの値のものを不可視なテキストにするかを制御できます。
つまり、`invisible'の異なる値を与えて
テキストをあらかじめいくつかのグループに分類しておき、
そのあとで`buffer-invisibility-spec'の値を変更して
さまざまなグループを可視／不可視にします。

        `buffer-invisibility-spec'で可視性を制御することは、
データベースの項目の一覧を表示するようなプログラムで特に有用です。
データベースの特定の項目だけを見るための
便利なフィルタコマンドを実装できます。
この変数に設定するのはとても速くでき、
変更すべき属性を探すためにバッファ内の全テキストを走査するよりも速いのです。

      -- Variable: buffer-invisibility-spec
          この変数は、属性`invisible'のどの種類を実際に
          不可視な文字にするかを指定する。

         `t'
               属性`invisible'が`nil'以外の文字を不可視にする。
               これがデフォルト。

         リスト
               リストの各要素で不可視にする条件を指定する。
               文字の属性`invisible'がこれらの条件の1つを満たすと、
               その文字を不可視にする。
               リストには2種類の要素がありうる。

              `ATOM'
                    文字の属性`invisible'の値がATOMであるか、
                    そのリストのメンバにATOMがあると、
                    文字を不可視にする。

              `(ATOM . t)'
                    文字の属性`invisible'の値がATOMであるか、
                    そのリストのメンバにATOMがあると、
                    文字を不可視にする。
                    さらに、その文字が行末にあり、直後に目に見える改行がある場合には、
                    `...'を表示する。

        `buffer-invisibility-spec'に要素を追加したり削除するために
2つの関数が特別にあります。

      -- Function: add-to-invisibility-spec element
          （リストにELEMENTが既存でなければ）
          `buffer-invisibility-spec'に要素ELEMENTを追加する。

      -- Function: remove-from-invisibility-spec element
          `buffer-invisibility-spec'から要素ELEMENTを削除する。

        `buffer-invisibility-spec'の使い方の慣習の1つに、
メジャーモードでは
`buffer-invisibility-spec'の1要素と属性`invisible'の値に
モード自体の名前を使うべきであるというのがあります。

          ;; `...'を表示したければ
          (add-to-invisibility-spec '(my-symbol . t))
          ;; `...'を表示しくなければ
          (add-to-invisibility-spec 'my-symbol)

          (overlay-put (make-overlay beginning end)
                       'invisible 'my-symbol)

          ;; オーバレイを終了したら
          (remove-from-invisibility-spec '(my-symbol . t))
          ;; 同じように
          (remove-from-invisibility-spec 'my-symbol)

        普通、テキストを操作したりポイントを移動するコマンドは、
テキストの可視性に注意しません。 ユーザーレベルの移動コマンドは、
`line-move-ignore-invisible'が`nil'以外であれば
不可視な改行を明示的に無視しますが、
それはそのように明示的にプログラムしてあるからにすぎません。

        インクリメンタルサーチでは、
不可視なテキストを含む一致箇所では、
不可視なオーバレイを一時的にあるいは恒久的に可視にできます。
これを可能にするには、オーバレイの属性`isearch-open-invisible'が
`nil'以外である必要があります。
その属性の値は、オーバレイを引数として呼ばれる関数である必要があります。
その関数がオーバレイを恒久的に可視にします。
その関数は、探索から抜けるときに一致箇所が
オーバレイにまたがっているときに使われます。

        探索中には、そのようなオーバレイは、
それらの属性`invisible'と`intangible'を一時的に変更することで
一時的に可視にされます。
特定のオーバレイに対して異なる扱いをしたければ、
属性`isearch-open-invisible-temporary'に関数を与えておきます。
その関数は2つの引数で呼ばれます。 第1引数はオーバレイ、
第2引数は、オーバレイを可視にする`t'、あるいは、
オーバレイを再度不可視にする`nil'です。


File: elisp-ja,  Node: Selective Display,  Next: Overlay Arrow,  Prev: Invisible Text,  Up: Display

37.5 選択表示
=================

     "選択表示"とは、
スクリーン上の特定の行を隠すための関連する機能対を指します。

        最初の変種は、明示的な選択表示で、
Lispプログラムで使用するために設計されています。
テキストを変更することでどの行を隠すかを制御します。
テキストを不可視にする機能（*note Invisible Text::）は、
この機能で部分的に置き換えてあります。

        2番目の変種は、字下げに基づいて自動的に隠す行を選択します。
この変種は、ユーザーレベルの機能であるように設計されています。

        明示的な選択表示を制御するには、
改行（コントロールJ）を復帰（コントロールM）に置き換えます。
置換前の改行に続いていたそれまでの行は見えなくなります。
厳密にいえば、改行だけが行を区切るため、
一時的にはもう行ではなくなっているのです。
つまり、先行する行の一部になっているのです。

        選択表示は、編集コマンドに直接には影響しません。
たとえば、`C-f'（`forward-char'）は
躊躇なく不可視なテキストの中へポイントを移動します。
しかし、改行文字を復帰文字に置換すると
影響を受ける編集コマンドもあります。 たとえば、`next-line'は、
改行だけを探すため不可視な行を飛び越してしまいます。
選択表示を使用するモードでは、
改行を考慮するようにコマンドを定義したり、
テキストの一部を可視／不可視にするコマンドを定義できます。

        選択表示しているバッファをファイルに書き出すときには、
すべてのコントロールM（復帰）は改行として出力されます。
つまり、つぎにファイルを読み込むと不可視なものはなく、
普通に見えるのです。 選択表示の効果は、Emacsの内側だけで見えるのです。

      -- Variable: selective-display
          このバッファローカルな変数は、選択表示をオンにする。
          つまり、行や行の一部を不可視にできる。

             * `selective-display'の値が`t'であると、
               行内のコントロールM（復帰）以降の部分を表示しない。
               これは明示的な選択表示である。

             * `selective-display'の値が正整数であると、
               字下げのコラム幅がその数より大きな行を表示しない。

          バッファのある部分が不可視であると、
          垂直方向に移動するコマンドは、
          その部分が存在しないがごとく動作し、
          1つのコマンド`next-line'で任意個数の不可視行を飛び越えられる。
          しかし、（`forward-char'などの）
          文字単位の移動コマンドは不可視な部分を無視せず、
          不可視な部分へのテキストの挿入／削除は可能である。

          つぎの例では、`selective-display'の値を変えて
          バッファ`foo'の_見た目_を示す。 バッファの_内容_に変更はない。

               (setq selective-display nil)
                    => nil

               ---------- Buffer: foo ----------
               1 on this column
                2on this column
                 3n this column
                 3n this column
                2on this column
               1 on this column
               ---------- Buffer: foo ----------

               (setq selective-display 2)
                    => 2

               ---------- Buffer: foo ----------
               1 on this column
                2on this column
                2on this column
               1 on this column
               ---------- Buffer: foo ----------

      -- Variable: selective-display-ellipses
          このバッファローカルな変数が`nil'以外であると、
          不可視なテキストが続く行末に`...'を表示する。
          つぎの例は、上の例の続きである。

               (setq selective-display-ellipses t)
                    => t

               ---------- Buffer: foo ----------
               1 on this column
                2on this column ...
                2on this column
               1 on this column
               ---------- Buffer: foo ----------

          表示テーブルを使って`...'にかわる別のテキストを指定できる。
          *note Display Tables::。


File: elisp-ja,  Node: Overlay Arrow,  Next: Temporary Displays,  Prev: Selective Display,  Up: Display

37.6 オーバレイ矢印
==========================

     "オーバレイ矢印"（overlay arrow）は、
バッファの特定の行にユーザーの注意を向けるために有用です。
たとえば、デバッガとのインターフェイスを取るためのモードでは、
オーバレイ矢印で実行するコードの行を示します。

      -- Variable: overlay-arrow-string
          この変数は、特定の行に注意を向けるために表示する文字列を保持する。
          矢印機能を使っていなければ`nil'である。

      -- Variable: overlay-arrow-position
          この変数は、オーバレイ矢印を表示する箇所を表すマーカを保持する。
          行頭を指すこと。 矢印のテキストはその行の先頭に現れ、
          その場所に本来現れるべきテキストを隠す。
          矢印は普通は短く、行には字下げがあるので、
          重要なものは普通はなにも上書きされない。

          オーバレイ文字列は、マーカが指すバッファでのみ表示される。
          したがって、ある時点では、1つのバッファだけにオーバレイ矢印を表示できる。

        同様のことは、属性`before-string'のオーバレイを
作成してもできます。 *Note Overlay Properties::。


File: elisp-ja,  Node: Temporary Displays,  Next: Overlays,  Prev: Overlay Arrow,  Up: Display

37.7 一時的な表示
=======================

     一時的な表示は、 出力をバッファに置き編集目的にではなく
ユーザーに読むように提示するために Lispプログラムが使います。

      -- Special Form: with-output-to-temp-buffer buffer-name forms...
          この関数は、BUFFER-NAMEという名前のバッファに
          FORMSの任意の出力が挿入されるように準備して FORMSを実行する。
          そのバッファは適当なウィンドウに表示されるが、
          そのバッファは選択されない。

          文字列BUFFER-NAMEは、既存である必要はない一時的なバッファを指定する。
          引数は、バッファではなく文字列であること。
          （問い合わせずに）はじめにバッファを消去し、
          `with-output-to-temp-buffer'が終了すると未変更と印を付ける。

          `with-output-to-temp-buffer'は、
          `standard-output'に一時的なバッファを束縛し、
          FORMSのフォーム群を評価する。
          FORMS内で用いたLisp出力関数からの出力は
          デフォルトでそのバッファに入る
          （しかし、スクリーン表示やエコー領域のメッセージは、
          用語の一般的な意味で『出力』であるが、 影響されない。） *note
          Output Functions::。

          FORMSの最後のフォームの値を返す。

               ---------- Buffer: foo ----------
                This is the contents of foo.
               ---------- Buffer: foo ----------

               (with-output-to-temp-buffer "foo"
                   (print 20)
                   (print standard-output))
               => #<buffer foo>

               ---------- Buffer: foo ----------
               20

               #<buffer foo>

               ---------- Buffer: foo ----------

      -- Variable: temp-buffer-show-function
          この変数が`nil'以外であると、 ヘルプバッファを表示するために
          `with-output-to-temp-buffer'がこの値を関数として呼び出す。
          関数は1つの引数、つまり、表示すべきバッファを受け取る。

          この関数では、
          `save-window-excursion'を使いウィンドウとバッファを選択した内側で、
          `with-output-to-temp-buffer'が普通に行うように
          `temp-buffer-show-hook'を呼び出すのがよい。

      -- Variable: temp-buffer-show-hook
          このノーマルフックは、ヘルプバッファを表示後に
          `with-output-to-temp-buffer'が実行する。
          フックを実行するときには、
          ヘルプバッファがカレントバッファであり、
          それを表示しているウィンドウが選択されているウィンドウである。

      -- Function: momentary-string-display string position &optional
               char message
          この関数は、カレントバッファ内の位置POSITIONに
          文字列STRINGを瞬間的に表示する。
          アンドゥリストやバッファの変更状態には影響しない。

          瞬間的な表示は、つぎの入力イベントまで持続する。
          つぎの入力イベントがCHARであると、
          `momentary-string-display'はそれを無視して戻る。
          さもなければ、そのイベントは入力として使われるように保存される。
          したがって、CHARを打つと文字列の表示が単に消えるだけであるが、
          （たとえば）`C-f'を打つと文字列の表示が消えるだけでなく
          （たぶん）ポイントを進めることになる。
          引数CHARはデフォルトでは空白である。

          `momentary-string-display'の戻り値に意味はない。

          文字列STRINGにコントロール文字が含まれなければ、
          属性`before-string'のオーバレイを作成（のちに削除）することで
          より一般的な方法で同じことを行える。 *note Overlay
          Properties::。

          MESSAGEが`nil'以外であると、 STRINGをバッファに表示中には、
          MESSAGEをエコー領域に表示する。 `nil'であると、デフォルトは
          「継続するには文字CHARを打つこと」 といったメッセージである。

          つぎの例では、ポイントは始めは2行目の先頭に位置している。

               ---------- Buffer: foo ----------
               This is the contents of foo.
               -!-Second line.
               ---------- Buffer: foo ----------

               (momentary-string-display
                 "**** Important Message! ****"
                 (point) ?\r
                 "Type RET when done reading")
               => t

               ---------- Buffer: foo ----------
               This is the contents of foo.
               **** Important Message! ****Second line.
               ---------- Buffer: foo ----------

               ---------- Echo Area ----------
               Type RET when done reading
               ---------- Echo Area ----------


File: elisp-ja,  Node: Overlays,  Next: Width,  Prev: Temporary Displays,  Up: Display

37.8 オーバレイ
====================

ユーザーに提示するためにスクリーン上でのバッファのテキストの見た目を
変えるために"オーバレイ"（overlay）を使えます。
オーバレイは、特定のバッファに属するオブジェクトであり、
指定された開始位置と終了位置があります。
また、調べたり設定できる属性もあります。
これらの属性は、オーバレイの内側のテキストの表示に影響します。

     * Menu:

     * Overlay Properties::	How to read and set properties.
     			What properties do to the screen display.
     * Managing Overlays::   Creating, moving, finding overlays.


File: elisp-ja,  Node: Overlay Properties,  Next: Managing Overlays,  Up: Overlays

37.8.1 オーバレイ属性
----------------------------

     オーバレイ属性はある意味でテキスト属性に似ていて、
どちらの属性でも文字の表示方法を変更できます。
しかし、多くの点で異なります。
テキスト属性は、テキストの一部であるとみなされますが、
オーバレイはテキストの一部とはみなしません。
したがって、さまざまなバッファや文字列のあいだでテキストをコピーしても
テキスト属性は保存されますが、オーバレイは保存されません。
バッファ内のテキスト属性を変更するとバッファを変更済みと印を付けますが、
オーバレイを移動したりその属性を変更しても
バッファの変更とは考えません。 テキスト属性の変更と異なり、
オーバレイの変更はバッファのアンドゥリストには記録されません。
比較のために*Note Text Properties::。

    `priority'
          この属性の値（非負の数であること）は、
          オーバレイの優先順位を決定する。
          優先順位は、複数のオーバレイが同じ文字を覆い、
          いずれも表示用のフェイスを指定している場合に意味を持つ。
          `priority'の値の大きなものが他に優先し、
          そのフェイス属性が他の低い順位の属性のフェイス属性に優先する。

          現在、すべてのオーバレイ属性はテキスト属性に優先する。
          負の優先順位の意味を決めかねているので、負の優先順位は避けてほしい。

    `window'
          属性`window'が`nil'以外であると、
          オーバレイをそのウィンドウだけに適用する。

    `category'
          オーバレイに属性`category'があると、
          それをオーバレイの"カテゴリ"（category）と呼ぶ。
          これはシンボルであること。
          シンボルの属性がオーバレイの属性のデフォルトの役割を果たす。

    `face'
          この属性は、テキストの表示方法、たとえば、
          フォントや表示色を制御する。
          その値は、フェイス名であるかフェイス名のリストである。
          詳しくは、*note Faces::。

          属性値がリストであると、その要素は、 `(foreground-color .
          COLOR-NAME)'か `(background-color . COLOR-NAME)'の形でもよい。
          これらの要素は、前景色だけや背景色だけを指定する。
          したがって、使用する各色を表すフェイスを作成する必要はない。

    `mouse-face'
          この属性は、マウスがオーバレイの範囲に入っているときに
          `face'のかわりに使われる。

    `modification-hooks'
          この属性の値は、オーバレイの内側の文字を変更したり、
          オーバレイの内側にテキストを挿入したときに
          呼び出される関数のリストである。

          フック関数は、各変更の前後に呼び出される。
          関数が受け取った情報を保存し呼び出しごとに比較すれば
          バッファテキストにどのような変更が行われたかを正確に判定できる。

          変更前に呼ばれるときには、各関数は4つの引数を受け取る。
          オーバレイ、`nil'、変更対象のテキスト範囲の先頭と末尾である。

          変更後に呼ばれるときには、各関数は5つの引数を受け取る。
          オーバレイ、`t'、変更済みのテキスト範囲の先頭と末尾、
          その範囲の変更前のテキストの長さである。
          （挿入では変更前の長さはゼロである。
          削除では変更前の長さは削除された文字数であり、
          変更後の先頭位置と末尾位置は同じである。）

    `insert-in-front-hooks'
          この属性の値は、オーバレイの開始位置へのテキスト挿入の前後に
          呼び出される関数のリストである。
          呼び出し方法は`modification-hooks'の関数群と同じである。

    `insert-behind-hooks'
          この属性の値は、オーバレイの終了位置へのテキスト挿入の前後に
          呼び出される関数のリストである。
          呼び出し方法は`modification-hooks'の関数群と同じである。

    `invisible'
          属性`invisible'は、オーバレイ内のテキストを不可視にする。
          つまり、それらはスクリーン上に現れない。 詳しくは、*note
          Invisible Text::。

    `intangible'
          属性`intangible'は、オーバレイにおいて
          テキスト属性`intangible'と同様に働く。 詳しくは、*note
          Special Properties::。

    `isearch-open-invisible'
          この属性は、インクリメンタルサーチに対して、
          一致箇所がオーバレイに重なったときに
          不可視なオーバレイを恒久的に可視にする方法を指示する。 *note
          Invisible Text::。

    `isearch-open-invisible-temporary'
          この属性は、インクリメンタルサーチに対して、
          探索中に不可視なオーバレイを一時的に可視にする方法を指示する。
          *note Invisible Text::。

    `before-string'
          この属性の値は、オーバレイの先頭位置に追加表示する文字列である。
          文字列はいかなる意味においてもバッファには現れず、
          スクリーン上のみに現れる。
          文字列は1コラムで表示される文字のみであること。
          タブや改行を含むコントロール文字を含むと奇妙な結果を生じる。

    `after-string'
          この属性の値は、オーバレイの末尾位置に追加表示する文字列である。
          文字列はいかなる意味においてもバッファには現れず、
          スクリーン上のみに現れる。
          文字列は1コラムで表示される文字のみであること。
          タブや改行を含むコントロール文字を含むと奇妙な結果を生じる。

    `evaporate'
          この属性が`nil'以外であると、
          オーバレイが空に（つまり覆う文字がなく）なると、
          自動的にオーバレイを削除する。

    `local-map'
          この属性が`nil'以外であると、当該部分のテキストに対する
          キーマップを指定する。
          ポイントの直後の文字がオーバレイに入っていると、
          属性の値はバッファローカルなキーマップに置き換わる。 *note
          Active Keymaps::。

        つぎは、オーバレイの属性を読み書きするための関数です。

      -- Function: overlay-get overlay prop
          この関数は、オーバレイOVERLAYに記録されている
          属性PROPの値をあれば返す。
          OVERLAYにそのような属性に対する値が記録されていなくても、
          属性`category'がありそれがシンボルであれば、
          そのシンボルの属性PROPを使う。 さもなければ値は`nil'である。

      -- Function: overlay-put overlay prop value
          この関数は、オーバレイOVERLAYに属性PROPの値として
          VALUEを設定する。 VALUEを返す。

        与えられた文字のオーバレイ属性とテキスト属性の両方を調べる
関数codeget-char-propertyも参照してください。 *Note Examining
Properties::。


File: elisp-ja,  Node: Managing Overlays,  Prev: Overlay Properties,  Up: Overlays

37.8.2 オーバレイの管理
-------------------------------

     本節では、オーバレイを作成、削除、移動したり、
それらの内容を調べる関数について述べます。

      -- Function: make-overlay start end &optional buffer
               front-advance rear-advance
          この関数は、バッファBUFFERに属する
          STARTからENDまでを覆うオーバレイを作成しそれを返す。
          STARTとENDのどちらもバッファ内位置を指定する
          整数かマーカであること。
          BUFFERを省略すると、カレントバッファにオーバレイを作成する。

          引数FRONT-ADVANCEとREAR-ADVANCEは、
          オーバレイの開始位置と終了位置における挿入型を指定する。
          *note Marker Insertion Types::。

      -- Function: overlay-start overlay
          この関数は、オーバレイOVERLAYの開始位置を整数で返す。

      -- Function: overlay-end overlay
          この関数は、オーバレイOVERLAYの終了位置を整数で返す。

      -- Function: overlay-buffer overlay
          この関数は、オーバレイOVERLAYが属するバッファを返す。

      -- Function: delete-overlay overlay
          この関数は、オーバレイOVERLAYを削除する。
          Lispオブジェクトとしてはオーバレイは存在し続けるが、
          それが属したバッファとの対応付けは消失し、
          表示上の効果もなくなる。

          削除したオーバレイは恒久的に無意味ではない。
          `move-overlay'を呼び出して新たなバッファ内位置をそれに与えられる。

      -- Function: move-overlay overlay start end &optional buffer
          この関数は、オーバレイOVERLAYをバッファBUFFERに移し、
          STARTからENDを覆うようにする。
          STARTとENDのどちらもバッファ内位置を指定し、
          整数かマーカである。
          BUFFERを省略すると、オーバレイは同じバッファに留まる。

          戻り値はOVERLAYである。

          これは、オーバレイの端を変更する唯一の正しい方法である。
          オーバレイのマーカを手で修正しようとしないこと。
          他の重要なデータ構造を更新しそこない、
          いくつかのオーバレイを『失う』ことにもなりかねない。

      -- Function: overlays-at pos
          この関数は、カレントバッファの位置POSを覆うすべての
          オーバレイのリストを返す。 このリスト内の順番に意味はない。
          オーバレイが位置POSかそのまえで始まり、かつ、
          位置POSかそのうしろで終るときに、 オーバレイは位置POSを覆う。

      -- Function: overlays-in beg end
          この関数は、BEGからENDまでの領域と
          重なり合っているすべてのオーバレイのリストを返す。
          『重なり合っている』とは、
          少なくとも1文字がオーバレイに覆われていて、かつ、
          その文字が指定された領域に入っていることを意味する。
          しかし、空のオーバレイであっても
          それがBEGにあるかBEGとENDのあいだにあれば、
          空のオーバレイも結果に含まれる。

      -- Function: next-overlay-change pos
          この関数は、位置POSのうしろにある
          オーバレイのつぎの開始位置か終了位置を返す。

      -- Function: previous-overlay-change pos
          この関数は、位置POSのまえにある
          オーバレイのまえの開始位置か終了位置を返す。


File: elisp-ja,  Node: Width,  Next: Faces,  Prev: Overlays,  Up: Display

37.9 表示幅
==============

     すべての文字が同じ表示幅ではありませんから、
これらの関数で文字の表示幅を検査できます。
関連する関数については、*note Primitive Indent::と*Note Screen Lines::

      -- Function: char-width char
          この関数は、文字CHARを選択されているウィンドウで
          カレントバッファに表示した場合のコラム幅を返す。

      -- Function: string-width string
          この関数は、文字列STRINGを選択されているウィンドウで
          カレントバッファに表示した場合のコラム幅を返す。

      -- Function: truncate-string-to-width string width &optional
               start-column padding
          この関数は、幅WIDTHに収まる文字列STRINGの部分を
          新たな文字列として返す。

          STRINGが幅WIDTHに満たない場合、 STRINGの終りで結果は終る。
          STRING内の1つの複数コラム文字がコラムWIDTHを越える場合には、
          その文字は結果に含めない。
          したがって、結果はWIDTHより短くなりえるがそれを越えることはない。

          省略可能な引数START-COLUMNは、開始コラムを指定する。
          これが`nil'以外であると、文字列のはじめの
          START-COLUMNコラムを結果から省く。
          STRING内の1つの複数コラム文字がコラムSTART-COLUMNを越える場合には、
          その文字は結果に含めない。

          省略可能な引数PADDINGが`nil'以外であると、
          結果の文字列の先頭や末尾に付加して
          ちょうどWIDTHコラムにするためのパディング文字である。
          WIDTHより短くなる場合に 結果の末尾にパディング文字を使う。
          複数コラム文字がコラムSTART-COLUMNを越える場合には、
          結果の先頭にパディング文字を使う。

               (truncate-string-to-width "\tab\t" 12 4)
                    => "ab"
               (truncate-string-to-width "\tab\t" 12 4 ?\ )
                    => "    ab  "


File: elisp-ja,  Node: Faces,  Next: Blinking,  Prev: Width,  Up: Display

37.10 フェイス
==================

     "フェイス"（face）とは、図形的な属性、つまり、
フォント、前景色、背景色、下線 の名前付きの集合体です。
フェイスはスクリーン上のテキストの表示を制御します。

        各フェイスには固有の"フェイス番号"（face number）があり、
Emacs内部の下位レベルでフェイスを区別するために使われます。
しかし、ほとんどの目的には、
Lispプログラムでは名前でフェイスを参照できます。

      -- Function: facep object
          この関数は、OBJECTがフェイスを指名するシンボル
          （あるいは、フェイスデータを記録するために内部的に使われる種類のベクトル）
          であると`t'を返す。 さもなければ`nil'を返す。

        各フェイス名はすべてのフレームで有効であり、
デフォルトではすべてのフレームで同じ意味を持ちます。
しかし、望みの1つのフレームで特定のフェイス名に
特定の意味を持たせることもできます。

     * Menu:

     * Standard Faces::      The faces Emacs normally comes with.
     * Defining Faces::      How to define a face with `defface'.
     * Merging Faces::	How Emacs decides which face to use for a character.
     * Face Functions::	How to define and examine faces.


File: elisp-ja,  Node: Standard Faces,  Next: Defining Faces,  Up: Faces

37.10.1 標準フェイス
--------------------------

     つぎの表はすべての標準フェイスとその用途です。

    `default'
          このフェイスは通常のテキストに対して使う。

    `modeline'
          このフェイスはモード行とメニューバーに対して使う。

    `region'
          このフェイスは、暫定マーク（transient-mark）モードでリージョンを
          強調表示するために使う。

    `secondary-selection'
          このフェイスは、指定した任意の二次セレクションを示すために使う。

    `highlight'
          このフェイスは、さまざま目的向けに強調表示するために使う。

    `underline'
          このフェイスは、テキストに下線を引く。

    `bold'
          このフェイスは、可能ならば太字（bold）フォントを使う。
          フレームのフォントに太字（bold）変種があればそれを使う。
          太字変種を使用したい場合には、
          太字フォント変種を有するデフォルトフォントを選ぶのは読者の責任である。

    `italic'
          このフェイスは、フレームのフォントに
          斜体（italic）変種があればそれを使う。

    `bold-italic'
          このフェイスは、フレームのフォントに
          太字斜体（bold-italic）変種があればそれを使う。


File: elisp-ja,  Node: Defining Faces,  Next: Merging Faces,  Prev: Standard Faces,  Up: Faces

37.10.2 フェイスを定義する
-----------------------------------

     新たなフェイスを定義する方法は、`defface'を使うことです。
これは、カスタマイズバッファ （*note 簡便なカスタマイズ方法:
(emacs)Easy Customization.） を用いてユーザーがカスタマイズできる
カスタマイズ項目（*note Customization::）の一種を作成します。

      -- Macro: defface face spec doc [keyword value]...
          SPECに従ったデフォルトを持つカスタマイズ可能なフェイスとして
          FACEを宣言する。 シンボルFACEをクォートしないこと。
          引数DOCは、フェイスの説明文字列を指定する。

          `defface'を実行すると、SPECに従ったフェイスを定義し、
          ファイル`.emacs'から読み取った任意のカスタマイズを
          SPECの指定に優先させる。

          SPECの目的は、異なる種類の端末でフェイスがどのような
          見た目になるかを指定することである。 `(DISPLAY
          ATTS)'の形の要素から成る 連想リストであること。
          要素のCARのDISPLAYは端末の種類を指定する。
          CDRのATTSはフェイスの属性とその値のリストであり、
          その種類の端末上でそのフェイスがどのように見えるかを指定する。
          可能な属性は、`custom-face-attributes'の値で定義される。

          SPECの要素のDISPLAY部分は、要素を適用するフレームを決定する。
          SPECの1つより多くの要素が指定されたフレームに一致する場合、
          そのフレームに一致した最初の要素だけを用いる。
          DISPLAYには2つの可能性がある。

         `t'
               SPECの要素はすべてのフレームで一致する。
               したがって、SPECの以降の要素をけっして使わない。
               通常、`t'はSPECの最後の（あるいは唯一）の要素に使う。

         リスト
               DISPLAYがリストであると、 各要素は`(CHARACTERISTIC
               VALUE...)'の形であること。
               ここで、CHARACTERISTICはフレームの分類方法であり、
               VALUEはDISPLAYを適用すべき分類とみなす値である。
               特性CHARACTERISTICの可能な値はつぎのとおりである。

              `type'
                    フレームが使用するウィンドウシステムの種類であり、
                    `x'、`pc'（MS-DOSのコンソール）、 `w32'（MS Windows
                    9X/NT）、`tty'のいずれかである。

              `class'
                    フレームで扱える表示色の種類であり、
                    `color'、`grayscale'、`mono'のいずれかである。

              `background'
                    背景の種類であり、`light'か`dark'のいずれかである。

               DISPLAYの1つの要素において、 指定されたCHARACTERISTICに
               1つより多くのVALUEを指定すると、
               それらのいずれの値でも受け入れる。
               DISPLAYに1つより多くの要素がある場合、
               各要素は異なるCHARACTERISTICを指定すること。
               そうすれば、フレームの_各_特性は
               DISPLAYに指定されたそのフレーム向けの
               VALUEの1つに一致するはずである。

        標準フェイス`region'を`defface'で
定義するとつぎのようになります。

          (defface region
                   ((((class color) (background dark))
                     (:background "blue"))
                    (t (:background "gray")))
            "Used for displaying the region.")

        内部的には`defface'は、
`defface'に指定されたフェイス属性の記録には
シンボルの属性`face-defface-spec'、
カスタマイズバッファでユーザーが保存した属性の記録には `saved-face'、
説明文字列の記録には`face-documentation'を使います。

      -- User Option: frame-background-mode
          このオプションが`nil'以外であると、
          フェイスの定義を解釈する際に用いる背景の型を指定する。
          これが`dark'であると、
          実際の背景色に関わらずEmacsはすべてのフレームの背景は暗いとみなす。
          これが`light'であると、
          Emacsはすべてのフレームの背景は明るいとみなす。


File: elisp-ja,  Node: Merging Faces,  Next: Face Functions,  Prev: Defining Faces,  Up: Faces

37.10.3 表示向けにフェイスを併合する
--------------------------------------------------

     テキストの表示に使用するフェイスを指定する方法はつぎのとおりです。

        * デフォルトを使う。
          各フレームには"デフォルトのフェイス"があり、
          他のフェイスを指定していないすべてのテキストに使用される。
          （Emacsの将来の版では、
          すべてのテキスト向けのデフォルトに変更するかもしれない。）

        * テキスト属性を使う。 文字は属性`face'を持てる。
          それがある場合、そのフェイスで表示される。 *note Special
          Properties::。

          文字に属性`mouse-face'がある場合は、
          マウスが文字に『十分近い』ときには属性`face'のかわりにそれを使う。

        * オーバレイを使う。
          オーバレイは属性`face'や`mouse-face'を持てる。
          そのオーバレイが覆うすべてのテキストに適用される。

        * 活性なリージョンを使う。
          暫定マーク（transient-mark）モードでは、
          リージョンを特定のフェイス（下記の`region-face'を参照）
          で強調表示する。

        * 特別な字形を使う。 各字形では特定のフェイス番号を指定できる。
          *note Glyphs::。

        ある文字に対してこれらのさまざまな指定が
1つより多くのフェイスを指定する場合、
Emacsは指定されたさまざまなフェイスの属性を併合します。
特別な字形のフェイスが最初です。
適切ならば、つぎはリージョンの強調表示のフェイスです。
そのつぎはオーバレイのフェイスの属性、
さらにテキスト属性のフェイスが続き、 最後はデフォルトのフェイスです。

        複数のオーバレイが1つの文字を覆う場合、
高い優先順位のオーバレイが低いものに優先します。 *Note Overlays::。

フォントや表示色のような属性がうえのどれでも指定されていない場合には、
フレーム独自のフォントや表示色を使います。


File: elisp-ja,  Node: Face Functions,  Prev: Merging Faces,  Up: Faces

37.10.4 フェイスを扱う関数
-----------------------------------

フェイスの属性で指定できるのは、フォント、前景色、背景色、下線です。
フェイスでは値`nil'を指定することでこれらを未指定にできます。

        以下は、フェイスを作成したり変更する基本関数です。

      -- Function: make-face name
          この関数は、すべての属性を`nil'とした
          NAMEという名前の新たなフェイスを定義する。
          NAMEという名前のフェイスが既存ならばなにもしない。

      -- Function: face-list
          この関数は、定義済みのすべてのフェイス名のリストを返す。

      -- Function: copy-face old-face new-name &optional frame new-frame
          この関数は、既存のOLD-FACEという名前のフェイスのコピーとして
          フェイスNEW-NAMEを定義する。
          NEW-NAMEが既存でなければ、フェイスNEW-NAMEを作成する。

          省略可能な引数フレームFRAMEを指定すると、
          この関数はそのフレームだけに適用する。
          さもなければ、各フレームにおいて個別に、
          そのフレームのOLD-FACEの属性を
          同じフレームのNEW-FACEにコピーする。

          省略可能な引数フレームNEW-FRAMEを指定すると、 `copy-face'は
          フレームFRAMEのOLD-FACEの属性を
          フレームNEW-FRAMEのNEW-FACEにコピーする。

        以下の関数を使って既存のフレームの属性を変更できます。
フレームFRAMEを指定すると、そのフレームだけに影響します。
さもなければ、新たなフレームに適用されるデフォルトに加えて
すべてのフレームに影響します。

      -- Function: set-face-foreground face color &optional frame
      -- Function: set-face-background face color &optional frame
          これらの関数は、フェイスFACEの前景色（あるいは背景色）として
          COLORを設定する。 引数COLORは、表示色名の文字列であること。

          白黒スクリーンでは、濃淡は点猫パターンで実現する。

      -- Function: set-face-stipple face pattern &optional frame
          この関数は、フェイスFACEの背景点猫パターンとして
          PATTERNを設定する。
          引数PATTERNは、Xサーバーで定義された背景点猫パターンの名前であること。
          あるいは、点猫を使わないことを意味する`nil'であること。

          白黒階調の特定の濃淡を扱うために自動的に点猫パターンを使うため、
          普通は点猫パターンに注意する必要はない。

      -- Function: set-face-font face font &optional frame
          この関数は、フェイスFACEのフォントを設定する。
          引数FONTは、読者のシステムの正しいフォント名か
          Emacsのフォントセット名（*note
          Fontsets::）の文字列であること。
          フォントを明示的に設定するとつねに正確にそれを使うため、
          太字（bold）や斜体（italic）の属性の効果は消失することに注意。

      -- Function: set-face-bold-p face bold-p &optional frame
          この関数は、フェイスFACEの太字（bold）の属性を設定する。
          `nil'以外は太字あり、`nil'は太字なしを意味する。

      -- Function: set-face-italic-p face italic-p &optional frame
          この関数は、フェイスFACEの斜体（italic）の属性を設定する。
          `nil'以外は斜体あり、`nil'は斜体なしを意味する。

      -- Function: set-face-underline-p face underline-p &optional frame
          この関数は、フェイスFACEの下線の属性を設定する。
          `nil'以外は下線あり、`nil'は下線なしを意味する。

      -- Function: invert-face face &optional frame
          フェイスFACEの前景色と背景色を入れ換える。
          フェイスに前景色と背景色の両者が設定されていないと、
          その前景色と背景色にはデフォルトの背景色と前景色を設定する。

        つぎの関数は、フェイスの属性を調べます。
フレームFRAMEを指定しない場合、
新たなフレーム向けのデフォルトのデータを参照します。

      -- Function: face-foreground face &optional frame
      -- Function: face-background face &optional frame
          この関数は、フェイスFACEの前景色（あるいは背景色）を
          文字列で返す。

      -- Function: face-stipple face &optional frame
          この関数は、フェイスFACEの背景点猫パターンの名前を返す。
          なければ`nil'を返す。

      -- Function: face-font face &optional frame
          この関数はフェイスFACEのフォントの名前を返す。

      -- Function: face-bold-p face &optional frame
          この関数はフェイスFACEの太字（bold）属性を返す。

      -- Function: face-italic-p face &optional frame
          この関数はフェイスFACEの斜体（italic）属性を返す。

      -- Function: face-underline-p face &optional frame
          この関数はフェイスFACEの下線属性を返す。

      -- Function: face-id face
          この関数はフェイスFACEのフェイス番号を返す。

      -- Function: face-documentation face
          この関数はフェイスFACEの説明文字列を返す。
          なければ`nil'を返す。

      -- Function: face-equal face1 face2 &optional frame
          この関数は、フェイスFACE1とFACE2が
          表示上の同じ属性を持てば`t'を返す。

      -- Function: face-differs-from-default-p face &optional frame
          この関数は、フェイスFACEの表示がデフォルトのフェイスの表示と
          異なる場合には`t'を返す。
          フェイスの各属性がデフォルトフェイスの対応する属性に等しいか
          （デフォルトから継承すること意味する）`nil'であると、
          フェイスはデフォルトのフェイスと『等しい』とみなす。

      -- Variable: region-face
          この変数の値は、リージョンが活性（暫定マーク（transient-mark）モードのみ）
          の場合にリージョン内の文字の表示に使用するフェイス番号を指定する。
          リージョン内の文字では、これが指定するフェイスが
          テキスト属性やオーバレイのすべてのフェイスに優先する。
          暫定マーク（transient-mark）モードについて詳しくは、*note The
          Mark::。

          通常、値は`region'という名前のフェイスのフェイス番号である。

      -- Function: frame-update-face-colors frame
          この関数は、フレームFRAMEの前景色や背景色を変更後に
          フレームFRAME上のフェイスの表示を更新する。


File: elisp-ja,  Node: Blinking,  Next: Inverse Video,  Prev: Faces,  Up: Display

37.11 括弧を点滅する
===========================

     本節では、ユーザーが閉じ括弧を挿入したときに
Emacsが対応する開き括弧を指し示す機構について述べます。

      -- Variable: blink-paren-function
          この変数の値は、閉じ括弧構文の文字が挿入されるたびに
          呼び出される（引数なしの）関数であること。
          `blink-paren-function'の値が`nil'であると、なにもしない。

      -- User Option: blink-matching-paren
          この変数が`nil'であると、`blink-matching-open'はなにもしない。

      -- User Option: blink-matching-paren-distance
          この変数は、対応する括弧の走査を諦めるまでの最大距離を指定する。

      -- User Option: blink-matching-delay
          この関数は、対応する括弧にカーソルを留める秒数を指定する。
          秒未満を指定してもしばしば結果は良好であるが、
          デフォルトはすべてのシステムで動作する1である。

      -- コマンド: blink-matching-open
          この関数は、`blink-paren-function'のデフォルト値である。
          閉じ括弧構文の文字のうしろにポイントがあることを仮定し、
          カーソルを対応する開き括弧へ一時的に移動する。
          その文字がスクリーン上になければ、
          その文字が現れる文脈をエコー領域に表示する。
          遅れが大きくならないように、
          `blink-matching-paren-distance'文字より離れては探さない。

          つぎは、この関数を明示的に呼び出す例である。

               (defun interactive-blink-matching-open ()
                 "Indicate momentarily the start of sexp before point."
                 (interactive)
                 (let ((blink-matching-paren-distance
                        (buffer-size))
                       (blink-matching-paren t))
                   (blink-matching-open)))


File: elisp-ja,  Node: Inverse Video,  Next: Usual Display,  Prev: Blinking,  Up: Display

37.12 反転表示
==================

      -- User Option: inverse-video
          この変数は、スクリーン上のすべてのテキストに
          反転表示を使うかどうかを制御する。
          `nil'以外は使うことを意味し、 `nil'は使わないことを意味する。
          デフォルトは`nil'である。

      -- User Option: mode-line-inverse-video
          この変数は、モード行に反転表示を使うかどうかを制御する。
          `nil'以外であると、モード行を反転表示する。
          さもなければ、テキストと同様にモード行を普通に表示する。
          デフォルトは`t'である。

          ウィンドウフレームでは、
          `modeline'という名前のフェイスを使ってモード行を表示する。
          このフェイスは、変更していなければ、デフォルトフェイスの反転表示である。


File: elisp-ja,  Node: Usual Display,  Next: Display Tables,  Prev: Inverse Video,  Up: Display

37.13 通常の画面表示慣習
=================================

通常の画面表示慣習は、各文字コードをどのように表示するかを定義します。
表示テーブル（*note Display Tables::）を設定すれば、
これらの慣習を無効にできます。 通常の画面表示慣習をつぎに示します。

        * 文字コード32から126は、字形コード32から126に対応付ける。
          これは各文字をそのまま表示することを普通は意味する。

        * 文字コード9は水平タブである。
          `tab-width'で決定される位置まで空白として表示する。

        * 文字コード10は改行である。

        * 0から31の範囲とコード127のコードすべてには、
          `ctl-arrow'の値に従って2つの表示方法の一方を使う。
          `ctl-arrow'が`nil'以外であると、
          これらのコードを2つの字形列に対応付け、
          最初の字形は`^'のASCIIコードである。
          （表示テーブルで`^'のかわりに使う字形を指定できる。）
          さもなければ、これらは128から255の範囲のコードと同様に対応付ける。

        * 文字コード128から255は、4つの字形列に対応付ける。
          つまり、最初の字形は`\'のASCIIコード、
          残りは文字コードを8進数表示した数字文字である。
          （表示テーブルで`\'のかわりに使う字形を指定できる。）

        * 256を越えるマルチバイト文字コードは、そのまま表示する。
          あるいは、端末に表示できない文字は、疑問符か白抜きの箱で表示する。

        通常の画面表示慣習は、たとえ表示テーブルがあっても、
活性な表示テーブルにおいてその文字に対する項目が`nil'であるような
文字すべてに適用されます。 したがって、表示テーブルを設定するときには、
特別なふるまいをさせたい文字だけを指定すればよいのです。

これらの変数は、特定の文字群のスクリーンへの表示方法に影響します。
これらは文字が占めるコラム数を変化させるので、
字下げ関数にも影響します。
これらの変数は、モード行の表示方法にも影響します。
新たな値を用いてモード行の再表示を強制したいときには、
関数`force-mode-line-update'（*note Mode Line Format::）を
呼び出します。

      -- User Option: ctl-arrow
          このバッファローカルな変数は、
          コントロール文字の表示方法を制御する。
          `nil'以外であると、`^A'のように
          カレットに続けて文字を表示する。 `nil'であると、`\001'のように
          バックスラッシュに続けて3桁の8進数字で表示する。

      -- Variable: default-ctl-arrow
          この変数の値は、`ctl-arrow'を書き換えていないバッファ向けの
          `ctl-arrow'のデフォルト値である。 *note Default Value::。

      -- User Option: tab-width
          この変数の値は、Emacsのバッファ内のタブ文字の表示に使う
          タブストップの間隔である。 デフォルトは8である。
          この機能は、コマンド`tab-to-tab-stop'で設定する
          ユーザー設定可能なタブストップとはまったく独立であることに注意。
          *note Indent Tabs::。


File: elisp-ja,  Node: Display Tables,  Next: Beeping,  Prev: Usual Display,  Up: Display

37.14 表示テーブル
========================

     "表示テーブル"（display table）機能を使って、
すべての可能な文字コードのスクリーンへの表示方法を制御できます。
これは、ASCII文字集合にない文字を用いる
ヨーロッパの言語を表示するのに有用です。

表示テーブルは、各文字コードを"字形"（glyph）の列に対応付けます。
各字形は、スクリーン上で1文字を占める像です。 "字形テーブル"（glyph
table）を使えば、
読者の端末に各字形を表示する方法を定義することもできます。

        表示テーブルは、モード行の表示方法にも影響します。
新たな表示テーブルを用いてモード行の再表示を強制したいときには、
関数`force-mode-line-update'（*note Mode Line Format::）を
呼び出します。

     * Menu:

     * Display Table Format::	What a display table consists of.
     * Active Display Table::	How Emacs selects a display table to use.
     * Glyphs::			How to define a glyph, and what glyphs mean.


File: elisp-ja,  Node: Display Table Format,  Next: Active Display Table,  Up: Display Tables

37.14.1 表示テーブルの書式
-----------------------------------

     表示テーブルは、実際にはサブタイプが`display-table'である
文字テーブル（*note Char-Tables::）です。

      -- Function: make-display-table
          表示テーブルを作成して返す。
          テーブルのすべての要素の初期値は`nil'である。

        表示テーブルの通常の要素は、文字コードで添字付けします。
添字Cの要素は、文字コードCの表示方法を指定します。
値は`nil'であるか、字形の値のベクトル（*note Glyphs::）です。
要素が`nil'であると、その文字を通常の画面表示慣習 （*note Usual
Display::）に従って表示する指定です。

        表示テーブルを使って改行文字の表示を変更すると、
バッファ全体は長い1つの『行』として表示されます。

        表示テーブルには6つの『追加スロット』もあり、
それらは特別な目的を果たします。 それらの意味をつぎに示します。
スロットの内容が`nil'であると、 そのスロットに対して以下に述べる
デフォルトを使うことを意味します。

    0
          切り詰めたスクリーン行の末尾に使う字形 （デフォルトは`$'）。
          *note Glyphs::。

    1
          継続している行の末尾に使う字形 （デフォルトは`\'）。

    2
          文字を8進数文字コードで表示したことを表す字形
          （デフォルトは`\'）。

    3
          コントロール文字を表す字形 （デフォルトは`^'）。

    4
          符可視な行があることを表す字形のベクトル
          （デフォルトは`...'）。 *note Selective Display::。

    5
          左右に隣り合ったウィンドウの境界に使う字形
          （デフォルトは`|'）。 *note Splitting Windows::。

        たとえば、`ctl-arrow'に`nil'以外の値を設定した効果を
模倣する表示テーブルの作成方法をつぎに示します。

          (setq disptab (make-display-table))
          (let ((i 0))
            (while (< i 32)
              (or (= i ?\t) (= i ?\n)
                  (aset disptab i (vector ?^ (+ i 64))))
              (setq i (1+ i)))
            (aset disptab 127 (vector ?^ ??)))

      -- Function: display-table-slot display-table slot
          この関数は表示テーブルDISPLAY-TABLEの
          追加スロットSLOTの値を返す。
          引数SLOTは0から5までの数であるか、
          スロット名（シンボル）であること。
          正しいシンボルは、`truncation'、`wrap'、
          `escape'、`control'、`selective-display'、
          `vertical-border'である。

      -- Function: set-display-table-slot display-table slot value
          この関数は表示テーブルDISPLAY-TABLEの
          追加スロットSLOTに値VALUEを保存する。
          引数SLOTは0から5までの数であるか、
          スロット名（シンボル）であること。
          正しいシンボルは、`truncation'、`wrap'、
          `escape'、`control'、`selective-display'、
          `vertical-border'である。


File: elisp-ja,  Node: Active Display Table,  Next: Glyphs,  Prev: Display Table Format,  Up: Display Tables

37.14.2 活性な表示テーブル
-----------------------------------

     各ウィンドウに表示テーブルを指定でき、
各バッファにも表示テーブルを指定できます。
バッファBがウィンドウWに表示されているとき、
ウィンドウWに表示テーブルがあればそれを使って表示します。
さもなければ、バッファBに表示テーブルがあればそれを使います。
それ以外では、標準の表示テーブルがあればそれを使います。
選択されている表示テーブルを"活性な"表示テーブルと呼びます。

      -- Function: window-display-table window
          この関数は、ウィンドウWINDOWの表示テーブルを返す。
          WINDOWに表示テーブルが割り付けられていなければ`nil'を返す。

      -- Function: set-window-display-table window table
          この関数は、ウィンドウWINDOWの表示テーブルとして
          TABLEを設定する。
          引数TABLEは、表示テーブルであるか`nil'であること。

      -- Variable: buffer-display-table
          この変数はすべてのバッファで自動的にバッファローカルである。
          バッファでの値は、そのバッファに対して用いる表示テーブルを指定する。
          それが`nil'であると、バッファに表示テーブルを
          割り付けていないことを意味する。

      -- Variable: standard-display-table
          この変数の値はデフォルトの表示テーブルであり、
          ウィンドウに表示テーブルがなく
          そのウィンドウのバッファにも表示テーブルがない場合に使われる。
          この変数はデフォルトでは`nil'である。

        特定のウィンドウにおいて使用する表示テーブルがない場合には、
つまり、ウィンドウで未指定であり、そのバッファでも未指定であり、
`standard-display-table'が`nil'である場合には、
そのウィンドウ内のすべての文字コードには通常の画面表示慣習を使います。
*Note Usual Display::。


File: elisp-ja,  Node: Glyphs,  Prev: Active Display Table,  Up: Display Tables

37.14.3 字形
--------------

     "字形"（glyph）は、文字を一般化したものです。
スクリーン上で1文字を占める像を表します。
文字と同様に、字形はLispでは整数で表現します。

        字形としての各整数の意味は、字形テーブルで定義されます。
これは変数`glyph-table'の値です。

      -- Variable: glyph-table
          この変数の値は、現在の字形テーブルである。
          これはベクトルであること。
          G番目の要素は、字形コードGを定義する。
          値がベクトルではなく`nil'であると、
          すべての字形は単純（下記参照）である。

        字形テーブルの要素として可能な型はつぎのとおりです。

    STRING
          この字形を出力するために端末へSTRINGの文字群を送出する。
          これは文字端末では使えるがウィンドウシステムでは使えない。

    INTEGER
          この字形コードを字形コードINTEGERの別称として定義する。
          字形に対してフェイスコードを指定するために別称を使うことができる。
          下記参照。

    `nil'
          この字形は単純である。 通常の端末では、字形コード mod 524288
          は出力すべき文字である。 ウィンドウシステムでは、字形コード
          mod 524288 は出力すべき文字あり、
          字形コードを524288で除した値は出力中に使用すべきフェイス番号
          （*note Face Functions::）である。 （524288は 2**19。） *note
          Faces::。

        字形コードが字形テーブルの長さに等しいか大きいと、
そのコードは自動的に単純とします。


File: elisp-ja,  Node: Beeping,  Next: Window Systems,  Prev: Display Tables,  Up: Display

37.15 ベルを鳴らす
========================

     本節では、ユーザーの注意を引くためにEmacsにベルを鳴らせる
（あるいはスクリーンを点滅させる）方法について述べます。
ベルを鳴らす頻度はなるべく控えめにしてください。
頻繁にベルが鳴るとわずらわしいものです。
エラーを通知するほうがふさわしいときには、
単にベルを鳴らさないように注意してください。 （*note Errors::。）

      -- Function: ding &optional do-not-terminate
          この関数は、ベルを鳴らすかスクリーンを点滅する
          （下記の`visible-bell'を参照）。
          また、DO-NOT-TERMINATEが`nil'であると
          現在実行中のキーボードマクロを終了する。

      -- Function: beep &optional do-not-terminate
          `ding'の同義語。

      -- User Option: visible-bell
          この変数は、ベルを鳴らすかわりにスクリーンを点滅させるかどうかを決定する。
          `nil'以外であると点滅するを意味し、
          `nil'であると点滅しないを意味する。
          これは、ウィンドウシステムを用いている場合か、
          端末のtermcapの定義にビジュアルベル機能（`vb'）がある
          文字端末で有効である。

      -- Variable: ring-bell-function
          これが`nil'以外であると、
          Emacsに『ベルを鳴らす』方法を指定する。
          この値は、引数なしの関数であること。


File: elisp-ja,  Node: Window Systems,  Prev: Beeping,  Up: Display

37.16 ウィンドウシステム
=================================

     Emacsはいくつかのウィンドウシステムで、
特にXウィンドウシステムで動作します。
EmacsもXも用語『ウィンドウ』を使いますが、用法は異なります。
Emacsの1つのフレームは、Xでは1つのウィンドウです。
Emacsの個々のウィンドウについては、Xはまったくわかりません。

      -- Variable: window-system
          この変数は、Emacsが動作しているウィンドウシステムの種類を
          Lispプログラムに伝える。 可能な値はつぎのとおりである。

         `x'
               Xを用いて表示している。

         `pc'
               MSDOSを用いて表示している。

         `w32'
               Windows NTかWindows 95を用いて表示している。

         `nil'
               文字ベースの端末を用いて表示している。

      -- Variable: window-setup-hook
          この変数は、Emacsが初期化ファイルを処理したあとに実行する
          ノーマルフックである。
          読者のファイル`.emacs'、（あれば）デフォルトの初期化ファイル、
          端末固有のLispコードをすべてロードし、
          フック`term-setup-hook'を実行し終えてから、
          このフック実行する。

          このフックは内部目的用であり、
          ウィンドウシステムとの通信を設定し、最初のウィンドウを作成する。
          ユーザーが干渉すべきではない。



File: elisp-ja,  Node: Calendar,  Next: System Interface,  Prev: Display,  Up: Top

38 カレンダーと日誌のカスタマイズ
************************************************

     カレンダーや日誌を個人の好みに合わせるための
カスタマイズ項目がたくさんあります。

     * Menu:

     * Calendar Customizing::   Defaults you can set.
     * Holiday Customizing::    Defining your own holidays.
     * Date Display Format::    Changing the format.
     * Time Display Format::    Changing the format.
     * Daylight Savings::       Changing the default.
     * Diary Customizing::      Defaults you can set.
     * Hebrew/Islamic Entries:: How to obtain them.
     * Fancy Diary Display::    Enhancing the diary display, sorting entries,
                                  using included diary files.
     * Sexp Diary Entries::     Fancy things you can do.
     * Appt Customizing::	   Customizing appointment reminders.


File: elisp-ja,  Node: Calendar Customizing,  Next: Holiday Customizing,  Up: Calendar

38.1 カレンダーのカスタマイズ
=========================================

     変数`view-diary-entries-initially'に`t'を設定しておくと、
カレンダーを呼び出すと現在の日に対する日誌記録を自動的に表示できます。
その日がウィンドウで見える場合に限って日誌記録が表示されます。
つぎの行、

          (setq view-diary-entries-initially t)
          (calendar)

     を個人のファイル`.emacs'に入れておくと、
Emacsを起動するたびに、カレンダーと日誌の両者のウィンドウを表示します。

        同様に、変数`view-calendar-holidays-initially'に
`t'を設定しておくと、
カレンダーに入ると自動的に3か月分の祝祭日一覧を表示します。
祝祭日一覧は別のウィンドウに現れます。

        変数`mark-diary-entries-in-calendar'に`t'を設定すると、
日誌に入れてある日付に印を付けられます。
カレンダーのウィンドウ内容を再計算するときにこの効果が現れます。
これらの日付に印を付ける方法は2つあります。
ディスプレイで使えるならばフェイス（*note Faces::）を変更するか、
日付にプラス記号（`+'）を付加します。

        同様に、変数`mark-holidays-in-calendar'に`t'を設定すると、
フェイスを変えるかアスタリスク（`*'）を付加することで
祝祭日に印を付けられます。

        変数`calendar-holiday-marker'は、
祝祭日の日付にどのように印を付けるかを指定します。
その値は、日付に付加する文字か日付の表示に使うフェイス名です。
同様に、変数`diary-entry-marker'は、
日誌に入っている日付にどのように印を付けるかを指定します。
カレンダー（calendar）モードは、このような目的のために
`holiday-face'と`diary-face'という名前のフェイスを作成します。
Emacsが端末で複数のフェイスを扱える場合には、
これらの変数のデフォルト値はこれらのシンボルです。

        変数`calendar-load-hook'は、
（カレンダーを実際に表示し始めるまえに）カレンダーパッケージを初めて
ロードしたときに実行されるノーマルフックです。

カレンダーを開始するとノーマルフック`initial-calendar-window-hook'を
実行します。 カレンダーの表示を再計算してもこのフックは実行されません。
しかし、コマンド`q'でカレンダーを抜けてから再度カレンダーに入ると
このフックを再度実行します。

        変数`today-visible-calendar-hook'は、
今日の日付がウィンドウで見えるときに
カレンダーバッファにカレンダーの準備を終えてから実行される
ノーマルフックです。
このフックの1つの用途は、今日の日付をアスタリスクで置き換えることです。
それにはフック関数`calendar-star-date'を使います。

          (add-hook 'today-visible-calendar-hook 'calendar-star-date)

他の標準的なフック関数は、フェイスを変更するかアスタリスクを付加することで
現在の日付に印を付けます。 つぎのように使います。

          (add-hook 'today-visible-calendar-hook 'calendar-mark-today)

     変数`calendar-today-marker'は、
今日の日付の印の付け方を指定します。
その値は、日付に付加する文字か日付の表示に使うフェイス名です。
この目的のために`calendar-today-face'という名前のフェイスがあります。
Emacsが端末で複数のフェイスを扱える場合には、
この変数のデフォルト値はこのシンボルです。

     同様なノーマルフック`today-invisible-calendar-hook'は、
現在の日付がウィンドウで見え_ない_ときに実行されます。


File: elisp-ja,  Node: Holiday Customizing,  Next: Date Display Format,  Prev: Calendar Customizing,  Up: Calendar

38.2 祝祭日のカスタマイズ
===================================

     Emacsは、複数のリストの中の1つのリストに入っている項目群で
定義される祝祭日を把握しています。
これらの祝祭日のリストに祝祭日を追加したり削除して
個人の目的に合うようにカスタマイズできます。
Emacsが使用する祝祭日のリストは、 一般祝祭日（`general-holidays'）、
地域祝祭日（`local-holidays'）、
キリスト教祝祭日（`christian-holidays'）、
ヘブライ（ユダヤ教）祝祭日（`hebrew-holidays'）、
イスラム（回教徒）祝祭日（`islamic-holidays'）、
その他の祝祭日（`other-holidays'）です。

        一般祝祭日は、デフォルトでは、合州国に共通の祝祭日です。
これらの祝祭日を削除するには、`general-holidays'に`nil'を設定します。

        デフォルトの地域祝祭日はありません（サイトによってはある）。
以下に述べるように、
変数`local-holidays'に祝祭日の任意のリストを設定できます。

        デフォルトでは、Emacsが承知している宗教のすべての祝祭日が
Emacsに入っているのではなく、世俗的なカレンダーに共通するものだけです。
宗教上の祝祭日を網羅的に入れるには、 `all-christian-calendar-holidays'、
`all-hebrew-calendar-holidays'、
`all-islamic-calendar-holidays'の変数のいずれか（あるいは、すべて）に
`t'を設定します。 宗教上の祝祭日を削除するには、対応する
`christian-holidays'、`hebrew-holidays'、
`islamic-holidays'の変数のいずれか（あるいは、すべて）に
`nil'を設定します。

        変数`other-holidays'には、祝祭日の任意のリストを設定できます。
このリストは、普通は空ですが、個人的な使用を意図しています。

        リスト（`general-holidays'、`local-holidays'、
`christian-holidays'、`hebrew-holidays'、
`islamic-holidays'、`other-holidays'）のおのおのは、
祝祭日（あるいは祝祭日のリスト）を記述する "祝祭日形式"（holiday
form）から成るリストです。

        可能な祝祭日形式の一覧をつぎに示します。
月と日は1から数えますが、『曜日』は日曜日を0と数えます。
要素STRINGは、文字列で表した祝祭日の名称です。

    `(holiday-fixed MONTH DAY STRING)'
          グレゴリオ暦の固定した日付。

    `(holiday-float MONTH DAYNAME K STRING)'
          グレゴリオ暦のMONTH月のK番目の曜日DAYNAME。
          （日曜日はDAYNAME=0、…。） Kが負であると、月末から数える。

    `(holiday-hebrew MONTH DAY STRING)'
          ヘブライ暦の固定した日付。

    `(holiday-islamic MONTH DAY STRING)'
          イスラム暦の固定した日付。

    `(holiday-julian MONTH DAY STRING)'
          ユリウス暦の固定した日付。

    `(holiday-sexp SEXP STRING)'
          Lisp式SEXPで計算される日付。
          計算式では、年として変数`year'を使い、祝祭日の日付を返す。
          あるいは、その年に該当する祝祭日がなければ`nil'を返す。
          SEXPの値は、`(MONTH DAY YEAR)'の形の
          リストで表した日付であること。

    `(if CONDITION HOLIDAY-FORM)'
          条件CONDITIONが真である場合にのみ祝祭日になる。

    `(FUNCTION [ARGS])'
          引数ARGSで関数FUNCTIONを呼び出して計算される日付のリスト。

        たとえば、フランスで7月14日に祝われる革命記念日（Bastille
Day）を 扱えるようにするにはつぎのようにします。

          (setq other-holidays '((holiday-fixed 7 14 "Bastille Day")))

     祝祭日形式 `(holiday-fixed 7 14 "Bastille Day")'は、
7の月（7月）の14日目を指定します。

        多くの祝祭日は、特定の月の特定の週にあります。
バージン諸島で4月の第4月曜日に祝われる ハリケーン祈願日（Hurricane
Supplication Day）を記述する 祝祭日形式はつぎのようになります。

          (holiday-float 8 1 4 "Hurricane Supplication Day")

     ここで、8は8月、1は月曜日（日曜日は0、火曜日は2といった具合）、4は
その月の4回目（1は最初、2は2回目、-1は最後、-2は最後の1つまえ
といった具合）を意味します。

ヘブライ暦、イスラム暦、ユリウス暦の固定した日付の祝祭日も指定できます。
たとえば、

          (setq other-holidays
                '((holiday-hebrew 10 2 "Last day of Hanukkah")
                  (holiday-islamic 3 12 "Mohammed's Birthday")
                  (holiday-julian 4 2 "Jefferson's Birthday")))

     は、ハヌカー祭の最終日（ヘブライ暦の月はニサンNisanを1と数える）、
イスラムが祝うモハメッドの誕生日
（イスラム暦の月はムハラMuharramを1と数える）、
ユリウス暦の1743年4月2日のトーマスジェファーソンの誕生日を 追加します。

        条件付きの祝祭日を含めるには、Emacs Lispの`if'や`holiday-sexp'を
使います。
たとえば、アメリカ大統領選挙は、4で割り切れる年の11月の第1月曜日の
あとの最初の火曜日に行われます。

          (holiday-sexp (if (= 0 (% year 4))
                             (calendar-gregorian-from-absolute
                              (1+ (calendar-dayname-on-or-before
                                    1 (+ 6 (calendar-absolute-from-gregorian
                                            (list 11 1 year))))))
                        "US Presidential Election"))

     あるいは、

          (if (= 0 (% displayed-year 4))
              (fixed 11
                     (extract-calendar-day
                       (calendar-gregorian-from-absolute
                         (1+ (calendar-dayname-on-or-before
                               1 (+ 6 (calendar-absolute-from-gregorian
                                        (list 11 1 displayed-year)))))))
                     "US Presidential Election"))

特別な計算を必要とする祝祭日は、これまでの形式にあてはまりません。
そのような場合、計算を行うLisp関数を書く必要があります。
たとえば、日食月食を含めるには、
`other-holidays'に`(eclipses)'を追加して、
以下のような形でカレンダーウィンドウの見えている範囲の期間内の
対応するグレゴリオ暦の日付の（空である可能性もある）リストを 返すEmacs
Lisp関数`(eclipses)'を書きます。

          (((6 27 1991) "Lunar Eclipse") ((7 11 1991) "Solar Eclipse") ... )


File: elisp-ja,  Node: Date Display Format,  Next: Time Display Format,  Prev: Holiday Customizing,  Up: Calendar

38.3 日付表示書式
=======================

     日誌、モード行、メッセージに現れる日付の表示方法は、
`calendar-date-display-form'を設定することでカスタマイズできます。
この変数は、
文字列で表した数字が入った`month'、`day'、`year'の各変数と、
英字の文字列が入った`monthname'と`dayname'の各変数を
用いた式のリストを保持しています。
アメリカスタイルでは、このリストのデフォルト値はつぎのようになります。

          ((if dayname (concat dayname ", ")) monthname " " day ", " year)

一方、ヨーロッパスタイルでは、この値のデフォルトはつぎのようになります。

          ((if dayname (concat dayname ", ")) day " " monthname " " year)

     ISO規格の日付の表記法はつぎのとおりです。

          (year "-" month "-" day)

     典型的なアメリカの書式はつぎのとおりです。

          (month "/" day "/" (substring year -2))


File: elisp-ja,  Node: Time Display Format,  Next: Daylight Savings,  Prev: Date Display Format,  Up: Calendar

38.4 時刻表示書式
=======================

     カレンダーと日誌はデフォルトではアメリカスタイル、
つまり、12時制で時刻を表示します。
ヨーロッパスタイルやアメリカ軍の24時制を好むならば、
変数`calendar-time-display-form'を変更します。 この変数は、
文字列で表した数字が入った`12-hours'、`24-hours'、 `minutes'の各変数と、
英字の文字列が入った`am-pm'と`time-zone'の各変数を
用いた式のリストを保持しています。
`calendar-time-display-form'のデフォルト値はつぎのとおりです。

          (12-hours ":" minutes am-pm
                    (if time-zone " (") time-zone (if time-zone ")"))

     つぎの値では、ヨーロッパスタイルの時刻になります。

          (24-hours ":" minutes
                    (if time-zone " (") time-zone (if time-zone ")"))


File: elisp-ja,  Node: Daylight Savings,  Next: Diary Customizing,  Prev: Time Display Format,  Up: Calendar

38.5 夏時間
==============

     Emacsは、標準時間と夏時間の違いを理解しています。
つまり、日出入時刻、夏至冬至、春分秋分、朔弦望ではその違いを考慮します。
夏時間の規則は、地域ごと、年ごとに変わりえます。
正しく扱うためには、どの規則が適用されるかをEmacsが知っている必要があります。

        読者の居住地域に適用される規則を記録している
オペレーティングシステムもあります。
これらのシステム上では、Emacsは自動的にシステムから必要な情報を得られます。
この情報の一部やすべてが欠落していると、
GNU世界の中心であるマサチューセッツ州ケンブリッジで
現在使用している規則で補います。

        デフォルトで選んだ規則が読者の地域に適切でないときには、
変数`calendar-daylight-savings-starts'と
`calendar-daylight-savings-ends'に設定してEmacsに伝えます。
これらの値は、変数`year'を使ったLisp式である必要があります。
これらの式を評価すると、夏時間を開始／終了するグレゴリオ暦の日付を表す
`(MONTH DAY YEAR)'の形のリストに なる必要があります。
夏時間をとらない場合には、値は`nil'であるべきです。

        Emacsは、これらの式を用いて夏時間の開始と終了を判定し、
祝祭日や太陽／月に関する時刻を補正します。

        マサチューセッツ州ケンブリッジに対する値は、つぎのとおりです。

          (calendar-nth-named-day 1 0 4 year)
          (calendar-nth-named-day -1 0 10 year)

     つまり、指定された`year'年の4月の最初の日曜日と
その年の10月の最後の日曜日です。
10月1日に夏時間を始めると変更したとすると、
変数`calendar-daylight-savings-starts'に つぎのように設定します。

          (list 10 1 year)

より複雑な例として、ヘブライ暦のニサンの初日に夏時間が始まるとしましょう。
`calendar-daylight-savings-starts'には、 つぎの値を設定します。

          (calendar-gregorian-from-absolute
            (calendar-absolute-from-hebrew
              (list 1 1 (+ year 3760))))

     これは、ニサンはヘブライ暦の最初の月であり、
ヘブライ暦年とグレゴリオ暦年はニサンで3760年違うからです。

        読者の地域で夏時間をとっていなかったり、
つねに標準時間を望む場合には、 `calendar-daylight-savings-starts'と
`calendar-daylight-savings-ends'に`nil'を設定します。

        変数`calendar-daylight-time-offset'は、
夏時間と標準時間の分で計った差を指定します。
ケンブリッジに対する値は60です。

        変数`calendar-daylight-savings-starts-time'と
`calendar-daylight-savings-ends-time'は、
夏時間と標準時間との移行が行われる
地方時の真夜中の0時からの経過分を指定します。
ケンブリッジでは、どちらの変数の値も120です。


File: elisp-ja,  Node: Diary Customizing,  Next: Hebrew/Islamic Entries,  Prev: Daylight Savings,  Up: Calendar

38.6 日誌のカスタマイズ
================================

     通常、日誌用バッファのウィンドウのモード行には、
日誌記録の日付に一致する祝祭日があれば表示されます。
祝祭日を検査する処理には数秒を要するので、
祝祭日情報を含めると日誌用バッファの表示に遅れが生じます。
祝祭日情報をなくして日誌用バッファの表示を速くしたい場合には、
変数`holidays-in-diary-buffer'に`nil'を設定します。

        変数`number-of-diary-entries'は、
一度に表示する日誌記録の日数を制御します。
これは、`view-diary-entries-initially'が`t'であるときの
最初の表示に影響します。
たとえば、デフォルト値は1で、現在の日付の日誌記録のみを表示します。
値が2であると、現在とつぎの日付の日誌記録を表示します。
この値は7要素のベクトルでもかまいません。 たとえば、値が`[0 2 2 2 2 4
1]'であると、 日曜日には日誌記録をなにも表示せず、
月曜日から木曜日には現在とつぎの日付の日誌記録を表示し、
金曜日には金曜日から月曜日の日誌記録を表示し、
土曜日にはその日だけの日誌記録を表示します。

        変数`print-diary-entries-hook'は、
日誌用バッファで現在見えている日誌記録のみを収めた一時的なバッファの
準備ができると実行されるノーマルフックです。
（他の関係ない日誌記録は一時的なバッファには入っていない。
日誌用バッファではそれらは隠されている。）
このフックのデフォルト値は、コマンド`lpr-buffer'で印刷します。
別のコマンドで印刷したい場合には、単にこのフックの値を変更します。
別の用途は、たとえば、行を日付と時刻で並び替えることです。

        `diary-date-forms'に設定すれば、
目的に合うように個人の日誌ファイル内の日付の書式を
アメリカスタイルやヨーロッパスタイルにカスタマイズできます。
この変数は、日付を認識するパターンのリストです。
各パターンは、正規表現（*note Regular Expressions::）や
`month'、`day'、`year'、`monthname'、
`dayname'のシンボルを要素とするリストです。
これらの要素すべては、日誌ファイル内の特定種類のテキストに一致する
パターンとして働きます。 全体として日付パターンとして一致するには、
すべての要素が順に一致する必要があります。

        日付パターンの正規表現は、`*'を単語構成文字に変更した
標準の構文テーブルを用いて通常どおりに一致をとります。

        `month'、`day'、`year'、`monthname'、`dayname'の
シンボルは、対象にしている月、日、年、月の名前、曜日です。
数に一致するシンボルは、数の先頭にある0を許します。
名前に一致するシンボルは、3文字の省略形や大文字で始まることを許します。
日誌記録では`*'は『任意の日』『任意に月』などを表し、
対象とする日付に関係なく一致するべきなので、
すべてのシンボルは`*'に一致できます。

アメリカスタイルの`diary-date-forms'のデフォルト値はつぎのとおりです。

          ((month "/" day "[^/0-9]")
           (month "/" day "/" year "[^0-9]")
           (monthname " *" day "[^,0-9]")
           (monthname " *" day ", *" year "[^0-9]")
           (dayname "\\W"))

        リスト内の日付パターンは、_互いに排他的_であり、
日誌記録の日付と1つの白文字以外には他の部分に一致してはいけません。
互いに排他的であるためには、
パターンは日付を終える白文字を越えて日誌記録本文に一致する必要があります。
それには、日付パターンの最初の要素は`backup'である必要があります。
これにより、日付を認識する処理では、
一致し終えてから日誌記録の現在の単語の先頭に戻ります。
たとえ`backup'を使ったとしても、
日付パターンは日誌本体の最初の単語を越えて一致してはいけません。
ヨーロッパスタイルの`diary-date-forms'のデフォルト値は、
つぎのとおりです。

          ((day "/" month "[^/0-9]")
           (day "/" month "/" year "[^0-9]")
           (backup day " *" monthname "\\W+\\<[^*0-9]")
           (day " *" monthname " *" year "[^0-9]")
           (dayname "\\W"))

     ここでは、3番目のパターンで`backup'を使っています。
4番目のパターンと区別するために、
日付のつぎの単語の一部と一致する必要があるからです。


File: elisp-ja,  Node: Hebrew/Islamic Entries,  Next: Fancy Diary Display,  Prev: Diary Customizing,  Up: Calendar

38.7 ヘブライ暦日付やイスラム暦日付の日誌記録
=================================================================

     日誌ファイルには、世界標準のグレゴリオ暦日付に加えて、
ヘブライ暦日付やイスラム暦日付を入れることもできます。
しかし、そのような記録の認識には時間がかかり、
ほとんどの人はそれらを使わないので、
それらは明示的にオンにする必要があります。
日誌でヘブライ暦日付の日誌記録を認識できるように望むなら、
たとえば、つぎのようにする必要があります。

          (add-hook 'nongregorian-diary-listing-hook 'list-hebrew-diary-entries)
          (add-hook 'nongregorian-diary-marking-hook 'mark-hebrew-diary-entries)

     イスラム暦日付の日誌記録を望むなら、つぎのようにします。

          (add-hook 'nongregorian-diary-listing-hook 'list-islamic-diary-entries)
          (add-hook 'nongregorian-diary-marking-hook 'mark-islamic-diary-entries)

        ヘブライ暦日付やイスラム暦日付の日誌記録は、
グレゴリオ暦日付と同じ形式ですが、 ヘブライ暦日付のまえには`H'、
イスラム暦日付のまえには`I'がある点が異なります。
さらに、ヘブライ暦やイスラム暦の月は、最初の3文字で一意に決まらないため、
月の省略形は使えません。 たとえば、ヘブライ暦日付Heshvan
25の日誌記録はつぎのようになります。

          HHeshvan 25 Happy Hebrew birthday!

     これはヘブライ暦日付Heshvan 25に対する任意の日誌に現れます。
イスラム暦日付Dhu al-Qada 25に一致する日誌記録はつぎのようになります。

          IDhu al-Qada 25 Happy Islamic birthday!

        グレゴリオ暦日付の日誌記録では、
ヘブライ暦日付とイスラム暦日付の記録は、
それらの前にアンパサンド（`&'）があると印付けされません。

        ヘブライ暦やイスラム暦において
指定した日付や似た日付に一致する日誌記録を作成するための
カレンダーのコマンド一覧をつぎに示します。

    `i h d'
          選択した日付に対応するヘブライ暦日付に日誌記録を追加する
          （`insert-hebrew-diary-entry'）。

    `i h m'
          選択した日付に対応するヘブライ暦月の日に日誌記録を追加する
          （`insert-monthly-hebrew-diary-entry'）。
          この日誌記録は、選択した日付のヘブライ暦の月内の日と同じ
          任意の日付に一致する。

    `i h y'
          選択した日付のヘブライ暦年の日に日誌記録を追加する
          （`insert-yearly-hebrew-diary-entry'）。
          この日誌記録は、選択した日付のヘブライ暦の月とその月内の日と同じ
          任意の日付に一致する。

    `i i d'
          選択した日付に対応するイスラム暦日付に日誌記録を追加する
          （`insert-islamic-diary-entry'）。

    `i i m'
          選択した日付に対応するイスラム暦の月内の日に日誌記録を追加する
          （`insert-monthly-islamic-diary-entry'）。

    `i i y'
          選択した日付のイスラム暦年の日に日誌記録を追加する
          （`insert-yearly-islamic-diary-entry'）。

これらのコマンドは、日誌記録の対応する普通のコマンドと同様に働きます。
カレンダーウィンドウにおいてポイントがある日付に作用し、
日誌記録の日付に関する部分のみを挿入します。
日誌記録の本文は自分で入力する必要があります。


File: elisp-ja,  Node: Fancy Diary Display,  Next: Sexp Diary Entries,  Prev: Hebrew/Islamic Entries,  Up: Calendar

38.8 装飾日誌表示
=======================

日誌表示は、日誌用バッファを準備してからフック`diary-display-hook'を
実行することで動作します。
このフックのデフォルト値（`simple-diary-display'）は、
関係ない日誌記録を隠してからバッファを表示します。
しかし、つぎのようにフックを指定すると

          (add-hook 'diary-display-hook 'fancy-diary-display)

     装飾日誌表示を行えます。
日誌記録と祝祭日を表示専用の特別なバッファにコピーして表示します。
別のバッファにコピーするので、表示テキストが綺麗になるように変更できます。
たとえば、日付順に記録をソートするなどです。

単純な日誌表示では、`print-diary-entries'でバッファ内容を印刷できます。
1週間分の毎日の日誌を印刷するには、 その週の日曜日にポイントを置いて`7
d'と打ってから `M-x print-diary-entries'を行います。
祝祭日が入っていると表示が遅くなりますが、
変数`holidays-in-diary-buffer'に`nil'を設定すると速くできます。

        通常、装飾日誌用バッファでは、
たとえ祝祭日であっても日誌記録がない日は表示しません。
そのような日を装飾日誌用バッファに表示するには、
変数`diary-list-include-blanks'に`t'を設定します。

        装飾日誌表示を使うときには、
ノーマルフック`list-diary-entries-hook'を使って
各日誌記録を時刻でソートできます。 つぎのようにします。

          (add-hook 'list-diary-entries-hook 'sort-diary-entries t)

     これは、各日ごとに認識できる時刻で始まる日誌記録をソートします。
各日の先頭には時刻のついていない日誌項目がきます。

装飾日誌表示には、取り込んだ日誌ファイルを処理する能力もあります。
これにより、グループのメンバは、グループに共通な行事を記述した
日誌ファイルを共有できます。 つぎのような行を日誌ファイルに書きます。

          #include "FILENAME"

     そうすると、ファイルFILENAMEから
日誌記録を装飾日誌用バッファに取り込みます。
取り込み機構は再帰的ですから、
取り込んだファイル内で別のファイルを取り込むことができます。
もちろん、取り込みが循環しないように注意してください。
取り込み機能をオンにするにはつぎのようにします。

          (add-hook 'list-diary-entries-hook 'include-other-diary-files)
          (add-hook 'mark-diary-entries-hook 'mark-included-diary-files)

        通常の日誌表示は個人の日誌ファイルの記録を直接表示するため、
取り込み機構は装飾日誌表示でのみ動作します。


File: elisp-ja,  Node: Sexp Diary Entries,  Next: Appt Customizing,  Prev: Fancy Diary Display,  Up: Calendar

38.9 S式項目と装飾日誌表示
====================================

     S式を使った日誌記録は、
複雑な条件で適用される日誌記録を作る以上のことができます。
装飾日誌表示を使っている場合には、S式日誌項目は、
日付に依存した記録テキストを生成できます。
たとえば、記念日の記録では、テキストに何回目の記念日であるかを入れられます。
したがって、つぎの日誌記録の`%d'は年齢で置き換えられます。

          %%(diary-anniversary 10 31 1948) Arthur's birthday (%d years old)

つまり、装飾日誌用バッファでは、1990年10月31日の項目はつぎのようになります。

          Arthur's birthday (42 years old)

     日誌ファイルにつぎの項目が入っていると、

          %%(diary-anniversary 10 31 1948) Arthur's %d%s birthday

装飾日誌用バッファでは、1990年10月31日の項目はつぎのようになります。

          Arthur's 42nd birthday

        同様に、周期的な日誌項目では繰り返し回数を計算できます。

          %%(diary-cyclic 50 1 1 1990) Renew medication (%d%s time)

     は、1990年9月8日の装飾日誌表示ではつぎのようになります。

          Renew medication (5th time)


        当日の日誌項目としてだけでなく、
それよりまえの日の日誌項目にも含めるためのS式日誌項目があります。
たとえば、記念日の1週間前に督促がほしいときには、 つぎのようにします。

          %%(diary-remind '(diary-anniversary 12 22 1968) 7) Ed's anniversary

     すると、装飾日誌には、12月15日と12月22日に
          Ruth & Ed's anniversary
        と表示されます。

        関数`diary-date'は、整数や整数のリストや`t'で指定した
月、日、年の組み合わせで表される日付に適用されます。 たとえば、

          %%(diary-date '(10 11 12) 22 t) Rake leaves

     により、装飾日誌には、各年の10月22日、11月22日、12月22日には

          Rake leaves

     と表示されます。

        関数`diary-float'により、
11月の第3金曜日とか4月の最後の火曜日といった
日付に適用する日誌記録を記述できます。
パラメータは、月MONTH、曜日DAYNAME、添字Nです。
日曜日をDAYNAME=0、月曜日をDAYNAME=1、…として、
MONTH月のN番目の曜日DAYNAMEに項目が現れます。
Nが負であると、MONTH月の月末から数えます。
MONTHは、月のリストでも、1つの月でも、全部の月を指定する`t'でも
かまいません。 省略可能なパラメータDAYを指定して、
MONTH月のN番目の曜日DAYNAMEの 前後のDAY日を指定できます。
Nが正だとDAYのデフォルトは1であり、
Nが負だとDAYのデフォルトはMONTH月の月末です。 たとえば、

          %%(diary-float t 1 -1) Pay rent

     は、装飾日誌に各月の最後の月曜日に

          Pay rent

     を表示します。

S式日誌項目の一般性により、アルゴリズムで日誌項目を指定できます。
S式日誌項目には、項目を当該日に適用するどうかを計算する式を含められます。
その値が`nil'以外であると、その項目を当該日に適用します。
その式では、対象とする日付を知るために変数`date'を使えます。
この変数の値は、グレゴリオ暦で表した リスト`(MONTH DAY YEAR)'です。

        毎月のウィークデイである21日か、
21日が週末の場合にはそのまえの金曜日に給料を支払われるとしましょう。
そのような日付に一致するS式日誌項目はつぎのように書けます。

          &%%(let ((dayname (calendar-day-of-week date))
                   (day (car (cdr date))))
                (or (and (= day 21) (memq dayname '(1 2 3 4 5)))
                    (and (memq day '(19 20)) (= dayname 5)))
                   ) Pay check deposited

        以下のS式日誌項目は、日付に依存して変わるテキストを
日誌項目に入れる機能を（装飾日誌表示で）利用できます。

    `%%(diary-sunrise-sunset)'
          今日の地方時での日出入時刻に対する日誌項目を作る。

    `%%(diary-phases-of-moon)'
          月に朔弦望に対する日誌項目を作る。

    `%%(diary-day-of-year)'
          年内の通算日数と残り日数で今日の日誌項目を作る。

    `%%(diary-iso-date)'
          今日に対応するISO商用暦の日誌項目を作る。

    `%%(diary-julian-date)'
          今日に対応するユリウス暦の日誌項目を作る。

    `%%(diary-astro-day-number)'
          今日に対応する天文通算日（ユリウス日）の日誌項目を作る。

    `%%(diary-hebrew-date)'
          今日に対応するヘブライ暦の日誌項目を作る。

    `%%(diary-islamic-date)'
          今日に対応するイスラム暦の日誌項目を作る。

    `%%(diary-french-date)'
          今日に対応するフランス革命暦の日誌項目を作る。

    `%%(diary-mayan-date)'
          今日に対応するマヤ暦の日誌項目を作る。

     したがって、

          &%%(diary-hebrew-date)

     を含んだ日誌項目は、装飾日誌表示を使っていると、
毎日の日誌表示に対応するヘブライ暦の日付を含めることになります。
（単純な日誌表示では、行`&%%(diary-hebrew-date)'は
すべての日付の日誌に現れるが、特別なことはなにもしない。）

        つぎの関数は、ある標準的な方法でヘブライ暦に基づく
S式日誌項目を構成するために使えます。

    `%%(diary-rosh-hodesh)'
          各ヘブライ月の礼拝の始まりと終りを教える日誌項目を作る。

    `%%(diary-parasha)'
          毎週のシナゴーグ朗読会を教える土曜日の日誌項目を作る。

    `%%(diary-sabbath-candles)'
          安息日のたそがれの_地方時_を教える金曜日の日誌項目を作る。

    `%%(diary-omer)'
          適切ならばオーメル(1) の回数を与える日誌項目を作る。

    `%%(diary-yahrzeit MONTH DAY YEAR) NAME'
          命日に対応した日誌項目を作る。
          命日の日付は_グレゴリオ暦_で指定する。
          正しいヘブライ暦の追悼日とその前日に日誌項目が現れる。
          （ヨーロッパスタイルでは、パラメータの順序を
          DAY、MONTH、YEARと変える。）

        ---------- Footnotes ----------

        (1) omer：
     過ぎ越しの祝い（Passover）の二日目から七週の祭（Shabuoth）の前日
     までの49日間


File: elisp-ja,  Node: Appt Customizing,  Prev: Sexp Diary Entries,  Up: Calendar

38.10 約束の警告表示のカスタマイズ
================================================

     Emacsにどのように約束の警告表示を行わせ、
どの程度前から行わせるかは、つぎの変数に設定することで正確に指定できます。

    `appt-message-warning-time'
          約束の警告表示を開始する時間を分で表したもの。
          デフォルトは10分である。

    `appt-audible'
          これが`nil'以外であると、Emacsは約束の警告表示として端末のベルを鳴らす。
          デフォルトは`t'。

    `appt-visible'
          これが`nil'以外であると、Emacsは約束のメッセージをエコー領域に表示する。
          デフォルトは`t'。

    `appt-display-mode-line'
          これが`nil'以外であると、Emacsは約束までの残り分数をモード行に表示する。
          デフォルトは`t'。

    `appt-msg-window'
          これが`nil'以外であると、
          Emacsは約束のメッセージを別のウィンドウに表示する。
          デフォルトは`t'。

    `appt-disp-window-function'
          この変数は、約束のメッセージを表示するウィンドウを作るための関数を保持する。

    `appt-delete-window-function'
          この変数は、時間が過ぎたら
          約束のメッセージを表示したウィンドウを削除するための関数を保持する。

    `appt-display-duration'
          約束のメッセージを表示する秒数。 デフォルトは5秒である。



File: elisp-ja,  Node: System Interface,  Next: Tips,  Prev: Calendar,  Up: Top

39 オペレーティングシステムとのインターフェイス
*********************************************************************

     本章は、Emacsの起動と終了、
オペレーティングシステムの環境に収められた値の参照方法、
端末入出力とフロー制御についてです。

        関連情報については*Note Building Emacs::。
また、端末やスクリーンに関係する
オペレーティングシステムの状態情報については、 *note
Display::も参照してください。

     * Menu:

     * Starting Up::         Customizing Emacs start-up processing.
     * Getting Out::         How exiting works (permanent or temporary).
     * System Environment::  Distinguish the name and kind of system.
     * User Identification:: Finding the name and user id of the user.
     * Time of Day::		Getting the current time.
     * Time Conversion::     Converting a time from numeric form to a string, or
                               to calendrical data (or vice versa).
     * Timers::		Setting a timer to call a function at a certain time.
     * Terminal Input::      Recording terminal input for debugging.
     * Terminal Output::     Recording terminal output for debugging.
     * Special Keysyms::     Defining system-specific key symbols for X windows.
     * Flow Control::        How to turn output flow control on or off.
     * Batch Mode::          Running Emacs without terminal interaction.


File: elisp-ja,  Node: Starting Up,  Next: Getting Out,  Up: System Interface

39.1 Emacsの始動
===================

     本節では、Emacsが起動時になにを行うか、および、
それらをカスタマイズする方法について述べます。

     * Menu:

     * Start-up Summary::        Sequence of actions Emacs performs at start-up.
     * Init File::               Details on reading the init file (`.emacs').
     * Terminal-Specific::       How the terminal-specific Lisp file is read.
     * Command Line Arguments::  How command line arguments are processed,
                                   and how you can customize them.


File: elisp-ja,  Node: Start-up Summary,  Next: Init File,  Up: Starting Up

39.1.1 概要：始動時の動作手順
----------------------------------------

     Emacsが始動したときに行う（`startup.el'での）
処理の順序はつぎのとおりです。

       1. `load-path'にある各ディレクトリファイルにおいて
          `subdirs.el'という名前のファイルを実行することで
          `load-path'にサブディレクトリを追加する。

       2. `LANG'などの環境変数で要求されていれば、
          言語環境と端末のコーディングシステムを設定する。

       3. ウィンドウシステムを使用している場合には、
          そのウィンドウシステム向けの初期化ライブラリをロードする。
          そのライブラリ名は`term/WINDOWSYSTEM-win.el'である。

       4. 初期化オプションを処理する。
          （初期化オプションの一部は、これより初期の段階で扱われる。）

       5. 必要ならば、ウィンドウフレームとフェイスを初期化する。

       6. ノーマルフック`before-init-hook'を実行する。

       7. オプション`-no-site-file'が指定されていなければ、
          ライブラリ`site-start'をロードする。
          このライブラリの名前は普通は`site-start.el'である。 

       8. コマンド行で`-q'や`-batch'が指定されていなければ、
          ファイル`~/.emacs'をロードする。
          オプション`-u'で、`~'のかわりに用いるホームディレクトリを持つ
          他のユーザー名を指定できる。

       9. `inhibit-default-init'が`nil'以外でなければ、
          ライブラリ`default'をロードする。
          （コマンド行で`-q'を指定したり、
          `-batch'モードでは、これを行わない。）
          ライブラリのファイル名は普通は`default.el'である。 

      10. ノーマルフック`after-init-hook'を実行する。

      11. バッファ`*scratch*'がカレントバッファであり
          基本（fundamental）モードであるならば、
          `initial-major-mode'に従ってメジャーモードを設定する。

      12. バッチモードやウィンドウシステムを用いていなければ、
          あれば端末固有のLispファイルが存在するならロードする。

      13. `inhibit-startup-echo-area-message'で抑制していなければ、
          初期メッセージをエコー領域に表示する。

      14. コマンド行の引数を処理する。

      15. `term-setup-hook'を実行する。

      16. 初期化ファイルの指定に従って
          選択されているフレームのパラメータを修正する
          `frame-notice-user-settings'を呼び出す。

      17. `window-setup-hook'を実行する。 *note Window Systems::。

      18. 未処理のコマンド行引数（上の数手順）がなく、
          `inhibit-startup-message'の値が`nil'であり、
          バッファが空であれば、
          コピーレフト／無保証／基本的な利用情報を表示する。

      -- User Option: inhibit-startup-message
          この変数は、（無保証などの）初期の始動メッセージを禁止する。
          これが`nil'以外であるとメッセージを表示しない。

          始動メッセージの内容に十分慣れたら、
          読者個人の初期化ファイルで設定できるようにこの変数がある。
          新規ユーザーが受け取るはずである情報を隠してしまうため、
          新規ユーザーの初期化ファイルや複数のユーザーに影響するような方法で
          この変数に設定しないこと。

      -- User Option: inhibit-startup-echo-area-message
          この変数は、エコー領域に表示する始動メッセージを制御する。
          個人のファイル`.emacs'につぎのフォームを追加することで
          エコー領域の始動メッセージを抑制できる。

               (setq inhibit-startup-echo-area-message
                     "YOUR-LOGIN-NAME")

          Emacsは、読者のファイル`.emacs'で上に示した式を明示的に検査する。
          読者のログイン名はLisp文字列定数として式に現れる必要がある。
          `inhibit-startup-echo-area-message'に同じ値を
          設定する別の方法では、始動メッセージを禁止できない。

          このように、望むならば自身のためにメッセージを簡単に禁止できるが、
          読者の`.emacs'をむやみにコピーしても、
          他人に対してはメッセージを禁止できない。


File: elisp-ja,  Node: Init File,  Next: Terminal-Specific,  Prev: Start-up Summary,  Up: Starting Up

39.1.2 初期化ファイル：`.emacs'
---------------------------------------

     読者がEmacsを始動すると、Emacsは読者のホームディレクトリから
ファイル`.emacs'を普通はロードしようとします。
このファイルが存在すれば、これにはLispコードを入れておく必要があります。
コマンド行オプション`-q'と`-u'は、 初期化ファイルの使い方に影響します。
`-q'は初期化ファイルをロードしないように指示し、
`-u'は読者の初期化ファイルのかわりに指定したユーザーの初期化ファイルを
ロードするように指示します。 *Note Emacsの起動と終了: (emacs)Entering
Emacs。

        "デフォルトの初期化ファイル"をサイトごとに持てます。
これは`default.el'という名前のライブラリです。
Emacsは、ライブラリを探索する標準パスから ファイル`default.el'を探します
（*note How Programs Do Loading::）。
Emacsの配布には、このファイルは付属していません。
ローカルなカスタマイズのためにサイトで用意します。
バッチモードや`-q'を指定してある場合を除いて、
デフォルトの初期化ファイルが存在すると、
読者がEmacsを始動するたびにそれをロードします。
しかし、存在するなら、個人の初期化ファイルをさきにロードします。
そこで`inhibit-default-init'に`nil'以外の値を設定してあると、
Emacsはそのあとファイル`default.el'をロードしません。

サイトごとのカスタマイズ向けの別のファイルは`site-start.el'です。
Emacsはユーザーの初期化ファイルをロードする_まえ_に
このファイルをロードします。 このファイルのロードを禁止するには
オプション`-no-site-file'を使います。

      -- Variable: site-run-file
          この変数は、ユーザーの初期化ファイルよりさきに
          ロードするべきサイトごとのカスタマイズファイルを指定する。
          普通の値は`"site-start"'である。
          実際に効果があるようにこれを変更する唯一の方法は、
          Emacsをダンプするまえに行うことである。

        読者のファイル`.emacs'に大量のコードがある場合には、
`SOMETHING.el'という名前の別のファイルへコピーして、
それをバイトコンパイルし（*note Byte Compilation::）、
読者のファイル`.emacs'では、`load'（*note Loading::）で
そのファイルをロードするようにします。

        読者のファイル`.emacs'でよく使われるであろう
さまざまなカスタマイズを行う方法の例については、 *Note
初期化ファイルの例: (emacs)Init Examples。

      -- User Option: inhibit-default-init
          この変数は、読者のEmacsセッションにおいては、
          デフォルトの初期化ライブラリファイルをロードしないようにする。
          その値が`nil'以外であるとデフォルトライブラリをロードしない。
          デフォルト値は`nil'である。

      -- Variable: before-init-hook
          すべての初期化ファイル （ユーザーの初期化ファイル、
          `default.el'と／あるいは`site-start.el'）を
          ロードする直前に一度だけ実行するノーマルフック。
          （実際の効果があるようにこれを変更する唯一の方法は、
          Emacsをダンプするまえに行うことである。）

      -- Variable: after-init-hook
          すべての初期化ファイル （ユーザーの初期化ファイル、
          `default.el'と／あるいは`site-start.el'）をロード直後、
          端末固有の初期化のまえに一度だけ実行するノーマルフック。


File: elisp-ja,  Node: Terminal-Specific,  Next: Command Line Arguments,  Prev: Init File,  Up: Starting Up

39.1.3 端末固有の初期化
-------------------------------

     端末の各種類ごとに、Emacsがその種類の端末で動作するときに
Emacsがロードする専用Lispライブラリを持てます。
ライブラリ名は、変数`term-file-prefix'の値と
端末種類を連結して作ります。
通常、`term-file-prefix'の値は`"term/"'であり、
これを変更することは勧めません。
Emacsは通常どおり、`load-path'のディレクトリ群において
`.elc'と`.el'の接尾辞でファイルを探します。

        端末固有ライブラリの普通の機能は、
Emacsが識別可能なキー列を送るように特別なキーを設定することです。
端末のすべてのファンクションキーがtermcapに入っていない場合には、
`function-key-map'を設定したり追加する必要もあります。

        端末種類の名前にハイフンが含まれる場合、
ライブラリ名を選ぶうえでは、最初のハイフンよりまえの名前の部分が有効です。
したがって、`aaa-48'と`aaa-30-rv'のどちらも
ライブラリ`term/aaa'を使います。 必要ならば、ライブラリでは`(getenv
"TERM")'を評価することで 端末種類の完全な名前を得ることができます。

        読者のファイル`.emacs'で
変数`term-file-prefix'に`nil'を設定すると、
端末固有ライブラリをロードしないようにできます。
この機能は、読者独自のカスタマイズを試すときに有用です。

        変数`term-setup-hook'に設定すれば、
端末固有ライブラリの特定の動作に優先できます。
これは、読者のファイル`.emacs'と端末固有ライブラリの両者を
ロードしたあとの初期化後にEmacsが実行するノーマルフックです。
端末専用ライブラリがない端末向けの初期化を定義するために
この変数を使えます。 *Note Hooks::。

      -- Variable: term-file-prefix
          変数`term-file-prefix'が`nil'以外であると、
          Emacsは、つぎのように端末固有の初期化ファイルをロードする。

               (load (concat term-file-prefix (getenv "TERM")))

          端末固有の初期化ファイルをロードしたくない場合には、
          読者のファイル`.emacs'で
          変数`term-file-prefix'に`nil'を設定する。
          それには、読者のファイル`.emacs'に `(setq term-file-prefix
          nil)'を入れる。

      -- Variable: term-setup-hook
          この変数は、読者のファイル`.emacs'、
          （あれば）デフォルトの初期化ファイル、
          端末固有のLispファイルをロードしたあとにEmacsが実行する
          ノーマルフックである。

          端末固有ファイルの定義に優先するために`term-setup-hook'を使える。

        関連する機能については、 *note Window
Systems::の`window-setup-hook'を参照してください。


File: elisp-ja,  Node: Command Line Arguments,  Prev: Terminal-Specific,  Up: Starting Up

39.1.4 コマンド行引数
----------------------------

Emacsを始動するときにコマンド行引数を使ってさまざまな動作を要求できます。
一日に一度より多くEmacsを始動する必要はないでしょうし、
しばしばEmacsセッションをそれより長く動かし続けるでしょうから、
コマンド行引数はほとんど使いません。
実際、コマンド行引数を使う癖は避けたほうがよいです。
そのような癖をつけると、Emacsを必要以上に終了したり再始動するからです。
これらのオプションは2つの理由で存在します。
（別のプログラムから起動される）他のエディタと互換性があるようにするのと、
シェルスクリプトから特定のLispプログラムを実行できるようにするためです。

        本節では、Emacsがコマンド行引数を処理する方法と、
それらをカスタマイズする方法について述べます。

      -- Function: command-line
          この関数は、Emacsを呼び出すときに指定されたコマンド行引数を解析して処理し、
          ユーザーのファイル`.emacs'をロードし始動メッセージを表示する。

      -- Variable: command-line-processed
          この変数の値は、コマンド行引数を一度処理し終えると`t'である。

          `dump-emacs'を呼んでEmacsを再ダンプするときには、
          この変数に`nil'を設定すれば、
          新たにダンプしたEmacsでコマンド行引数を処理するようにできる。

      -- Variable: command-switch-alist
          この変数の値は、ユーザー定義のコマンド行オプションの連想リストである。
          この変数は、読者が要素を追加できるように存在する。

          "コマンド行オプション"（command line option）は、
          つぎの形のコマンド行の引数である。

               -OPTION

          `command-switch-alist'の要素はつぎの形である。

               (OPTION . HANDLER-FUNCTION)

          HANDLER-FUNCTIONは、オプションOPTIONを処理するために呼ばれ、
          オプション名を唯一の引数として受け取る。

          コマンド行のオプションには引数が続く場合もある。
          そのような場合、HANDLER-FUNCTIONは
          変数`command-line-args-left'からすべての残りのコマンド行引数を
          調べることができる。
          （コマンド行引数全体のリストは`command-line-args'にある。）

          コマンド行引数は、ファイル`startup.el'の
          関数`command-line-1'が解析する。 *note コマンド行引数:
          (emacs)Command Arguments.も参照。

      -- Variable: command-line-args
          この変数の値は、Emacsに渡されたコマンド行引数のリストである。

      -- Variable: command-line-functions
          この変数の値は、認識できないコマンド行引数を処理する関数のリストである。
          つぎに処理する引数に特別な意味がないと、
          このリストの関数を`nil'以外の値を返すまで現れる順に呼び出す。

          これらの関数は引数なしで呼び出される。
          これらの関数では、呼び出し時に束縛される変数`argi'を介して
          対象となるコマンド行引数を参照できる。
          （いま対象となっている引数を除く）残りの引数は
          変数`command-line-args-left'にある。

          関数が`argi'を認識して処理したときには、
          その引数を処理したことを表すために`nil'以外の値を返すこと。
          後続の引数の一部も処理した場合には、
          `command-line-args-left'から
          それらを削除することで処理したことを示せる。

          これらの関数すべてが`nil'を返すと、
          訪問するファイル名として引数を用いる。


File: elisp-ja,  Node: Getting Out,  Next: System Environment,  Prev: Starting Up,  Up: System Interface

39.2 Emacsから抜ける
=========================

     Emacsから抜けるには2つの方法があります。
Emacsを終了するためにEmacsジョブをキルするか、
あとでEmacsを継続できるように休止します。
実用上は、ログアウトするとき以外にはEmacsをほとんど終了しないでしょう。
Emacsを休止するほうが一般的です。

     * Menu:

     * Killing Emacs::        Exiting Emacs irreversibly.
     * Suspending Emacs::     Exiting Emacs reversibly.


File: elisp-ja,  Node: Killing Emacs,  Next: Suspending Emacs,  Up: Getting Out

39.2.1 Emacsの終了
---------------------

Emacsを終了するとは、Emacsプロセスの実行を終らせることを意味します。
親プロセスが普通は制御を取り戻します。
Emacsを終了するための下位の基本関数は`kill-emacs'です。

      -- Function: kill-emacs &optional exit-data
          この関数は、Emacsプロセスを終了しEmacsを終える。

          EXIT-DATAが整数であると、Emacsプロセスの終了状態として使われる。
          （これは主にバッチ処理で有用である。 *note Batch
          Mode::を参照。）

          EXIT-DATAが文字列であると、
          その内容を端末入力バッファへ詰め込み、
          シェル（やつぎに入力を読むプログラム）がそれらを読み取れるようにする。

        保存済みのファイルを除くEmacsプロセス内のすべての情報は、
Emacsを終了すると失われます。
Emacsを不注意に終了すると多くの作業を失うことになるので、
保存する必要があるバッファがあったり動作中のサブプロセスがあると、
Emacsは確認を求めます。 これは関数`save-buffers-kill-emacs'が行います。

      -- Variable: kill-emacs-query-functions
          標準的な問い合わせをしたあとで、 `save-buffers-kill-emacs'は、
          リスト`kill-emacs-query-functions'内の関数を
          現れる順に引数なしで呼び出す。
          これらの関数では、ユーザーにさらなる確認を求めることができる。
          これらのどれかが`nil'を返すと、Emacsは終了しない。

      -- Variable: kill-emacs-hook
          この変数はノーマルフックである。
          `save-buffers-kill-emacs'がファイルをすべて保存し確認し終えると、
          このフックの関数群を実行する。


File: elisp-ja,  Node: Suspending Emacs,  Prev: Killing Emacs,  Up: Getting Out

39.2.2 Emacsの休止
---------------------

     "Emacsを休止する"とは、Emacsを一時的に停止し、
普通はシェルである親プロセスに制御を戻すことです。
これにより、あとで同じEmacsプロセスで、つまり、同じバッファ群、
同じキルリング、同じアンドゥ履歴などで編集を再開できます。
Emacsを再開するには、親シェルにおいて
ほとんどの場合`fg'などの適切なコマンドを使います。

        ジョブの休止を扱えないオペレーティングシステムもあります。
そのようなシステムでは、『休止』はEmacsのサブプロセスとして
一時的に新たなシェルを実際には作成します。
そのシェルを終了するとEmacsに戻ります。

        ウィンドウシステムを使っている場合には、
Emacsジョブを再開する親プロセスがいないかもしれませんし、
別のウィンドウへ移動すれば別のジョブへ入力できますから、
Emacsの休止は有用ではありません。
したがって、Emacsがウィンドウシステムを使っている場合には、
休止できません。

      -- Function: suspend-emacs string
          この関数は、Emacsを休止し、親プロセスへ制御を戻す。
          親プロセスがEmacsを再開した場合にのみ、
          `suspend-emacs'はLisp内の呼び出し側へ`nil'を返す。

          STRINGが`nil'以外であると、
          Emacsの親シェルが端末入力として読めるようにその文字群を送る。
          親シェルはSTRINGの文字群を表示せず、 その結果のみが現れる。

          休止するまえに、`suspend-emacs'は
          ノーマルフック`suspend-hook'を実行する。

          ユーザーがEmacsを再開すると、`suspend-emacs'は
          ノーマルフック`suspend-resume-hook'を実行する。 *note
          Hooks::。

          再開後のつぎの再表示では、
          変数`no-redraw-on-reenter'が`nil'ならば
          スクリーン全体を再描画する。 （*note Refresh Screen::）。

          つぎの例では、Emacsを休止しても`pwd'は表示されないことに注意。
          しかし、シェルはそれを読み取って実行する。

               (suspend-emacs)
                    => nil

               (add-hook 'suspend-hook
                         (function (lambda ()
                                     (or (y-or-n-p
                                           "Really suspend? ")
                                         (error "Suspend cancelled")))))
                    => (lambda nil
                         (or (y-or-n-p "Really suspend? ")
                             (error "Suspend cancelled")))
               (add-hook 'suspend-resume-hook
                         (function (lambda () (message "Resumed!"))))
                    => (lambda nil (message "Resumed!"))
               (suspend-emacs "pwd")
                    => nil
               ---------- Buffer: Minibuffer ----------
               Really suspend? y
               ---------- Buffer: Minibuffer ----------

               ---------- Parent Shell ----------
               lewis@slug[23] % /user/lewis/manual
               lewis@slug[24] % fg

               ---------- Echo Area ----------
               Resumed!

      -- Variable: suspend-hook
          この変数は、休止するまえに実行されるノーマルフックである。

      -- Variable: suspend-resume-hook
          この変数は、再開後に実行されるノーマルフックである。


File: elisp-ja,  Node: System Environment,  Next: User Identification,  Prev: Getting Out,  Up: System Interface

39.3 オペレーティングシステム環境
===============================================

     Emacsでは、さまざまな関数を介して
オペレーティングシステム環境の変数を参照できます。
これらの変数には、システムの名前、ユーザーの識別番号UIDなどが
含まれます。

      -- Variable: system-configuration
          この変数は、読者のシステムのハードウェア／ソフトウェア構成に対する
          GNUの構成名を文字列で保持している。
          この文字列の一部分を検査する簡便な方法は
          `string-match'を使うことである。

      -- Variable: system-type
          この変数の値は、Emacsが動作している
          オペレーティングシステムの種類を表すシンボルである。
          つぎに可能な値の一覧を示す。

         `alpha-vms'
               Alphaマシン上のVMS。

         `aix-v3'
               AIX。

         `berkeley-unix'
               バークレーBSD。

         `dgux'
               データジェネラルDGUXオペレーティングシステム。

         `gnu'
               （HURDかMachから成るGNUカーネルを使っている）GNUシステム。

         `gnu/linux'
               GNU/Linuxシステム。
               つまり、Linuxカーネルを用いたGNUシステムの変種。
               （これらのシステムは人々が『Linux』と呼ぶものの1つであるが、
               Linxuは実際にはカーネルのみであり、システム全体ではない。）

         `hpux'
               ヒューレットパッカードHPUXオペレーティングシステム。

         `irix'
               シリコングラフィックスIrixシステム。

         `ms-dos'
               マイクロソフトMS-DOS『オペレーティングシステム』。

         `next-mach'
               NeXTのMachベースのシステム。

         `rtu'
               マスコンプRTU、UCBユニバース。

         `unisoft-unix'
               ユニソフトUniPlus。

         `usg-unix-v'
               AT&T System V。

         `vax-vms'
               VAX VMS。

         `windows-nt'
               マイクロソフトWindows NT。

         `xenix'
               SCO Xenix 386。

          絶対に必要でない限り、細分類のために新たなシンボルを追加したくない！`
          ' 実際、将来にはこれらのいくつかを削除することを願っている。
          オペレーティングシステムの違いを区別するには、
          `system-configuration'を使うことを勧める。

      -- Function: system-name
          この関数は読者が使っているマシンの名前を返す。
               (system-name)
                    => "www.gnu.org"

        シンボル`system-name'は、関数としても変数としても使えます。
実際、関数としては、変数`system-name'が現在保持している値を返します。
したがって、Emacsが読者のシステム名に関して混乱している場合には、
変数`system-name'に設定できます。
変数はフレームタイトルの作成にも有用です（*note Frame Titles::）。

      -- Variable: mail-host-address
          この変数が`nil'以外であると、`system-name'のかわりに
          電子メイルアドレスの生成に使われる。
          たとえば、`user-mail-address'のデフォルト値の作成に使われる。
          *note User Identification::。
          （これはEmacsの始動時に行われるため、
          Emacsをダンプしたときの値が実際に使われる値である。 *note
          Building Emacs::）。

      -- Function: getenv var
          この関数は、環境変数VARの値を文字列で返す。
          Emacs内部では、環境変数の値はLisp変数`process-environment'に
          保持されている。

               (getenv "USER")
                    => "lewis"

               lewis@slug[10] % printenv
               PATH=.:/user/lewis/bin:/usr/bin:/usr/local/bin
               USER=lewis
               TERM=ibmapa16
               SHELL=/bin/csh
               HOME=/user/lewis

      -- コマンド: setenv variable value
          このコマンドは、環境変数VARIABLEに値VALUEを設定する。
          どちらの引数も文字列である。
          この関数は`process-environment'を修正することで動作する。
          この変数を`let'で束縛しても十分に実用的である。

      -- Variable: process-environment
          この変数は、各要素が1つの環境変数を記述する文字列のリストである。
          関数`getenv'と`setenv'は、この変数を用いて動作する。

               process-environment
               => ("l=/usr/stanford/lib/gnuemacs/lisp"
                   "PATH=.:/user/lewis/bin:/usr/class:/nfsusr/local/bin"
                   "USER=lewis"
                   "TERM=ibmapa16"
                   "SHELL=/bin/csh"
                   "HOME=/user/lewis")

      -- Variable: path-separator
          この変数は、（環境変数などで）探索パスを
          区切る文字を指定する文字列を保持する。
          UNIXとGNUシステムではその値は`":"'であり、 MS-DOSとWidows
          NTでは`";"'である。

      -- Variable: invocation-name
          この変数は、起動したEmacsのプログラム名を保持する。
          値は文字列であり、ディレクトリ名は含まない。

      -- Variable: invocation-directory
          この変数は、起動したEmacsの実行形式のディレクトリを保持する。
          ディレクトリを判別できない場合には`nil'である。

      -- Variable: installation-directory
          `nil'以外であると、サブディレクトリ`lib-src'と`etc'を
          探すためのディレクトリである。
          Emacsがこれらのディレクトリを標準のインストールディレクトリで
          みつけられなくてもEmacsの実行形式になんらかの意味で
          関連するディレクトリでみつけられれば、`nil'以外である。

      -- Function: load-average &optional use-float
          この関数は、1分間／5分間／15分間のロードアベレッジ
          （負荷平均）をリストで返す。

          デフォルトでは、これらの値は、動作しようとしてるプロセスの平均個数を表す
          システムのロードアベレッジを100倍した整数である。
          USE-FLOATが`nil'以外であると、 100倍しない浮動小数点数で返す。

               (load-average)
                    => (169 48 36)
               (load-average t)
                    => (1.69 0.48 0.36)

               lewis@rocky[5] % uptime
                11:55am  up 1 day, 19:37,  3 users,
                load average: 1.69, 0.48, 0.36

      -- Function: emacs-pid
          この関数は、Emacsプロセスのプロセス番号IDを返す。

      -- Variable: tty-erase-char
          この変数は、Emacsが始動するまえに
          システムの端末ドライバが選んでいた消去文字を保持する。

      -- Function: setprv privilege-name &optional setp getprv
          この関数は、（UNIX上には存在しない）VMS基本操作を設定／再設定する。
          最初の引数は文字列で表した基本操作の名前である。
          第2引数SETPは`t'か`nil'であり、
          基本操作をオンにするかオフにするかを表す。
          デフォルトは`nil'である。
          関数は、成功すれば`t'を返し、さもなければ`nil'を返す。

          第3引数GETPRVが`nil'以外であると、
          `setprv'は基本操作を変更しないが、
          その基本操作が現在オンであるかオフであるかを表す
          `t'か`nil'を返す。


File: elisp-ja,  Node: User Identification,  Next: Time of Day,  Prev: System Environment,  Up: System Interface

39.4 ユーザーの識別
==========================

      -- Variable: init-file-user
          この変数は、Emacsが使用すべきユーザー初期化ファイルを指定する。
          あるいは、そのようなものがなければ`nil'である。
          この値は、`-q'や`-u USER'の コマンド行オプションを反映する。

          カスタマイズファイルや他の種類のユーザープロフィールを
          ロードするLispパッケージは、それらを探す場所を判断するために
          この変数に従うこと。
          この変数のユーザー名のカスタマイズをロードするべきである。
          `init-file-user'が`nil'であると
          オプション`-q'が使われたことを意味し、
          Lispパッケージはいかなるカスタマイズファイルや
          ユーザープロフィールもロードしないこと。

      -- Variable: user-mail-address
          これは、Emacsを使用しているユーザーの通常の電子メイルアドレスを保持する。
          Emacsは通常、読者の初期化ファイルを読み取ったあと、
          この変数が未設定であるとデフォルト値を設定する。
          したがって、デフォルト値を使いたくない場合には、
          読者のファイル`~/.emacs'で別の値に設定できる。

      -- Function: user-login-name &optional uid
          UIDを指定しないと、 この関数はログインしたユーザー名を返す。
          環境変数`LOGNAME'が設定されていればその値を使う。
          さもなければ、環境変数`USER'が設定されていればその値を使う。
          さもなければ、実UIDではなく実効UIDに基づいた値である。

          UIDを指定すると、値は（整数である）UIDに
          対応するユーザー名である。

               (user-login-name)
                    => "lewis"

      -- Function: user-real-login-name
          この関数は、Emacsの実UIDに対応するユーザー名を返す。
          これは、実効UIDや環境変数`LOGNAME'と`USER'を無視する。

      -- Function: user-full-name &optional uid
          この関数は、ログインしたユーザーの氏名を返す。
          あるいは、環境変数`NAME'が設定してあればその値を返す。

               (user-full-name)
                    => "Bil Lewis"

          UIDが`nil'以外であると、
          それは整数のユーザー番号か文字列のログイン名であること。
          すると、`user-full-name'は、
          そのユーザー番号かログイン名に対応するユーザーの氏名を返す。

        シンボル`user-login-name'、`user-real-login-name'、
`user-full-name'は、関数でもある変数です。
関数としては、その変数が保持する値と同じ値を返します。
これらの変数により、関数として返す値を指定しておくことで
Emacsを『ごまかせ』ます。
これらの変数は、フレームタイトルの作成にも有用です （*note Frame
Titles::）。

      -- Function: user-real-uid
          この関数は、ユーザーの実UIDを返す。

               (user-real-uid)
                    => 19

      -- Function: user-uid
          この関数は、ユーザーの実効UIDを返す。


File: elisp-ja,  Node: Time of Day,  Next: Time Conversion,  Prev: User Identification,  Up: System Interface

39.5 時刻
===========

本節では、現在時刻と時刻帯（タイムゾーン）を調べる方法を説明します。

      -- Function: current-time-string &optional time-value
          この関数は、人間向けの文字列で現在時刻と日付を返す。
          文字列の書式は不変であり、各部分の文字数はつねに同じなので、
          各部分を取り出すのに`substring'を使っても問題ない。
          将来、文字列の末尾に追加情報を付加することもあるので、
          文字列の末尾からではなく先頭から文字を数えるほうがよい。

          引数TIME-VALUEを指定すると、
          それは現在時刻のかわりに書式付けする時刻を指定する。
          引数は、最初の2つの要素が整数であるリストであること。
          したがって、`current-time'（下記参照）や
          `file-attributes'（*note File
          Attributes::）で得た時刻を使える。

               (current-time-string)
                    => "Wed Oct 14 22:21:05 1987"

      -- Function: current-time
          この関数は、システムの時刻の値を 3つの整数のリスト`(HIGH LOW
          MICROSEC)'で返す。 整数HIGHとLOWを組み合わせると
          1970年1月1日0:00からの経過秒数を与える。 つまり、経過秒数は
          HIGH * 2**16 + LOWである。

          第3要素MICROSECは、現在の秒内のミリ秒を表す
          （返す時間精度が秒のシステムでは0）。

          最初の2つの要素は、関数`file-attributes'で得られる
          ファイルに関する時刻の値と比較できる。 *note File
          Attributes::。

      -- Function: current-time-zone &optional time-value
          この関数は、ユーザーの地域の時刻帯を記述するリストを返す。

          値は、`(OFFSET NAME)'の形である。 ここで、OFFSETはUTC (1)
          に対して進んでいる（グリニッジの東）秒数を 与える整数である。
          第2要素NAMEは、その時刻帯の名称を与える文字列である。
          夏時間制が始まったり終ると、どちらの要素も変わる。
          時刻帯には季節の時刻調整はないとユーザーが指定すると、
          どちらの値も定数である。

          値を計算するために必要な情報をオペレーティングシステムから得られないと
          リストのどちらの要素も`nil'である。

          引数TIME-VALUEを指定すると、
          現在時刻のかわりに分析すべき時刻を指定する。
          引数は、2つの整数を収めたコンスセルであるか、
          最初の2つの要素が整数であるリストであること。
          したがって、`current-time'（上記参照）や
          `file-attributes'（*note File
          Attributes::）で得た時刻を使える。

        ---------- Footnotes ----------

        (1) 【訳注】協定世界時。旧グリニッジ標準時に相当。


File: elisp-ja,  Node: Time Conversion,  Next: Timers,  Prev: Time of Day,  Up: System Interface

39.6 時刻の変換
====================

     これらの関数は、時刻の値（2つか3つの整数から成るリスト）を
文字列や日時情報に変換します。
日時情報を時刻の値に変換する関数もあります。
時刻の値は、関数`current-time'（*note Time of Day::）や
`file-attributes'（*note File Attributes::）で得られます。

多くのオペレーティングシステムでは、時刻の値を32ビットに制限しています。
これらのシステムでは、典型的には協定世界時1901年12月13日20:45:52から
2038年1月19日03:14:07までしか表現できません。
しかし、より大きな時刻の値を扱い、
より広い範囲の過去から未来を表現できるシステムもあります。

        時刻変換関数は、グレゴリオ暦を導入するまえであっても
つねにグレゴリオ暦を使います。
紀元前1年からの経過年数を数え、通常のグレゴリオ暦のように0年を飛ばしません。
たとえば、-37年は、グレゴリオ暦紀元前38年を表します。

      -- Function: format-time-string format-string time
          この関数は、TIMEをFORMAT-STRINGに従って文字列に変換する。
          引数FORMAT-STRINGには、時刻のさまざまな部分で置き換えられる
          `%'列を含んでよい。 `%'列の意味を以下に示す。

         `%a'
               曜日の省略名を表す。

         `%A'
               曜日の（省略しない）名称を表す。

         `%b'
               月の省略名を表す。

         `%B'
               月の（省略しない）名称を表す。

         `%c'
               `%x %X'の同義語。

         `%C'
               これにはローケル固有の意味がある。
               デフォルトのローケル（`C'）では、`%A, %B %e, %Y'と等価。

         `%d'
               ゼロでパディングした月内の日。

         `%D'
               `%m/%d/%y'の同義語。

         `%e'
               空白でパディングした月内の日。

         `%h'
               `%b'の同義語。

         `%H'
               時（00-23）を表す。

         `%I'
               時（00-12）を表す。

         `%j'
               年内の日（001-366）を表す。

         `%k'
               空白でパディングした時（0-23）を表す。

         `%l'
               空白でパディングした時（0-12）を表す。

         `%m'
               月（01-12）を表す。

         `%M'
               分（00-59）を表す。

         `%n'
               改行を表す。

         `%p'
               `AM'か`PM'の適切なほうを表す。

         `%r'
               `%I:%M:%S %p'の同義語。

         `%R'
               `%H:%M'の同義語。

         `%S'
               秒（00-60）を表す。

         `%t'
               タブ文字を表す。

         `%T'
               `%H:%M:%S'の同義語。

         `%U'
               日曜日を週の始まりと仮定した年内の週（01-52）を表す。

         `%w'
               数字で表した曜日（0-6）。 日曜日を0とする。

         `%W'
               月曜日を週の始まりと仮定した年内の週（01-52）を表す。

         `%x'
               これにはローケル固有の意味がある。
               デフォルトのローケル（`C'）では、`%D'と等価。

         `%X'
               これにはローケル固有の意味がある。
               デフォルトのローケル（`C'）では、`%T'と等価。

         `%y'
               年の下2桁（00-99）を表す。

         `%Y'
               100年単位の年を表す。

         `%Z'
               時刻帯の省略名を表す。

          これらの`%'列には、桁数やパディングの種類も指定できる。
          `printf'と同様に動作し、 `%'列のあいだに桁数を数字で指定する。
          桁数を`0'で始めるとゼロでパディングすることを意味する。
          桁数を`_'で始めると空白でパディングすることを意味する。

          たとえば、`%S'は分内の秒数を指定し、
          `%03S'はゼロでパディングして3桁にすることを意味し、
          `%_3S'は空白でパディングして3桁にすることを意味する。
          `%S'は普通はパディングして2桁にするため、
          `%3S'だけであるとゼロでパディングする。

      -- Function: decode-time time
          この関数は、時刻の値を日時情報に変換する。
          戻り値は、つぎの9要素のリストである。

               (SECONDS MINUTES HOUR DAY MONTH YEAR DOW DST ZONE)

          各要素の意味はつぎのとおりである。

         SEC
               0から59の整数で表した分内の秒数。

         MINUTE
               0から59の整数で表した時内の分数。

         HOUR
               0から23の整数で表した日内の時。

         DAY
               1から31の整数で表した月内の日。

         MONTH
               1から12の整数で表した年内の月。

         YEAR
               年。 典型的には1900より大きい。

         DOW
               日曜日を0とした0から6の整数で表した曜日。

         DST
               夏時間制が有効であると`t'、さもなければ`nil'。

         ZONE
               グリニッジから東周りではかった時刻帯を表す秒数。

          Common Lispに関した注意：` ' Common
          Lispでは、DOWとZONEの意味が異なる。

      -- Function: encode-time seconds minutes hour day month year
               &optional ...zone
          この関数は`decode-time'の逆である。
          7項目から成る日時情報を時刻の値に変換する。
          引数の意味については、上記`decode-time'の一覧を参照。

          100未満の年は普通の年として扱う。
          それらを1900年代として扱いたい場合には、
          `encode-time'を呼び出すまえに修正しておくこと。

          省略可能な引数ZONEのデフォルトは、
          現在の時刻帯とその夏時間制の規則である。
          指定する場合には、（`current-time-zone'で得られるような）リストであるか、
          環境変数`TZ'と同じ形式の文字列であるか、
          （`decode-time'で得られるような）整数であること。
          指定した時刻帯は、夏時間の補正をせずに使われる。

          `encode-time'に7引数より多く渡すと、
          始めの6つをSECONDSからYEARまでに、
          最後の引数をZONEに使い、そのあいだの引数は無視する。
          この機能は、`decode-time'が返したリストの要素を
          つぎのようにして`encode-time'の引数に使うことを可能にする。

               (apply 'encode-time (decode-time ...))

          引数SEC、MINUTE、HOUR、DAY、MONTHの
          値が範囲外になるようにすると単純な日時演算を行える。
          たとえば、0日はその月のまえの日を意味する。

          オペレーティングは可能な時刻の値の範囲を制限する。
          その範囲を越える時刻を符号化しようとするとエラーになる。


File: elisp-ja,  Node: Timers,  Next: Terminal Input,  Prev: Time Conversion,  Up: System Interface

39.7 遅延実行のためのタイマ
======================================

     未来のある時刻に関数を呼び出したり、
ある一定期間なにもしないでいたら関数を呼び出すために
"タイマ"を設定できます。

        Emacsは、Lispプログラムの任意の箇所ではタイマを実行できません。
サブプロセスからの出力を受け取るときにだけタイマを実行できます。
つまり、待つことが_可能_な`sit-for'や`read-event'などの
基本関数の内側や（入力を）待っているあいだに実行できます。
したがって、Emacsが忙しいとタイマの実行が遅れることがあります。
しかし、Emacsが暇ならば、タイマの実行はとても正確です。

      -- Function: run-at-time time repeat function &rest args
          この関数は、時刻TIMEに引数ARGSで
          関数FUNCTIONを呼び出すように予約する。
          引数FUNCTIONはのちに呼び出される関数であり、
          引数ARGSはそれを呼び出すときに与える引数である。
          時刻TIMEは文字列で指定する。

          絶対時刻をさまざまな書式で指定できる。
          この関数は、よく使われる日時の書式を受け付けるように努める。
          正しい書式にはつぎの2つを含む。

               YEAR-MONTH-DAY HOUR:MIN:SEC TIMEZONE

               HOUR:MIN:SEC TIMEZONE MONTH/DAY/YEAR

          ここで、どちらの例のフィールドもすべて数である。
          `current-time-string'が返す書式、および、 他の書式も許される。

          相対時刻を指定するには、単位を伴った数字を使う。
          たとえばつぎのとおり。

         `1 min'
               今から1分後。

         `1 min 5 sec'
               今から65秒後。

         `1 min 2 sec 3 hour 4 day 5 week 6 fortnight 7 month 8 year'
               今からちょうど103ヵ月、123日、10862秒後。 (1)

          TIMEが数（整数か浮動小数点数）であれば、
          秒単位の相対時刻を指定する。

          引数REPEATは、呼び出しをどの程度頻繁に繰り返すかを指定する。
          REPEATが`nil'であると、繰り返さずに
          時刻TIMEに関数FUNCTIONを一度だけ呼び出す。
          REPEATが数であると、繰り返し間隔を秒単位で指定する。

          ほとんどの場合、_最初_の呼び出しではREPEATの効果はなく、
          TIMEだけが時刻を指定する。 1つ例外があり、TIMEが`t'であると、
          時刻がREPEATの整数倍であるとタイマを実行する。
          これは`display-time'のような関数に有用である。

          関数`run-at-time'は、予約した未来の特定の動作を
          識別するタイマを返す。
          この値は、`cancel-timer'（下記参照）の呼び出しに使える。

      -- Macro: with-timeout (seconds timeout-forms...) body...
          BODYを実行するが、SECONDS秒でその実行を諦める。
          時間が切れるまえにBODYが終了すると
          `with-timeout'はBODYの最後のフォームの値を返す。
          しかし、時間が切れるとBODYの実行を取り止め、
          `with-timeout'はTIMEOUT-FORMSをすべて実行し、
          それらの最後の値を返す。

          このマクロは、SECONDS秒後に動作するタイマを設定することで動作する。
          その時間内にBODYが終了すれば、タイマを取り消す。
          タイマが実際に動作するとBODYの実行を終了させてから、
          TIMEOUT-FORMSを実行する。

          プログラムから待つことが可能な基本関数を呼び出したときにのみ、
          タイマはLispプログラム内で実行可能なため、
          `with-timeout'はBODYの計算途中では BODYの実行を停止できない。
          それらが待つことが可能な基本関数の1つを呼び出したときにのみ停止できる。
          したがって、長い計算を行わない入力を待つようなBODYに
          `with-timeout'を使う。

        関数`y-or-n-p-with-timeout'は、
応答を長く待ちすぎないようにタイマを使った単純な例です。 *Note
Yes-or-No Queries::。

      -- Function: run-with-idle-timer secs repeat function &rest args
          EmacsがSECS秒間なにもしないときに実行するタイマを設定する。
          SECSの値は整数でも浮動小数点数でもよい。

          REPEATが`nil'であると、
          これ以降にはじめてEmacsが十分長い期間なにもしないでいると、
          タイマを一度だけ実行する。 しばしばREPEATは`nil'以外であり、
          EmacsがSECS秒なにもしないでいる_たびに_
          タイマを実行することを意味する。

          関数`run-with-idle-timer'は、
          `cancel-timer'（下記参照）の呼び出しに使えるタイマの値を返す。

        Emacsがユーザー入力を待ち始めると『アイドル状態』になり、
なにか入力がくるまでアイドル状態のままです。
5秒間のアイドル状態で動作するタイマがあったとすると、
Emacsがアイドルになってから約5秒後にそのタイマが実行されます。
しかしREPEATが真（`nil'以外）であったとしても、
そのタイマはEmacsがアイドル状態であり続ける限りは再実行されません。
アイドル状態の期間は単調に増加するので、再度5秒後には戻りません。

        Emacsがアイドル状態のときにはさまざまなことを行います。
ガベッジコレクション、自動保存、サブプロセスからのデータの処理です。
しかし、アイドル状態中のこれらの動作はアイドルタイマに干渉しません。
アイドル状態の時間を0にしないからです。
600秒に設定されたアイドルタイマは、
最後のユーザーコマンドを終了してから10分後に実行されます。
たとえその10分間に、サブプロセスの出力を何千回も受け取ろうが、
ガベッジコレクションや自動保存を行ったとしてもです。

ユーザーが入力を与えると、その入力を実行中はEmacsは非アイドル状態です。
そして再度アイドル状態になり、
繰り返すように設定されたアイドルタイマを1つずつそれ以降に実行します。

      -- Function: cancel-timer timer
          タイマTIMERの予約を取り消す。 TIMERは、以前に`run-at-time'や
          `run-with-idle-timer'が返した値であること。
          これは、`run-at-time'の呼び出しの効果を取り消し、
          その時刻になってもなにも特別なことは起こらない。

        ---------- Footnotes ----------

        (1) 【訳注】fortnightは2週間のこと。


File: elisp-ja,  Node: Terminal Input,  Next: Terminal Output,  Prev: Timers,  Up: System Interface

39.8 端末入力
=================

     本節では、端末入力を記録したり処理する関数や変数について述べます。
関連する関数については*note Display::を参照してください。

     * Menu:

     * Input Modes::		Options for how input is processed.
     * Translating Input::   Low level conversion of some characters or events
     			  into others.
     * Recording Input::	Saving histories of recent or all input events.


File: elisp-ja,  Node: Input Modes,  Next: Translating Input,  Up: Terminal Input

39.8.1 入力方式
-------------------

      -- Function: set-input-mode interrupt flow meta quit-char
          この関数は、キーボード入力を読み取るモードを設定する。
          INTERRUPTが`nil'以外であると、 Emacsは入力割り込みを用いる。
          `nil'であると、CBREAKモードを用いる。
          デフォルトの設定はシステムに依存する。
          この指定に関わらずつねにCBREAKモードを用いるシステムもある。

          EmacsがXと直接通信しているときは、
          通信方法が割り込みであると承知していると
          この引数を無視して割り込みを使う。

          FLOWが`nil'以外であると、
          Emacsは端末出力にフロー制御XON/XOFF（`C-q'、`C-s'）を用いる。
          CBREAKモード以外ではこれの効果はない。 *note Flow Control::。

          引数METAは、文字コードが127を越える入力文字の扱い方を制御する。
          METAが`t'であると、8ビット目が立っている文字を
          メタ文字に変換する。
          METAが`nil'であると、8ビット目を無視する。
          パリティビットを用いる端末では、これが必要である。
          METAが`t'でも`nil'でもないと、
          Emacsは入力した8ビットすべてを無変更で使う。
          8ビット文字集合を使う端末には、これがよい。

          QUIT-CHARが`nil'以外であると、 中断に使用する文字を指定する。
          通常、この文字は`C-g'である。 *note Quitting::。

        関数`current-input-mode'は、Emacsが現在使用している
入力モードの設定を返します。

      -- Function: current-input-mode
          この関数は、キーボード入力を読み取るための現在のモードを返す。
          `set-input-mode'の引数に対応する `(INTERRUPT FLOW META
          QUIT)'の形の リストを返す。 各要素の意味はつぎのとおりである。
         INTERRUPT
               `nil'以外であると、Emacsは割り込み駆動の入力を用いている。
               `nil'であると、EmacsはCBREAKモードを用いている。

         FLOW
               `nil'以外であると、
               Emacsは端末出力にフロー制御XON/XOFF（`C-q'、`C-s'）
               を用いている。
               この値は、INTERRUPTが`nil'の場合にのみ意味を持つ。

         META
               Emacsが入力文字の8ビット目をメタビットとして扱うときには`t'である。
               Emacsが各入力文字の8ビット目をつねに0にするときには`t'である。
               さもなければ、Emacsは文字コードとして8ビットすべてを使っている。

         QUIT
               現在Emacsが中断に使っている文字であり、普通は`C-g'である。


File: elisp-ja,  Node: Translating Input,  Next: Recording Input,  Prev: Input Modes,  Up: Terminal Input

39.8.2 入力イベントの変換
----------------------------------

     本節では、入力イベントをキー列の一部になるまえに別の
入力イベントに変換する機能について述べます。
これらの機能は、ここに述べる順に各イベントに適用されます。
つまり、各イベントはまず`extra-keyboard-modifiers'に従って修正され、
つぎに（適切ならば）`keyboard-translate-table'を介して変換され、
最後に指定されているキーボードコーディングシステムで復号化されます。
キー列の一部として読み取られるイベントであると、
読み取られるキー列に追加され、それを含む部分キー列を
まず`function-key-map'で検査してから、
つぎに`key-translation-map'で検査します。

      -- Variable: extra-keyboard-modifiers
          この変数は、Lispプログラムがキーボード上の
          修飾キーを『押す』ことができるようにする。

         1
               <SHIFT>キー。

         2
               <LOCK>キー。

         4
               <CTL>キー。

         8
               <META>キー。

          ユーザーがキーボードのキーを打つたびに、
          ビットマスクで指定した修飾キーが押し下げられているかのように
          キーを修正する。

          ウィンドウシステムを使っているときには、
          プログラムは任意の修飾キーを『押す』ことができる。
          さもなければ、<CTL>と<META>のキーのみを
          仮想的に押すことができる。

      -- Variable: keyboard-translate-table
          この変数は、キーボード文字の変換表である。
          これにより、コマンドのバインディングを変更せずに、
          キーボードのキー配置を変更できる。
          その値は普通は文字テーブルであるか、あるいは、`nil'である。

          `keyboard-translate-table'が文字テーブルであると、
          キーボードから読み取った各文字をこの文字テーブルで探す。
          みつけた値が`nil'以外であると、
          実際の入力文字のかわりにその値を使う。

          つぎの例では、`keyboard-translate-table'に文字テーブルを設定する。
          そして、文字`C-s'と`C-\'、`C-q'と`C-^'を入れ換える。
          これ以降、`C-\'を打つと`C-s'を打った効果があり、
          その逆もそうである。 （この話題に関しては詳しくは、*note Flow
          Control::。）

               (defun evade-flow-control ()
                 "Replace C-s with C-\ and C-q with C-^."
                 (interactive)
                 (setq keyboard-translate-table
                       (make-char-table 'keyboard-translate-table nil))
                 ;; `C-s'と`C-\'を入れ換える
                 (aset keyboard-translate-table ?\034 ?\^s)
                 (aset keyboard-translate-table ?\^s ?\034)
                 ;; `C-q'と`C-^'を入れ換える
                 (aset keyboard-translate-table ?\036 ?\^q)
                 (aset keyboard-translate-table ?\^q ?\036))

          この変換は、端末から読み取った文字に最初に行われる変換である。
          `recent-keys'のような記録機能やドリブルファイルは、
          変換後の文字を記録する。

      -- Function: keyboard-translate from to
          この関数は、文字コードFROMを文字コードTOに変換するように
          `keyboard-translate-table'を変更する。
          必要ならばキーボード変換表を作成する。

        残りの変換機能は、読み取ったキー列の部分列を変換します。
それらは`read-key-sequence'に実装されていて、
`read-event'で読む入力には効果はありません。

      -- Variable: function-key-map
          この変数は、普通の文字端末上のファンクションキーが
          送出する文字の列を記述したキーマップを保持する。
          このキーマップは他のキーマップと同じ構造であるが、使い方が異なる。
          キー列のバインディングではなく、
          読み取りつつあるキー列を変換する方法を指定する。

          `function-key-map'がキー列Kを ベクトルVに『バインド』すると、
          キー列の_どこに_Kが現れても、 Vのイベントで置き換える。

          たとえば、端末VT100は、キーパッドのキー<PF1>を押すと `<ESC> O
          P'を送出する。
          したがって、Emacsではこの列を1つのイベント`pf1'に変換したい。
          VT100を使っているときに`function-key-map'において `<ESC> O
          P'を`[pf1]'に『バインド』すれば、 これを行える。

          つまり、`C-c <PF1>'を打つと 文字の列`C-c <ESC> O
          P'が送出される。 のちに関数`read-key-sequence'がこれを`C-c
          <PF1>'に戻し、 ベクトル`[?\C-c pf1]'を返す。

          マイナモード／ローカル／グローバルのキーマップに矛盾するような
          `function-key-map'内の項目は無視される。
          この意図は、ファンクションキーが送出する文字の列には
          それ独自のキーバインディングがあるべきではなく、
          もしあったとしても、もとの定義を優先することである。

          `function-key-map'の値は、
          端末のterminfoやtermcapの情報に従って自動的に普通は設定されるが、
          端末固有のLispファイルの助けが必要な場合もある。
          Emacsには、一般的な多くの端末向けの端末固有ファイルがある。
          それらの主目的は、terminfoやtermcapから推定できないものを
          `function-key-map'に定義することである。 *note
          Terminal-Specific::。

      -- Variable: key-translation-map
          この変数は、`function-key-map'と同様に
          入力イベントを別の入力イベントへ変換するために用いる別のキーマップである。
          `function-key-map'とは2つの意味で異なる。

             * `key-translation-map'は、
               `function-key-map'の変換後に使われる。
               `function-key-map'による変換結果を使う。

             *
               `key-translation-map'は、実際のキーバインディングに優先する。
               たとえば、`key-translation-map'で`C-x
               f'にバインディングがあると、 グローバルマップに`C-x
               f'のバインディングがあったとしても 変換結果が効果を持つ。

          `key-translation-map'の意図は、
          `self-insert-command'に普通はバインドされる通常の文字を含めて
          ユーザー向けに文字集合を別の文字集合に
          対応付けられるようにすることである。

        キーの『変換として』キー列のかわりに関数を用いると、
`function-key-map'や`key-translation-map'は
単なる配置替え以上のことに使えます。
その関数で当該キーの変換を計算するのです。

        キー変換関数は1つの引数を受け取ります。
その引数は、`read-key-sequence'で指定されたプロンプトか、
エディタコマンドループがキー列を読み取っている場合には`nil'です。
多くの場合、プロンプトの値は無視できます。

        関数自身が入力を読むときには、
後続のイベントを変更することもできます。
たとえば、後続の文字をハイパー文字にする`C-c h'の定義は
つぎのようになります。

          (defun hyperify (prompt)
            (let ((e (read-event)))
              (vector (if (numberp e)
                          (logior (lsh 1 24) e)
                        (if (memq 'hyper (event-modifiers e))
                            e
                          (add-event-modifier "H-" e))))))

          (defun add-event-modifier (string e)
            (let ((symbol (if (symbolp e) e (car e))))
              (setq symbol (intern (concat string
                                           (symbol-name symbol))))
              (if (symbolp e)
                  symbol
                (cons symbol (cdr e)))))

          (define-key function-key-map "\C-ch" 'hyperify)

        `set-keyboard-coding-system'を用いた
キーボード文字集合の復号化を有効にしているときには、
上に述べた変換を終えてから復号化を行います。 *Note Specifying Coding
Systems::。 Emacsの将来の版では、他の変換のまえに復号化を行うでしょう。


File: elisp-ja,  Node: Recording Input,  Prev: Translating Input,  Up: Terminal Input

39.8.3 入力を記録する
----------------------------

      -- Function: recent-keys
          この関数は、キーボードやマウスからの最近の100個の入力イベントを収めた
          ベクトルを返す。
          キー列として使われたかどうかに関わらず、すべてのイベントを含む。
          したがって、キーボードマクロで生成したイベントを数えずに
          最後の100個のイベントをつねに得ることになる。
          （キーボードマクロで生成したイベントを省くのは、
          それらはデバッグにはあまり役立たないからである。
          キーボードマクロを起動したイベントが見えれば十分なはずである。）

      -- コマンド: open-dribble-file filename
          この関数は、FILENAMEという名前の"ドリブルファイル" （dribble
          file）をオープンする。 ドリブルファイルをオープンしていると、
          （キーボードマクロを除く）キーボードやマウスからの各入力イベントを
          そのファイルに書き出す。
          文字でないイベントは、その表示表現を`<...>'で囲って表す。

          ドリブルファイルをクローズするには、
          引数に`nil'を指定してこの関数を呼び出す。

          この関数は、バグ報告のために
          Emacsのバグを引き起こす入力を記録するために普通は使う。

               (open-dribble-file "~/dribble")
                    => nil

        関数`open-termscript'（*note Terminal Output::）も
参照してください。


File: elisp-ja,  Node: Terminal Output,  Next: Special Keysyms,  Prev: Terminal Input,  Up: System Interface

39.9 端末出力
=================

     端末出力関数は、端末に出力を送ったり、
端末へ送った出力を記録します。
変数`baud-rate'は、Emacsが考えている端末の出力速度を表します。

      -- Variable: baud-rate
          この変数の値は、Emacsが関知する端末の出力速度である。
          この変数に設定しても実際のデータ転送速度を変更しないが、
          その値はパディングなどの計算に用いられる。
          また、ウィンドウシステムを使っている場合であっても、
          スクリーンのどの部分をスクロールするか、
          あるいは、再描画するかの決定に影響する。
          （このような決定を調整する方法を与えるために、
          ウィンドウシステムには真の『出力速度』はないがこのように設計した。）

          値の単位はボー（baud）である。

        ネットワーク経由で使い、
ネットワークの異なる部分が異なる速度で動いているときには、
Emacsが返す値はローカル端末で使っている場合の値と異なるかもしれません。
リモートマシンへの通信速度でローカル端末と通信する
ネットワークプロトコルもあり、
そのような場合、Emacsや他のプログラムは正しい値を得られます。
その他の場合では正しい値を得られません。
Emacsの値がまちがっているときには、
あまり最適でない決定をくだすでしょう。
この問題を修正するには、`baud-rate'に設定します。

      -- Function: baud-rate
          この廃れた関数は、変数`baud-rate'の値を返す。

      -- Function: send-string-to-terminal string
          この関数は、なにも変更せずに文字列STRINGを端末へ送る。
          STRING内のコントロール文字は、端末に依存する効果を持つ。

          この関数の1つの用途は、ファンクションキーの定義を
          ダウンロード可能な端末のファンクションキーを定義することである。
          たとえば、ファンクションキー4を（文字の列`C-u C-f'を
          計算機に送って）4文字進めると定義にするには、
          特定の端末ではつぎのようにする。

               (send-string-to-terminal "\eF4\^U\^F")
                    => nil

      -- コマンド: open-termscript filename
          この関数は、Emacsが端末へ送出するすべての文字を記録する
          "タームスクリプトファイル"（termscript file）を
          オープンするために使う。 関数は`nil'を返す。
          タームスクリプトファイルは、
          Emacsがスクリーンを乱してしまう問題、
          誤ったtermcap定義やEmacsの実際のバグではない端末の望ましくない設定の
          問題を調べるのに有用である。
          どのような文字の列が実際に出力されるか確信できれば、
          それらが使用中のtermcapのどの定義に対応するか調べられる。

          *note Terminal Input::の`open-dribble-file'も参照。

               (open-termscript "../junk/termscript")
                    => nil


File: elisp-ja,  Node: Special Keysyms,  Next: Flow Control,  Prev: Terminal Output,  Up: System Interface

39.10 システム固有のX11のキーシンボル
===================================================

     システム固有のX11のキーシンボル（keysym）を定義するには、
変数`system-key-alist'に設定します。

      -- Variable: system-key-alist
          この変数の値は、各要素がシステム固有の
          各キーシンボルに対応する連想リストであること。 要素は`(CODE .
          SYMBOL)'の形である。 ここで、CODEは（『提供業者固有の』ビット
          -2**28を 含まない）数値のキーシンボルコードであり、
          SYMBOLはファンクションキーの名前である。

          たとえば、`(168 . mute-acute)'は、 数値コードが -2**28 + 168
          であるHP Xサーバーが使うシステム固有キーを定義する。

          実際に使用しているXサーバーのキーシンボルと衝突しなければ、
          他のXサーバー向けのキーシンボルを連想リストから省かなくても問題ない。

          変数は現在の端末につねにローカルであり、
          バッファローカルにはなりえない。 *note Multiple Displays::。


File: elisp-ja,  Node: Flow Control,  Next: Batch Mode,  Prev: Special Keysyms,  Up: System Interface

39.11 フロー制御
=====================

     本節では、
『Emacsがなぜコマンド文字集合の中からフロー制御文字を使うのか？』という
質問に答えたいと思います。 この話題に関する別の視点については、
配布に含まれるファイル`emacs/INSTALL'の中の
フロー制御に関する記述を読んでください。
termcapの定義とDECの端末集線器については、
`emacs/etc/TERMS'を参照してください。

        ある時期には、ほとんどの端末ではフロー制御を行っておらず、
`C-s'と`C-q'をフロー制御に用いるものもありませんでした。
したがって、コマンド文字として`C-s'と`C-q'を選ぶことは
自然であり議論の余地はありませんでした。
キーに割り付けるべきコマンドがたくさんあったので、
ほとんどすべてのASCIIコントロール文字に意味を与えました。

のちに、フロー制御にこれらの文字を必要とする端末が導入されたのです。
それらはフルスクリーンエディタ向きの端末ではなかったので、
Emacsの保守陣はそれらを無視しました。
後年、`C-s'と`C-q'によるフロー制御が
端末で広く使われるようになりましたが、当時はそれはオプションでした。
Emacsユーザーの多くはフロー制御をオフにして、
フロー制御のために無意味なキーバインディングに
替えようとはしなかったのです。

Emacsと端末や集線器の製造業者のどちらの使い方が『正しい』でしょう？` '
この問に簡単な答えはありません。

        `C-s'と`C-q'で引き起こされる問題を解消するのに
気が進まないのは、`C-s'と`C-q'であることに理由がないからです。
文字ストリームに透過な別の（実用上一般的ではないが）
フロー制御技術があります。
さらに、それらをフロー制御に使うのは正式な規格ではありません。
興味深いことですが、（1970年ころの）紙テープパンチャ付きの
テレタイプモデル33では、計算機からパンチャをオン／オフするために
`C-s'と`C-q'を送っていました！

ウィンドウシステムやPC端末エミュレータが文字端末を置き換えるようになり
フロー制御の問題は徐々に解消しつつあります。
しばらくは、読者が望むならEmacsはフロー制御を
オンにする手軽な方法を提供します。
関数`enable-flow-control'を呼び出すのです。

      -- コマンド: enable-flow-control
          この関数は、出力のフロー制御に`C-s'と`C-q'を
          使うようにするとともに、`keyboard-translate-table' （*note
          Translating Input::）を用いて
          `C-\'と`C-^'をそれらのかわりに使えるようにする。

        読者のファイル`.emacs'で関数`enable-flow-control-on'を使えば、
特定の種類の端末で自動的にフロー制御をオンにできます。

      -- Function: enable-flow-control-on &rest termtypes
          この関数は、端末の種類がTERMTYPESの1つであると、
          フロー制御をオンにし`C-\'と`C-^'をかわりに使う。
          たとえば、つぎのように使う。

               (enable-flow-control-on "vt200" "vt300" "vt101" "vt131")

        `enable-flow-control'が行う処理はつぎのとおりです。

       1. `(set-input-mode nil t)'で 端末入力をCBREAKモードに設定し、
          オペレーティングシステムにフロー制御を行うように指示する。

       2. `C-\'と`C-^'を`C-s'と`C-q'に変換するように
          `keyboard-translate-table'を設定する。
          非常に下位レベルであることを除けば、
          Emacsは`C-s'や`C-q'を打ったと考えるので、
          たとえ他のコマンドに対しても`C-\'や`C-^'を打ったとしても
          実質的には`C-s'や`C-q'を打ったことになる。 *note Translating
          Input::。

        端末側がフロー制御文字を発行するのであれば、
カーネルのフロー制御処理をオンにすれば、
その端末に対する普通のパディングより少なくしても動作するはずです。
termcapの定義をカスタマイズしてパディング量を減らします。
あるいは、`baud-rate'に小さめの値を設定すると、
パディングの必要量の計算にEmacsは低い速度を使います。 *Note Terminal
Output::。


File: elisp-ja,  Node: Batch Mode,  Prev: Flow Control,  Up: System Interface

39.12 バッチモード
========================

     コマンド行オプション`-batch'は、 Emacsを非対話的に実行します。
このモードでは、Emacsは端末からコマンドを読まず、
端末のモードを変更せず、スクリーンに出力もしません。
これは、実行するLispプログラムを指定できるようにするためです。
それが終るとEmacsも終了します。 実行すべきプログラムは、
FILEという名前のライブラリをロードする`-l FILE'、 および、
引数なしで関数FUNCTIONを呼び出す`-f FUNCTION'で 指定します。

        バッチモードでは、ストリームとして`t'を指定した
`message'や`prin1'などでエコー領域に 表示されるLispプログラムの出力は、
Emacsの標準エラー記述子へ出力されます。 したがって、Emacsは非対話的な
アプリケーションプログラムのようにふるまいます。
（コマンドの表示などのEmacs自身がエコー領域に出力するものは
完全に抑制される。）

      -- Variable: noninteractive
          この変数は、Emacsがバッチモードで動作していると`nil'以外である。


File: elisp-ja,  Node: Antinews

Appendix A Emacs 20 Antinews _(2003/10/30)_
*******************************************

     Emacs 20 Antinewsの翻訳
(http://www.sodan.org/~knagano/emacs/emacs21-emacs20-antinews-j.html)
を参考に翻訳しています。上記文書の翻訳をされた方に深く感謝し ます。

時代に逆行する皆さんへ、Emacsヴァージョン20.4へのダウングレード情報を
お届けします。Emacs 21のさまざまな機能が省かれたことによる単純さをお楽
しみください。後述する節では、Emacs 20.3へダウングレードするための情報
をお届けします。

     * Menu:

     * Antinews Emacs 20::
     * Antinews Emacs 203::


File: elisp-ja,  Node: Antinews Emacs 20,  Next: Antinews Emacs 203,  Prev: Antinews,  Up: Antinews

A.1 Old Lisp Features in Emacs 20 _(2003/10/30)_
================================================

        * マクロの `push' と `pop' は削除されました。`dolist' と
          `dotimes'も同様です。

        *
          Emacsは画像を表示しません。(Emacsがはテキストを編集するためのものですの
          で、)画像もマージンもツールバーも表示しません。

        *
          テキストプロパティの`display'は特別な意味を持たなくなりました。こ
          のため、自分でコードを書かない限り、特別な効果はありませんので、Lispプ
          ログラムで自由に利用できます。ところで、画像を表示しないのであれば、
          `display' なんてテキストプロパティは必要なのかい？

        * テキストプロパティの `field'
          はもはや特別な意味を持たなくなりまし
          た。バッファはもはや「領域」には分割されません(「領域」で情報を分ける
          と意図しない動作をしてしまいますから)。

          コメント：テキストプロパティにfieldが追加されたそう
          な。例えば、M-x shellでプロンプトにfieldを設定しておけば、
          入力されたコマンドかプロンプトかが判断できるので、
          `C-a'などの挙動を制御できるわけです。

        * フェイスの属性がシンプルになりました。`:family'や`:height'、
          `:width'、`:weight'、`:slant'はなくなり、フォント名や太
          字、斜体字かどうかの指定になりました。

          フェイスの`:overline'や`:strike-through'、`:box'といっ
          た属性も削除されました。下線は常にテキストと同じ色になりました。他の色
          を使うなんて悪趣味ですよ。

          属性の単純化と合わせて、`set-face-attribute' や
          `face-attribute' も削除しました。フェイスの属性は `face-font'
          などの関数で得ることができますし、 `set-face-font'
          で値を変更することもできます(これらの関数はEmacs
          21で利用できますが、それほど便利ではありませんでした)。

        * 標準のフェイスである `scroll-bar'、`menu'、`border'、
          `cursor' や `mouse' は削除されました。フェイスでメニューなど
          の色を変えたりするのは、むしろ奇妙な方法ですので、あるべきではないので
          す。フレームの境界やカーソル、マウスカーソルの色を変えるには、
          `set-border-color'、`set-cursor-color' や `set-mouse-color'
          が利用できます。メニューの色はXのリソースを利用 できます。

        *
          もはやテキスト端末では色や他のフェイス属性を表示できません。したがって、
          端末がフェイスを表示できるかどうかを心配する必要はないのです。

        *
          ビープ音以外には音を鳴らす機能はありません。そのため、Emacsはあなたの
          平穏と静寂を乱しません。

        *
          タイ語などでは、いくつかの文字は重ね合わせて作られた画像として表示しま
          す。Emacs20でこのような言語の合成文字を表示する方法は複雑で練られてい
          ません。恥ずかしいのでこれくらいの説明にしておきます。

        * `delete-and-extract-region'
          (リージョン内のテキストをカットする関
          数)は削除されました。テキストを得るのには`buffer-substring'が使え
          ますし、削除するのには`delete-region' が利用できます。

        *
          正規表現は`[:alpha:]'(アルファベットを表す)のようなPOSIX使用の文字をサポートしていませ
          ん。これにより、すべての文字は同じように表現されます。

        * ハッシュテーブルは削除されました。連想リストを利用します。

        *
          Lispプリンタは循環構造を検出や出力をしません。とにかくLispリーダは循環
          構造を再現できないので、それでいいのです。しかし、循環構造を出力できる
          `cust-print.el' というライブラリはあります。

        * EmacsはX
          toolkitのツールバーを使わずに、Emacs自身で実現します。そして、常にフレー
          ムの前景色は背景色を使います。そのため、スクロールバーに異なる色を指定することは
          できません。

        *
          単純にするために、すべてのASCII文字は同じ高さと幅を持ちます(中国語のように
          ある種の文字は常にASCIIの2倍の幅になります)。すべての文字は同じように作られ
          表示されるのです。

        *
          Emacsのウィンドウサイズを変更でき、あるウィンドウでのサイズ変更は他のすべてのウィ
          ンドウに影響します。Windowsでは`window-size-fixed'を利用できなくなりました。

        * `intern-soft'はシンボルを引数として受け取らなくなりました。

        *
          `bitmap-spec-p'は`pixmap-spec-p'に名前を変更しました。この変更を調べる
          ことでEmacsのヘルプシステムを使う練習になります。

        * ツールチップは通常のフレームを使って処理されます。

        *
          モードラインの部分はマウスには反応しません。しかし、マウスによるコマンドの一部は
          利用できます。

        *
          Windowsはヘッダを表示できません。逆にモードラインは消すことはできません。

        * メニューの区切りとして点線のみを利用できます。

        * 縦方向の断片的なスクロールは存在しません。

        * 関数 `format' や `message' はテキストプロパティを無視します。

        *
          `propertize'(文字列にテキストプロパティを付けて返す関数)は存在しません。
          `set-text-properties'を用います。

        *
          色はウィンドウシステムでのみサポートされ、テキスト端末ではサポートされません。テ
          キスト端末の色に関連する関数は不要になりましたので、削除しました。

        * 関数 `color-values'や`color-defined-p'、`defined-colors'
          はそれぞ れ
          `x-color-values'、`x-color-defined-p'、`x-defined-colors' に名
          前が変わりました。

        *
          ウィンドウは固定された幅や高さにすることはできません。Emacsは必要な時、すべての
          ウィンドウのサイズを調整します。

        * プロパティの `before-string' や `after-string' の値として使わ
          れる文字はシングルコラムとして表示される文字を含まなければいけません。タブや改行
          などの制御文字だと変な結果になるでしょう。

        *
          ミニバッファのプロンプトは実はミニバッファの内容には表れません。プロンプトはミニ
          バッファウィンドウに特別な方法で表示しているのです。

          コメント：ミニバッファでC-aを行うと、プロンプトの後にカーソルが移動します。Emacs
          21では左カーソルでこれより前に行くことができます。単なる文字なわけですから、当然
          ですね。しかし、Emacs
          20.4では不可能です。これは、単なる文字ではないのでプロンプ
          ト以降のみしか触ることができないのです。

        *
          `write-region'の排他的に開く機能は削除されました。このため、7番目の引数が
          `nil' でない場合は、ユーザに確認を求めます。

        *
          `buffer-size'のオプション引数は削除され、常にカレントバッファの文字数を返し
          ます。

        * `assq-delete-all' は削除されました。

        * `:set-after'はもはや`defcustom'にはありません。

        *
          `small-temporary-file-directory'は特別な意味を持たなくなりました。これで
          `temporary-file-directory'というたった一つの変数のみで一時ファイルを作るディ
          レクトリを指定できます。しかし、Emacsのすべての機能がその変数を利用するわけでは
          ありません。あるものは環境変数`TMP'を使うでしょうし、あるものは
          環境変数`TMPDIR'を使うでしょう。

        * `save-some-buffers'の2番目の引数PREDが `nil'
          でなければ、正確に
          どのような値であるかは問題にならない。とにかく`nil'でないならば、`t'と
          同じことになり、ファイルでないバッファも保存する。

        * `inhibit-modification-hooks'は特別な意味を持たなくなりました。

        *
          `fontification-functions'は削除されました。`window-scroll-functions'の
          ような他のフックを使うことで、同じような処理を行うことができます。

        * `redisplay-dont-pause'は特別な意味を持たなくなりました。

        * `calendar-move-hook' は削除されました。

        *
`move-to-column'は2番目の引数が`nil'でなければ、`t'として扱います。


File: elisp-ja,  Node: Antinews Emacs 203,  Prev: Antinews Emacs 20,  Up: Antinews

A.2 Old Lisp Features in Emacs 20.3 _(2003/10/30)_
==================================================

     ここではEmacs 20.3で削除される機能を紹介しましょう。

        これらはLisp言語自身の変更です。

        * `line-beginning-position' と
          `line-end-position'は削除されました。

        * `directory-files-and-attributes'、`file-attributes-lessp'、
          `file-expand-wildcards' は削除されました。

        * `decode-coding-region' と
          `encode-coding-region'は後で役立つようにテキ
          ストプロパティをそのまま残します(もっともめったに役立たないですけど)。

        * `position-bytes' と `byte-to-position' は削除されました。

        *
          `with-output-to-temp-buffer'で作られる一時バッファは書き込み可能です。
          Fundamental mode以外にしなければヘルプモードになります。

        *
          `sref'はINDEXを文字数ではなくバイト数として解釈します。そして、
          `char-bytes'は文字通り文字が占めるバイト数を返します。

        * `process-running-child-p' は削除されました。

        * `interrupt-process'
          とそれと似た関数は2番目の引数が`lambda'であれば特
          別なことはしません。

        * `define-prefix-command'は2つの引数だけを受け取ります。

        *
          `read-char'、`read-event'、`read-char-exclusive'の2番目の引数の意
          味がこれまでとは逆になります。引数が`nil'であれば、現在の入力方法を用います。

        * `with-temp-message'は削除されました。

        * `clear-this-command-keys' は削除されました。

        * `gap-position' と `gap-size'は削除されました。

        * `modify-face'で引数が`(nil)'であっても特別な意味は持ちません。

        * base64の変換用関数は削除されました。

        *
          `find-file'やそれを利用したような関数でワイルドカードを利用できなくなしまし
          た。

        *
          `file-attributes'はファイルサイズを返します。これは、整数に収まるなら整数に
          なります。収まらないと浮動小数点になります。


File: elisp-ja,  Node: Tips,  Next: GNU Emacs Internals,  Prev: System Interface,  Up: Top

Appendix B ヒントと慣習
*****************************

     本章では、Emacs Lispの機能についてさらに述べることはしません。
かわりに、前章までに述べてきた機能を効率よく使うための助言や Emacs
Lispプログラマが従うべき慣習について述べます。

     * Menu:

     * Coding Conventions::        Conventions for clean and robust programs.
     * Compilation Tips::          Making compiled code run fast.
     * Documentation Tips::        Writing readable documentation strings.
     * Comment Tips::	      Conventions for writing comments.
     * Library Headers::           Standard headers for library packages.


File: elisp-ja,  Node: Coding Conventions,  Next: Compilation Tips,  Up: Tips

B.1 Emacs Lispのコーディングの慣習
============================================

     ここでは、読者が広く使われることを意図した Emacs
Lispコードを書く場合に従うべき慣習について述べます。

        * すべてのグローバル変数は同じ名前空間を共有し、
          すべての関数も別の名前空間を共有するため、
          読者のプログラムを別のLispプログラムと区別するための短い単語を選ぶべきである。
          そして、すべてのグローバル変数、定数、関数の名前を
          選んでおいた接頭辞で始めるように注意する。

          Emacs
          Lispでは基本関数ではないがLispの伝統的な基本関数の名前にさえも
          この勧告は適用される。 たとえ`copy-list'にさえもである。
          信じるかどうかは別にして、
          `copy-list'のもっともらしい定義方法は複数ある。
          安全であるためには、読者の接頭辞を付けて
          `foo-copy-list'や`mylib-copy-list'のような名前にする。

          読者が、`twiddle-files'のような特定の名前でEmacsに
          追加すべき関数を書いた場合には、読者のプログラムでは
          その名前で呼ばないようにする。
          読者のプログラムでは`mylib-twiddle-files'としておき、
          Emacsに名前を追加するように提案するメイルを
          `bug-gnu-emacs@gnu.org'へ送る。
          われわれがそのようにすることを決定したときには、
          名前をとても簡単に変更できる。

          1つの接頭辞では不十分な場合には、 意味がある限りは、
          2つか3つの共通する別の接頭辞を読者のパッケージで使ってもよい。

          接頭辞とシンボル名の残りの部分とはハイフン`-'で分ける。
          これはEmacs自身やほとんどのEmacs
          Lispプログラムと一貫性がある。

        * プログラムに少なくとも複数の入り口がある場合には、
          各ライブラリプログラムに`provide'の呼び出しがあるとしばしば有用である。

        *
          別のライブラリプログラムをあらかじめロードしておく必要があるファイルでは、
          ファイルの先頭のコマンドにそのように記述しておくこと。
          さらに、必要なものが確実にロードされておくように`require'を使う。

        * 別のファイルBARで定義されるマクロを
          ファイルFOOで使っている場合には、
          FOOでそのマクロを始めて使うまえにFOOにつぎの式があること。

               (eval-when-compile (require 'BAR))

          （さらに、`require'が働くように、 ライブラリBARには`(provide
          'BAR)'があること。）
          この式により、FOOをバイトコンパイルするときに
          BARをロードすることになる。
          さもないと、必要なマクロをロードせずにFOOをコンパイルする危険を侵し、
          正しく動作しないコンパイル済みコードを生成することになる。
          *note Compiling Macros::。

          `eval-when-compile'を使うことで、
          FOOのコンパイル済みの版を_使う_ときには BARをロードしない。

        * メジャーモードを定義するときには、
          メジャーモードの慣習に従うこと。 *note Major Mode
          Conventions::。

        * マイナモードを定義するときには、
          マイナモードの慣習に従うこと。 *note Minor Mode
          Conventions::。

        * 関数の目的が特定の条件を満たすかどうかを報告するのであれば、
          その関数には`p'で終る名前を付ける。
          名前が1単語である場合には`p'だけを付加する。
          複数の単語であれば`-p'を付加する。
          たとえば、`framep'や`frame-live-p'である。

        * 真偽の条件を記録するユーザーオプション変数には、
          `-flag'で終る名前を付ける。

        * 読者のメジャーモードでは、 `C-c
          LETTER'をキーとして定義しないこと。
          これらのキー列はユーザー向けに予約済みである。
          それら*だけ*がユーザー向けに予約されたキー列であり、
          それらを禁止しないこと。

          かわりに、`C-c'のあとにコントロール文字か数字文字か特定の句読点文字が続く
          キー列を定義する。
          これらのキー列は、メジャーモード用に予約してある。

          Emacsのすべてのモードをこの慣習に従うように変換するのは
          たいへんな作業量であった。
          この慣習を捨てさるとその作業をむだにしてしまい、ユーザーにも不便である。

        * `C-c'のあとに`{'、`}'、`<'、`>'、`:'、`;'の
          いずれかが続くキー列もメジャーモード用に予約してある。

        * `C-c'のあとにこれら以外の句読点文字が続くキー列は、
          マイナモード用に割り当ててある。
          これらをメジャーモードで使うことは絶対禁止ではないが、
          これらを使うと、メジャーモードのバインディングが
          マイナモードでときどき隠されてしまう。

        * 修飾キーを使わないファンクションキー<F5>から<F9>は、
          ユーザーが定義するように予約してある。

        * （`C-c'を含む）任意のプレフィックス文字に続く
          `C-h'をバインドしないこと。
          `C-h'をバインドしなければ、これは自動的に
          プレフィックス文字のサブコマンド一覧を表示するヘルプ文字になる。

        * <ESC>に続く<ESC>以外には、
          <ESC>で終るキー列をバインドしないこと。 （つまり、`<ESC>
          <ESC>'で終るキー列をバインドするのはよい。）

          この規則の理由は、任意の文脈において
          <ESC>に対するプレフィックスでないバインディングがあることで、
          エスケープシーケンスをその文脈におけるファンクションキーと
          認識することを防げる。

        *
          ユーザーが出入りできる一時的なモードや状態のように働くものでは、
          脱出手段として`<ESC> <ESC>'や `<ESC> <ESC> <ESC>'を定義する。

          Emacsの普通のコマンドを受け付ける状態、、あるいは、
          より一般的には<ESC>に続けてファンクションキーや矢印キーが
          意味を持つ可能性がある任意の状態では、
          <ESC>に続くエスケープシーケンスの認識を妨げる `<ESC>
          <ESC>'を定義するべきではない。
          そのような状態では、脱出手段として`<ESC> <ESC> <ESC>'を
          定義する。 さもなければ脱出手段として`<ESC> <ESC>'を定義する。

        *
          アプリケーションでは、シフトキーを押し下げたボタン1関連のマウスイベントを
          バインドすべきではない。
          これらのイベントには、`S-mouse-1'、`M-S-mouse-1'、
          `C-S-mouse-1'などが含まれる。
          これらはユーザー向けに予約してある。

        * 読み出し専用のテキスト向けの特別なメジャーモードでは、普通、
          `mouse-2'と<RET>をテキスト内のある種の参照を
          辿るように再定義するべきである。
          dired、info、コンパイル（compilation）、出現（occur）などのモードは
          このように再定義している。

        * Emacsの普通のふるまいを変更するようなパッケージでは、
          その機能をオン／オフするコマンドを含めるとよい。
          その機能をオン／オフする`WHATEVER-mode'という
          名前のコマンドを用意し、自動ロード（*note
          Autoload::）するようにする。
          パッケージをロードしただけでは見ためには効果がない、
          つまり、その機能をオンにしないようにパッケージを設計すること。
          ユーザーはコマンドを起動してその機能をオンにする。

        * Emacsの基本関数の別名を定義することは悪い考えである。
          そのかわりに標準の名前を使う。

        *
          Emacsの基本関数を再定義（あるいはアドバイス）することは謹むべきである。
          特定のプログラムに対しては正しく動作するであろうが、
          他のプログラムがその結果どうなるかはわからない。

        *
          Emacsの標準の関数やライブラリプログラムを置き換えるようなファイルでは、
          そのファイルの先頭の目立つコメントに
          どの関数を置き換え元のふるまいとの相違点を記述すること。

        * 読者のEmacs Lispのソースファイルの名前は13文字以下にすること。
          こうすると、ファイルをコンパイルしても、
          コンパイル済みのファイル名は14文字以下になり、
          どんな種類のUNIXシステムにも収まるだけの短さである。

        * プログラムでは`next-line'や`previous-line'を使わないこと。
          ほとんどの場合、`forward-line'のほうがより便利であり、
          予測可能で堅牢でもある。 *note Text Lines::。

        *
          マークを設定することが読者のプログラムの意図した機能の一部でなければ、
          マークを設定する関数は呼び出さないこと。
          マークはユーザーレベルの機能であり、
          ユーザーの便宜のために値を指定する以外には、
          マークを変更するのは正しくない。 *note The Mark::。

          特に、以下のいずれの関数も使わないこと。

             * `beginning-of-buffer', `end-of-buffer'

             * `replace-string', `replace-regexp'

          対話的なユーザー向けの他の機能を必要とせずに
          単にポイントを移動したり特定の文字列を置換するには、
          これらの関数は1行か2行の単純なLispコードで置き換えられる。

        *
          ベクトルを使う特別な理由がない限りは、ベクトルではなくリストを使う。
          Lispには、ベクトルに対するよりもリストを操作する機能のほうが多くあり、
          リストを扱うほうが普通はより簡便である。

          （リストだけが許す）要素を挿入したり削除する必要がないのであれば、
          ある程度のサイズがあり
          （先頭から末尾に向けての探索ではなく）ランダムに参照する表には
          ベクトルのほうが適している。

        * エコー領域にメッセージを表示する推奨方法は、
          `princ'ではなく関数`message'を使うことである。 *note The Echo
          Area::。

        * エラー条件に出会ったときには、
          関数`error'（あるいは`signal'）を呼び出す。
          関数`error'は戻ってこない。 *note Signaling Errors::。

          エラーを報告するために、
          `message'、`throw'、`sleep-for'、`beep'は使わないこと。

        * エラーメッセージは大英文字で始め、ピリオドで終えないこと。

        * 実行に時間を要する多くのコマンドでは、
          開始時には`Operating...'のメッセージを表示し、
          終了時にはそれを`Operating...done'と変える。
          これらのメッセージの形を同じにしておくこと。
          `...'の周りに空白は_なく_、末尾にピリオドも_ない_。

        * 再帰編集の使用は避けるように努めること。
          そのかわりにrmailのコマンド`e'のようにする。
          つまり、古いローカルキーマップに戻るためのコマンドを収めた
          新しいローカルキーマップを使う。
          あるいは、コマンド`edit-options'のようにする。
          別のバッファに切り替え、戻るのはユーザーに任せる。 *note
          Recursive Editing::。

        * 変数名を`*'で始めたり終える慣習があるシステムもある。 Emacs
          Lispではこの慣習を使わないので、読者のプログラムでも使わないこと。
          （Emacsでは、特別な目的のバッファにのみそのような名前を使う。）
          すべてのライブラリで同じ慣習を使うと、
          ユーザーにはEmacsがより整合して見える。

        * 自由変数には`defvar'の定義を追加して、
          コンパイル時の未定義な自由変数に対する警告を避けるように努めること。

          ある関数で変数を束縛しその変数を別の関数で使ったり設定すると、
          その変数を定義しない限りコンパイラは後者の関数について警告を出す。
          しかし、しばしばこれらの変数は短い名前で、
          Lispパッケージでそのような変数名を定義すべきかどうか明らかでない。
          したがって、そのような変数の名前は、
          読者のパッケージの他の関数や変数に使っている接頭辞で
          始まる名前に改名すべきである。

        * デフォルトの字下げパラメータを使って、
          各関数を`C-M-q'（`indent-sexp'）で字下げすること。

        * 閉じ括弧だけの行にする癖をつけないこと。
          Lispプログラマはこれに当惑する。
          たまには、閉じ括弧が多数個連続するときに
          それらを1つか2つの塊に分けることは意味がある。

        * コピーを配布する場合には、ファイルに著作権表示を入れること。
          つぎのような文面を使う。

               ;; Copyright (C) YEAR NAME

               ;; This program is free software; you can redistribute it and/or
               ;; modify it under the terms of the GNU General Public License as
               ;; published by the Free Software Foundation; either version 2 of
               ;; the License, or (at your option) any later version.

               ;; This program is distributed in the hope that it will be
               ;; useful, but WITHOUT ANY WARRANTY; without even the implied
               ;; warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
               ;; PURPOSE.  See the GNU General Public License for more details.

               ;; You should have received a copy of the GNU General Public
               ;; License along with this program; if not, write to the Free
               ;; Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
               ;; MA 02111-1307 USA

          読者がフリーソフトウェアファウンデーションに著作権を委譲する契約を
          結んでいるときには、 NAMEとして`Free Software Foundation,
          Inc.'を使う。 さもなければ読者自身の名前を使う。


File: elisp-ja,  Node: Compilation Tips,  Next: Documentation Tips,  Prev: Coding Conventions,  Up: Tips

B.2 コンパイル済みコードを速くするヒント
==========================================================

バイトコンパイルしたLispプログラムの実行速度を改良する方法を示します。

        * ライブラリ`profile'やライブラリ`elp'で、
          読者のプログラムを計測する。
          操作方法についてはファイル`profile.el'と`elp.el'を参照。

        * 可能な場合には再帰ではなく繰り返しを使う。
          コンパイル済みの関数が別のコンパイル済み関数を呼び出す場合であっても
          Emacs Lispでは関数呼び出しは遅い。

        * `memq'、`member'、`assq'、`assoc'のリスト探索基本関数を
          使うほうが明示的な繰り返しよりも速い。
          これらの探索基本関数の1つを使えるようにデータ構造を変更する価値はある。

        * ある種の組み込み関数は、バイトコンパイル済みのコードでは
          普通の関数呼び出しを避けるように特別に扱われる。
          これらの関数を使うのはよいことである。
          コンパイラが関数を特別に扱うかどうかを調べるには、
          その属性`byte-compile'を調べる。
          属性が`nil'以外であれば、その関数は特別に扱われる。

          たとえば、つぎの入力は、`aref'が特別にコンパイルされることを示す
          （*note Array Functions::）。

               (get 'aref 'byte-compile)
                    => byte-compile-two-args

        *
          読者のプログラムの実行時間のかなりの部分を小さな関数の呼び出しが
          占めるときには、その関数をインラインにする。
          これにより関数呼び出しのオーバヘッドを削除できる。
          関数をインラインにするとプログラム変更の柔軟性を減じるので、
          ユーザーが速度を気にするほど遅い部分の十分な速度向上が得られない限り、
          このようにしないこと。 *note Inline Functions::。


File: elisp-ja,  Node: Documentation Tips,  Next: Comment Tips,  Prev: Compilation Tips,  Up: Tips

B.3 説明文字列に関するヒント
========================================

     説明文字列を書くうえでのヒントや慣習を述べます。 コマンド`M-x
checkdoc-minor-mode'を実行して、 これらの慣習の多くを確認できます。

        * ユーザーが知っておくことを意図した各コマンド、関数、変数には、
          説明文字列を付けること。

        *
          Lispプログラムの内部変数やサブルーティンにも説明文字列を付ける。
          Emacsの初期の版では、説明文字列のかわりにコメントを使うと容量を節約できたが、
          今はこれはあてはまらない。

        * 説明文字列の最初の行は、1つか2つの完全な文であり、
          それだけで概要を表していること。 `M-x
          apropos'は説明文字列の最初の行だけを表示するため、
          それだけで十分に表せないと表示結果が悪くなる。
          特に、最初の行は大文字で始め、ピリオドで終えること。

          説明文字列には、関数や変数の使い方の詳細を述べる追加の行があってよい。
          それらの行も完全な文から成るべきであるが、見ためをよくするために
          適当に詰めてよい。

        * 一貫性があるように、関数の説明文字列の最初の文の動詞は
          『to』を省いた不定詞にする。 たとえば、『Returns the cons of
          A and B.』ではなく 『Return the cons of A and B.』とする。
          最初の行の残りの文についても同様にするとよい。
          以降の文節では適切な主語があるほうが一般にはよい。

        *
          説明文字列は受動態ではなく能動態で書き、未来形ではなく現在形で書く。
          たとえば、『A list containing A and B will be
          returned.』ではなく 『Return a list containing A and
          B.』と書く。

        * 不必要に単語『cause』（および同義語）を使わないこと。 『Cause
          Emacs to display text in boldface,』ではなく 単に『Display
          text in boldface.』と書く。

        * 説明文字列は、白文字で始めたり終えないこと。

        * 80コラムのスクリーン上のEmacsのウィンドウに収まるように
          説明文字列を整形する。
          ほとんどの行を60文字を越えないようにするとよい。
          必要な情報を入れるためならば最初の行が長くなってもよい。

          しかし、説明文字列全体を単純に整形するよりは、
          注意深く行分けすると読みやすくなる。
          説明文字列が長い場合には、話題ごとに空行で区切る。

        * ソースコード上で説明文字列の最初の行に揃えるために
          説明文字列の残りの行を字下げ*しないこと*。
          ソースコード上では見ためがよくても、
          ユーザーが説明文字を見るときには奇妙に見える。
          文字列を始めるダブルクォートのまえにある字下げは
          文字列の一部ではないことに注意！

        * ユーザーが禁止コマンドを実行しようとすると、
          Emacsは当該コマンドの説明文字列の最初の文節、
          つまり、最初の空行までを表示する。
          必要ならば、最初の空行のまえに入れるべき情報を選んで、
          このような表示が有用であるようにする。

        * ユーザーが対話的に設定したがるような変数では、
          その変数の説明文字列は`*'で始める。
          変数の値が、長いリストや関数であるとき、あるいは、
          初期化ファイルでのみ設定するような変数であるときには、
          その説明文字列を`*'で始めないこと。 *note Defining
          Variables::。

        * yes/noのフラグを表す変数の説明文字列は『Non-nil
          means...』のような
          単語で始めて、`nil'以外の値はすべて同値であることを明らかにし、
          `nil'と`nil'以外の意味を明確に示すこと。

        * 関数の説明文字列でその引数について述べるときには、
          その引数の値を表す名前には大文字で書いた引数名を使う。
          したがって、関数`/'の説明文字列では、
          その第2引数の名前は`divisor'なので、`DIVISOR'と表す。

          また、リストやベクトルを（その一部が変化するかもしれない）構成部分に
          分解したものを示すときなどのメタ変数には、すべて大文字を使う。

        * 説明文字列でLispシンボルを参照するときには、
          それが表示されるとき（つまり普通はすべて小文字）のように
          シングルクォートで囲って書く。 たとえば、`lambda'である。
          これには2つ例外があり、tとnilはシングルクォートで囲まずに書く。
          （本書では、すべてのシンボルをシングルクォートで囲む別の慣習を用いている。）

          ヘルプモードでは、説明文字列でシングルクォートで囲ったシンボルを使うと、
          そのシンボルに関数定義や変数定義があるときには自動的に
          ハイパーリンクを作成する。
          この機能を利用するために特別なことをする必要はない。
          しかし、シンボルに関数定義と変数定義の両方があり、
          どちらか一方のみを参照したい場合には、 シンボルの名前のまえに
          `variable'、`option'、`function'、`command'の
          いずれかの単語を書くだけでどちらであるかを指定できる。
          （これらの単語を認識するときには大文字小文字は区別しない。）
          たとえばつぎのように書くと、

               This function sets the variable `buffer-file-name'.

          ハイパーリンクは、変数`buffer-file-name'の説明文字列を指し、
          その関数の説明文字列は指さない。

          シンボルに関数定義や変数定義があっても、
          説明文字列でのシンボルの使い方には無関係な場合には、
          シンボルの名前のまえに単語`symbol'を書けば、
          ハイパーリンクを作らないようにできる。
          たとえば、つぎのようにすると、

               If the argument KIND-OF-RESULT is the symbol `list',
               this function returns a list of all the objects
               that satisfy the criterion.

          ここでは`list'の関数／変数定義は無関係なので、
          関数`list'の説明文字列を指すハイパーリンクは作られない。

        * 説明文字列に直接キー列を書き込まないこと。
          そのかわりに、それの標準的なキー列を作成する
          `\\[...]'の書き方を使う。
          たとえば、`C-f'と書くかわりに、`\\[forward-char]'と書く。
          Emacsが説明文字列を表示するときに、
          `forward-char'に現在バインドされているキーにEmacsが置き換える。
          （普通は`C-f'であるが、ユーザーがキーバインディングを変更していれば、
          別の文字になる。） *note Keys in Documentation::。

        * メジャーモードの説明文字列では、
          グローバルなキーマップではなくそのモードのローカルなキーマップでの
          キーバインディングを参照したいだろう。
          それには、使用するキーマップを指定する構文`\\<...>'を
          説明文字列の中に書く。
          最初に`\\[...]'を使うまえにこうしておくこと。
          `\\<...>'の内側のテキストは、
          メジャーモード向けのローカルキーマップを保持する変数の名前であること。

          説明文字列の表示を遅くしてしまうので、
          `\\[...]'を何回も使うのは実用的ではない。
          したがって、読者のメジャーモードのもっとも重要なコマンドの記述にこれを使い、
          モードのキーマップの残りを表示するには`\\{...}'を使う。


File: elisp-ja,  Node: Comment Tips,  Next: Library Headers,  Prev: Documentation Tips,  Up: Tips

B.4 コメントの書き方のヒント
========================================

コメントを置く場所とそれらの字下げ方法については以下のような慣習を推奨します。

    `;'
          1つのセミコロン`;'で始まるコメントは、
          ソースコードの右側で同じコラム位置に揃えること。
          そのようなコメントは、その行のコードの動作を説明する。
          lispモードやその関連するモードでは、
          コマンド`M-;'（`indent-for-comment'）で
          自動的に右側の正しい位置に`;'を挿入したり、
          そのようなコメントが既存ならば整列できる。

          つぎとその下の例は、Emacsのソースから持ってきたものである。

               (setq base-version-list                 ; there was a base
                     (assoc (substring fn 0 start-vn)  ; version to which
                            file-version-assoc-list))  ; this looks like
                                                       ; a subversion

    `;;'
          2つのセミコロン`;;'で始まるコメントは、
          その部分のコードの字下げに揃えること。
          そのようなコメントは、その後続の行の目的や
          その箇所でのプログラムの状態を記述する。

               (prog1 (setq auto-fill-function
                            ...
                            ...
                 ;; update mode line
                 (force-mode-line-update)))

          説明文字列を持たない各関数
          （所属するパッケージで内部向けにのみ使用される関数）では、
          関数が行うことと正しい呼び出し方を記述した
          2つのセミコロンで始まるコメントを関数のまえに書くこと。
          各引数の意味とその可能な値を関数がどのように解釈するかを正確に説明すること。

    `;;;'
          3つのセミコロン`;;;'で始まるコメントは、左端に揃えること。
          そのようなコメントは、関数定義の外側で使い、
          プログラムの設計原理を説明する一般的な表明である。
          たとえばつぎのとおり。

               ;;; This Lisp code is run in Emacs
               ;;; when it is to operate as a server
               ;;; for other processes.

          3つのセミコロンで始まるコメントの別の使い方は、
          関数内の行をコメントにする場合である。
          そのような行が左端に留まるように3つのセミコロンを使うのである。

               (defun foo (a)
               ;;; This is no longer necessary.
               ;;;  (force-mode-line-update)
                 (message "Finished with %s" a))

    `;;;;'
          4つのセミコロン`;;;;'で始まるコメントは、
          左端に揃えて、プログラムの主要な部分のヘッダに使う。
          たとえばつぎのとおり。

               ;;;; The kill ring

     `M-;'（`indent-for-comment'）や <TAB>（`lisp-indent-line'）などの
Emacsのlispモードの字下げコマンドは、
これらの慣習にしたがって自動的にコメントを字下げします。 *Note
コメントの操作: (emacs)Comments。


File: elisp-ja,  Node: Library Headers,  Prev: Comment Tips,  Up: Tips

B.5 Emacsライブラリのヘッダの慣習
=============================================

Emacsには、コメントをいくつかの部分に分けて作者などの情報を与えるために、
Lispライブラリの特別なコメントに対する慣習があります。
本節ではそれらの慣習について述べます。 まず、例を示します。

          ;;; lisp-mnt.el --- minor mode for Emacs Lisp maintainers

          ;; Copyright (C) 1992 Free Software Foundation, Inc.

          ;; Author: Eric S. Raymond <esr@snark.thyrsus.com>
          ;; Maintainer: Eric S. Raymond <esr@snark.thyrsus.com>
          ;; Created: 14 Jul 1992
          ;; Version: 1.2
          ;; Keywords: docs

          ;; This file is part of GNU Emacs.
          ...
          ;; Free Software Foundation, Inc., 59 Temple Place - Suite 330,
          ;; Boston, MA 02111-1307, USA.

        最初の行はつぎの形式であるべきです。

          ;;; FILENAME --- DESCRIPTION

     この記述は1行で完全になるようにします。

        著作権表示のあとには、`;; HEADER-NAME:'で始まる
いくつかの"ヘッダコメント"（header comment）行が続きます。
HEADER-NAMEに使う可能性のある慣習の一覧を以下に示します。

    `Author'
          この行では、少なくともライブラリの主作者の
          氏名とネットワークアドレスを明記する。

          複数の作者がいる場合には、以下のように、
          `;;'とタブ文字で始めた継続行に その人達を列挙する。

               ;; Author: Ashwin Ram <Ram-Ashwin@cs.yale.edu>
               ;;      Dave Sill <de5@ornl.gov>
               ;;      Dave Brennan <brennan@hal.com>
               ;;      Eric Raymond <esr@snark.thyrsus.com>

    `Maintainer'
          この行には、作者行（`Author'）のように1人の氏名とアドレス、
          アドレスのみ、文字列`FSF'のいずれかを書く。
          保守者行（`Maintainer'）がない場合には、
          作者行の人達が保守していると仮定する。
          上の例は、保守者行が冗長であり、少々いんちきである。

          作者行（`Author'）と保守者行（`Maintainer'）の考えは、
          手作業で名前を探さずに『保守者にメイルを送る』ようなLisp関数を
          作れるようにするためである。

          ネットワークアドレスに加えて人の氏名も書く場合には、
          ネットワークアドレスを`<...>'で必ず囲むこと。

    `Created'
          この行は省略できるが、ファイルの作成日時を書く。
          歴史的な意味だけである。

    `Version'
          各Lispプログラムの版番号を記録しておきたい場合に、
          この行に版番号を書く。

    `Adapted-By'
          このヘッダ行では、（たとえば、スタイルの慣習に適合するように変更したなどの）
          インストールのためにライブラリを受理した人の名前を書く。

    `Keywords'
          この行には、ヘルプコマンド`finder-by-keyword'向けの
          キーワードを書く。
          意味のあるキーワードを理解するためにこのコマンドを試してほしい。

          この部分は重要である。
          人々が特定の話題で探して読者のパッケージをみつけるであろう。
          キーワードは空白やカンマで区切る。

        ほとんどのLispライブラリには、
`Author'と`Keywords'のヘッダコメント行が必要です。
残りのものは必要に応じて使います。
別の名前のヘッダ行があってもかまいません。
それらには標準的な意味はありませんが、害になることもありません。

ライブラリファイルの内容を分割するために形式を定めたコメントも使います。
それらを以下に示します。

    `;;; Commentary:'
          ライブラリの動作を説明する入門的なコメントを始める。
          著作権表示の直後にきて、 `Change
          Log'、`History'、`Code'のいずれかのコメント行で終る。
          このテキストはパッケージfinderが使うので、
          その文脈で意味があるようにすること。

    `;;; Documentation'
          `;;; Commentary:'のかわりに使っているファイルもあるが、 `;;;
          Commentary:'のほうが好ましい。

    `;;; Change Log:'
          （変更履歴をライブラリに収める場合の）
          ライブラリファイルに収めた変更記録情報を始める。
          Emacsで配布されるほとんどのLispファイルでは、
          変更履歴はファイル`ChangeLog'に収めてあり、
          ソースファイルには収めない。 それらのファイルには`;;; Change
          Log:'行はない。

    `;;; Code:'
          プログラムの実際のコードを始める。

    `;;; FILENAME ends here'
          これは"最終行"（footer line）であり、ファイルの末尾に現れる。
          その目的は、最終行が欠如していることでファイルが切り詰められていることが
          わかるようにするのである。



File: elisp-ja,  Node: GNU Emacs Internals,  Next: Standard Errors,  Prev: Tips,  Up: Top

Appendix C GNU Emacsの内部
*****************************

本章では、Lispライブラリをあらかじめロードした実用的なEmacsの実行形式の
ダンプ方法、メモリ領域の割り当て方、 Cプログラマに興味があるようなGNU
Emacsの内部について述べます。

     * Menu:

     * Building Emacs::      How to the dumped Emacs is made.
     * Pure Storage::        A kludge to make preloaded Lisp functions sharable.
     * Garbage Collection::  Reclaiming space for Lisp objects no longer used.
     * Memory Usage::        Info about total size of Lisp objects made so far.
     * Writing Emacs Primitives::   Writing C code for Emacs.
     * Object Internals::    Data formats of buffers, windows, processes.


File: elisp-ja,  Node: Building Emacs,  Next: Pure Storage,  Up: GNU Emacs Internals

C.1 Emacsの構築方法
========================

     本節では、Emacsの実行形式を構築する手順を説明します。
メイクファイルが自動的にこれらすべてを行うので、
Emacsを構築してインストールするために本節のことがらを
読者が知っている必要はありません。 本節の内容は、Emacsの保守者向けです。

        ディレクトリ`src'のCソースファイル群をコンパイルすると、
`temacs'と呼ばれる実行形式ファイルが作られます。
これは"裸のインピュアEmacs"（bare impure Emacs）とも呼びます。
これには、Emacs Lispインタープリタと入出力ルーティンが含まれますが、
編集コマンドは入っていません。

        コマンド`temacs -l loadup'で、
実用的なEmacsの実行形式を作るために`temacs'を使います。
これらの引数は、`temacs'に対して
ファイル`loadup.el'で指定したLispファイル群を評価するように指示します。
これらのファイルはEmacsの通常の編集環境を作り上げ、
その結果、Emacsは裸ではありませんがまだインピュアです。

        標準のLispファイル群をロードするにはかなり時間が必要です。
しかし、読者がEmacsを実行するたびにこれを行う必要はありません。
`temacs'は、必要なファイルをあらかじめロードした`emacs'という
実行形式プログラムとしてダンプできます。
`emacs'はファイル群をロードする必要がないので素早く起動します。
これが通常インストールされるEmacsの実行形式です。

        `emacs'を作るにはコマンド`temacs -batch -l loadup
dump'を使います。 ここでの`-batch'の目的は、
`temacs'が端末に関するデータを初期化しないようにするためです。
これにより、ダンプしたEmacsでは端末情報の表が空であることを保証できます。
引数`dump'は、`emacs'という名前の新たな実行形式を
ダンプするように`loadup.el'に指示します。

        ダンプできないオペレーティングシステムもあります。
そのようなシステムでは、Emacsを使うたびに コマンド`temacs -l
loadup'でEmacsを起動する必要があります。
これにはかなり時間がかかりますが、多くても1日に1回、あるいは、
ログアウトしなのであれば週に1回Emacsを起動する必要があるだけでしょうから、
余分な時間は重大問題にはならないでしょう。

        あらかじめロードしておく追加のファイルは、
それらをロードする`site-load.el'という名前のライブラリを
書くことで指定できます。 追加データのための領域を確保するために
`src/puresize.h'の`PURESIZE'の値を増やす必要があるかもしれません。
（十分な大きさになるまで20000ずつ増やして試すこと。）
しかし、マシンが速くなればなるほど、あらかじめロードしておくファイルを
追加することの利点は減少します。
最近のマシンでは、このようにする必要はないでしょう。

        `loadup.el'が`site-load.el'を読み終えると、
`Snarf-documentation'（*note Accessing Documentation::）を呼び出して、
基本関数やあらかじめロードした関数（および変数）の説明文字列を
それらの説明文字列を格納したファイル`etc/DOC'から探します。

        ダンプする直前に実行すべきList式を指定するには、
`site-init.el'という名前のライブラリにそれらのLisp式を入れておきます。
このファイルは、説明文字列を探し終えてから実行されます。

        関数定義や変数定義をあらかじめロードしたいときには、
それを行ってあとでEmacsを実行したときにそれらの説明文字列を
参照できるようにする方法が3つあります。

        * ファイル`etc/DOC'を作成するときに
          それらのファイルが走査されるようにしておき、
          `site-load.el'でそれらのファイルをロードする。

        * `site-init.el'でファイルをロードし、
          Emacsをインストールするときにそれらのファイルを
          Lispファイル向けのインストールディレクトリへコピーする。

        * それらの各ファイルでローカル変数として
          `byte-compile-dynamic-docstrings'の値に`nil'以外を指定し、
          `site-load.el'か`site-init.el'でそれらのファイルをロードする。
          （これには、それらの説明文字列がつねにEmacsの領域を占めてしまう
          欠点がある。）

無変更の普通のEmacsにユーザーが期待する機能を変更するようなものを
`site-load.el'や`site-init.el'に入れることは勧められません。
読者のサイトでは普通の機能に優先させるべきであると思うときには、
`default.el'でそれを行います。
そうすれば、ユーザーは好みに応じて読者が行った変更を無効にできます。
*Note Start-up Summary::。

      -- Function: dump-emacs to-file from-file
          この関数は、Emacsの現在の状態を
          実行形式ファイルTO-FILEへダンプする。
          FROM-FILE（これは普通は実行形式ファイル`temacs'）から
          シンボルを取り出す。

          すでにダンプしたEmacsでこの関数を使うときには、
          `-batch'を指定してEmacsを実行すること。


File: elisp-ja,  Node: Pure Storage,  Next: Garbage Collection,  Prev: Building Emacs,  Up: GNU Emacs Internals

C.2 ピュアメモリ
======================

     Emacs Lispでは、ユーザーが作成したLispオブジェクト向けに
2種類のメモリ、"普通メモリ"（normal storage）と "ピュアメモリ"（pure
storage）を使います。
普通メモリは、Emacsセッション中に新たに作成されるすべてのデータを置く場所です。
普通メモリに関する情報は以下の節を参照してください。
ピュアメモリは、あらかじめロードした標準Lispファイル群の特定のデータ、
つまり、Emacsの実行中にけっして変化しないデータを収めるために使います。

ピュアメモリは、`temacs'があらかじめロードする標準Lispライブラリを
ロードしている最中にのみ割り当てられます。
ファイル`emacs'では読み出し専用
（これができるオペレーティングシステムでは）と印が付けられ、
当該マシンで同時に実行されているすべてのEmacsのジョブで
メモリ領域を共有できるようにします。 ピュアメモリは拡張できません。
Emacsをコンパイルしたときに固定サイズが割り当てられ、
あらかじめロードするライブラリに対して十分な大きさがないと
`temacs'はクラッシュします。
その場合には、ファイル`src/puresize.h'のコンパイルパラメータ
`PURESIZE'を増やす必要があります。
あらかじめロードするライブラリを追加したり標準機能に機能を追加しなければ、
そのようなことは普通は起こらないはずです。

      -- Function: purecopy object
          この関数は、ピュアメモリ内にOBJECTをコピーしそれを返す。
          文字列のコピーでは、ピュアメモリ内に同じ文字の新たな文字列を単純に作る。
          ベクトルやコンスセルの内容は再帰的にコピーする。
          シンボルなどの他のオブジェクトはコピーせずに無変更でそれらを返す。
          マーカをコピーしようとするとエラーを通知する。

          この関数は、Emacsを構築してダンプするとき以外ではなにもしない。
          普通はファイル`emacs/lisp/loaddefs.el'でのみ呼び出されるが、
          あらかじめロードするとこれを呼び出すようなパッケージも少数だがある。

      -- Variable: pure-bytes-used
          この変数の値は、割り当て済みのピュアメモリのバイト数である。
          典型的には、ダンプしたEmacsでは
          この値は利用可能なピュアメモリの総量にとても近い。
          そうでない場合には、あらかじめロードしたライブラリが少ないのであろう。

      -- Variable: purify-flag
          この変数は、`defun'が関数定義をピュアメモリに
          コピーすべきかどうかを決定する。
          `nil'以外であると、関数定義をピュアメモリにコピーする。

          Emacsを構築中の初期段階ですべての基本的な関数をロード中には
          （これらの関数を共有してガベッジコレクションの対象にしないように）、
          このフラグは`t'である。
          実行形式としてEmacsをダンプするときには、
          ダンプ前後の実際の値には関係なくこの変数には`nil'を書く。

          実行中のEmacsでこのフラグを変更するべきではない。


File: elisp-ja,  Node: Garbage Collection,  Next: Memory Usage,  Prev: Pure Storage,  Up: GNU Emacs Internals

C.3 ガベッジコレクション
==================================

     プログラムがリストを作成したり、（ライブラリをロードするなどして）
ユーザーが新たに関数を定義すると、
それらのデータは普通メモリへ置かれます。
普通メモリが足りなくなると、Emacsはオペレーティングシステムに
1kバイトの倍数のブロックでメモリ割り当てを要求します。
各ブロックは1つの種類のLispオブジェクトに使いますから、
シンボル、コンスセル、マーカなどはメモリの異なるブロックに分離されます。
（ベクトル、長い文字列、バッファ、特定の編集向けデータ型などの
比較的大きなものは各オブジェクトごとに独立のブロックを割り当てるが、
短い文字列は8kバイトのブロックに詰め込む。）

        あるメモリ部分をしばらく使ってから、
（たとえば）バッファを削除したり
オブジェクトに対する最後の参照を削除するなどして
当該メモリを解放することはよくあることです。
Emacsには、このような放置されたメモリを回収する
"ガベッジコレクタ"（garbage collector）があります。
（この名前は伝統的だが、
『ガベッジリサイクル』のほうがこの機能を直観的に表すかもしれない。）

        ガベッジコレクタは、Lispプログラムから現時点で参照可能な
すべてのLispオブジェクトを探して印を付けることで動作します。
まず、すべてのシンボル、それらの値、それらに関連付けられた関数定義、
および、スタック上の任意のデータは参照可能であると仮定します。
参照可能なオブジェクトから間接的に辿れる任意のオブジェクトも
参照可能です。

        印付けが終ったときには、無印であるすべてのオブジェクトは
ゴミ（ガベッジ）です。 Lispプログラムやユーザーがなにをしようと、
無印のオブジェクトに辿り着く方法はないのでそれらを参照することは不可能です。
無印のオブジェクトを使っているものはいないので、
それらのメモリ領域は再利用できます。
ガベッジコレクタの2段目の動作（『掃く』（sweep））は、
無印のオブジェクトのメモリ領域を再利用できるようにすることです。

        掃き作業では、未使用のコンスセルを"自由リスト"（free
list）に入れて、 将来の割り当てに備えます。
シンボルやマーカについても同様です。
参照可能な文字列は8kバイトのブロックより小さな領域を占めるように詰め込み、
不要になった8kバイトのブロックは解放します。
ベクトル、バッファ、ウィンドウ、他の大きなオブジェクトは、
`malloc'や`free'を使って個別に割り当てたり解放します。

          Common Lispに関した注意：` ' 他のLispと異なり、GNU Emacs
          Lispでは、
          自由リストが空になってもガベッジコレクタを呼び出さない。
          そのかわりに、オペレーティングシステムにメモリ割り当てを単純に要求し、
          `gc-cons-threshold'バイトを使い尽くすまでは処理を継続する。

          つまり、ガベッジコレクタを明示的に呼び出した直後のLispプログラムの部分では、
          （プログラムのその部分で2度目にガベッジコレクタを呼び出すほど
          多くのメモリを使わないと仮定すれば）
          その部分を実行中にはガベッジコレクタが呼ばれないことを保証できるのである。

      -- コマンド: garbage-collect
          このコマンドはガベッジコレクタを実行し、
          使用中のメモリ量に関する情報を返す。
          （まえのガベッジコレクタの起動後に
          `gc-cons-threshold'バイト以上のLispデータを使うと
          自発的なガベッジコレクタの起動を引き起こす。）

          `garbage-collect'が返すリストにはつぎの情報が含まれる。

               ((USED-CONSES . FREE-CONSES)
                (USED-SYMS . FREE-SYMS)
                (USED-MISCS . FREE-MISCS)
                USED-STRING-CHARS
                USED-VECTOR-SLOTS
                (USED-FLOATS . FREE-FLOATS)
                (USED-INTERVALS . FREE-INTERVALS))

          例を示す。

               (garbage-collect)
                    => ((106886 . 13184) (9769 . 0)
                               (7731 . 4651) 347543 121628
                               (31 . 94) (1273 . 168))

          各要素の意味はつぎのとおりである。

         USED-CONSES
               使用中のコンスセルの個数。

         FREE-CONSES
               オペレーティングシステムから得たメモリであるが
               現在未使用なコンスセルの個数。

         USED-SYMS
               使用中のシンボルの個数。

         FREE-SYMS
               オペレーティングシステムから得たメモリであるが
               現在未使用なシンボルの個数。

         USED-MISCS
               その他の使用中のオブジェクトの個数。
               マーカ、オーバレイ、ユーザーに見えないある種のオブジェクトを含む。

         FREE-MISCS
               オペレーティングシステムから得たメモリであるが
               現在未使用なその他のオブジェクトの個数。

         USED-STRING-CHARS
               使用中の文字列の総文字数。

         USED-VECTOR-SLOTS
               存在するベクトルの要素の総個数。

         USED-FLOATS
               使用中の浮動小数点数の個数。

         FREE-FLOATS
               オペレーティングシステムから得たメモリであるが
               現在未使用な浮動小数点数の個数。

         USED-INTERVALS
               使用中のインターバルの個数。
               インターバルとはテキスト属性を表現するために使う内部データ構造である。

         FREE-INTERVALS
               オペレーティングシステムから得たメモリであるが
               現在未使用なインターバルの個数。

      -- User Option: garbage-collection-messages
          この変数が`nil'以外であると、
          Emacsはガベッジコレクションの始まりと終りにメッセージを表示する。
          デフォルト値は`nil'であり、そのようなメッセージを表示しない。

      -- User Option: gc-cons-threshold
          この変数の値は、ガベッジコレクションのあとで
          つぎにガベッジコレクションを起こすまでに
          Lispオブジェクトに割り当てるべきメモリバイト数である。
          コンスセルは8バイト、
          文字列は1文字1バイトと数バイトのオーバヘッドといった具合である。
          バッファの内容に割り当てたメモリ量は数えない。
          この閾値を越えてもただちにつぎのガベッジコレクションは起こらず、
          つぎにLispのエバリュエータが呼ばれときに起きる。

          最初の閾値は400,000である。
          より大きな値を指定すると、ガベッジコレクションの起動回数が少なくなる。
          ガベッジコレクションに費す時間を減少できるが、
          全体のメモリ使用量を増加させる。
          大量のLispデータを作成するようなプログラムを実行するときに設定する。

          10,000までの小さな値を指定すると、
          ガベッジコレクションの回数を増やせる。
          10,000未満の値が意味を持つのはつぎにガベッジコレクションが起きるまでである。
          `garbage-collect'は閾値を10,000に戻す。

`garbage-collect'が返す値は、データ型ごとのLispデータのメモリ使用量です。
対照的に、関数`memory-limit'は、
Emacsが現在使用中のメモリ総量に関する情報を与えます。

      -- Function: memory-limit
          この関数は、Emacsが最後に割り当てた最終バイトのアドレスを
          1024で割ったものを返す。
          値を1024で割るのは、Lispの整数に収めるためである。

          読者の操作がメモリ使用量にどのように影響するかを調べるのに使える。


File: elisp-ja,  Node: Memory Usage,  Next: Writing Emacs Primitives,  Prev: Garbage Collection,  Up: GNU Emacs Internals

C.4 メモリ使用量
======================

     これらの変数は、Emacsが割り当てたデータ型ごとのメモリ総量に関する
情報を与えます。
これらと`(garbage-collect)'が返す値との違いに注意してください。
`(garbage-collect)'の値は現存するオブジェクトを数えますが、
これらの変数は、すでに解放したオブジェクトを含めて
割り当てたオブジェクトの個数やサイズを数えます。

      -- Variable: cons-cells-consed
          このEmacsセッションでこれまでに割り当てたコンスセルの総数。

      -- Variable: floats-consed
          このEmacsセッションでこれまでに割り当てた浮動小数点数の総数。

      -- Variable: vector-cells-consed
          このEmacsセッションでこれまでに割り当てたベクトルセルの総数。

      -- Variable: symbols-consed
          このEmacsセッションでこれまでに割り当てたシンボルの総数。

      -- Variable: string-chars-consed
          このEmacsセッションでこれまでに割り当てた文字列の総文字数。

      -- Variable: misc-objects-consed
          このEmacsセッションでこれまでに割り当てたその他のオブジェクトの総数。
          マーカやオーバレイ、ユーザーに見えないある種のオブジェクトを含む。

      -- Variable: intervals-consed
          このEmacsセッションでこれまでに割り当てたインターバルの総数。


File: elisp-ja,  Node: Writing Emacs Primitives,  Next: Object Internals,  Prev: Memory Usage,  Up: GNU Emacs Internals

C.5 Emacs基本関数の書き方
=================================

     Lisp基本関数は、Cで実装したLisp関数です。
Lispから呼び出すためのCの関数とのインターフェイスの詳細は、
数個のCのマクロで処理しています。
新たにCのコードを書く方法をほんとうに理解する唯一の方法は、
ソースを読むことですが、ここではその一部を説明します。

        スペシャルフォームの例は、`eval.c'から引用した`or'の定義です。
（普通の関数も同じように見える。）

          DEFUN ("or", For, Sor, 0, UNEVALLED, 0,
            "Eval args until one of them yields non-nil; return that value.\n\
          The remaining args are not evalled at all.\n\
          If all args return nil, return nil.")
            (args)
               Lisp_Object args;
          {
            register Lisp_Object val;
            Lisp_Object args_left;
            struct gcpro gcpro1;

            if (NULL (args))
              return Qnil;

            args_left = args;
            GCPRO1 (args_left);

            do
              {
                val = Feval (Fcar (args_left));
                if (!NULL (val))
                  break;
                args_left = Fcdr (args_left);
              }
            while (!NULL (args_left));

            UNGCPRO;
            return val;
          }

        マクロ`DEFUN'の引数の詳しい説明から始めます。
その雛型はつぎのとおりです。

          DEFUN (LNAME, FNAME, SNAME, MIN, MAX, INTERACTIVE, DOC)

    LNAME
          関数名として定義するLispシンボルの名前である。
          上の例では、`or'である。

    FNAME
          この関数のCの関数としての名前である。
          この関数をCのコードから呼び出すときに使う名前である。
          慣習により、Lispでの名前のまえに`F'を付けるが、
          Lispでの名前のダッシュ（`-'）はすべて下線に置き換える。
          したがって、Cのコードからこの関数を呼び出すには、`For'を呼び出す。
          引数は`Lisp_Object'型である必要があることに注意してほしい。
          ファイル`lisp.h'では、
          `Lisp_Object'型の値を作成するためのさまざまなマクロや関数を宣言してある。

    SNAME
          これは、Lispでの関数を表現するsubrオブジェクト向けのデータを保持する
          構造体に使うCの変数名である。
          この構造体は、シンボルを作成しその定義としてsubrオブジェクトを保存する
          初期化ルーティンへLispのシンボル名を運ぶ構造体である。
          慣習により、この名前はつねに
          FNAMEの`F'を`S'に置き換えたものである。

    MIN
          関数が必要とする引数の最小の個数である。
          関数`or'は最小0個の引数を許す。

    MAX
          関数が許す引数の最大の個数に制限があるときの引数の最大の個数である。
          あるいは、評価していない引数を受け取るスペシャルフォームであることを
          表す`UNEVALLED'、
          評価済みの引数を何個でも受け取ることを表す`MANY'
          （`&rest'に等価）でもよい。
          `UNEVALLED'も`MANY'もマクロである。 MAXが数であるときには、
          それはMINより小さくなく、かつ、7より大きくないこと。

    INTERACTIVE
          この関数の対話指定であり、
          Lisp関数において`interactive'の引数に使う文字列である。
          `or'の場合には0（空ポインタ）であり、
          `or'は対話的に呼び出せないことを表す。
          値`""'は、対話的に呼び出されると
          この関数は引数を受け取らないことを表す。

    DOC
          説明文字列である。 各行末に`\n\'と書く必要があることを除けば、
          Lispで定義する関数の説明文字列のように書く。
          特に、最初の行は1つの文であること。

        マクロ`DEFUN'の呼び出しのあとには、
Cの関数に必須な引数名の並びを書き、引数に対する普通のCの宣言を続けます。
引数の最大個数が固定されている関数では、
各Lisp引数向けにCの引数宣言を書き、
それらをすべて`Lisp_Object'型にします。
Lisp関数に引数の個数に上限がないとき、
それを実装するCの関数は実際には2つの引数を受け取ります。
第1引数はLisp引数の個数であり、
第2引数はそれらの値を収めたブロックのアドレスです。
引数の型は`int'と`Lisp_Object *'です。

        関数`For'自身の内側では、
マクロ`GCPRO1'と`UNGCPRO'を使っていることに注意してください。
`GCPRO1'は、ガベッジコレクションから変数を『保護』するために使います。
つまり、ガベッジコレクタに対してこの変数を調べてその内容を
参照可能なオブジェクトとみなすように指示します。
`Feval'や`Feval'を直接／間接的に呼び出すものを呼ぶときには、
このようにする必要があります。
そのような場面では、再度参照する意図がある任意のLispオブジェクトは
保護する必要があります。
`UNGCPRO'は、この関数での変数の保護を取り消します。
これは明示的に行う必要があります。

ほとんどのデータ型では、少なくともそのオブジェクトへの1つのポインタを
保護すれば十分であり、そのオブジェクトに循環がない限り、
そのオブジェクトへのすべてのポインタは正しく保たれます。
文字列にはこれはあてはまりません。
ガベッジコレクタがそれらを移動するからです。
ガベッジコレクタが文字列を移動すると、
それに対する既知のポインタをすべて再配置し、
それ以外のポインタは不正になります。
したがって、ガベッジコレクタが動く可能性のある任意の部分では、
文字列へのすべてのポインタを保護する必要があります。

        マクロ`GCPRO1'は1つのローカル変数のみを保護します。
2つ保護したい場合にはかわりに`GCPRO2'を使います。
`GCPRO1'を繰り返しても働きません。
`GCPRO3'や`GCPRO4'のマクロもあります。

これらのマクロは`gcpro1'などのローカル変数を暗黙のうちに使いますが、
読者はこれらを型`struct gcpro'で明示的に宣言する必要があります。
したがって、`GCPRO2'を使う場合には、
`gcpro1'と`gcpro2'を宣言する必要があります。
残念ですが、ここではすべての詳細は説明しきれません。

Emacsをいったんダンプしたあとでも静的やグローバルな変数に書き込むのであれば、
それらの変数にはCの初期化構文を使ってはいけません。
初期化構文を伴うそれらの変数は、Emacsをダンプすると
（オペレーティングシステムによっては）その結果として
読み出し専用のメモリ領域に割り当てられます。 *Note Pure Storage::。

        関数の内側では静的変数を使わずに、
すべての静的変数はファイルのトップレベルに置きます。
オペレーティングシステムによっては
Emacsはキーワード`static'を空のマクロと定義することもあるので、
これは必要なことなのです。
（このような定義を使うのは、そのようなシステムは、
初期化構文があろうとなかろうと静的と宣言した変数を
ダンプ後には読み出し専用にしてしまうからである。）

        Cの関数を定義しただけではLisp基本関数としては使えません。
基本関数に対するLispシンボルを作成し、
その関数セルに適切なsubrオブジェクトを保存する必要があります。
そのコードはつぎのようになります。

          defsubr (&SUBR-STRUCTURE-NAME);

     ここで、SUBR-STRUCTURE-NAMEは`DEFUN'の第3引数に使った名前です。

すでにLisp基本関数が定義されているファイルに新たな基本関数を追加するときには、
（ファイルの末尾近くで）`syms_of_SOMETHING'という名前の関数を探し、
それに`defsubr'の呼び出しを追加します。
ファイルにこの関数がなかったり、新たなファイルを作成した場合には、
`syms_of_FILENAME'（たとえば`syms_of_myfile'）を追加します。
そして、ファイル`emacs.c'でこれらの関数を呼び出している箇所を探して、
そこに`syms_of_FILENAME'の呼び出しを追加します。

        関数`syms_of_FILENAME'は、
Lisp変数として見える任意のCの変数を定義する場所でもあります。
`DEFVAR_LISP'は、Lispから見える`Lisp_Object'型のCの変数を作ります。
`DEFVAR_INT'は、Lispからはつねに整数を値として見える
`int'型のCの変数を作ります。
`DEFVAR_BOOL'は、Lispからは`t'か`nil'を値として見える
`int'型のCの変数を作ります。

        ファイルだけに有効な`Lisp_Object'型のCの変数を定義した場合には、
つぎのようにして、`syms_of_FILENAME'の中で`staticpro'を
呼び出してその変数をガベッジコレクションから保護する必要があります。

          staticpro (&VARIABLE);

        つぎは、少々複雑な引数を取る別の関数の例です。
これは`window.c'から取ったもので、
マクロとLispオブジェクトを操作する関数の使い方を例示します。

          DEFUN ("coordinates-in-window-p", Fcoordinates_in_window_p,
            Scoordinates_in_window_p, 2, 2,
            "xSpecify coordinate pair: \nXExpression which evals to window: ",
            "Return non-nil if COORDINATES is in WINDOW.\n\
          COORDINATES is a cons of the form (X . Y), X and Y being distances\n\
          ...
          If they are on the border between WINDOW and its right sibling,\n\
             `vertical-line' is returned.")
            (coordinates, window)
               register Lisp_Object coordinates, window;
          {
            int x, y;

            CHECK_LIVE_WINDOW (window, 0);
            CHECK_CONS (coordinates, 1);
            x = XINT (Fcar (coordinates));
            y = XINT (Fcdr (coordinates));

            switch (coordinates_in_window (XWINDOW (window), &x, &y))
              {
              case 0:			/* NOT in window at all. */
                return Qnil;

              case 1:			/* In text part of window. */
                return Fcons (make_number (x), make_number (y));

              case 2:			/* In mode line of window. */
                return Qmode_line;

              case 3:			/* On right border of window.  */
                return Qvertical_line;

              default:
                abort ();
              }
          }

        Cのコードでは、関数がCで定義されていない限り、
関数をその名前で呼び出せないことに注意してください。
Lispで書かれた関数を呼び出す方法は、Lispの関数`funcall'を
内蔵する`Ffuncall'を使うことです。
Lisp関数`funcall'は任意個数の引数を受け付けるので、
Cでは2つの引数、Lispレベルの引数の個数と
それらの値を収めた一次元の配列を受け取ります。
Lispレベルの最初の引数は呼び出すべきLisp関数であり、
残りはそれに渡す引数です。 `Ffuncall'はエバリュエータを呼び出すので、
`Ffuncall'を呼び出す周りでは、
ガベッジコレクションからポインタを保護する必要があります。

        Cの関数、`call0'、`call1'、`call2'などは、
固定個数の引数を受け取るLisp関数を簡便に呼び出す手軽な方法です。
これらは`Ffuncall'を呼び出して動作します。

        `eval.c'は例を調べるにはとてもよいファイルです。
`lisp.h'には重要なマクロや関数の定義が入っています。


File: elisp-ja,  Node: Object Internals,  Prev: Writing Emacs Primitives,  Up: GNU Emacs Internals

C.6 オブジェクトの内部
===============================

     GNU Emacs Lispは、さまざまな型のデータを扱います。
実際のデータはヒープに保存されていて、
プログラムはポインタを介してそれらを参照します。
ほとんどの実装では、ポインタは32ビット長です。
Emacsをコンパイルしたオペレーティングシステムやマシンの種類に依存しますが、
オブジェクトのアドレスには28ビットを使い、
残りのビットはガベッジコレクションの印や
オブジェクトの型を表す識別子であるタグに使います。

        Lispオブジェクトはタグ付ポインタとして表現しますから、
任意のオブジェクトのLispデータ型を判定することが可能です。
Cのデータ`Lisp_Object'は、任意のデータ型のLispオブジェクトを保持できます。
普通の変数は`Lisp_Object'型ですから、
Lispの任意の値の任意の型を保持できます。
実際のデータ型は、実行中にのみ判定できます。
関数引数についても同じことがいえます。
特定の型の引数のみを受け付る関数が必要な場合には、 適切な述語（*note
Type Predicates::） を使って型を明示的に検査する必要があります。 

     * Menu:

     * Buffer Internals::    Components of a buffer structure.
     * Window Internals::    Components of a window structure.
     * Process Internals::   Components of a process structure.


File: elisp-ja,  Node: Buffer Internals,  Next: Window Internals,  Up: Object Internals

C.6.1 バッファの内部
---------------------------

バッファには、Lispプログラマが直接には参照できないフィールドがあります。
それらをCのコードで使っている名前で以下に述べます。
多くはLisp基本関数を介してLispプログラムから間接的に参照できます。

    `name'
          バッファ名はバッファを指名する文字列である。
          これは一意であることが保証される。 *note Buffer Names::。

    `save_modified'
          このフィールドは、バッファが最後に保存された時刻を整数で保持する。
          *note Buffer Modification::。

    `modtime'
          このフィールドは、訪問しているファイルの更新時刻を保持している。
          これはファイルを読み書きしたときに設定される。
          バッファをファイルに書き込むたびに、
          このフィールドとファイルの更新時刻を比較する。 *note Buffer
          Modification::。

    `auto_save_modified'
          このフィールドは、バッファを最後に自動保存した時刻を保持する。

    `last_window_start'
          このフィールドは、バッファをウィンドウに最後に表示したときの
          バッファの`window-start'（表示開始）位置を保持する。

    `undo_list'
          このフィールドは、バッファのアンドゥリストを保持する。 *note
          Undo::。

    `syntax_table_v'
          このフィールドは、バッファの構文テーブルを保持する。 *note
          Syntax Tables::。

    `downcase_table'
          このフィールドは、テキストを小文字に変換するための変換表を保持する。
          *note Case Tables::。

    `upcase_table'
          このフィールドは、テキストを大文字に変換するための変換表を保持する。
          *note Case Tables::。

    `case_canon_table'
          このフィールドは、大文字小文字を区別しない探索のために
          テキストを正則にするための変換表を保持する。 *note Case
          Tables::。

    `case_eqv_table'
          このフィールドは、大文字小文字を区別しない探索のための
          同値テーブルを保持する。 *note Case Tables::。

    `display_table'
          このフィールドは、バッファの表示テーブルを保持する。
          表示テーブルがなければ`nil'である。 *note Display Tables::。

    `markers'
          このフィールドは、バッファを現在指しているすべてのマーカの連鎖を
          保持している。
          バッファからテキストを削除したり、バッファのギャップが移動すると、
          これらのマーカのおのおのを検査し更新する必要がある。 *note
          Markers::。

    `backed_up'
          このフィールドは、このバッファで訪問しているファイルの
          バックアップファイルを作成したかどうかを表すフラグである。

    `mark'
          このフィールドは、バッファのマークを保持する。
          マークはマーカであり、そのためリスト`markers'にも含まれている。
          *note The Mark::。

    `mark_active'
          バッファのマークが活性であれば、
          このフィールドは`nil'以外である。

    `local_var_alist'
          このフィールドは、このバッファにバッファローカルな変数を記述した
          連想リストを保持している。
          バッファオブジェクトに特別な場所がある組み込みのバッファローカルな変数は
          含まない。 （それらはこの一覧では省いた。） *note
          Buffer-Local Variables::。

    `base_buffer'
          このフィールドは、（間接バッファであれば）バッファの基底バッファ、あるいは、
          `nil'を保持する。

    `keymap'
          このフィールドは、バッファのローカルキーマップを保持する。
          *note Keymaps::。

    `overlay_center'
          このフィールドは、現在のオーバレイの中央位置を保持する。
          *note Overlays::。

    `overlays_before'
          このフィールドは、バッファの現在のオーバレイの中央位置か
          それよりまえで終るこのバッファのオーバレイのリストを保持している。
          それらは終了位置が減る順に並んでいる。

    `overlays_after'
          このフィールドは、バッファの現在のオーバレイの中央位置より
          うしろで終るこのバッファのオーバレイのリストを保持している。
          それらは開始位置が増える順に並んでいる。

    `enable_multibyte_characters'
          このフィールドは、`enable-multibyte-characters'の
          バッファローカルな値を保持しており、 `t'か`nil'である。


File: elisp-ja,  Node: Window Internals,  Next: Process Internals,  Prev: Buffer Internals,  Up: Object Internals

C.6.2 ウィンドウの内部
------------------------------

     ウィンドウには以下のような参照可能なフィールドがあります。

    `frame'
          このウィンドウがあるフレーム。

    `mini_p'
          このウィンドウがミニバッファ用ウィンドウであれば`nil'以外。

    `buffer'
          このウィンドウで表示しているバッファ。
          これはウィンドウの生存期間中にしばしば変化する。

    `dedicated'
          このウィンドウがそのバッファ専用であると`nil'以外である。

    `pointm'
          これは、このウィンドウが選択されていたときの
          カレントバッファのポイント値である。
          選択されていないときには、まえの値が保持される。

    `start'
          ウィンドウに表示する最初の文字のバッファ内位置である。

    `force_start'
          このフラグが`nil'以外であると、
          Lispプログラムが明示的にウィンドウをスクロールしたことを表す。
          ポイントがスクリーンからはみ出しているとつぎの再表示の動作に影響する。
          ポイントの周りのテキストをウィンドウに表示するようにスクロールするかわりに、
          スクリーン上に位置するようにポイントを移動する。

    `last_modified'
          このウィンドウの最後の再表示が完了した時点での
          ウィンドウのバッファのフィールド`modified'である。

    `last_point'
          このウィンドウの最後の再表示が完了した時点での
          バッファのポイント値である。

    `left'
          コラム数で数えたウィンドウの左端である。
          （スクリーンの最左端コラムは0コラム目。）

    `top'
          行数で数えたウィンドウの上端である。
          （スクリーンの最上端行は0行目。）

    `height'
          行数で数えたウィンドウの高さ。

    `width'
          コラム数で数えたウィンドウの幅。

    `next'
          これは、兄弟関係でつぎのウィンドウである。
          兄弟関係で最右端か最下端であるウィンドウでは`nil'である。

    `prev'
          これは、兄弟関係でまえのウィンドウである。
          兄弟関係で最左端か最上端であるウィンドウでは`nil'である。

    `parent'
          内部的にはEmacsはウィンドウを木に並べている。
          兄弟関係の各グループには親ウィンドウがあり、
          親ウィンドウの領域はその兄弟すべての領域を含む。
          このフィールドはウィンドウの親を指す。

          親ウィンドウはバッファを表示せず、
          その子ウィンドウの形以外には、表示に関してはなんの役割も持たない。
          Emacs Lispプログラムでは親ウィンドウを参照せず、
          バッファを実際に表示する木の葉にあるウィンドウを操作する。

    `hscroll'
          これは、ウィンドウの表示を水平方向左向きにスクロールしているコラム数。
          これは普通は0である。

    `use_time'
          これは、このウィンドウが選択されていた最後の時刻。
          関数`get-lru-window'がこのフィールドを使う。

    `display_table'
          ウィンドウの表示テーブル。 指定されていなければ`nil'である。

    `update_mode_line'
          `nil'以外であると、ウィンドウのモード行を更新する必要があることを表す。

    `base_line_number'
          バッファの特定の位置の行番号である。 あるいは`nil'。
          これは、モード行にポイント位置の行番号を表示するために使われる。

    `base_line_pos'
          行番号が既知のバッファ内位置。 既知でなければ`nil'である。

    `region_showing'
          このウィンドウでリージョン（やその一部）を強調表示しているときには、
          このフィールドは、当該リージョンの一方の端を表すマーク位置を保持している。
          さもなければこのフィールドは`nil'である。


File: elisp-ja,  Node: Process Internals,  Prev: Window Internals,  Up: Object Internals

C.6.3 プロセスの内部
---------------------------

     プロセスにはつぎのようなフィールドがあります。

    `name'
          プロセスの名前である文字列。

    `command'
          このプロセスを開始するために使用されたコマンド引数から成るリスト。

    `filter'
          バッファのかわりにプロセスからの出力を受け取るために使用する関数。
          あるいは`nil'。

    `sentinel'
          プロセスがシグナルを受け取るたびに呼ばれる関数。
          あるいは`nil'。

    `buffer'
          プロセスに対応付けられたバッファ。

    `pid'
          UNIXのプロセスIDである整数。

    `childp'
          フラグであり、これが実際に子プロセスであると`nil'以外である。
          ネットワーク接続であると`nil'以外。

    `mark'
          プロセスからの最後の出力をバッファに挿入した箇所の末尾位置を表すマーカ。
          これはしばしばバッファの末尾であるが、つねにではない。

    `kill_without_query'
          これが`nil'以外であると、このプロセスが動作中にEmacsを終了しようとしても
          プロセスをキルすることに関して確認を求めない。

    `raw_status_low'
    `raw_status_high'
          これらの2つのフィールドは、
          システムコール`wait'で返されるプロセス状態の各16ビットを記録する。

    `status'
          `process-status'が返すべきプロセス状態。

    `tick'
    `update_tick'
          この2つのフィールドが等しくないと、
          番兵を実行するかプロセスのバッファにメッセージを挿入するかして、
          プロセスの状態変化を報告する必要がある。

    `pty_flag'
          サブプロセスとの通信にPTY（疑似端末）を
          使用している場合には`nil'以外であり、
          パイプを使用している場合には`nil'である。

    `infd'
          このプロセスからの入力用ファイル記述子。

    `outfd'
          このプロセスへの出力用ファイル記述子。

    `subtty'
          サブプロセスが使用している端末のファイル記述子。
          （これを記録する必要のないシステムもあり、その場合には値は`nil'である。）

    `tty_name'
          サブプロセスが使用している端末の名前。
          パイプを使用しているときには`nil'である。



File: elisp-ja,  Node: Standard Errors,  Next: Standard Buffer-Local Variables,  Prev: GNU Emacs Internals,  Up: Top

Appendix D 標準のエラー
*****************************

以下は、概念ごとにまとめた標準Emacsのエラーシンボルの完全な一覧です。
一覧には、各シンボルの（シンボルの属性`error-message'にある）メッセージと
そのようなエラーが生起する場面の記述への相互参照を示しました。

        各エラーシンボルには、属性`error-conditions'があり、
これはシンボルのリストです。
通常、このリストは、エラーシンボルそのものとシンボル`error'を含みます。
しばしば、追加のシンボルも含みます。
それらは中間的な分類種別であり、`error'より細分化したものですが、
エラーシンボルそのものよりは大分類です。
たとえば、ファイル参照に関するすべてのエラーには、
条件`file-error'が入っています。
以下で、特定のエラーシンボルにおいて追加のシンボルを言及していないときには、
そのエラーには追加シンボルがないことを意味します。

        特別な例外ですが、エラーシンボル`quit'には
条件`error'がありません。
これは、中断（quit）をエラーとみなさないからです。

        エラーが生起する場面とその処理方法については、*Note Errors::。

    `ÂÃÃÃ'
          Ɩŭň; ŏǅ。

    `error'
          `"error"'
          *note Errors::。

    `quit'
          `"Quit"'
          *note Quitting::。

    `args-out-of-range'
          `"Args out of range"'
          *note Sequences Arrays Vectors::。

    `arith-error'
          `"Arithmetic error"'
          *note Numbers::の`/'と`%'を参照。

    `beginning-of-buffer'
          `"Beginning of buffer"'
          *note Motion::。

    `buffer-read-only'
          `"Buffer is read-only"'
          *note Read Only Buffers::。

    `cyclic-function-indirection'
          `"Symbol's chain of function indirections\
          contains a loop"'
          *note Function Indirection::。

    `end-of-buffer'
          `"End of buffer"'
          *note Motion::。

    `end-of-file'
          `"End of file during parsing"'
          これはファイル入出力ではなくLispリーダに関連することなので、
          `file-error'ではないことに注意。
          *note Input Functions::。

    `file-already-exists'
          これは`file-error'。
          *note Writing to Files::。

    `file-date-error'
          これは`file-error'の小分類。 `copy-file'で、
          出力ファイルの最終更新日付の設定に失敗すると生起する。
          *note Changing Files::。

    `file-error'
          このエラーとその小分類にはエラー文字列がない。
          エラー条件`file-error'があると、
          データ項目のみからエラーメッセージを作るからである。
          *note Files::。

    `file-locked'
          これは`file-error'。
          *note File Locks::。

    `file-supersession'
          これは`file-error'。
          *note Modification Time::。

    `invalid-function'
          `"Invalid function"'
          *note Classifying Lists::。

    `invalid-read-syntax'
          `"Invalid read syntax"'
          *note Input Functions::。

    `invalid-regexp'
          `"Invalid regexp"'
          *note Regular Expressions::。

    `mark-inactive'
          `"Mark inactive"'
          *note The Mark::。

    `no-catch'
          `"No catch for tag"'
          *note Catch and Throw::。

    `scan-error'
          `"Scan error"'
          これは、構文解析関数が不正な構文や対応していない括弧を
          みつけると生起する。
          *note List Motion::、および、*note Parsing Expressions::。

    `search-failed'
          `"Search failed"'
          *note Searching and Matching::。

    `setting-constant'
          `"Attempt to set a constant symbol"'
          シンボル`nil'や`t'、および、
          `:'で始まる任意のシンボルは変更できない。
          *note Variables that Never Change: Constant Variables.。

    `undefined-color'
          `"Undefined color"'
          *note Color Names::。

    `void-function'
          `"Symbol's function definition is void"'
          *note Function Cells::。

    `void-variable'
          `"Symbol's value as variable is void"'
          *note Accessing Variables::。

    `wrong-number-of-arguments'
          `"Wrong number of arguments"'
          *note Classifying Lists::。

    `wrong-type-argument'
          `"Wrong type argument"'
          *note Type Predicates::。

        `arith-error'の特別な場合に分類された以下の種類のエラーは、
数学関数を不正に使ったときに特定のシステムで生起します。

    `domain-error'
          `"Arithmetic domain error"'
          *note Math Functions::。

    `overflow-error'
          `"Arithmetic overflow error"'
          *note Math Functions::。

    `range-error'
          `"Arithmetic range error"'
          *note Math Functions::。

    `singularity-error'
          `"Arithmetic singularity error"'
          *note Math Functions::。

    `underflow-error'
          `"Arithmetic underflow error"'
          *note Math Functions::。



File: elisp-ja,  Node: Standard Buffer-Local Variables,  Next: Standard Keymaps,  Prev: Standard Errors,  Up: Top

Appendix E バッファローカルな変数
********************************************

     以下は、各バッファにおいて、自動的にバッファローカルになる
Emacsの汎用目的の変数一覧です。
ほとんどのものは、設定したときにだけバッファローカルになります。
これらのごく少数は、各バッファでつねにローカルになります。
多くのLispパッケージで内部使用向けにこのような変数を定義しますが、
それらすべてをここに示すことはしていません。

    `abbrev-mode'
          *note Abbrevs::。

    `auto-fill-function'
          *note Auto Filling::。

    `buffer-auto-save-file-name'
          *note Auto-Saving::。

    `buffer-backed-up'
          *note Backup Files::。

    `buffer-display-count'
          *note Displaying Buffers::。

    `buffer-display-table'
          *note Display Tables::。

    `buffer-file-format'
          *note Format Conversion::。

    `buffer-file-name'
          *note Buffer File Name::。

    `buffer-file-number'
          *note Buffer File Name::。

    `buffer-file-truename'
          *note Buffer File Name::。

    `buffer-file-type'
          *note MS-DOS File Types::。

    `buffer-invisibility-spec'
          *note Invisible Text::。

    `buffer-offer-save'
          *note Saving Buffers::。

    `buffer-read-only'
          *note Read Only Buffers::。

    `buffer-saved-size'
          *note Point::。

    `buffer-undo-list'
          *note Undo::。

    `cache-long-line-scans'
          *note Text Lines::。

    `case-fold-search'
          *note Searching and Case::。

    `ctl-arrow'
          *note Usual Display::。

    `comment-column'
          *note コメントの操作: (emacs)Comments.。

    `default-directory'
          *note System Environment::。

    `defun-prompt-regexp'
          *note List Motion::。

    `enable-multibyte-characters'
          *note Non-ASCII Characters::。

    `fill-column'
          *note Auto Filling::。

    `goal-column'
          *note ポイント位置を移動する: (emacs)Moving Point.。

    `left-margin'
          *note Indentation::。

    `local-abbrev-table'
          *note Abbrevs::。

    `local-write-file-hooks'
          *note Saving Buffers::。

    `major-mode'
          *note Mode Help::。

    `mark-active'
          *note The Mark::。

    `mark-ring'
          *note The Mark::。

    `minor-modes'
          *note Minor Modes::。

    `mode-line-buffer-identification'
          *note Mode Line Variables::。

    `mode-line-format'
          *note Mode Line Data::。

    `mode-line-modified'
          *note Mode Line Variables::。

    `mode-line-process'
          *note Mode Line Variables::。

    `mode-name'
          *note Mode Line Variables::。

    `overwrite-mode'
          *note Insertion::。

    `paragraph-separate'
          *note Standard Regexps::。

    `paragraph-start'
          *note Standard Regexps::。

    `point-before-scroll'
          マウスコマンドとスクロールコマンドの通信に使う。

    `require-final-newline'
          *note Insertion::。

    `selective-display'
          *note Selective Display::。

    `selective-display-ellipses'
          *note Selective Display::。

    `tab-width'
          *note Usual Display::。

    `truncate-lines'
          *note Truncation::。

    `vc-mode'
          *note Mode Line Variables::。



File: elisp-ja,  Node: Standard Keymaps,  Next: Standard Hooks,  Prev: Standard Buffer-Local Variables,  Up: Top

Appendix F 標準のキーマップ
***********************************

     以下のシンボルは、さまざまなキーマップの名前として使われています。
これらの一部はEmacsの始動時に存在しますが、
他のものは関連するモードを使ったときにのみロードされます。
以下は、完全な一覧ではありません。

これらのマップのほとんどすべては、ローカルマップとして使われます。
もちろん、存在するモードの中で、グローバルキーマップを変更するのは
Vipモードと端末（terminal）モードだけです。

    `Buffer-menu-mode-map'
          バッファメニュー（buffer-menu）モードで使う完全なキーマップ。

    `c-mode-map'
          Cモードで使う疎なキーマップ。

    `command-history-map'
          コマンド履歴（command-history）モードで使う完全なキーマップ。

    `ctl-x-4-map'
          プレフィックス`C-x 4'の下位コマンド用の疎なキーマップ。

    `ctl-x-5-map'
          プレフィックス`C-x 5'の下位コマンド用の疎なキーマップ。

    `ctl-x-map'
          `C-x'コマンド用の完全なキーマップ。

    `debugger-mode-map'
          デバッガモードで使う完全なキーマップ。

    `dired-mode-map'
          `dired-mode'バッファで使う完全なキーマップ。

    `edit-abbrevs-map'
          `edit-abbrevs'で使う疎なキーマップ。

    `edit-tab-stops-map'
          `edit-tab-stops'で使う疎なキーマップ。

    `electric-buffer-menu-mode-map'
          エレクトリックバッファメニュー（electric-buffer-menu）モードで
          使う完全なキーマップ。

    `electric-history-map'
          エレクトリックコマンド履歴（electric-command-history）モードで
          使う完全なキーマップ。

    `emacs-lisp-mode-map'
          emacs-lispモードで使う疎なキーマップ。

    `facemenu-menu'
          テキスト属性メニューを表示するキーマップ。

    `facemenu-background-menu'
          テキスト属性メニューのBackground
          Colorサブメニューを表示するキーマップ。

    `facemenu-face-menu'
          テキスト属性メニューのFaceサブメニューを表示するキーマップ。

    `facemenu-foreground-menu'
          テキスト属性メニューのForeground Colorを表示するキーマップ。

    `facemenu-indentation-menu'
          テキスト属性メニューのIndentaionサブメニューを表示するキーマップ。

    `facemenu-justification-menu'
          テキスト属性メニューのJustificationサブメニューを表示するキーマップ。

    `facemenu-special-menu'
          テキスト属性メニューのSpecial Propsサブメニューを
          表示するキーマップ。

    `function-key-map'
          キーパッドやファンクションキーの変換用のキーマップ。
          それらがなければ、この変数は空の疎なキーマップである。 *note
          Translating Input::。

    `fundamental-mode-map'
          基本（fundamental）モード用のローカルキーマップ。
          これは空であり、変更すべきでない。

    `Helper-help-map'
          ヘルプユーティリティパッケージが使う完全なキーマップ。
          この変数の値セルと関数セルには同一のキーマップが入っている。

    `Info-edit-map'
          infoの`e'コマンドで使う疎なキーマップ。

    `Info-mode-map'
          infoコマンドを収めた疎なキーマップ。

    `isearch-mode-map'
          インクリメンタルサーチ中に打鍵できる文字を定義するキーマップ。

    `key-translation-map'
          キー変換用のキーマップ。 これは、`function-key-map'と違って、
          もとのキーバインディングに優先する。 *note Translating
          Input::。

    `lisp-interaction-mode-map'
          Lispモードで使う疎なキーマップ。

    `lisp-mode-map'
          Lispモードで使う疎なキーマップ。

    `menu-bar-edit-menu'
          メニューバーのEditメニューを表示するキーマップ。

    `menu-bar-files-menu'
          メニューバーのFilesメニューを表示するキーマップ。

    `menu-bar-help-menu'
          メニューバーのHelpメニューを表示するキーマップ。

    `menu-bar-mule-menu'
          メニューバーのMuleメニューを表示するキーマップ。

    `menu-bar-search-menu'
          メニューバーのSearchメニューを表示するキーマップ。

    `menu-bar-tools-menu'
          メニューバーのToolsメニューを表示するキーマップ。

    `mode-specific-map'
          `C-c'に続く文字用のキーマップ。
          これはグローバルマップの中にあることに注意。
          このマップは実際にはモード固有ではない。
          プレフィックスキー`C-c'の主要な使い方を記述する `C-h
          b'（`display-bindings'）において、
          ユーザーに有益なようにこの名前を選んだ。

    `occur-mode-map'
          出現（occur）モードで使うローカルキーマップ。

    `query-replace-map'
          `query-replace'やその関連コマンドの応答用に使うキーマップ。
          `y-or-n-p'や`map-y-or-n-p'もこれを使う。
          このマップを使う関数は、プレフィックスキーを使わない。
          一度に1つのイベントを探す。

    `text-mode-map'
          テキスト（text）モードで使う疎なキーマップ。

    `view-mode-map'
          閲覧（view）モードで使う完全なキーマップ。



File: elisp-ja,  Node: Standard Hooks,  Next: Index,  Prev: Standard Keymaps,  Up: Top

Appendix G 標準のフック
*****************************

     以下は、Emacsから適切な場面に呼び出される関数を
読者が指定するためのフック変数の一覧です。

        これらのほとんどの変数の名前は`-hook'で終ります。
これらは、`run-hooks'で実行される "ノーマルフック"（normal hooks）です。
そのようなフックの値は関数のリストです。
関数は引数なしで呼び出され、その値は完全に無視します。
このようなフックに新たな関数を追加する推奨方法は、
`add-hook'を呼び出すことです。 フックの使い方について詳しくは、*Note
Hooks::。

        `-hooks'や`-functions'で終る名前の変数は、
普通、"アブノーマルフック"（abnormal hooks）です。
それらの値も関数のリストですが、
それらの関数は特別な方法（引数を渡したり、戻り値を使用したり）で
呼び出されます。 これらの変数のごく少数は実際にはノーマルフックですが、
ノーマルフックの名前を`-hook'で終えるという慣行を
確立するまえに命名したものです。

        `-function'で終る名前の変数では、その値は1つの関数です。
（Emacsの旧版では、ノーマルフックでないにも関わらず、
`-hook'で終る名前の変数があった。
しかしながら、それらはすべて改名した。）

    `activate-mark-hook'

    `after-change-function'

    `after-change-functions'

    `after-init-hook'

    `after-insert-file-functions'

    `after-make-frame-hook'

    `after-revert-hook'

    `after-save-hook'

    `auto-fill-function'

    `auto-save-hook'

    `before-change-function'

    `before-change-functions'

    `before-init-hook'

    `before-make-frame-hook'

    `before-revert-hook'

    `blink-paren-function'

    `buffer-access-fontify-functions'

    `c-mode-hook'

    `calendar-load-hook'

    `change-major-mode-hook'

    `command-history-hook'

    `command-line-functions'

    `comment-indent-function'

    `deactivate-mark-hook'

    `diary-display-hook'

    `diary-hook'

    `dired-mode-hook'

    `disabled-command-hook'

    `echo-area-clear-hook'

    `edit-picture-hook'

    `electric-buffer-menu-mode-hook'

    `electric-command-history-hook'

    `electric-help-mode-hook'

    `emacs-lisp-mode-hook'

    `find-file-hooks'

    `find-file-not-found-hooks'

    `first-change-hook'

    `fortran-comment-hook'

    `fortran-mode-hook'

    `ftp-setup-write-file-hooks'

    `ftp-write-file-hook'

    `indent-mim-hook'

    `initial-calendar-window-hook'

    `kill-buffer-hook'

    `kill-buffer-query-functions'

    `kill-emacs-hook'

    `kill-emacs-query-functions'

    `LaTeX-mode-hook'

    `ledit-mode-hook'

    `lisp-indent-function'

    `lisp-interaction-mode-hook'

    `lisp-mode-hook'

    `list-diary-entries-hook'

    `local-write-file-hooks'

    `m2-mode-hook'

    `mail-mode-hook'

    `mail-setup-hook'

    `mark-diary-entries-hook'

    `medit-mode-hook'

    `menu-bar-update-hook'

    `minibuffer-setup-hook'

    `minibuffer-exit-hook'

    `news-mode-hook'

    `news-reply-mode-hook'

    `news-setup-hook'

    `nongregorian-diary-listing-hook'

    `nongregorian-diary-marking-hook'

    `nroff-mode-hook'

    `outline-mode-hook'

    `plain-TeX-mode-hook'

    `post-command-hook'

    `pre-abbrev-expand-hook'

    `pre-command-hook'

    `print-diary-entries-hook'

    `prolog-mode-hook'

    `protect-innocence-hook'

    `redisplay-end-trigger-functions'

    `rmail-edit-mode-hook'

    `rmail-mode-hook'

    `rmail-summary-mode-hook'

    `scheme-indent-hook'

    `scheme-mode-hook'

    `scribe-mode-hook'

    `shell-mode-hook'

    `shell-set-directory-error-hook'

    `suspend-hook'

    `suspend-resume-hook'

    `temp-buffer-show-function'

    `term-setup-hook'

    `terminal-mode-hook'

    `terminal-mode-break-hook'

    `TeX-mode-hook'

    `text-mode-hook'

    `today-visible-calendar-hook'

    `today-invisible-calendar-hook'

    `vi-mode-hook'

    `view-hook'

    `window-configuration-change-hook'

    `window-scroll-functions'

    `window-setup-hook'

    `window-size-change-functions'

    `write-contents-hooks'

    `write-file-hooks'

    `write-region-annotate-functions'


File: elisp-ja,  Node: Index,  Next: New Symbols,  Prev: Standard Hooks,  Up: Top

Index
*****

     All variables, functions, keys, programs, files, and concepts are
in this one index.

        All names and concepts are permuted, so they appear several
times, one for each permutation of the parts of the name.  For example,
`function-name' would appear as function-name and name, function-.

      [index ]
     * Menu:

     * "、文字列:                             Syntax for Strings.
                                                              (line   6)
* "、表示:                               Output Functions.    (line   9)
* #$:                                    Docs and Compilation.
                                                              (line  53)
* #@COUNT:                               Docs and Compilation.
                                                              (line  53)
* $、正規表現:                           Syntax of Regexps.   (line 148)
* $、画面表示:                           Truncation.          (line   6)
* %:                                     Arithmetic Operations.
                                                              (line 111)
* %、書式付け:                           Formatting Strings.  (line  23)
* &define （edebug）:                    Specification List.  (line  82)
* &not （edebug）:                       Specification List.  (line  77)
* &optional:                             Argument List.       (line  18)
* &optional （edebug）:                  Specification List.  (line  51)
* &or （edebug）:                        Specification List.  (line  69)
* &rest:                                 Argument List.       (line  18)
* &rest （edebug）:                      Specification List.  (line  60)
* &、置換:                               Replacing Match.     (line  44)
* 'によるクォート:                       Quoting.             (line  15)
* (...)、リスト:                         Cons Cell Type.      (line  82)
* (、正規表現:                           Syntax of Regexps.   (line 199)
* )、正規表現:                           Syntax of Regexps.   (line 199)
* *:                                     Arithmetic Operations.
                                                              (line  65)
* *scratch*:                             Auto Major Mode.     (line 101)
* *、対話指定:                           Using Interactive.   (line  77)
* *、正規表現:                           Syntax of Regexps.   (line  34)
* +:                                     Arithmetic Operations.
                                                              (line  40)
* +、正規表現:                           Syntax of Regexps.   (line  67)
* , （バッククォート）:                  Backquote.           (line  20)
* ,@ （バッククォートとの組み合わせ）:   Backquote.           (line  39)
* -:                                     Arithmetic Operations.
                                                              (line  50)
* .emacs:                                Init File.           (line   6)
* .emacsのカスタマイズ:                  Major Mode Conventions.
                                                              (line 153)
* .、リスト:                             Dotted Pair Notation.
                                                              (line   6)
* .、正規表現:                           Syntax of Regexps.   (line  29)
* /:                                     Arithmetic Operations.
                                                              (line  76)
* /=:                                    Comparison of Numbers.
                                                              (line  53)
* 1+:                                    Arithmetic Operations.
                                                              (line  18)
* 1-:                                    Arithmetic Operations.
                                                              (line  37)
* 2C-mode-map:                           Prefix Keys.         (line  44)
* 2の補数:                               Integer Basics.      (line  37)
* 8進数字文字入力:                       Quoted Character Input.
                                                              (line  12)
* 8進数字文字定数:                       Character Type.      (line 127)
* ;、コメント内:                         Comments.            (line   6)
* <:                                     Comparison of Numbers.
                                                              (line  57)
* <=:                                    Comparison of Numbers.
                                                              (line  61)
* <ESC>:                                 Functions for Key Lookup.
                                                              (line  98)
* <SPC>、ミニバッファ:                   Text from Minibuffer.
                                                              (line 173)
* <TAB>、ミニバッファ:                   Text from Minibuffer.
                                                              (line 176)
* =:                                     Comparison of Numbers.
                                                              (line  49)
* >:                                     Comparison of Numbers.
                                                              (line  65)
* >=:                                    Comparison of Numbers.
                                                              (line  69)
* ?、ミニバッファ:                       Text from Minibuffer.
                                                              (line 179)
* ?、文字定数:                           Character Type.      (line 127)
* ?、正規表現:                           Syntax of Regexps.   (line  74)
* @、対話指定:                           Using Interactive.   (line  80)
* [...]（edebug）:                       Specification List.  (line 117)
* [、正規表現:                           Syntax of Regexps.   (line  80)
* \'、正規表現:                          Syntax of Regexps.   (line 270)
* \<、正規表現:                          Syntax of Regexps.   (line 290)
* \=、正規表現:                          Syntax of Regexps.   (line 274)
* \>、正規表現:                          Syntax of Regexps.   (line 294)
* \`、正規表現:                          Syntax of Regexps.   (line 266)
* \a:                                    Character Type.      (line  40)
* \b:                                    Character Type.      (line  40)
* \B、正規表現:                          Syntax of Regexps.   (line 287)
* \b、正規表現:                          Syntax of Regexps.   (line 278)
* \e:                                    Character Type.      (line  40)
* \f:                                    Character Type.      (line  40)
* \n:                                    Character Type.      (line  40)
* \N、置換:                              Replacing Match.     (line  47)
* \n、表示:                              Output Variables.    (line  11)
* \r:                                    Character Type.      (line  40)
* \s、正規表現:                          Syntax of Regexps.   (line 250)
* \S、正規表現:                          Syntax of Regexps.   (line 259)
* \t:                                    Character Type.      (line  40)
* \v:                                    Character Type.      (line  40)
* \w、正規表現:                          Syntax of Regexps.   (line 242)
* \W、正規表現:                          Syntax of Regexps.   (line 247)
* \、シンボル内:                         Symbol Type.         (line  20)
* \、文字列:                             Syntax for Strings.  (line   6)
* \、文字定数:                           Character Type.      (line 127)
* \、正規表現:                           Syntax of Regexps.   (line 155)
* \、画面表示:                           Truncation.          (line   6)
* \、置換:                               Replacing Match.     (line  52)
* \、表示:                               Output Functions.    (line   9)
* ]、正規表現:                           Syntax of Regexps.   (line  80)
* ^、正規表現:                           Syntax of Regexps.   (line 125)
* `:                                     Backquote.           (line   6)
* ` （リストの置換）:                    Backquote.           (line   6)
* abbrev-all-caps:                       Abbrev Expansion.    (line  40)
* abbrev-expansion:                      Abbrev Expansion.    (line  20)
* abbrev-file-name:                      Abbrev Files.        (line  17)
* abbrev-mode:                           Abbrev Mode.         (line  10)
* abbrev-prefix-mark:                    Abbrev Expansion.    (line  34)
* abbrev-start-location:                 Abbrev Expansion.    (line  46)
* abbrev-start-location-buffer:          Abbrev Expansion.    (line  54)
* abbrev-symbol:                         Abbrev Expansion.    (line  12)
* abbrev-table-name-list:                Abbrev Tables.       (line  26)
* abbreviate-file-name:                  Directory Names.     (line  70)
* abbrevs-changed:                       Abbrev Files.        (line  34)
* abort-recursive-edit:                  Recursive Editing.   (line  90)
* abs:                                   Comparison of Numbers.
                                                              (line  89)
* accept-process-output:                 Accepting Output.    (line  13)
* access-file:                           Testing Accessibility.
                                                              (line  69)
* accessible-keymaps:                    Scanning Keymaps.    (line  10)
* acos:                                  Math Functions.      (line  19)
* activate-mark-hook:                    The Mark.            (line 149)
* active-minibuffer-window:              Minibuffer Misc.     (line  54)
* ad-activate:                           Activation of Advice.
                                                              (line  30)
* ad-activate-regexp:                    Activation of Advice.
                                                              (line  44)
* ad-add-advice:                         Computed Advice.     (line  12)
* ad-deactivate:                         Activation of Advice.
                                                              (line  33)
* ad-deactivate-all:                     Activation of Advice.
                                                              (line  36)
* ad-deactivate-regexp:                  Activation of Advice.
                                                              (line  49)
* ad-default-compilation-action:         Activation of Advice.
                                                              (line  71)
* ad-define-subr-args:                   Subr Arguments.      (line  16)
* ad-disable-advice:                     Enabling Advice.     (line  22)
* ad-disable-regexp:                     Enabling Advice.     (line  35)
* ad-do-it:                              Around-Advice.       (line  21)
* ad-enable-advice:                      Enabling Advice.     (line  26)
* ad-enable-regexp:                      Enabling Advice.     (line  39)
* ad-get-arg:                            Argument Access in Advice.
                                                              (line  29)
* ad-get-args:                           Argument Access in Advice.
                                                              (line  32)
* ad-return-value:                       Defining Advice.     (line  31)
* ad-set-arg:                            Argument Access in Advice.
                                                              (line  35)
* ad-set-args:                           Argument Access in Advice.
                                                              (line  38)
* ad-start-advice:                       Activation of Advice.
                                                              (line  64)
* ad-stop-advice:                        Activation of Advice.
                                                              (line  68)
* ad-unadvise:                           Defining Advice.     (line 129)
* ad-unadvise-all:                       Defining Advice.     (line 132)
* ad-update-all:                         Activation of Advice.
                                                              (line  39)
* ad-update-regexp:                      Activation of Advice.
                                                              (line  55)
* adaptive-fill-first-line-regexp:       Adaptive Fill.       (line  28)
* adaptive-fill-function:                Adaptive Fill.       (line  36)
* adaptive-fill-mode:                    Adaptive Fill.       (line  10)
* adaptive-fill-regexp:                  Adaptive Fill.       (line  20)
* add-abbrev:                            Defining Abbrevs.    (line  11)
* add-hook:                              Hooks.               (line  98)
* add-name-to-file:                      Changing Files.      (line  22)
* add-text-properties:                   Changing Properties. (line  25)
* add-to-invisibility-spec:              Invisible Text.      (line  61)
* add-to-list:                           Setting Variables.   (line  90)
* after-change-function:                 Change Hooks.        (line  62)
* after-change-functions:                Change Hooks.        (line  22)
* after-find-file:                       Subroutines of Visiting.
                                                              (line  33)
* after-init-hook:                       Init File.           (line  64)
* after-insert-file-functions:           Saving Properties.   (line  35)
* after-load-alist:                      Hooks for Loading.   (line  35)
* after-make-frame-hook:                 Creating Frames.     (line  28)
* after-revert-hook:                     Reverting.           (line  81)
* after-save-hook:                       Saving Buffers.      (line 114)
* after-string （オーバレイ属性）:       Overlay Properties.  (line 113)
* alist（連想リスト）:                   Association Lists.   (line   6)
* all-christian-calendar-holidays:       Holiday Customizing. (line  24)
* all-completions:                       Basic Completion.    (line  87)
* all-hebrew-calendar-holidays:          Holiday Customizing. (line  24)
* all-islamic-calendar-holidays:         Holiday Customizing. (line  24)
* and:                                   Combining Conditions.
                                                              (line  17)
* append:                                Building Lists.      (line  57)
* append-to-file:                        Writing to Files.    (line  12)
* apply:                                 Calling Functions.   (line  57)
* applyとデバッグ:                       Internals of Debugger.
                                                              (line  60)
* appt-audible:                          Appt Customizing.    (line   9)
* appt-delete-window-function:           Appt Customizing.    (line   9)
* appt-disp-window-function:             Appt Customizing.    (line   9)
* appt-display-duration:                 Appt Customizing.    (line   9)
* appt-display-mode-line:                Appt Customizing.    (line   9)
* appt-message-warning-time:             Appt Customizing.    (line   9)
* appt-msg-window:                       Appt Customizing.    (line   9)
* appt-visible:                          Appt Customizing.    (line   9)
* apropos:                               Help Functions.      (line  13)
* aref:                                  Array Functions.     (line  21)
* arith-error、除算:                     Arithmetic Operations.
                                                              (line  88)
* arith-errorの例:                       Handling Errors.     (line 133)
* arrayp:                                Array Functions.     (line   9)
* ASCII文字コード:                       Character Type.      (line   6)
* aset:                                  Array Functions.     (line  33)
* ash:                                   Bitwise Operations.  (line  80)
* asin:                                  Math Functions.      (line  14)
* ask-user-about-lock:                   File Locks.          (line  46)
* ask-user-about-supersession-threat:    Modification Time.   (line  56)
* assoc:                                 Association Lists.   (line  58)
* assoc-default:                         Association Lists.   (line 155)
* assoc-ignore-case:                     Text Comparison.     (line 102)
* assoc-ignore-representation:           Text Comparison.     (line 108)
* assq:                                  Association Lists.   (line  99)
* atan:                                  Math Functions.      (line  24)
* atom:                                  List-related Predicates.
                                                              (line  18)
* auto-fill-function:                    Auto Filling.        (line  18)
* auto-mode-alist:                       Auto Major Mode.     (line 106)
* auto-save-default:                     Auto-Saving.         (line 130)
* auto-save-file-format:                 Format Conversion.   (line 131)
* auto-save-file-name-p:                 Auto-Saving.         (line  35)
* auto-save-hook:                        Auto-Saving.         (line 127)
* auto-save-interval:                    Auto-Saving.         (line 112)
* auto-save-list-file-name:              Auto-Saving.         (line 179)
* auto-save-list-file-prefix:            Auto-Saving.         (line 196)
* auto-save-mode:                        Auto-Saving.         (line  26)
* auto-save-timeout:                     Auto-Saving.         (line 118)
* auto-save-visited-file-name:           Auto-Saving.         (line  90)
* autoload:                              Autoload.            (line  26)
* back-to-indentation:                   Motion by Indent.    (line  10)
* backtrace:                             Internals of Debugger.
                                                              (line  18)
* backtrace-debug:                       Internals of Debugger.
                                                              (line  68)
* backtrace-frame:                       Internals of Debugger.
                                                              (line  87)
* backup-buffer:                         Making Backups.      (line   7)
* backup-by-copying:                     Rename or Copy.      (line  31)
* backup-by-copying-when-linked:         Rename or Copy.      (line  39)
* backup-by-copying-when-mismatch:       Rename or Copy.      (line  46)
* backup-by-copying-when-privileged-mismatch: Rename or Copy. (line  60)
* backup-directory-alist:                Making Backups.      (line  65)
* backup-enable-predicate:               Making Backups.      (line  39)
* backup-file-name-p:                    Backup Names.        (line  11)
* backup-inhibited:                      Making Backups.      (line  51)
* backward-char:                         Character Motion.    (line  39)
* backward-delete-char-untabify:         Deletion.            (line  63)
* backward-delete-char-untabify-method:  Deletion.            (line  82)
* backward-list:                         List Motion.         (line  21)
* backward-prefix-chars:                 Motion and Syntax.   (line  25)
* backward-sexp:                         List Motion.         (line  50)
* backward-to-indentation:               Motion by Indent.    (line  14)
* backward-word:                         Word Motion.         (line  23)
* barf-if-buffer-read-only:              Read Only Buffers.   (line  58)
* batch-byte-compile:                    Compilation Functions.
                                                              (line 114)
* baud-rate:                             Terminal Output.     (line  11)
* beep:                                  Beeping.             (line  20)
* before-change-function:                Change Hooks.        (line  56)
* before-change-functions:               Change Hooks.        (line  17)
* before-init-hook:                      Init File.           (line  57)
* before-make-frame-hook:                Creating Frames.     (line  25)
* before-revert-hook:                    Reverting.           (line  77)
* before-string （オーバレイ属性）:      Overlay Properties.  (line 106)
* beginning-of-buffer:                   Buffer End Motion.   (line  19)
* beginning-of-defun:                    List Motion.         (line  53)
* beginning-of-line:                     Text Lines.          (line  40)
* blink-matching-delay:                  Blinking.            (line  21)
* blink-matching-open:                   Blinking.            (line  26)
* blink-matching-paren:                  Blinking.            (line  15)
* blink-matching-paren-distance:         Blinking.            (line  18)
* blink-paren-function:                  Blinking.            (line  10)
* bobp:                                  Near Point.          (line  57)
* bold （フェイス名）:                   Standard Faces.      (line  28)
* bold-italic （フェイス名）:            Standard Faces.      (line  38)
* bolp:                                  Near Point.          (line  67)
* bool-vector-p:                         Bool-Vectors.        (line  21)
* boundp:                                Void Variables.      (line  67)
* buffer-access-fontified-property:      Lazy Properties.     (line  28)
* buffer-access-fontify-functions:       Lazy Properties.     (line  15)
* buffer-auto-save-file-name:            Auto-Saving.         (line  17)
* buffer-backed-up:                      Making Backups.      (line  12)
* buffer-base-buffer:                    Indirect Buffers.    (line  39)
* buffer-disable-undo:                   Maintaining Undo.    (line  26)
* buffer-display-table:                  Active Display Table.
                                                              (line  24)
* buffer-display-time:                   Buffers and Windows. (line  83)
* buffer-enable-undo:                    Maintaining Undo.    (line  16)
* buffer-end:                            Point.               (line  53)
* buffer-file-coding-system:             Encoding and I/O.    (line  23)
* buffer-file-format:                    Format Conversion.   (line  93)
* buffer-file-name:                      Buffer File Name.    (line  24)
* buffer-file-number:                    Buffer File Name.    (line  46)
* buffer-file-truename:                  Buffer File Name.    (line  39)
* buffer-file-type:                      MS-DOS File Types.   (line  14)
* buffer-flush-undo:                     Maintaining Undo.    (line  27)
* buffer-invisibility-spec:              Invisible Text.      (line  32)
* buffer-list:                           The Buffer List.     (line  26)
* buffer-local-variables:                Creating Buffer-Local.
                                                              (line  77)
* Buffer-menu-mode-map:                  Standard Keymaps.    (line  16)
* buffer-modified-p:                     Buffer Modification. (line  24)
* buffer-modified-tick:                  Buffer Modification. (line  51)
* buffer-name:                           Buffer Names.        (line  21)
* buffer-name-history:                   Minibuffer History.  (line  58)
* buffer-offer-save:                     Killing Buffers.     (line  79)
* buffer-read-only:                      Read Only Buffers.   (line  30)
* buffer-saved-size:                     Auto-Saving.         (line 166)
* buffer-size:                           Point.               (line  57)
* buffer-string:                         Buffer Contents.     (line  40)
* buffer-substring:                      Buffer Contents.     (line  10)
* buffer-substring-no-properties:        Buffer Contents.     (line  35)
* buffer-undo-list:                      Undo.                (line  15)
* bufferp:                               Buffer Basics.       (line  43)
* bury-buffer:                           The Buffer List.     (line  91)
* byte-code:                             Compilation Functions.
                                                              (line 125)
* byte-code-function-p:                  What Is a Function.  (line  94)
* byte-compile:                          Compilation Functions.
                                                              (line  34)
* byte-compile-dynamic:                  Dynamic Loading.     (line  50)
* byte-compile-dynamic-docstrings:       Docs and Compilation.
                                                              (line  49)
* byte-compile-file:                     Compilation Functions.
                                                              (line  73)
* byte-recompile-directory:              Compilation Functions.
                                                              (line 100)
* C-c:                                   Prefix Keys.         (line  23)
* C-g:                                   Quitting.            (line   6)
* C-h:                                   Prefix Keys.         (line  20)
* C-M-x:                                 Instrumenting.       (line  10)
* c-mode-map:                            Standard Keymaps.    (line  19)
* c-mode-syntax-table:                   Standard Syntax Tables.
                                                              (line  17)
* C-q:                                   Flow Control.        (line  14)
* C-s:                                   Flow Control.        (line  14)
* C-x:                                   Prefix Keys.         (line  31)
* C-x 4:                                 Prefix Keys.         (line  38)
* C-x 5:                                 Prefix Keys.         (line  41)
* C-x 6:                                 Prefix Keys.         (line  44)
* C-x <RET>:                             Prefix Keys.         (line  35)
* C-x v:                                 Prefix Keys.         (line  47)
* caar:                                  List Elements.       (line 106)
* cache-long-line-scans:                 Truncation.          (line  54)
* cadr:                                  List Elements.       (line 109)
* calendar-date-display-form:            Date Display Format. (line   6)
* calendar-daylight-savings-ends:        Daylight Savings.    (line  18)
* calendar-daylight-savings-ends-time:   Daylight Savings.    (line  59)
* calendar-daylight-savings-starts:      Daylight Savings.    (line  18)
* calendar-daylight-savings-starts-time: Daylight Savings.    (line  59)
* calendar-daylight-time-offset:         Daylight Savings.    (line  55)
* calendar-holiday-marker:               Calendar Customizing.
                                                              (line  33)
* calendar-holidays:                     Holiday Customizing. (line   6)
* calendar-load-hook:                    Calendar Customizing.
                                                              (line  43)
* calendar-mark-today:                   Calendar Customizing.
                                                              (line  64)
* calendar-star-date:                    Calendar Customizing.
                                                              (line  59)
* calendar-time-display-form:            Time Display Format. (line   6)
* calendar-today-marker:                 Calendar Customizing.
                                                              (line  66)
* call-interactively:                    Interactive Call.    (line  34)
* call-process:                          Synchronous Processes.
                                                              (line  32)
* call-process-region:                   Synchronous Processes.
                                                              (line 118)
* cancel-debug-on-entry:                 Function Debugging.  (line  61)
* cancel-timer:                          Timers.              (line 123)
* capitalize:                            Case Conversion.     (line  52)
* capitalize-region:                     Case Changes.        (line  14)
* capitalize-word:                       Case Changes.        (line  51)
* car:                                   List Elements.       (line   7)
* car-safe:                              List Elements.       (line  35)
* case-fold-search:                      Searching and Case.  (line  38)
* case-replace:                          Searching and Case.  (line  29)
* case-table-p:                          Case Tables.         (line  64)
* catch:                                 Catch and Throw.     (line  64)
* category （オーバレイ属性）:           Overlay Properties.  (line  35)
* category （テキスト属性）:             Special Properties.  (line  11)
* category-docstring:                    Categories.          (line  38)
* category-set-mnemonics:                Categories.          (line  92)
* category-table:                        Categories.          (line  52)
* category-table-p:                      Categories.          (line  55)
* CBREAK:                                Flow Control.        (line  66)
* cdar:                                  List Elements.       (line 112)
* cddr:                                  List Elements.       (line 115)
* cdr:                                   List Elements.       (line  21)
* cdr-safe:                              List Elements.       (line  49)
* ceiling:                               Numeric Conversions. (line  27)
* change-major-mode-hook:                Creating Buffer-Local.
                                                              (line 148)
* char-after:                            Near Point.          (line  11)
* char-before:                           Near Point.          (line  23)
* char-bytes:                            Splitting Characters.
                                                              (line  12)
* char-category-set:                     Categories.          (line  83)
* char-charset:                          Character Sets.      (line  28)
* char-equal:                            Text Comparison.     (line   7)
* char-or-string-p:                      Predicates for Strings.
                                                              (line  14)
* char-syntax:                           Syntax Table Functions.
                                                              (line  63)
* char-table-extra-slot:                 Char-Tables.         (line  65)
* char-table-p:                          Char-Tables.         (line  45)
* char-table-parent:                     Char-Tables.         (line  58)
* char-table-range:                      Char-Tables.         (line  75)
* char-table-subtype:                    Char-Tables.         (line  49)
* char-to-string:                        String Conversion.   (line  20)
* char-valid-p:                          Character Codes.     (line  17)
* char-width:                            Width.               (line  11)
* charset-dimension:                     Chars and Bytes.     (line  15)
* charset-list:                          Character Sets.      (line  25)
* charsetp:                              Character Sets.      (line  21)
* check-coding-system:                   Lisp and Coding Systems.
                                                              (line  18)
* checkdoc-minor-mode:                   Documentation Tips.  (line   6)
* christian-holidays:                    Holiday Customizing. (line   6)
* cl:                                    Lisp History.        (line  30)
* cl-specs.el:                           Instrumenting.       (line  41)
* cl.el （edebug）:                      Instrumenting.       (line  41)
* clear-abbrev-table:                    Abbrev Tables.       (line  14)
* clear-visited-file-modtime:            Modification Time.   (line  27)
* CLに関した注意−−Emacsではthrowのみ:    Catch and Throw.     (line  57)
* CLに関した注意−−rplacaとsetcar:        Modifying Lists.     (line  10)
* CLに関した注意−−setはローカル:         Setting Variables.   (line  80)
* CLに関した注意−−unionとintersectionの欠落: Sets And Lists.  (line  13)
* CLに関した注意−−オブジェクト配列内のシンボル: Creating Symbols.
                                                              (line  64)
* CLに関した注意−−スペシャルフォームの比較: Special Forms.    (line  96)
* CLに関した注意−−スペシャル変数:        Variable Scoping.    (line  26)
* CLに関した注意−−メモリ領域の追加:      Garbage Collection.  (line  49)
* CLに関した注意−−大文字小文字の区別:    Symbol Type.         (line  38)
* CLに関した注意−−整数とeq:              Comparison of Numbers.
                                                              (line  41)
* CLに関した注意−−既存シンボルのインターン: Creating Symbols. (line 112)
* CLに関した注意−−省略可能引数のデフォルト: Argument List.    (line  49)
* CLに関した注意−−継続可能なエラーはない: Signaling Errors.   (line  66)
* coding-system-change-eol-conversion:   Lisp and Coding Systems.
                                                              (line  24)
* coding-system-change-text-conversion:  Lisp and Coding Systems.
                                                              (line  32)
* coding-system-for-read:                Specifying Coding Systems.
                                                              (line  10)
* coding-system-for-write:               Specifying Coding Systems.
                                                              (line  40)
* coding-system-get:                     Coding System Basics.
                                                              (line  47)
* coding-system-list:                    Lisp and Coding Systems.
                                                              (line   9)
* coding-system-p:                       Lisp and Coding Systems.
                                                              (line  15)
* combine-after-change-calls:            Change Hooks.        (line  33)
* command-debug-status:                  Internals of Debugger.
                                                              (line  77)
* command-execute:                       Interactive Call.    (line  52)
* command-history:                       Command History.     (line  15)
* command-history-map:                   Standard Keymaps.    (line  22)
* command-line:                          Command Line Arguments.
                                                              (line  20)
* command-line-args:                     Command Line Arguments.
                                                              (line  57)
* command-line-functions:                Command Line Arguments.
                                                              (line  60)
* command-line-processed:                Command Line Arguments.
                                                              (line  24)
* command-switch-alist:                  Command Line Arguments.
                                                              (line  31)
* commandp:                              Interactive Call.    (line  13)
* commandpの例:                          High-Level Completion.
                                                              (line  83)
* Common Lisp:                           Lisp History.        (line  11)
* Common Lisp（edebug）:                 Instrumenting.       (line  41)
* compare-buffer-substrings:             Comparing Text.      (line  11)
* compare-strings:                       Text Comparison.     (line  83)
* compare-window-configurations:         Window Configurations.
                                                              (line  86)
* compile-defun:                         Compilation Functions.
                                                              (line  67)
* completing-read:                       Minibuffer Completion.
                                                              (line  11)
* completion-auto-help:                  Completion Commands. (line 110)
* completion-ignore-case:                Basic Completion.    (line 111)
* completion-ignored-extensions:         File Name Completion.
                                                              (line  59)
* compute-motion:                        Screen Lines.        (line  65)
* concat:                                Creating Strings.    (line  88)
* cond:                                  Conditionals.        (line  54)
* condition-case:                        Handling Errors.     (line  78)
* cons:                                  Building Lists.      (line  12)
* cons-cells-consed:                     Memory Usage.        (line  14)
* consp:                                 List-related Predicates.
                                                              (line  13)
* continue-process:                      Signals to Processes.
                                                              (line  86)
* Control-X-prefix:                      Prefix Keys.         (line  31)
* convert-standard-filename:             Standard File Names. (line  23)
* coordinates-in-window-p:               Coordinates and Windows.
                                                              (line  17)
* copy-alist:                            Association Lists.   (line 172)
* copy-category-table:                   Categories.          (line  62)
* copy-face:                             Face Functions.      (line  20)
* copy-file:                             Changing Files.      (line  78)
* copy-keymap:                           Creating Keymaps.    (line  33)
* copy-marker:                           Creating Markers.    (line  49)
* copy-region-as-kill:                   Kill Functions.      (line  35)
* copy-sequence:                         Sequence Functions.  (line  57)
* copy-syntax-table:                     Syntax Table Functions.
                                                              (line  16)
* cos:                                   Math Functions.      (line  10)
* count-lines:                           Text Lines.          (line  71)
* count-loop:                            A Sample Function Description.
                                                              (line  66)
* create-file-buffer:                    Subroutines of Visiting.
                                                              (line  11)
* create-fontset-from-fontset-spec:      Fontsets.            (line  18)
* ctl-arrow:                             Usual Display.       (line  48)
* ctl-x-4-map:                           Prefix Keys.         (line  38)
* ctl-x-5-map:                           Prefix Keys.         (line  41)
* ctl-x-map:                             Prefix Keys.         (line  31)
* current-buffer:                        Current Buffer.      (line  96)
* current-case-table:                    Case Tables.         (line  75)
* current-column:                        Columns.             (line  20)
* current-fill-column:                   Margins.             (line  54)
* current-frame-configuration:           Frame Configurations.
                                                              (line  11)
* current-global-map:                    Active Keymaps.      (line  84)
* current-indentation:                   Primitive Indent.    (line  11)
* current-input-method:                  Input Methods.       (line  20)
* current-input-mode:                    Input Modes.         (line  37)
* current-justification:                 Filling.             (line 126)
* current-kill:                          Low-Level Kill Ring. (line  12)
* current-left-margin:                   Margins.             (line  48)
* current-local-map:                     Active Keymaps.      (line  93)
* current-message:                       The Echo Area.       (line  65)
* current-minor-mode-maps:               Active Keymaps.      (line 109)
* current-prefix-arg:                    Prefix Command Arguments.
                                                              (line  86)
* current-time:                          Time of Day.         (line  26)
* current-time-string:                   Time of Day.         (line   9)
* current-time-zone:                     Time of Day.         (line  39)
* current-window-configuration:          Window Configurations.
                                                              (line  18)
* cursor-in-echo-area:                   The Echo Area.       (line  69)
* cust-print:                            Printing in Edebug.  (line   6)
* data-directory:                        Help Functions.      (line 127)
* deactivate-mark:                       The Mark.            (line 134)
* deactivate-mark-hook:                  The Mark.            (line 150)
* debug:                                 Invoking the Debugger.
                                                              (line   9)
* debug-ignored-errors:                  Error Debugging.     (line  35)
* debug-on-entry:                        Function Debugging.  (line  14)
* debug-on-error:                        Error Debugging.     (line  19)
* debug-on-errorの利用:                  Processing of Errors.
                                                              (line  23)
* debug-on-next-call:                    Internals of Debugger.
                                                              (line  60)
* debug-on-quit:                         Infinite Loops.      (line  23)
* debug-on-signal:                       Error Debugging.     (line  51)
* debugger:                              Internals of Debugger.
                                                              (line   9)
* debugger-mode-map:                     Standard Keymaps.    (line  34)
* decode-coding-region:                  Explicit Encoding.   (line  55)
* decode-coding-string:                  Explicit Encoding.   (line  62)
* decode-time:                           Time Conversion.     (line 139)
* def-edebug-spec:                       Instrumenting Macro Calls.
                                                              (line  17)
* defadvice:                             Defining Advice.     (line  10)
* defalias:                              Defining Functions.  (line  60)
* default （フェイス名）:                Standard Faces.      (line   9)
* default-abbrev-mode:                   Abbrev Mode.         (line  18)
* default-boundp:                        Default Value.       (line  30)
* default-buffer-file-type:              MS-DOS File Types.   (line  47)
* default-case-fold-search:              Searching and Case.  (line  44)
* default-ctl-arrow:                     Usual Display.       (line  55)
* default-directory:                     File Name Expansion. (line  56)
* default-enable-multibyte-characters:   Text Representations.
                                                              (line  44)
* default-file-modes:                    Changing Files.      (line 132)
* default-fill-column:                   Margins.             (line  30)
* default-frame-alist:                   Initial Parameters.  (line  47)
* default-input-method:                  Input Methods.       (line  25)
* default-justification:                 Filling.             (line 120)
* default-major-mode:                    Auto Major Mode.     (line  80)
* default-minibuffer-frame:              Minibuffers and Frames.
                                                              (line  26)
* default-mode-line-format:              Mode Line Variables. (line  94)
* default-process-coding-system:         Default Coding Systems.
                                                              (line  73)
* default-text-properties:               Examining Properties.
                                                              (line  45)
* default-truncate-lines:                Truncation.          (line  31)
* default-value:                         Default Value.       (line  24)
* default.el:                            Start-up Summary.    (line  40)
* defconst:                              Defining Variables.  (line 100)
* defcustom:                             Variable Definitions.
                                                              (line   9)
* defface:                               Defining Faces.      (line  12)
* defgroup:                              Group Definitions.   (line  26)
* define-abbrev:                         Defining Abbrevs.    (line  23)
* define-abbrev-table:                   Abbrev Tables.       (line  18)
* define-category:                       Categories.          (line  31)
* define-derived-mode:                   Derived Modes.       (line  10)
* define-key:                            Changing Key Bindings.
                                                              (line  42)
* define-key-after:                      Modifying Menus.     (line  12)
* define-logical-name:                   Changing Files.      (line 113)
* define-prefix-command:                 Prefix Keys.         (line  95)
* defining-kbd-macro:                    Keyboard Macros.     (line  41)
* defmacro:                              Defining Macros.     (line  18)
* defsubst:                              Inline Functions.    (line   6)
* defun:                                 Defining Functions.  (line  10)
* defun-prompt-regexp:                   List Motion.         (line  63)
* defvar:                                Defining Variables.  (line  26)
* delete:                                Sets And Lists.      (line  91)
* delete-auto-save-file-if-necessary:    Auto-Saving.         (line 148)
* delete-auto-save-files:                Auto-Saving.         (line 153)
* delete-backward-char:                  Deletion.            (line  49)
* delete-blank-lines:                    User-Level Deletion. (line  98)
* delete-char:                           Deletion.            (line  35)
* delete-directory:                      Create/Delete Dirs.  (line  15)
* delete-exited-processes:               Deleting Processes.  (line  21)
* delete-file:                           Changing Files.      (line  92)
* delete-frame:                          Deleting Frames.     (line  14)
* delete-frameイベント:                  Misc Events.         (line   8)
* delete-horizontal-space:               User-Level Deletion. (line  10)
* delete-indentation:                    User-Level Deletion. (line  34)
* delete-old-versions:                   Numbered Backups.    (line  48)
* delete-other-windows:                  Deleting Windows.    (line  33)
* delete-overlay:                        Managing Overlays.   (line  31)
* delete-process:                        Deleting Processes.  (line  28)
* delete-region:                         Deletion.            (line  27)
* delete-to-left-margin:                 Margins.             (line  69)
* delete-window:                         Deleting Windows.    (line  27)
* delete-windows-on:                     Deleting Windows.    (line  41)
* delq:                                  Sets And Lists.      (line  30)
* describe-bindings:                     Scanning Keymaps.    (line 101)
* describe-buffer-case-table:            Case Tables.         (line  96)
* describe-mode:                         Mode Help.           (line  13)
* describe-prefix-bindings:              Help Functions.      (line 101)
* detect-coding-region:                  Lisp and Coding Systems.
                                                              (line  59)
* detect-coding-string:                  Lisp and Coding Systems.
                                                              (line  74)
* diary-anniversary:                     Sexp Diary Entries.  (line  13)
* diary-astro-day-number:                Sexp Diary Entries.  (line  97)
* diary-cyclic:                          Sexp Diary Entries.  (line  29)
* diary-date:                            Sexp Diary Entries.  (line  46)
* diary-date-forms:                      Diary Customizing.   (line  34)
* diary-day-of-year:                     Sexp Diary Entries.  (line  97)
* diary-display-hook:                    Fancy Diary Display. (line   6)
* diary-entry-marker:                    Calendar Customizing.
                                                              (line  33)
* diary-float:                           Sexp Diary Entries.  (line  57)
* diary-french-date:                     Sexp Diary Entries.  (line  97)
* diary-hebrew-date:                     Sexp Diary Entries.  (line  97)
* diary-islamic-date:                    Sexp Diary Entries.  (line  97)
* diary-iso-date:                        Sexp Diary Entries.  (line  97)
* diary-julian-date:                     Sexp Diary Entries.  (line  97)
* diary-list-include-blanks:             Fancy Diary Display. (line  25)
* diary-mayan-date:                      Sexp Diary Entries.  (line  97)
* diary-omer:                            Sexp Diary Entries.  (line 139)
* diary-parasha:                         Sexp Diary Entries.  (line 139)
* diary-phases-of-moon:                  Sexp Diary Entries.  (line  97)
* diary-remind:                          Sexp Diary Entries.  (line  40)
* diary-rosh-hodesh:                     Sexp Diary Entries.  (line 139)
* diary-sabbath-candles:                 Sexp Diary Entries.  (line 139)
* diary-sunrise-sunset:                  Sexp Diary Entries.  (line  97)
* diary-yahrzeit:                        Sexp Diary Entries.  (line 139)
* digit-argument:                        Prefix Command Arguments.
                                                              (line 106)
* ding:                                  Beeping.             (line  14)
* directory-abbrev-alist:                Directory Names.     (line  50)
* directory-file-name:                   Directory Names.     (line  34)
* directory-files:                       Contents of Directories.
                                                              (line  17)
* dired-kept-versions:                   Numbered Backups.    (line  54)
* dired-mode-map:                        Standard Keymaps.    (line  37)
* disable-command:                       Disabling Commands.  (line  39)
* disabled:                              Disabling Commands.  (line  12)
* disabled-command-hook:                 Disabling Commands.  (line  44)
* disassemble:                           Disassembly.         (line  21)
* discard-input:                         Event Input Misc.    (line  72)
* display-buffer:                        Choosing Window.     (line  13)
* display-buffer-function:               Choosing Window.     (line 160)
* display-completion-list:               Completion Commands. (line  93)
* display-table-slot:                    Display Table Format.
                                                              (line  61)
* do-auto-save:                          Auto-Saving.         (line 135)
* doc-directory:                         Accessing Documentation.
                                                              (line 118)
* documentation:                         Accessing Documentation.
                                                              (line  21)
* documentation-property:                Accessing Documentation.
                                                              (line   7)
* DOC（説明文）ファイル:                 Documentation Basics.
                                                              (line  40)
* DOSのファイル型:                       MS-DOS File Types.   (line   6)
* double-click-time:                     Repeat Events.       (line  78)
* down-list:                             List Motion.         (line  29)
* downcase:                              Case Conversion.     (line  19)
* downcase-region:                       Case Changes.        (line  37)
* downcase-word:                         Case Changes.        (line  66)
* drag-n-dropイベント:                   Misc Events.         (line  45)
* dump-emacs:                            Building Emacs.      (line  89)
* easy-mmode-define-minor-mode:          Easy-Mmode.          (line  11)
* echo-area-clear-hook:                  The Echo Area.       (line  78)
* echo-keystrokes:                       The Echo Area.       (line  95)
* edebug <1>:                            Edebug.              (line   6)
* edebug:                                Source Breakpoints.  (line   6)
* edebug-all-defs:                       Edebug Options.      (line  17)
* edebug-all-forms:                      Edebug Options.      (line  27)
* edebug-continue-kbd-macro:             Edebug Options.      (line  81)
* edebug-display-freq-count:             Coverage Testing.    (line  26)
* edebug-eval-top-level-form:            Instrumenting.       (line  28)
* edebug-global-break-condition:         Edebug Options.      (line 100)
* edebug-initial-mode:                   Edebug Options.      (line  60)
* edebug-on-error:                       Edebug Options.      (line  86)
* edebug-on-quit:                        Edebug Options.      (line  91)
* edebug-print-circle:                   Printing in Edebug.  (line  44)
* edebug-print-length:                   Printing in Edebug.  (line  18)
* edebug-print-level:                    Printing in Edebug.  (line  22)
* edebug-print-trace-after:              Trace Buffer.        (line  23)
* edebug-print-trace-before:             Trace Buffer.        (line  23)
* edebug-save-displayed-buffer-points:   Edebug Options.      (line  46)
* edebug-save-windows:                   Edebug Options.      (line  36)
* edebug-set-global-break-condition:     Global Break Condition.
                                                              (line  13)
* edebug-setup-hook:                     Edebug Options.      (line   9)
* edebug-test-coverage:                  Edebug Options.      (line  77)
* edebug-trace <1>:                      Edebug Options.      (line  68)
* edebug-trace:                          Trace Buffer.        (line  33)
* edebug-tracing:                        Trace Buffer.        (line  27)
* edebug-unwrap:                         Specification List.  (line  35)
* edebugの実行モード:                    Edebug Execution Modes.
                                                              (line   6)
* edebugモード:                          Edebug.              (line   6)
* edebug用仕様リスト:                    Specification List.  (line   6)
* edit-abbrevs-map:                      Standard Keymaps.    (line  40)
* edit-and-eval-command:                 Object from Minibuffer.
                                                              (line  47)
* edit-tab-stops-map:                    Standard Keymaps.    (line  43)
* electric-buffer-menu-mode-map:         Standard Keymaps.    (line  46)
* electric-future-map:                   A Sample Variable Description.
                                                              (line  16)
* electric-history-map:                  Standard Keymaps.    (line  50)
* elp.el:                                Compilation Tips.    (line   8)
* elt:                                   Sequence Functions.  (line  35)
* emacs-build-time:                      Version Info.        (line  19)
* emacs-lisp-mode-map:                   Standard Keymaps.    (line  54)
* emacs-lisp-mode-syntax-table:          Standard Syntax Tables.
                                                              (line  20)
* emacs-major-version:                   Version Info.        (line  35)
* emacs-minor-version:                   Version Info.        (line  38)
* emacs-pid:                             System Environment.  (line 170)
* emacs-version:                         Version Info.        (line   9)
* emacs/etc/DOC-VERSION:                 Documentation Basics.
                                                              (line  40)
* EMACSLOADPATH環境変数:                 Library Search.      (line  10)
* Emacsのイベント標準表記:               Describing Characters.
                                                              (line  12)
* Emacsの休止:                           Suspending Emacs.    (line   6)
* Emacsの始動:                           Start-up Summary.    (line   6)
* Emacsの構築方法:                       Building Emacs.      (line   6)
* Emacsの終了 <1>:                       Killing Emacs.       (line   6)
* Emacsの終了:                           Getting Out.         (line   6)
* enable-command:                        Disabling Commands.  (line  34)
* enable-flow-control:                   Flow Control.        (line  49)
* enable-flow-control-on:                Flow Control.        (line  58)
* enable-local-eval:                     Auto Major Mode.     (line  62)
* enable-local-variables:                Auto Major Mode.     (line  46)
* enable-multibyte-characters:           Text Representations.
                                                              (line  35)
* enable-recursive-minibuffers:          Minibuffer Misc.     (line  92)
* encode-coding-region:                  Explicit Encoding.   (line  42)
* encode-coding-string:                  Explicit Encoding.   (line  49)
* encode-time:                           Time Conversion.     (line 178)
* end-of-buffer:                         Buffer End Motion.   (line  30)
* end-of-defun:                          List Motion.         (line  58)
* end-of-file（ファイルの終り）:         Input Functions.     (line  12)
* end-of-line:                           Text Lines.          (line  48)
* enlarge-window:                        Resizing Windows.    (line  13)
* enlarge-window-horizontally:           Resizing Windows.    (line  37)
* eobp:                                  Near Point.          (line  62)
* eolp:                                  Near Point.          (line  72)
* eq:                                    Equality Predicates. (line  11)
* equal:                                 Equality Predicates. (line  58)
* erase-buffer:                          Deletion.            (line  15)
* error:                                 Signaling Errors.    (line  15)
* error-conditions:                      Error Symbols.       (line   6)
* error-message-string:                  Handling Errors.     (line 129)
* error、デバッグ:                       Invoking the Debugger.
                                                              (line  61)
* esc-map:                               Prefix Keys.         (line  16)
* ESC-prefix:                            Prefix Keys.         (line  16)
* etc/DOC-VERSION:                       Documentation Basics.
                                                              (line  40)
* eval:                                  Eval.                (line  25)
* eval-after-load:                       Hooks for Loading.   (line  10)
* eval-and-compile:                      Eval During Compile. (line   9)
* eval-current-buffer:                   Eval.                (line  69)
* eval-current-buffer （edebug）:        Instrumenting.       (line  20)
* eval-defun （edebug）:                 Instrumenting.       (line  10)
* eval-expression （edebug）:            Instrumenting.       (line  54)
* eval-minibuffer:                       Object from Minibuffer.
                                                              (line  35)
* eval-region:                           Eval.                (line  48)
* eval-region （edebug）:                Instrumenting.       (line  20)
* eval-when-compile:                     Eval During Compile. (line  18)
* evalとデバッグ:                        Internals of Debugger.
                                                              (line  60)
* evaporate （オーバレイ属性）:          Overlay Properties.  (line 120)
* event-basic-type:                      Classifying Events.  (line  62)
* event-click-count:                     Repeat Events.       (line  70)
* event-convert-list:                    Classifying Events.  (line  86)
* event-end:                             Accessing Events.    (line  22)
* event-modifiers:                       Classifying Events.  (line  29)
* event-start:                           Accessing Events.    (line  15)
* eventp:                                Input Events.        (line  13)
* exec-directory:                        Subprocess Creation. (line  57)
* exec-path:                             Subprocess Creation. (line  64)
* execute-extended-command:              Interactive Call.    (line  70)
* execute-kbd-macro:                     Keyboard Macros.     (line  13)
* executing-macro:                       Keyboard Macros.     (line  33)
* exit:                                  Recursive Editing.   (line  33)
* exit-minibuffer:                       Minibuffer Misc.     (line   9)
* exit-recursive-edit:                   Recursive Editing.   (line  86)
* exp:                                   Math Functions.      (line  28)
* expand-abbrev:                         Abbrev Expansion.    (line  27)
* expand-file-name:                      File Name Expansion. (line  15)
* expt:                                  Math Functions.      (line  41)
* extended-command-history:              Minibuffer History.  (line  64)
* extra-keyboard-modifiers:              Translating Input.   (line  18)
* face （オーバレイ属性）:               Overlay Properties.  (line  41)
* face （テキスト属性）:                 Special Properties.  (line  18)
* face-background:                       Face Functions.      (line  86)
* face-bold-p:                           Face Functions.      (line  97)
* face-differs-from-default-p:           Face Functions.      (line 117)
* face-documentation:                    Face Functions.      (line 109)
* face-equal:                            Face Functions.      (line 113)
* face-font:                             Face Functions.      (line  94)
* face-foreground:                       Face Functions.      (line  85)
* face-id:                               Face Functions.      (line 106)
* face-italic-p:                         Face Functions.      (line 100)
* face-list:                             Face Functions.      (line  17)
* face-stipple:                          Face Functions.      (line  90)
* face-underline-p:                      Face Functions.      (line 103)
* facemenu-background-menu:              Standard Keymaps.    (line  60)
* facemenu-face-menu:                    Standard Keymaps.    (line  64)
* facemenu-foreground-menu:              Standard Keymaps.    (line  67)
* facemenu-indentation-menu:             Standard Keymaps.    (line  70)
* facemenu-justification-menu:           Standard Keymaps.    (line  73)
* facemenu-keymap:                       Prefix Keys.         (line  50)
* facemenu-menu:                         Standard Keymaps.    (line  57)
* facemenu-special-menu:                 Standard Keymaps.    (line  76)
* facep:                                 Faces.               (line  16)
* false（偽）:                           nil and t.           (line   6)
* fancy-diary-display:                   Fancy Diary Display. (line  12)
* fboundp:                               Function Cells.      (line  46)
* fceiling:                              Rounding Operations. (line  18)
* FEATURE-unload-hook:                   Unloading.           (line  25)
* featurep:                              Named Features.      (line 113)
* features:                              Named Features.      (line 117)
* fetch-bytecode:                        Dynamic Loading.     (line  55)
* ffloor:                                Rounding Operations. (line  14)
* file-accessible-directory-p:           Testing Accessibility.
                                                              (line  55)
* file-already-exists:                   Changing Files.      (line 104)
* file-attributes:                       File Attributes.     (line  55)
* file-coding-system-alist:              Default Coding Systems.
                                                              (line  18)
* file-directory-p:                      Kinds of Files.      (line  31)
* file-error:                            How Programs Do Loading.
                                                              (line  73)
* file-executable-p:                     Testing Accessibility.
                                                              (line  31)
* file-exists-p:                         Testing Accessibility.
                                                              (line   9)
* file-local-copy:                       Magic File Names.    (line 112)
* file-locked:                           File Locks.          (line  59)
* file-locked-p:                         File Locks.          (line  23)
* file-modes:                            File Attributes.     (line  12)
* file-name-absolute-p:                  Relative File Names. (line  17)
* file-name-all-completions:             File Name Completion.
                                                              (line  10)
* file-name-all-versions:                Contents of Directories.
                                                              (line  44)
* file-name-as-directory:                Directory Names.     (line  24)
* file-name-buffer-file-type-alist:      MS-DOS File Types.   (line  28)
* file-name-completion:                  File Name Completion.
                                                              (line  33)
* file-name-directory:                   File Name Components.
                                                              (line  26)
* file-name-history:                     Minibuffer History.  (line  55)
* file-name-nondirectory:                File Name Components.
                                                              (line  39)
* file-name-sans-extension:              File Name Components.
                                                              (line  64)
* file-name-sans-versions:               File Name Components.
                                                              (line  50)
* file-newer-than-file-p:                Testing Accessibility.
                                                              (line  79)
* file-newest-backup:                    Backup Names.        (line  86)
* file-nlinks:                           File Attributes.     (line  39)
* file-ownership-preserved-p:            Testing Accessibility.
                                                              (line  75)
* file-precious-flag:                    Saving Buffers.      (line 120)
* file-readable-p:                       Testing Accessibility.
                                                              (line  20)
* file-regular-p:                        Kinds of Files.      (line  47)
* file-relative-name:                    File Name Expansion. (line  41)
* file-supersession:                     Modification Time.   (line  63)
* file-symlink-p:                        Kinds of Files.      (line  11)
* file-truename:                         Truenames.           (line  16)
* file-writable-p:                       Testing Accessibility.
                                                              (line  38)
* fill-column:                           Margins.             (line  17)
* fill-context-prefix:                   Adaptive Fill.       (line  15)
* fill-individual-paragraphs:            Filling.             (line  58)
* fill-individual-varying-indent:        Filling.             (line  77)
* fill-nobreak-predicate:                Margins.             (line  87)
* fill-paragraph:                        Filling.             (line  37)
* fill-paragraph-function:               Filling.             (line 135)
* fill-prefix:                           Margins.             (line   7)
* fill-region:                           Filling.             (line  44)
* fill-region-as-paragraph:              Filling.             (line  82)
* fillarray:                             Array Functions.     (line  58)
* find-backup-file-name:                 Backup Names.        (line  66)
* find-charset-region:                   Scanning Charsets.   (line  12)
* find-charset-string:                   Scanning Charsets.   (line  22)
* find-coding-systems-for-charsets:      Lisp and Coding Systems.
                                                              (line  55)
* find-coding-systems-region:            Lisp and Coding Systems.
                                                              (line  38)
* find-coding-systems-string:            Lisp and Coding Systems.
                                                              (line  47)
* find-file:                             Visiting Functions.  (line  20)
* find-file-hooks:                       Visiting Functions.  (line 102)
* find-file-name-handler:                Magic File Names.    (line 105)
* find-file-noselect:                    Visiting Functions.  (line  35)
* find-file-not-found-hooks:             Visiting Functions.  (line 111)
* find-file-other-window:                Visiting Functions.  (line  77)
* find-file-read-only:                   Visiting Functions.  (line  85)
* find-operation-coding-system:          Default Coding Systems.
                                                              (line  83)
* first-change-hook:                     Change Hooks.        (line  93)
* fixup-whitespace:                      User-Level Deletion. (line  64)
* float:                                 Numeric Conversions. (line   9)
* floatp:                                Predicates on Numbers.
                                                              (line  15)
* floats-consed:                         Memory Usage.        (line  17)
* floor:                                 Numeric Conversions. (line  20)
* fmakunbound:                           Function Cells.      (line  51)
* focus-follows-mouse:                   Input Focus.         (line  88)
* following-char:                        Near Point.          (line  29)
* font-lock-beginning-of-syntax-function: Other Font Lock Variables.
                                                              (line  23)
* font-lock-builtin-face:                Faces for Font Lock. (line  26)
* font-lock-comment-face:                Faces for Font Lock. (line  16)
* font-lock-constant-face:               Faces for Font Lock. (line  41)
* font-lock-defaults:                    Font Lock Basics.    (line  15)
* font-lock-function-name-face:          Faces for Font Lock. (line  29)
* font-lock-keyword-face:                Faces for Font Lock. (line  22)
* font-lock-keywords:                    Search-based Fontification.
                                                              (line  11)
* font-lock-keywords-case-fold-search:   Other Font Lock Variables.
                                                              (line  15)
* font-lock-keywords-only:               Other Font Lock Variables.
                                                              (line  10)
* font-lock-mark-block-function:         Other Font Lock Variables.
                                                              (line  40)
* font-lock-string-face:                 Faces for Font Lock. (line  19)
* font-lock-syntactic-keywords:          Syntactic Font Lock. (line  11)
* font-lock-syntax-table:                Other Font Lock Variables.
                                                              (line  19)
* font-lock-type-face:                   Faces for Font Lock. (line  37)
* font-lock-variable-name-face:          Faces for Font Lock. (line  33)
* font-lock-warning-face:                Faces for Font Lock. (line  44)
* foo:                                   A Sample Function Description.
                                                              (line  23)
* for:                                   Argument Evaluation. (line  11)
* force-mode-line-update:                Mode Line Format.    (line  31)
* format:                                Formatting Strings.  (line  19)
* format-alist:                          Format Conversion.   (line  13)
* format-find-file:                      Format Conversion.   (line 109)
* format-insert-file:                    Format Conversion.   (line 118)
* format-time-string:                    Time Conversion.     (line  24)
* format-write-file:                     Format Conversion.   (line 103)
* forward-char:                          Character Motion.    (line  28)
* forward-comment:                       Parsing Expressions. (line 124)
* forward-line:                          Text Lines.          (line  56)
* forward-list:                          List Motion.         (line  17)
* forward-sexp:                          List Motion.         (line  33)
* forward-to-indentation:                Motion by Indent.    (line  19)
* forward-word:                          Word Motion.         (line  11)
* frame-background-mode:                 Defining Faces.      (line  82)
* frame-char-height:                     Size and Position.   (line  42)
* frame-char-width:                      Size and Position.   (line  43)
* frame-height:                          Size and Position.   (line  26)
* frame-list:                            Finding All Frames.  (line   7)
* frame-live-p:                          Deleting Frames.     (line  18)
* frame-parameters:                      Parameter Access.    (line   9)
* frame-pixel-height:                    Size and Position.   (line  37)
* frame-pixel-width:                     Size and Position.   (line  38)
* frame-selected-window:                 Frames and Windows.  (line  30)
* frame-title-format:                    Frame Titles.        (line  17)
* frame-top-window:                      Frames and Windows.  (line  20)
* frame-update-face-colors:              Face Functions.      (line 134)
* frame-visible-p:                       Visibility of Frames.
                                                              (line  30)
* frame-width:                           Size and Position.   (line  27)
* framep:                                Frames.              (line  22)
* fround:                                Rounding Operations. (line  26)
* fset:                                  Function Cells.      (line  66)
* ftp-login:                             Cleanups.            (line  57)
* ftruncate:                             Rounding Operations. (line  22)
* funcall:                               Calling Functions.   (line  25)
* funcallとデバッグ:                     Internals of Debugger.
                                                              (line  60)
* function:                              Anonymous Functions. (line  85)
* function-key-map:                      Translating Input.   (line  85)
* functionp:                             What Is a Function.  (line  81)
* fundamental-mode:                      Auto Major Mode.     (line  12)
* fundamental-mode-abbrev-table:         Standard Abbrev Tables.
                                                              (line  20)
* fundamental-mode-map:                  Standard Keymaps.    (line  85)
* gap-position:                          Buffer Gap.          (line  19)
* gap-size:                              Buffer Gap.          (line  22)
* garbage-collect:                       Garbage Collection.  (line  61)
* garbage-collection-messages:           Garbage Collection.  (line 130)
* gc-cons-threshold:                     Garbage Collection.  (line 135)
* general-holidays:                      Holiday Customizing. (line  17)
* generate-new-buffer:                   Creating Buffers.    (line  34)
* generate-new-buffer-name:              Buffer Names.        (line  74)
* get:                                   Symbol Plists.       (line  23)
* get-buffer:                            Buffer Names.        (line  58)
* get-buffer-create:                     Creating Buffers.    (line  18)
* get-buffer-process:                    Process Buffers.     (line  55)
* get-buffer-window:                     Buffers and Windows. (line  32)
* get-buffer-window-list:                Buffers and Windows. (line  57)
* get-char-property:                     Examining Properties.
                                                              (line  26)
* get-file-buffer:                       Buffer File Name.    (line  59)
* get-file-char:                         Input Streams.       (line 134)
* get-largest-window:                    Selecting Windows.   (line  68)
* get-lru-window:                        Selecting Windows.   (line  41)
* get-process:                           Process Information. (line  21)
* get-register:                          Registers.           (line  53)
* get-text-property:                     Examining Properties.
                                                              (line  18)
* get-unused-category:                   Categories.          (line  47)
* getenv:                                System Environment.  (line  99)
* global-abbrev-table:                   Standard Abbrev Tables.
                                                              (line  10)
* global-key-binding:                    Functions for Key Lookup.
                                                              (line  74)
* global-map:                            Active Keymaps.      (line  73)
* global-mode-string:                    Mode Line Variables. (line  42)
* global-set-key:                        Key Binding Commands.
                                                              (line  31)
* global-unset-key:                      Key Binding Commands.
                                                              (line  39)
* glyph-table:                           Glyphs.              (line  14)
* goto-char:                             Character Motion.    (line  10)
* goto-line:                             Text Lines.          (line  16)
* hack-local-variables:                  Auto Major Mode.     (line 163)
* handle-switch-frame:                   Input Focus.         (line  49)
* hebrew-holidays:                       Holiday Customizing. (line   6)
* help-char:                             Help Functions.      (line  56)
* help-command:                          Help Functions.      (line  35)
* help-event-list:                       Help Functions.      (line  75)
* help-form:                             Help Functions.      (line  80)
* help-map:                              Help Functions.      (line  32)
* Helper-describe-bindings:              Help Functions.      (line 111)
* Helper-help:                           Help Functions.      (line 117)
* Helper-help-map:                       Standard Keymaps.    (line  89)
* highlight （フェイス名）:              Standard Faces.      (line  22)
* holidays-in-diary-buffer:              Diary Customizing.   (line   6)
* HOME、環境変数:                        Subprocess Creation. (line  17)
* icon-title-format:                     Frame Titles.        (line  23)
* iconify-frame:                         Visibility of Frames.
                                                              (line  26)
* iconify-frameイベント:                 Misc Events.         (line  15)
* identity:                              Calling Functions.   (line  94)
* IEEE浮動小数点数:                      Float Basics.        (line  16)
* if:                                    Conditionals.        (line  12)
* ignore:                                Calling Functions.   (line  97)
* ignored-local-variables:               Auto Major Mode.     (line  54)
* imenu-case-fold-search:                Imenu.               (line  58)
* imenu-create-index-function:           Imenu.               (line 120)
* imenu-extract-index-name-function:     Imenu.               (line 109)
* imenu-generic-expression:              Imenu.               (line  18)
* imenu-index-alist:                     Imenu.               (line 133)
* imenu-prev-index-position-function:    Imenu.               (line  98)
* imenu-syntax-alist:                    Imenu.               (line  66)
* inc:                                   Simple Macro.        (line  11)
* include-other-diary-files:             Fancy Diary Display. (line  52)
* indent-according-to-mode:              Mode-Specific Indent.
                                                              (line  25)
* indent-code-rigidly:                   Region Indent.       (line  61)
* indent-for-tab-command:                Mode-Specific Indent.
                                                              (line  29)
* indent-line-function:                  Mode-Specific Indent.
                                                              (line  12)
* indent-region:                         Region Indent.       (line  10)
* indent-region-function:                Region Indent.       (line  26)
* indent-relative:                       Relative Indent.     (line  10)
* indent-relative-maybe:                 Relative Indent.     (line  50)
* indent-rigidly:                        Region Indent.       (line  45)
* indent-tabs-mode:                      Primitive Indent.    (line  27)
* indent-to:                             Primitive Indent.    (line  16)
* indent-to-left-margin:                 Margins.             (line  75)
* indirect-function:                     Function Indirection.
                                                              (line  65)
* Info-edit-map:                         Standard Keymaps.    (line  93)
* Info-mode-map:                         Standard Keymaps.    (line  96)
* inhibit-default-init:                  Init File.           (line  51)
* inhibit-eol-conversion:                Specifying Coding Systems.
                                                              (line  50)
* inhibit-file-name-handlers:            Magic File Names.    (line  98)
* inhibit-file-name-operation:           Magic File Names.    (line 102)
* inhibit-point-motion-hooks:            Special Properties.  (line 123)
* inhibit-quit:                          Quitting.            (line  85)
* inhibit-read-only:                     Read Only Buffers.   (line  35)
* inhibit-startup-echo-area-message:     Start-up Summary.    (line  80)
* inhibit-startup-message:               Start-up Summary.    (line  70)
* init-file-user:                        User Identification. (line   7)
* initial-calendar-window-hook:          Calendar Customizing.
                                                              (line  47)
* initial-frame-alist:                   Initial Parameters.  (line  10)
* initial-major-mode:                    Auto Major Mode.     (line 101)
* input-method-alist:                    Input Methods.       (line  46)
* input-method-function:                 Reading One Event.   (line  69)
* input-pending-p:                       Event Input Misc.    (line  48)
* insert:                                Insertion.           (line  39)
* insert-abbrev-table-description:       Abbrev Tables.       (line  30)
* insert-and-inherit:                    Sticky Properties.   (line  56)
* insert-before-markers:                 Insertion.           (line  46)
* insert-before-markers-and-inherit:     Sticky Properties.   (line  60)
* insert-behind-hooks （オーバレイ属性）: Overlay Properties. (line  80)
* insert-behind-hooks （テキスト属性）:  Special Properties.  (line  88)
* insert-buffer:                         Commands for Insertion.
                                                              (line  10)
* insert-buffer-substring:               Insertion.           (line  73)
* insert-char:                           Insertion.           (line  59)
* insert-default-directory:              Reading File Names.  (line  60)
* insert-directory:                      Contents of Directories.
                                                              (line  49)
* insert-directory-program:              Contents of Directories.
                                                              (line  72)
* insert-file-contents:                  Reading from Files.  (line  13)
* insert-file-contents-literally:        Reading from Files.  (line  52)
* insert-hebrew-diary-entry:             Hebrew/Islamic Entries.
                                                              (line  72)
* insert-in-front-hooks （オーバレイ属性）: Overlay Properties.
                                                              (line  75)
* insert-in-front-hooks （テキスト属性）: Special Properties. (line  88)
* insert-islamic-diary-entry:            Hebrew/Islamic Entries.
                                                              (line  72)
* insert-monthly-hebrew-diary-entry:     Hebrew/Islamic Entries.
                                                              (line  72)
* insert-monthly-islamic-diary-entry:    Hebrew/Islamic Entries.
                                                              (line  72)
* insert-register:                       Registers.           (line  65)
* insert-yearly-hebrew-diary-entry:      Hebrew/Islamic Entries.
                                                              (line  72)
* insert-yearly-islamic-diary-entry:     Hebrew/Islamic Entries.
                                                              (line  72)
* installation-directory:                System Environment.  (line 146)
* int-to-string:                         String Conversion.   (line  53)
* intangible （オーバレイ属性）:         Overlay Properties.  (line  90)
* intangible （テキスト属性）:           Special Properties.  (line  69)
* integer-or-marker-p:                   Predicates on Markers.
                                                              (line  17)
* integerp:                              Predicates on Numbers.
                                                              (line  21)
* interactive:                           Using Interactive.   (line  10)
* interactive-p:                         Interactive Call.    (line  94)
* interactiveの使用例:                   Interactive Examples.
                                                              (line   6)
* intern:                                Creating Symbols.    (line  96)
* intern-soft:                           Creating Symbols.    (line 119)
* interpreter-mode-alist:                Auto Major Mode.     (line 150)
* interprogram-cut-function:             Low-Level Kill Ring. (line  53)
* interprogram-paste-function:           Low-Level Kill Ring. (line  36)
* interrupt-process:                     Signals to Processes.
                                                              (line  54)
* intervals-consed:                      Memory Usage.        (line  33)
* invalid-function:                      Function Indirection.
                                                              (line  23)
* invalid-read-syntax:                   Printed Representation.
                                                              (line  30)
* invalid-regexp:                        Syntax of Regexps.   (line 298)
* inverse-video:                         Inverse Video.       (line   7)
* invert-face:                           Face Functions.      (line  76)
* invisible （オーバレイ属性）:          Overlay Properties.  (line  85)
* invisible （テキスト属性）:            Special Properties.  (line  64)
* invocation-directory:                  System Environment.  (line 142)
* invocation-name:                       System Environment.  (line 138)
* isearch-mode-map:                      Standard Keymaps.    (line  99)
* islamic-holidays:                      Holiday Customizing. (line   6)
* italic （フェイス名）:                 Standard Faces.      (line  34)
* iメニュー:                             Imenu.               (line   6)
* just-one-space:                        User-Level Deletion. (line  94)
* justify-current-line:                  Filling.             (line  99)
* kept-new-versions:                     Numbered Backups.    (line  31)
* kept-old-versions:                     Numbered Backups.    (line  36)
* key-binding:                           Functions for Key Lookup.
                                                              (line  54)
* key-description:                       Describing Characters.
                                                              (line  12)
* key-translation-map:                   Translating Input.   (line 119)
* keyboard-coding-system:                Terminal I/O Encoding.
                                                              (line  13)
* keyboard-quit:                         Quitting.            (line  90)
* keyboard-translate:                    Translating Input.   (line  76)
* keyboard-translate-table:              Translating Input.   (line  43)
* keymap-parent:                         Inheritance and Keymaps.
                                                              (line  29)
* keymapp:                               Format of Keymaps.   (line  84)
* keyword-symbols-constant-flag:         Constant Variables.  (line  21)
* kill-all-local-variables:              Creating Buffer-Local.
                                                              (line 124)
* kill-append:                           Low-Level Kill Ring. (line  30)
* kill-buffer:                           Killing Buffers.     (line  35)
* kill-buffer-hook:                      Killing Buffers.     (line  73)
* kill-buffer-query-functions:           Killing Buffers.     (line  65)
* kill-emacs:                            Killing Emacs.       (line  11)
* kill-emacs-hook:                       Killing Emacs.       (line  35)
* kill-emacs-query-functions:            Killing Emacs.       (line  28)
* kill-local-variable:                   Creating Buffer-Local.
                                                              (line 105)
* kill-new:                              Low-Level Kill Ring. (line  25)
* kill-process:                          Signals to Processes.
                                                              (line  63)
* kill-read-only-ok:                     Kill Functions.      (line  30)
* kill-region:                           Kill Functions.      (line  17)
* kill-ring:                             Internals of Kill Ring.
                                                              (line  54)
* kill-ring-max:                         Internals of Kill Ring.
                                                              (line  64)
* kill-ring-yank-pointer:                Internals of Kill Ring.
                                                              (line  58)
* lambda、キーマップ:                    Key Lookup.          (line  67)
* lambda、デバッグ:                      Invoking the Debugger.
                                                              (line  31)
* last-abbrev:                           Abbrev Expansion.    (line  59)
* last-abbrev-location:                  Abbrev Expansion.    (line  66)
* last-abbrev-text:                      Abbrev Expansion.    (line  71)
* last-coding-system-used:               Encoding and I/O.    (line  39)
* last-command:                          Command Loop Info.   (line  10)
* last-command-char:                     Command Loop Info.   (line  83)
* last-command-event:                    Command Loop Info.   (line  82)
* last-event-frame:                      Command Loop Info.   (line  97)
* last-input-char:                       Event Input Misc.    (line  54)
* last-input-event:                      Event Input Misc.    (line  53)
* last-kbd-macro:                        Keyboard Macros.     (line  50)
* last-nonmenu-event:                    Command Loop Info.   (line  74)
* last-prefix-arg:                       Prefix Command Arguments.
                                                              (line  96)
* left-margin:                           Margins.             (line  82)
* length:                                Sequence Functions.  (line  16)
* let:                                   Local Variables.     (line  58)
* let*:                                  Local Variables.     (line  79)
* line-move-ignore-invisible:            Invisible Text.      (line  85)
* lisp-interaction-mode-map:             Standard Keymaps.    (line 107)
* lisp-mode-abbrev-table:                Standard Abbrev Tables.
                                                              (line  30)
* lisp-mode-map:                         Standard Keymaps.    (line 110)
* lisp-mode.el:                          Example Major Modes. (line  54)
* Lispの入れ子のエラー:                  Eval.                (line  78)
* Lispの大文字小文字変換:                Case Conversion.     (line   6)
* Lispの歴史:                            Lisp History.        (line   6)
* Lispオブジェクト:                      Lisp Data Types.     (line   6)
* Lispデバッガ:                          Debugger.            (line   6)
* Lispプリンタ:                          Output Functions.    (line  43)
* Lispライブラリ:                        Loading.             (line   6)
* Lispリーダ:                            Streams Intro.       (line   6)
* Lisp式単位の移動:                      List Motion.         (line   6)
* list:                                  Building Lists.      (line  35)
* list-buffers-directory:                Buffer File Name.    (line  99)
* list-diary-entries-hook:               Fancy Diary Display. (line  52)
* list-hebrew-diary-entries:             Hebrew/Islamic Entries.
                                                              (line  14)
* list-islamic-diary-entries:            Hebrew/Islamic Entries.
                                                              (line  19)
* list-processes:                        Process Information. (line  10)
* listify-key-sequence:                  Event Input Misc.    (line  36)
* listp:                                 List-related Predicates.
                                                              (line  27)
* ln:                                    Changing Files.      (line 104)
* load:                                  How Programs Do Loading.
                                                              (line  18)
* load-average:                          System Environment.  (line 153)
* load-file:                             How Programs Do Loading.
                                                              (line  84)
* load-history:                          Unloading.           (line  44)
* load-in-progress:                      How Programs Do Loading.
                                                              (line  95)
* load-library:                          How Programs Do Loading.
                                                              (line  91)
* load-path:                             Library Search.      (line  10)
* load-read-function:                    How Programs Do Loading.
                                                              (line  99)
* loadhist-special-hooks:                Unloading.           (line  70)
* loadup.el:                             Building Emacs.      (line  17)
* local-abbrev-table:                    Standard Abbrev Tables.
                                                              (line  16)
* local-holidays:                        Holiday Customizing. (line  20)
* local-key-binding:                     Functions for Key Lookup.
                                                              (line  67)
* local-map （オーバレイ属性）:          Overlay Properties.  (line 125)
* local-map （テキスト属性）:            Special Properties.  (line  37)
* local-set-key:                         Key Binding Commands.
                                                              (line  59)
* local-unset-key:                       Key Binding Commands.
                                                              (line  67)
* local-variable-p:                      Creating Buffer-Local.
                                                              (line  72)
* local-write-file-hooks:                Saving Buffers.      (line  91)
* locate-library:                        Library Search.      (line 105)
* lock-buffer:                           File Locks.          (line  31)
* log:                                   Math Functions.      (line  32)
* log10:                                 Math Functions.      (line  37)
* logand:                                Bitwise Operations.  (line 127)
* logb:                                  Float Basics.        (line  42)
* logior:                                Bitwise Operations.  (line 161)
* lognot:                                Bitwise Operations.  (line 197)
* logxor:                                Bitwise Operations.  (line 179)
* looking-at:                            Regexp Search.       (line 110)
* lookup-key:                            Functions for Key Lookup.
                                                              (line   9)
* lookup-keyにおける小文字への変換:      Key Sequence Input.  (line  48)
* lower-frame:                           Raising and Lowering.
                                                              (line  32)
* lsh:                                   Bitwise Operations.  (line  15)
* M-g:                                   Prefix Keys.         (line  50)
* M-x:                                   Interactive Call.    (line  80)
* Maclisp:                               Lisp History.        (line  11)
* macroexpand:                           Expansion.           (line  35)
* mail-host-address:                     System Environment.  (line  90)
* major-mode:                            Mode Help.           (line  21)
* make-abbrev-table:                     Abbrev Tables.       (line   9)
* make-auto-save-file-name:              Auto-Saving.         (line  61)
* make-backup-file-name:                 Backup Names.        (line  37)
* make-backup-file-name-function:        Making Backups.      (line  87)
* make-backup-files:                     Making Backups.      (line  22)
* make-bool-vector:                      Bool-Vectors.        (line  18)
* make-byte-code:                        Byte-Code Objects.   (line  55)
* make-category-set:                     Categories.          (line  72)
* make-char:                             Splitting Characters.
                                                              (line  44)
* make-char-table:                       Char-Tables.         (line  36)
* make-directory:                        Create/Delete Dirs.  (line  12)
* make-display-table:                    Display Table Format.
                                                              (line  10)
* make-face:                             Face Functions.      (line  12)
* make-frame:                            Creating Frames.     (line   9)
* make-frame-invisible:                  Visibility of Frames.
                                                              (line  22)
* make-frame-on-display:                 Multiple Displays.   (line  34)
* make-frame-visible:                    Visibility of Frames.
                                                              (line  18)
* make-frame-visibleイベント:            Misc Events.         (line  23)
* make-help-screen:                      Help Functions.      (line 132)
* make-indirect-buffer:                  Indirect Buffers.    (line  31)
* make-keymap:                           Creating Keymaps.    (line   9)
* make-list:                             Building Lists.      (line  47)
* make-local-hook:                       Hooks.               (line 134)
* make-local-variable:                   Creating Buffer-Local.
                                                              (line   7)
* make-marker:                           Creating Markers.    (line  12)
* make-overlay:                          Managing Overlays.   (line  11)
* make-sparse-keymap:                    Creating Keymaps.    (line  24)
* make-string:                           Creating Strings.    (line  10)
* make-symbol:                           Creating Symbols.    (line  83)
* make-symbolic-link:                    Changing Files.      (line 104)
* make-syntax-table:                     Syntax Table Functions.
                                                              (line   9)
* make-temp-name:                        Unique File Names.   (line  24)
* make-translation-table:                Translation of Characters.
                                                              (line  13)
* make-variable-buffer-local:            Creating Buffer-Local.
                                                              (line  46)
* make-variable-frame-local:             Frame-Local Variables.
                                                              (line  19)
* make-vector:                           Vector Functions.    (line  25)
* makunbound:                            Void Variables.      (line  20)
* map-char-table:                        Char-Tables.         (line 118)
* map-y-or-n-p:                          Multiple Queries.    (line  12)
* mapatoms:                              Creating Symbols.    (line 142)
* mapcar:                                Mapping Functions.   (line  19)
* mapconcat:                             Mapping Functions.   (line  53)
* mark:                                  The Mark.            (line  51)
* mark-active:                           The Mark.            (line 145)
* mark-diary-entries-hook:               Fancy Diary Display. (line  52)
* mark-diary-entries-in-calendar:        Calendar Customizing.
                                                              (line  22)
* mark-even-if-inactive:                 The Mark.            (line 126)
* mark-hebrew-diary-entries:             Hebrew/Islamic Entries.
                                                              (line  14)
* mark-holidays-in-calendar:             Calendar Customizing.
                                                              (line  29)
* mark-included-diary-files:             Fancy Diary Display. (line  52)
* mark-islamic-diary-entries:            Hebrew/Islamic Entries.
                                                              (line  19)
* mark-marker:                           The Mark.            (line  58)
* mark-ring:                             The Mark.            (line 156)
* mark-ring-max:                         The Mark.            (line 165)
* marker-buffer:                         Information from Markers.
                                                              (line  13)
* marker-insertion-type:                 Marker Insertion Types.
                                                              (line  22)
* marker-position:                       Information from Markers.
                                                              (line   9)
* markerp:                               Predicates on Markers.
                                                              (line  11)
* match-beginning:                       Simple Match Data.   (line  46)
* match-data:                            Entire Match Data.   (line  10)
* match-end:                             Simple Match Data.   (line  56)
* match-string:                          Simple Match Data.   (line  27)
* match-string-no-properties:            Simple Match Data.   (line  42)
* max:                                   Comparison of Numbers.
                                                              (line  73)
* max-lisp-eval-depth:                   Eval.                (line  72)
* max-specpdl-size:                      Local Variables.     (line 111)
* member:                                Sets And Lists.      (line  75)
* memory-limit:                          Garbage Collection.  (line 160)
* memq:                                  Sets And Lists.      (line  18)
* menu-bar-edit-menu:                    Standard Keymaps.    (line 113)
* menu-bar-files-menu:                   Standard Keymaps.    (line 116)
* menu-bar-final-items:                  Menu Bar.            (line  71)
* menu-bar-help-menu:                    Standard Keymaps.    (line 119)
* menu-bar-mule-menu:                    Standard Keymaps.    (line 122)
* menu-bar-search-menu:                  Standard Keymaps.    (line 125)
* menu-bar-tools-menu:                   Standard Keymaps.    (line 128)
* menu-bar-update-hook:                  Menu Bar.            (line  81)
* menu-item:                             Extended Menu Items. (line   6)
* menu-prompt-more-char:                 Keyboard Menus.      (line  25)
* message:                               The Echo Area.       (line  22)
* message-box:                           The Echo Area.       (line  58)
* message-log-max:                       The Echo Area.       (line  85)
* message-or-box:                        The Echo Area.       (line  44)
* meta-prefix-char:                      Functions for Key Lookup.
                                                              (line  98)
* min:                                   Comparison of Numbers.
                                                              (line  83)
* minibuffer-allow-text-properties:      Text from Minibuffer.
                                                              (line 114)
* minibuffer-auto-raise:                 Raising and Lowering.
                                                              (line  36)
* minibuffer-complete:                   Completion Commands. (line  68)
* minibuffer-complete-and-exit:          Completion Commands. (line  71)
* minibuffer-complete-word:              Completion Commands. (line  63)
* minibuffer-completion-confirm:         Completion Commands. (line  79)
* minibuffer-completion-help:            Completion Commands. (line  85)
* minibuffer-completion-predicate:       Completion Commands. (line  58)
* minibuffer-completion-table:           Completion Commands. (line  51)
* minibuffer-depth:                      Minibuffer Misc.     (line  88)
* minibuffer-exit-hook:                  Minibuffer Misc.     (line  45)
* minibuffer-frame-alist:                Initial Parameters.  (line  41)
* minibuffer-help-form:                  Minibuffer Misc.     (line  49)
* minibuffer-history:                    Minibuffer History.  (line  49)
* minibuffer-local-completion-map:       Completion Commands. (line  10)
* minibuffer-local-map:                  Text from Minibuffer.
                                                              (line 124)
* minibuffer-local-must-match-map:       Completion Commands. (line  27)
* minibuffer-local-ns-map:               Text from Minibuffer.
                                                              (line 167)
* minibuffer-prompt:                     Minibuffer Misc.     (line  34)
* minibuffer-prompt-width:               Minibuffer Misc.     (line  38)
* minibuffer-scroll-window:              Minibuffer Misc.     (line  79)
* minibuffer-setup-hook:                 Minibuffer Misc.     (line  42)
* minibuffer-window:                     Minibuffer Misc.     (line  58)
* minibuffer-window-active-p:            Minibuffer Misc.     (line  75)
* minor-mode-alist:                      Mode Line Variables. (line  57)
* minor-mode-key-binding:                Functions for Key Lookup.
                                                              (line  81)
* minor-mode-map-alist:                  Active Keymaps.      (line 125)
* minor-mode-overriding-map-alist:       Active Keymaps.      (line 152)
* misc-objects-consed:                   Memory Usage.        (line  29)
* mod:                                   Arithmetic Operations.
                                                              (line 136)
* mode-class属性:                        Major Mode Conventions.
                                                              (line 137)
* mode-line-buffer-identification:       Mode Line Variables. (line  37)
* mode-line-format:                      Mode Line Data.      (line  14)
* mode-line-format、シェルモード:        Mode Line Data.      (line  79)
* mode-line-frame-identification:        Mode Line Variables. (line  30)
* mode-line-inverse-video:               Inverse Video.       (line  13)
* mode-line-modified:                    Mode Line Variables. (line  18)
* mode-line-mule-info:                   Mode Line Variables. (line  13)
* mode-line-process:                     Mode Line Variables. (line  85)
* mode-name:                             Mode Line Variables. (line  52)
* mode-specific-map:                     Prefix Keys.         (line  23)
* modeline （フェイス名）:               Standard Faces.      (line  12)
* modification-hooks （オーバレイ属性）: Overlay Properties.  (line  56)
* modification-hooks （テキスト属性）:   Special Properties.  (line  80)
* modify-category-entry:                 Categories.          (line 100)
* modify-frame-parameters:               Parameter Access.    (line  13)
* modify-syntax-entry:                   Syntax Table Functions.
                                                              (line  23)
* momentary-string-display:              Temporary Displays.  (line  66)
* mouse-face （オーバレイ属性）:         Overlay Properties.  (line  52)
* mouse-face （テキスト属性）:           Special Properties.  (line  31)
* mouse-movement-p:                      Classifying Events.  (line  83)
* mouse-pixel-position:                  Mouse Position.      (line  23)
* mouse-position:                        Mouse Position.      (line  10)
* mouse-wheelイベント:                   Misc Events.         (line  30)
* move-marker:                           Moving Markers.      (line  35)
* move-overlay:                          Managing Overlays.   (line  40)
* move-to-column:                        Columns.             (line  28)
* move-to-left-margin:                   Margins.             (line  59)
* move-to-window-line:                   Screen Lines.        (line  45)
* movemail:                              Subprocess Creation. (line  57)
* MS-DOSとファイルモード:                Changing Files.      (line 134)
* MS-DOSのファイル型:                    MS-DOS File Types.   (line   6)
* mule-keymap:                           Prefix Keys.         (line  35)
* multibyte-string-p:                    Text Representations.
                                                              (line  55)
* multiple-frames:                       Frame Titles.        (line  28)
* NaN（非数値）:                         Float Basics.        (line  16)
* narrow-to-page:                        Narrowing.           (line  33)
* narrow-to-region:                      Narrowing.           (line  26)
* natnump:                               Predicates on Numbers.
                                                              (line  34)
* nconc:                                 Rearrangement.       (line  16)
* negative-argument:                     Prefix Command Arguments.
                                                              (line 112)
* network-coding-system-alist:           Default Coding Systems.
                                                              (line  65)
* newline:                               Commands for Insertion.
                                                              (line  37)
* newline-and-indent:                    Mode-Specific Indent.
                                                              (line  36)
* next-char-property-change:             Property Search.     (line  81)
* next-frame:                            Finding All Frames.  (line  19)
* next-history-element:                  Minibuffer Misc.     (line  22)
* next-matching-history-element:         Minibuffer Misc.     (line  30)
* next-overlay-change:                   Managing Overlays.   (line  70)
* next-property-change:                  Property Search.     (line  26)
* next-screen-context-lines:             Vertical Scrolling.  (line 112)
* next-single-property-change:           Property Search.     (line  53)
* next-window:                           Cyclic Window Ordering.
                                                              (line  23)
* nil:                                   Constant Variables.  (line   6)
* nil、キーマップ:                       Key Lookup.          (line  40)
* nil、リスト:                           Cons Cell Type.      (line  82)
* nilとリスト:                           Cons Cells.          (line   6)
* nilの使い方:                           nil and t.           (line   6)
* nil入力ストリーム:                     Input Streams.       (line  43)
* nil出力ストリーム:                     Output Streams.      (line  29)
* nlistp:                                List-related Predicates.
                                                              (line  36)
* no-catch:                              Catch and Throw.     (line  87)
* no-redraw-on-reenter:                  Refresh Screen.      (line  28)
* nonascii-insert-offset:                Converting Representations.
                                                              (line  49)
* nonascii-translation-table:            Converting Representations.
                                                              (line  60)
* nongregorian-diary-listing-hook:       Hebrew/Islamic Entries.
                                                              (line  14)
* nongregorian-diary-marking-hook:       Hebrew/Islamic Entries.
                                                              (line  14)
* noninteractive:                        Batch Mode.          (line  22)
* normal-auto-fill-function:             Auto Filling.        (line  32)
* normal-backup-enable-predicate:        Making Backups.      (line  46)
* normal-mode:                           Auto Major Mode.     (line  22)
* not:                                   Combining Conditions.
                                                              (line  11)
* not-modified:                          Buffer Modification. (line  41)
* nreverse:                              Rearrangement.       (line  64)
* nth:                                   List Elements.       (line  63)
* nthcdr:                                List Elements.       (line  82)
* null:                                  List-related Predicates.
                                                              (line  42)
* num-input-keys:                        Key Sequence Input.  (line  82)
* num-nonmacro-input-events:             Key Sequence Input.  (line  88)
* number-of-diary-entries:               Diary Customizing.   (line  13)
* number-or-marker-p:                    Predicates on Markers.
                                                              (line  21)
* number-to-string:                      String Conversion.   (line  42)
* numberp:                               Predicates on Numbers.
                                                              (line  25)
* obarray:                               Creating Symbols.    (line 139)
* obarray（オブジェクト配列）:           Creating Symbols.    (line  11)
* occur-mode-map:                        Standard Keymaps.    (line 139)
* one-window-p:                          Splitting Windows.   (line 128)
* only-global-abbrevs:                   Defining Abbrevs.    (line  44)
* open-dribble-file:                     Recording Input.     (line  17)
* open-network-stream:                   Network.             (line  25)
* open-termscript:                       Terminal Output.     (line  50)
* optional引数:                          Argument List.       (line  18)
* or:                                    Combining Conditions.
                                                              (line  54)
* other-buffer:                          The Buffer List.     (line  64)
* other-holidays:                        Holiday Customizing. (line  34)
* other-window:                          Cyclic Window Ordering.
                                                              (line  82)
* other-window-scroll-buffer:            Vertical Scrolling.  (line  79)
* overlay-arrow-position:                Overlay Arrow.       (line  16)
* overlay-arrow-string:                  Overlay Arrow.       (line  12)
* overlay-buffer:                        Managing Overlays.   (line  28)
* overlay-end:                           Managing Overlays.   (line  25)
* overlay-get:                           Overlay Properties.  (line 134)
* overlay-put:                           Overlay Properties.  (line 141)
* overlay-start:                         Managing Overlays.   (line  22)
* overlays-at:                           Managing Overlays.   (line  54)
* overlays-in:                           Managing Overlays.   (line  60)
* overriding-local-map:                  Active Keymaps.      (line 166)
* overriding-local-map-menu-flag:        Active Keymaps.      (line 182)
* overriding-terminal-local-map:         Active Keymaps.      (line 173)
* overwrite-mode:                        Commands for Insertion.
                                                              (line  63)
* page-delimiter:                        Standard Regexps.    (line  10)
* paragraph-separate:                    Standard Regexps.    (line  24)
* paragraph-start:                       Standard Regexps.    (line  30)
* parse-partial-sexp:                    Parsing Expressions. (line  16)
* parse-sexp-ignore-comments:            Parsing Expressions. (line 111)
* parse-sexp-lookup-properties:          Syntax Properties.   (line  25)
* path-separator:                        System Environment.  (line 132)
* PATH、環境変数:                        Subprocess Creation. (line  17)
* peculiarエラー:                        Error Symbols.       (line  33)
* perform-replace:                       Search and Replace.  (line   8)
* plist-get:                             Other Plists.        (line   9)
* plist-put:                             Other Plists.        (line  16)
* plist（属性リスト）:                   Property Lists.      (line   6)
* point:                                 Point.               (line  35)
* point-entered （テキスト属性）:        Special Properties.  (line 100)
* point-left （テキスト属性）:           Special Properties.  (line 100)
* point-marker:                          Creating Markers.    (line  18)
* point-max:                             Point.               (line  47)
* point-max-marker:                      Creating Markers.    (line  28)
* point-min:                             Point.               (line  41)
* point-min-marker:                      Creating Markers.    (line  23)
* pop-mark:                              The Mark.            (line 111)
* pop-to-buffer:                         Displaying Buffers.  (line  68)
* pop-up-frame-alist:                    Choosing Window.     (line  92)
* pop-up-frame-function:                 Choosing Window.     (line  83)
* pop-up-frames:                         Choosing Window.     (line  68)
* pop-up-windows:                        Choosing Window.     (line  53)
* pos-visible-in-window-p:               Window Start.        (line 107)
* posix-looking-at:                      POSIX Regexps.       (line  30)
* posix-search-backward:                 POSIX Regexps.       (line  26)
* posix-search-forward:                  POSIX Regexps.       (line  21)
* posix-string-match:                    POSIX Regexps.       (line  34)
* posn-col-row:                          Accessing Events.    (line  43)
* posn-point:                            Accessing Events.    (line  37)
* posn-timestamp:                        Accessing Events.    (line  48)
* posn-window:                           Accessing Events.    (line  34)
* posn-x-y:                              Accessing Events.    (line  40)
* post-command-hook:                     Command Overview.    (line  50)
* pre-abbrev-expand-hook:                Abbrev Expansion.    (line  78)
* pre-command-hook:                      Command Overview.    (line  45)
* preceding-char:                        Near Point.          (line  52)
* prefix-arg:                            Prefix Command Arguments.
                                                              (line  91)
* prefix-help-command:                   Help Functions.      (line  94)
* prefix-numeric-value:                  Prefix Command Arguments.
                                                              (line  79)
* previous-char-property-change:         Property Search.     (line  89)
* previous-frame:                        Finding All Frames.  (line  43)
* previous-history-element:              Minibuffer Misc.     (line  18)
* previous-matching-history-element:     Minibuffer Misc.     (line  26)
* previous-overlay-change:               Managing Overlays.   (line  74)
* previous-property-change:              Property Search.     (line  68)
* previous-single-property-change:       Property Search.     (line  75)
* previous-window:                       Cyclic Window Ordering.
                                                              (line  77)
* primitive-undo:                        Undo.                (line  87)
* prin1:                                 Output Functions.    (line  60)
* prin1-to-string:                       Output Functions.    (line  94)
* princ:                                 Output Functions.    (line  72)
* print:                                 Output Functions.    (line  43)
* print-diary-entries:                   Diary Customizing.   (line  25)
* print-diary-entries-hook:              Diary Customizing.   (line  25)
* print-escape-multibyte:                Output Variables.    (line  47)
* print-escape-newlines:                 Output Variables.    (line  11)
* print-escape-nonascii:                 Output Variables.    (line  36)
* print-help-return-message:             Help Functions.      (line  43)
* print-length:                          Output Variables.    (line  58)
* print-level:                           Output Variables.    (line  72)
* printの例:                             Output Streams.      (line  46)
* priority （オーバレイ属性）:           Overlay Properties.  (line  20)
* process-buffer:                        Process Buffers.     (line  24)
* process-coding-system:                 Process Information. (line 110)
* process-coding-system-alist:           Default Coding Systems.
                                                              (line  39)
* process-command:                       Process Information. (line  29)
* process-connection-type:               Asynchronous Processes.
                                                              (line  72)
* process-contact:                       Process Information. (line  49)
* process-environment:                   System Environment.  (line 120)
* process-exit-status:                   Process Information. (line  98)
* process-filter:                        Filter Functions.    (line  93)
* process-id:                            Process Information. (line  38)
* process-kill-without-query:            Deleting Processes.  (line  36)
* process-list:                          Process Information. (line  15)
* process-mark:                          Process Buffers.     (line  30)
* process-name:                          Process Information. (line  46)
* process-send-eof:                      Input to Processes.  (line  59)
* process-send-region:                   Input to Processes.  (line  48)
* process-send-string:                   Input to Processes.  (line  28)
* process-sentinel:                      Sentinels.           (line  73)
* process-status:                        Process Information. (line  54)
* process-tty-name:                      Process Information. (line 104)
* processp:                              Processes.           (line  27)
* profile.el:                            Compilation Tips.    (line   8)
* prog1:                                 Sequencing.          (line  48)
* prog2:                                 Sequencing.          (line  64)
* progn:                                 Sequencing.          (line  33)
* provide:                               Named Features.      (line  73)
* pure-bytes-used:                       Pure Storage.        (line  40)
* purecopy:                              Pure Storage.        (line  29)
* purify-flag:                           Pure Storage.        (line  46)
* push-mark:                             The Mark.            (line 100)
* put:                                   Symbol Plists.       (line  34)
* put-text-property:                     Changing Properties. (line  20)
* query-replace-history:                 Minibuffer History.  (line  52)
* query-replace-map:                     Search and Replace.  (line  32)
* quietly-read-abbrev-file:              Abbrev Files.        (line  20)
* quit-flag:                             Quitting.            (line  79)
* quit-process:                          Signals to Processes.
                                                              (line  69)
* quote:                                 Quoting.             (line  13)
* quoted-insertの抑制:                   Changing Key Bindings.
                                                              (line 153)
* raise-frame:                           Raising and Lowering.
                                                              (line  28)
* random:                                Random Numbers.      (line  27)
* rassoc:                                Association Lists.   (line  90)
* rassq:                                 Association Lists.   (line 124)
* re-search-backward:                    Regexp Search.       (line  63)
* re-search-forward:                     Regexp Search.       (line  20)
* read:                                  Input Functions.     (line  16)
* read-buffer:                           High-Level Completion.
                                                              (line  15)
* read-buffer-function:                  High-Level Completion.
                                                              (line  47)
* read-char:                             Reading One Event.   (line  44)
* read-coding-system:                    User-Chosen Coding Systems.
                                                              (line  30)
* read-command:                          High-Level Completion.
                                                              (line  54)
* read-event:                            Reading One Event.   (line   9)
* read-expression-history:               Minibuffer History.  (line  70)
* read-file-name:                        Reading File Names.  (line  12)
* read-from-minibuffer:                  Text from Minibuffer.
                                                              (line  18)
* read-from-string:                      Input Functions.     (line  21)
* read-input-method-name:                Input Methods.       (line  37)
* read-kbd-macro:                        Describing Characters.
                                                              (line  49)
* read-key-sequence:                     Key Sequence Input.  (line  13)
* read-key-sequence-vector:              Key Sequence Input.  (line  44)
* read-minibuffer:                       Object from Minibuffer.
                                                              (line   9)
* read-no-blanks-input:                  Text from Minibuffer.
                                                              (line 150)
* read-non-nil-coding-system:            User-Chosen Coding Systems.
                                                              (line  38)
* read-only （テキスト属性）:            Special Properties.  (line  49)
* read-passwd:                           Reading a Password.  (line  10)
* read-quoted-char:                      Quoted Character Input.
                                                              (line  12)
* read-quoted-charの中断:                Quitting.            (line  58)
* read-string:                           Text from Minibuffer.
                                                              (line  90)
* read-variable:                         High-Level Completion.
                                                              (line  89)
* real-last-command:                     Command Loop Info.   (line  21)
* recent-auto-save-p:                    Auto-Saving.         (line 103)
* recent-keys:                           Recording Input.     (line   7)
* recenter:                              Vertical Scrolling.  (line 118)
* recursion-depth:                       Recursive Editing.   (line 100)
* recursive-edit:                        Recursive Editing.   (line  66)
* redirect-frame-focus:                  Input Focus.         (line  56)
* redisplay-end-trigger-functions:       Window Hooks.        (line  55)
* redraw-display:                        Refresh Screen.      (line  15)
* redraw-frame:                          Refresh Screen.      (line  10)
* regexp-history:                        Minibuffer History.  (line  61)
* regexp-opt:                            Syntax of Regexps.   (line 321)
* regexp-opt-depth:                      Syntax of Regexps.   (line 340)
* regexp-quote:                          Syntax of Regexps.   (line 306)
* regexp（正規表現）:                    Regular Expressions. (line   6)
* region （フェイス名）:                 Standard Faces.      (line  15)
* region-beginning:                      The Region.          (line  11)
* region-end:                            The Region.          (line  17)
* region-face:                           Face Functions.      (line 124)
* register-alist:                        Registers.           (line  13)
* reindent-then-newline-and-indent:      Mode-Specific Indent.
                                                              (line  46)
* remove-from-invisibility-spec:         Invisible Text.      (line  65)
* remove-hook:                           Hooks.               (line 126)
* remove-text-properties:                Changing Properties. (line  46)
* rename-auto-save-file:                 Auto-Saving.         (line 159)
* rename-buffer:                         Buffer Names.        (line  40)
* rename-file:                           Changing Files.      (line  66)
* replace-buffer-in-windows:             Displaying Buffers.  (line 112)
* replace-match:                         Replacing Match.     (line  10)
* require:                               Named Features.      (line  97)
* require-final-newline:                 Saving Buffers.      (line 137)
* requireによるロードエラー:             Named Features.      (line  24)
* rest引数:                              Argument List.       (line  18)
* reverse:                               Building Lists.      (line 154)
* revert-buffer:                         Reverting.           (line  11)
* revert-buffer-function:                Reverting.           (line  52)
* revert-buffer-insert-file-contents-function: Reverting.     (line  63)
* revert-without-query:                  Reverting.           (line  41)
* ring-bell-function:                    Beeping.             (line  31)
* rm:                                    Changing Files.      (line  92)
* round:                                 Numeric Conversions. (line  30)
* rplaca:                                Modifying Lists.     (line  10)
* rplacd:                                Modifying Lists.     (line  10)
* run-at-time:                           Timers.              (line  18)
* run-hook-with-args:                    Hooks.               (line  79)
* run-hook-with-args-until-failure:      Hooks.               (line  83)
* run-hook-with-args-until-success:      Hooks.               (line  91)
* run-hooks:                             Hooks.               (line  61)
* run-with-idle-timer:                   Timers.              (line  89)
* safe-length:                           List Elements.       (line  97)
* same-window-buffer-names:              Choosing Window.     (line 150)
* same-window-regexps:                   Choosing Window.     (line 155)
* save-abbrevs:                          Abbrev Files.        (line  29)
* save-buffer:                           Saving Buffers.      (line  15)
* save-buffer-coding-system:             Encoding and I/O.    (line  32)
* save-current-buffer:                   Current Buffer.      (line 111)
* save-excursion:                        Excursions.          (line  18)
* save-match-data:                       Saving Match Data.   (line  22)
* save-restriction:                      Narrowing.           (line  52)
* save-selected-window:                  Selecting Windows.   (line  25)
* save-some-buffers:                     Saving Buffers.      (line  34)
* save-window-excursion:                 Window Configurations.
                                                              (line  55)
* scan-lists:                            Parsing Expressions. (line  78)
* scan-sexps:                            Parsing Expressions. (line  97)
* screen-height:                         Size and Position.   (line  31)
* screen-width:                          Size and Position.   (line  32)
* scroll-bar-event-ratio:                Accessing Events.    (line  53)
* scroll-bar-scale:                      Accessing Events.    (line  58)
* scroll-conservatively:                 Vertical Scrolling.  (line  90)
* scroll-down:                           Vertical Scrolling.  (line  46)
* scroll-left:                           Horizontal Scrolling.
                                                              (line  28)
* scroll-margin:                         Vertical Scrolling.  (line  83)
* scroll-other-window:                   Vertical Scrolling.  (line  57)
* scroll-preserve-screen-position:       Vertical Scrolling.  (line 107)
* scroll-right:                          Horizontal Scrolling.
                                                              (line  34)
* scroll-step:                           Vertical Scrolling.  (line 101)
* scroll-up:                             Vertical Scrolling.  (line  35)
* search-backward:                       String Search.       (line  61)
* search-failed:                         String Search.       (line  45)
* search-forward:                        String Search.       (line  18)
* secondary-selection （フェイス名）:    Standard Faces.      (line  19)
* select-frame:                          Input Focus.         (line  35)
* select-safe-coding-system:             User-Chosen Coding Systems.
                                                              (line   8)
* select-window:                         Selecting Windows.   (line  14)
* selected-frame:                        Input Focus.         (line  11)
* selected-window:                       Selecting Windows.   (line  10)
* selection-coding-system:               Window System Selections.
                                                              (line  58)
* selective-display:                     Selective Display.   (line  41)
* selective-display-ellipses:            Selective Display.   (line  85)
* self-insert-and-exit:                  Minibuffer Misc.     (line  13)
* self-insert-command:                   Commands for Insertion.
                                                              (line  15)
* self-insert-command、マイナモード:     Keymaps and Minor Modes.
                                                              (line  10)
* self-insert-commandの無効化:           Changing Key Bindings.
                                                              (line 142)
* send-string-to-terminal:               Terminal Output.     (line  37)
* sentence-end:                          Standard Regexps.    (line  35)
* sentence-end-double-space:             Filling.             (line 130)
* sequencep:                             Sequence Functions.  (line  12)
* set:                                   Setting Variables.   (line  40)
* set-auto-mode:                         Auto Major Mode.     (line  70)
* set-buffer:                            Current Buffer.      (line 102)
* set-buffer-auto-saved:                 Auto-Saving.         (line 107)
* set-buffer-major-mode:                 Auto Major Mode.     (line  92)
* set-buffer-modified-p:                 Buffer Modification. (line  30)
* set-buffer-multibyte:                  Selecting a Representation.
                                                              (line  11)
* set-case-syntax:                       Case Tables.         (line  93)
* set-case-syntax-delims:                Case Tables.         (line  90)
* set-case-syntax-pair:                  Case Tables.         (line  87)
* set-case-table:                        Case Tables.         (line  78)
* set-category-table:                    Categories.          (line  68)
* set-char-table-default:                Char-Tables.         (line  52)
* set-char-table-extra-slot:             Char-Tables.         (line  69)
* set-char-table-parent:                 Char-Tables.         (line  62)
* set-char-table-range:                  Char-Tables.         (line  95)
* set-default:                           Default Value.       (line  79)
* set-default-file-modes:                Changing Files.      (line 120)
* set-display-table-slot:                Display Table Format.
                                                              (line  70)
* set-face-background:                   Face Functions.      (line  41)
* set-face-bold-p:                       Face Functions.      (line  64)
* set-face-font:                         Face Functions.      (line  56)
* set-face-foreground:                   Face Functions.      (line  40)
* set-face-italic-p:                     Face Functions.      (line  68)
* set-face-stipple:                      Face Functions.      (line  47)
* set-face-underline-p:                  Face Functions.      (line  72)
* set-file-modes:                        Changing Files.      (line 116)
* set-frame-configuration:               Frame Configurations.
                                                              (line  15)
* set-frame-height:                      Size and Position.   (line  55)
* set-frame-position:                    Size and Position.   (line  14)
* set-frame-size:                        Size and Position.   (line  47)
* set-frame-width:                       Size and Position.   (line  69)
* set-input-method:                      Input Methods.       (line  29)
* set-input-mode:                        Input Modes.         (line   7)
* set-keyboard-coding-system:            Terminal I/O Encoding.
                                                              (line  18)
* set-keymap-parent:                     Inheritance and Keymaps.
                                                              (line  33)
* set-left-margin:                       Margins.             (line  37)
* set-mark:                              The Mark.            (line  75)
* set-marker:                            Moving Markers.      (line  13)
* set-marker-insertion-type:             Marker Insertion Types.
                                                              (line  15)
* set-match-data:                        Entire Match Data.   (line  33)
* set-mouse-pixel-position:              Mouse Position.      (line  27)
* set-mouse-position:                    Mouse Position.      (line  16)
* set-process-buffer:                    Process Buffers.     (line  50)
* set-process-coding-system:             Process Information. (line 119)
* set-process-filter:                    Filter Functions.    (line  89)
* set-process-sentinel:                  Sentinels.           (line  58)
* set-register:                          Registers.           (line  57)
* set-right-margin:                      Margins.             (line  42)
* set-screen-height:                     Size and Position.   (line  72)
* set-screen-width:                      Size and Position.   (line  72)
* set-standard-case-table:               Case Tables.         (line  68)
* set-syntax-table:                      Syntax Table Functions.
                                                              (line  88)
* set-terminal-coding-system:            Terminal I/O Encoding.
                                                              (line  28)
* set-text-properties:                   Changing Properties. (line  69)
* set-visited-file-modtime:              Modification Time.   (line  43)
* set-visited-file-name:                 Buffer File Name.    (line  73)
* set-window-buffer:                     Buffers and Windows. (line  15)
* set-window-configuration:              Window Configurations.
                                                              (line  29)
* set-window-dedicated-p:                Choosing Window.     (line 179)
* set-window-display-table:              Active Display Table.
                                                              (line  19)
* set-window-hscroll:                    Horizontal Scrolling.
                                                              (line  61)
* set-window-point:                      Window Point.        (line  50)
* set-window-redisplay-end-trigger:      Window Hooks.        (line  63)
* set-window-start:                      Window Start.        (line  53)
* setcar:                                Setcar.              (line  11)
* setcdr:                                Setcdr.              (line   9)
* setenv:                                System Environment.  (line 114)
* setplist:                              Symbol Plists.       (line  10)
* setprv:                                System Environment.  (line 177)
* setq:                                  Setting Variables.   (line  10)
* setq-default:                          Default Value.       (line  38)
* setting-constant:                      Constant Variables.  (line   6)
* shell-command-history:                 Minibuffer History.  (line  67)
* shell-command-to-string:               Synchronous Processes.
                                                              (line 169)
* shell-quote-argument:                  Shell Arguments.     (line  15)
* shrink-window:                         Resizing Windows.    (line  43)
* shrink-window-horizontally:            Resizing Windows.    (line  52)
* shrink-window-if-larger-than-buffer:   Resizing Windows.    (line  59)
* signal:                                Signaling Errors.    (line  38)
* signal-process:                        Signals to Processes.
                                                              (line  91)
* simple-diary-display:                  Fancy Diary Display. (line   6)
* sin:                                   Math Functions.      (line   9)
* single-key-description:                Describing Characters.
                                                              (line  19)
* sit-for:                               Waiting.             (line  13)
* site-init.el:                          Building Emacs.      (line  59)
* site-load.el:                          Building Emacs.      (line  45)
* site-run-file:                         Init File.           (line  34)
* site-start.el:                         Start-up Summary.    (line  29)
* skip-chars-backward:                   Skipping Characters. (line  48)
* skip-chars-forward:                    Skipping Characters. (line  11)
* skip-syntax-backward:                  Motion and Syntax.   (line  17)
* skip-syntax-forward:                   Motion and Syntax.   (line  10)
* sleep-for:                             Waiting.             (line  45)
* Snarf-documentation:                   Accessing Documentation.
                                                              (line 105)
* sort:                                  Rearrangement.       (line  98)
* sort-columns:                          Sorting.             (line 202)
* sort-diary-entries:                    Fancy Diary Display. (line  34)
* sort-fields:                           Sorting.             (line 185)
* sort-fold-case:                        Sorting.             (line 103)
* sort-lines:                            Sorting.             (line 170)
* sort-numeric-fields:                   Sorting.             (line 193)
* sort-pages:                            Sorting.             (line 180)
* sort-paragraphs:                       Sorting.             (line 175)
* sort-regexp-fields:                    Sorting.             (line 109)
* sort-subr:                             Sorting.             (line  13)
* special:                               Major Mode Conventions.
                                                              (line 137)
* special-display-buffer-names:          Choosing Window.     (line  98)
* special-display-frame-alist:           Choosing Window.     (line 146)
* special-display-function:              Choosing Window.     (line 127)
* special-display-popup-frame:           Choosing Window.     (line 134)
* special-display-regexps:               Choosing Window.     (line 114)
* special-event-map:                     Active Keymaps.      (line 195)
* split-char:                            Splitting Characters.
                                                              (line  29)
* split-height-threshold:                Choosing Window.     (line  59)
* split-line:                            Commands for Insertion.
                                                              (line  56)
* split-string:                          Creating Strings.    (line 126)
* split-window:                          Splitting Windows.   (line  16)
* split-window-horizontally:             Splitting Windows.   (line 115)
* split-window-vertically:               Splitting Windows.   (line 100)
* sqrt:                                  Math Functions.      (line  46)
* standard-case-table:                   Case Tables.         (line  72)
* standard-category-table:               Categories.          (line  59)
* standard-character-translation-table-for-decode: Translation of Characters.
                                                              (line  38)
* standard-character-translation-table-for-encode: Translation of Characters.
                                                              (line  42)
* standard-display-table:                Active Display Table.
                                                              (line  30)
* standard-input:                        Input Functions.     (line  49)
* standard-output:                       Output Variables.    (line   7)
* standard-syntax-table:                 Standard Syntax Tables.
                                                              (line  10)
* start-process:                         Asynchronous Processes.
                                                              (line  17)
* start-process-shell-command:           Asynchronous Processes.
                                                              (line  56)
* startup.el:                            Start-up Summary.    (line   6)
* stop-process:                          Signals to Processes.
                                                              (line  75)
* store-match-data:                      Entire Match Data.   (line  39)
* store-substring:                       Modifying Strings.   (line  15)
* string:                                Creating Strings.    (line  23)
* string-as-multibyte:                   Selecting a Representation.
                                                              (line  33)
* string-as-unibyte:                     Selecting a Representation.
                                                              (line  26)
* string-chars-consed:                   Memory Usage.        (line  26)
* string-equal:                          Text Comparison.     (line  37)
* string-lessp:                          Text Comparison.     (line  79)
* string-make-multibyte:                 Converting Representations.
                                                              (line  72)
* string-make-unibyte:                   Converting Representations.
                                                              (line  67)
* string-match:                          Regexp Search.       (line  81)
* string-to-char:                        String Conversion.   (line  25)
* string-to-int:                         String Conversion.   (line  80)
* string-to-number:                      String Conversion.   (line  58)
* string-width:                          Width.               (line  15)
* string<:                               Text Comparison.     (line  40)
* string=:                               Text Comparison.     (line  18)
* stringp:                               Predicates for Strings.
                                                              (line  10)
* subr:                                  What Is a Function.  (line  21)
* subrp:                                 What Is a Function.  (line  85)
* subst-char-in-region:                  Substitution.        (line  10)
* substitute-command-keys:               Keys in Documentation.
                                                              (line  37)
* substitute-in-file-name:               File Name Expansion. (line  70)
* substitute-key-definition:             Changing Key Bindings.
                                                              (line 104)
* substring:                             Creating Strings.    (line  29)
* suppress-keymap:                       Changing Key Bindings.
                                                              (line 142)
* suspend-emacs:                         Suspending Emacs.    (line  26)
* suspend-hook:                          Suspending Emacs.    (line  76)
* suspend-resume-hook:                   Suspending Emacs.    (line  79)
* switch-to-buffer:                      Displaying Buffers.  (line  25)
* switch-to-buffer-other-window:         Displaying Buffers.  (line  51)
* symbol-function:                       Function Cells.      (line  15)
* symbol-name:                           Creating Symbols.    (line  73)
* symbol-plist:                          Symbol Plists.       (line   7)
* symbol-value:                          Accessing Variables. (line  14)
* symbolp:                               Symbols.             (line  16)
* symbols-consed:                        Memory Usage.        (line  23)
* syntax-table:                          Syntax Table Functions.
                                                              (line  92)
* syntax-table （テキスト属性）:         Syntax Properties.   (line   6)
* syntax-table-p:                        Syntax Basics.       (line  44)
* system-configuration:                  System Environment.  (line  12)
* system-key-alist:                      Special Keysyms.     (line  10)
* system-name:                           System Environment.  (line  79)
* system-type:                           System Environment.  (line  18)
* S式単位の移動:                         List Motion.         (line   6)
* S式日誌項目:                           Sexp Diary Entries.  (line   6)
* t:                                     Constant Variables.  (line   6)
* tab-stop-list:                         Indent Tabs.         (line  24)
* tab-to-tab-stop:                       Indent Tabs.         (line  17)
* tab-width:                             Usual Display.       (line  59)
* tan:                                   Math Functions.      (line  11)
* TCP:                                   Network.             (line   6)
* temacs:                                Building Emacs.      (line   6)
* temp-buffer-show-function:             Temporary Displays.  (line  48)
* temp-buffer-show-hook:                 Temporary Displays.  (line  58)
* temporary-file-directory:              Unique File Names.   (line  38)
* term-file-prefix:                      Terminal-Specific.   (line  39)
* term-setup-hook:                       Terminal-Specific.   (line  51)
* Termcap:                               Terminal-Specific.   (line  20)
* terminal-coding-system:                Terminal I/O Encoding.
                                                              (line  23)
* TERM、環境変数:                        Terminal-Specific.   (line  39)
* terpri:                                Output Functions.    (line  86)
* text-char-description:                 Describing Characters.
                                                              (line  35)
* text-mode-abbrev-table:                Standard Abbrev Tables.
                                                              (line  26)
* text-mode-map:                         Standard Keymaps.    (line 148)
* text-mode-syntax-table:                Standard Syntax Tables.
                                                              (line  14)
* text-properties-at:                    Examining Properties.
                                                              (line  40)
* text-property-any:                     Property Search.     (line  94)
* text-property-not-all:                 Property Search.     (line 105)
* thing-at-point:                        Buffer Contents.     (line  55)
* this-command:                          Command Loop Info.   (line  25)
* this-command-keys:                     Command Loop Info.   (line  59)
* this-command-keys-vector:              Command Loop Info.   (line  69)
* three-step-help:                       Help Functions.      (line 156)
* throw:                                 Catch and Throw.     (line  79)
* throwの例:                             Recursive Editing.   (line  33)
* TMPDIR、環境変数:                      Unique File Names.   (line  38)
* TMP、環境変数:                         Unique File Names.   (line  38)
* today-invisible-calendar-hook:         Calendar Customizing.
                                                              (line  73)
* today-visible-calendar-hook:           Calendar Customizing.
                                                              (line  52)
* toggle-read-only:                      Read Only Buffers.   (line  50)
* top-level:                             Recursive Editing.   (line  96)
* tq-close:                              Transaction Queues.  (line  35)
* tq-create:                             Transaction Queues.  (line  13)
* tq-enqueue:                            Transaction Queues.  (line  21)
* track-mouse:                           Mouse Tracking.      (line  19)
* transient-mark-mode:                   The Mark.            (line 120)
* translate-region:                      Substitution.        (line  33)
* transpose-regions:                     Transposition.       (line  10)
* true（真）:                            nil and t.           (line  24)
* truncate:                              Numeric Conversions. (line  17)
* truncate-lines:                        Truncation.          (line  21)
* truncate-partial-width-windows:        Truncation.          (line  35)
* truncate-string-to-width:              Width.               (line  20)
* try-completion:                        Basic Completion.    (line  11)
* tty-erase-char:                        System Environment.  (line 173)
* type-of:                               Type Predicates.     (line 166)
* tと真:                                 nil and t.           (line  24)
* t入力ストリーム:                       Input Streams.       (line  38)
* t出力ストリーム:                       Output Streams.      (line  26)
* undefined:                             Functions for Key Lookup.
                                                              (line  50)
* undefined、キーマップ:                 Key Lookup.          (line 100)
* underline （フェイス名）:              Standard Faces.      (line  25)
* undo-boundary:                         Undo.                (line  64)
* undo-limit:                            Maintaining Undo.    (line  47)
* undo-strong-limit:                     Maintaining Undo.    (line  51)
* unexec:                                Building Emacs.      (line  89)
* unhandled-file-name-directory:         Magic File Names.    (line 123)
* unintern:                              Creating Symbols.    (line 161)
* universal-argument:                    Prefix Command Arguments.
                                                              (line 102)
* unless:                                Conditionals.        (line  44)
* unload-feature:                        Unloading.           (line  11)
* unlock-buffer:                         File Locks.          (line  38)
* unread-command-char:                   Event Input Misc.    (line  40)
* unread-command-events:                 Event Input Misc.    (line  11)
* unwind-protect:                        Cleanups.            (line  12)
* up-list:                               List Motion.         (line  25)
* upcase:                                Case Conversion.     (line  35)
* upcase-initials:                       Case Conversion.     (line  74)
* upcase-region:                         Case Changes.        (line  44)
* upcase-word:                           Case Changes.        (line  75)
* update-directory-autoloads:            Autoload.            (line  97)
* update-file-autoloads:                 Autoload.            (line  97)
* use-global-map:                        Active Keymaps.      (line 112)
* use-hard-newlines:                     Filling.             (line 149)
* use-local-map:                         Active Keymaps.      (line 118)
* user-full-name:                        User Identification. (line  55)
* user-login-name:                       User Identification. (line  55)
* user-mail-address:                     User Identification. (line  21)
* user-real-login-name:                  User Identification. (line  55)
* user-real-uid:                         User Identification. (line  64)
* user-uid:                              User Identification. (line  70)
* user-variable-p:                       Defining Variables.  (line 126)
* values:                                Eval.                (line  94)
* variable-documentation:                Documentation Basics.
                                                              (line  36)
* variable-interactive:                  Defining Variables.  (line 137)
* vc-mode:                               Mode Line Variables. (line 120)
* vc-prefix-map:                         Prefix Keys.         (line  47)
* vconcat:                               Vector Functions.    (line  32)
* vector:                                Vector Functions.    (line  17)
* vector-cells-consed:                   Memory Usage.        (line  20)
* vectorp:                               Vector Functions.    (line   9)
* verify-visited-file-modtime:           Modification Time.   (line  15)
* version-control:                       Numbered Backups.    (line  12)
* vertical-motion:                       Screen Lines.        (line  31)
* view-calendar-holidays-initially:      Calendar Customizing.
                                                              (line  17)
* view-diary-entries-initially:          Calendar Customizing.
                                                              (line   6)
* view-file:                             Visiting Functions.  (line  92)
* view-mode-map:                         Standard Keymaps.    (line 151)
* view-register:                         Registers.           (line  62)
* visible-bell:                          Beeping.             (line  23)
* visible-frame-list:                    Finding All Frames.  (line  13)
* visited-file-modtime:                  Modification Time.   (line  37)
* void-function:                         Function Cells.      (line  15)
* void-variable:                         Void Variables.      (line   6)
* waiting-for-user-input-p:              Sentinels.           (line  77)
* walk-windows:                          Cyclic Window Ordering.
                                                              (line  89)
* when:                                  Conditionals.        (line  34)
* where-is-internal:                     Scanning Keymaps.    (line  67)
* while:                                 Iteration.           (line  12)
* wholenump:                             Predicates on Numbers.
                                                              (line  29)
* widen:                                 Narrowing.           (line  44)
* window （オーバレイ属性）:             Overlay Properties.  (line  31)
* window-at:                             Coordinates and Windows.
                                                              (line   9)
* window-buffer:                         Buffers and Windows. (line  25)
* window-configuration-change-hook:      Window Hooks.        (line  69)
* window-configuration-p:                Window Configurations.
                                                              (line  83)
* window-dedicated-p:                    Choosing Window.     (line 175)
* window-display-table:                  Active Display Table.
                                                              (line  15)
* window-edges:                          Size of Window.      (line  42)
* window-end:                            Window Start.        (line  36)
* window-frame:                          Frames and Windows.  (line  10)
* window-height:                         Size of Window.      (line  15)
* window-hscroll:                        Horizontal Scrolling.
                                                              (line  44)
* window-live-p:                         Deleting Windows.    (line  20)
* window-min-height:                     Resizing Windows.    (line  71)
* window-min-width:                      Resizing Windows.    (line  80)
* window-minibuffer-p:                   Minibuffer Misc.     (line  66)
* window-point:                          Window Point.        (line  36)
* window-redisplay-end-trigger:          Window Hooks.        (line  66)
* window-scroll-functions:               Window Hooks.        (line  18)
* window-setup-hook:                     Window Systems.      (line  29)
* window-size-change-functions:          Window Hooks.        (line  32)
* window-start:                          Window Start.        (line  14)
* window-system:                         Window Systems.      (line  13)
* window-width:                          Size of Window.      (line  30)
* windowp:                               Basic Windows.       (line  83)
* Windowsのファイル型:                   MS-DOS File Types.   (line   6)
* with-current-buffer:                   Current Buffer.      (line 125)
* with-output-to-string:                 Output Functions.    (line 114)
* with-output-to-temp-buffer:            Temporary Displays.  (line  10)
* with-temp-buffer:                      Current Buffer.      (line 134)
* with-temp-file:                        Writing to Files.    (line  62)
* with-timeout:                          Timers.              (line  65)
* word-search-backward:                  String Search.       (line 110)
* word-search-forward:                   String Search.       (line  67)
* words-include-escapes:                 Word Motion.         (line  32)
* write-abbrev-file:                     Abbrev Files.        (line  39)
* write-char:                            Output Functions.    (line  90)
* write-contents-hooks:                  Saving Buffers.      (line 102)
* write-file:                            Saving Buffers.      (line  48)
* write-file-hooks:                      Saving Buffers.      (line  61)
* write-region:                          Writing to Files.    (line  22)
* write-region-annotate-functions:       Saving Properties.   (line  11)
* wrong-number-of-arguments:             Argument List.       (line   6)
* wrong-type-argument:                   Type Predicates.     (line   6)
* x-close-connection:                    Multiple Displays.   (line  60)
* x-color-defined-p:                     Color Names.         (line   7)
* x-color-values:                        Color Names.         (line  28)
* x-display-backing-store:               Server Data.         (line  36)
* x-display-color-cells:                 Server Data.         (line  59)
* x-display-color-p:                     Server Data.         (line  56)
* x-display-grayscale-p:                 Server Data.         (line  53)
* x-display-list:                        Multiple Displays.   (line  40)
* x-display-mm-height:                   Server Data.         (line  27)
* x-display-mm-width:                    Server Data.         (line  33)
* x-display-pixel-height:                Server Data.         (line  24)
* x-display-pixel-width:                 Server Data.         (line  30)
* x-display-planes:                      Server Data.         (line  44)
* x-display-save-under:                  Server Data.         (line  41)
* x-display-screens:                     Server Data.         (line  15)
* x-display-visual-class:                Server Data.         (line  47)
* x-get-cut-buffer:                      Window System Selections.
                                                              (line  50)
* x-get-resource:                        Resources.           (line   8)
* x-get-selection:                       Window System Selections.
                                                              (line  31)
* x-list-font:                           Font Names.          (line   7)
* x-open-connection:                     Multiple Displays.   (line  44)
* x-parse-geometry:                      Size and Position.   (line  79)
* x-pointer-shape:                       Pointer Shapes.      (line  10)
* x-popup-dialog:                        Dialog Boxes.        (line  15)
* x-popup-menu:                          Pop-Up Menus.        (line  11)
* x-resource-class:                      Resources.           (line  23)
* x-sensitive-text-pointer-shape:        Pointer Shapes.      (line  13)
* x-server-vendor:                       Server Data.         (line  21)
* x-server-version:                      Server Data.         (line  18)
* x-set-cut-buffer:                      Window System Selections.
                                                              (line  53)
* x-set-selection:                       Window System Selections.
                                                              (line  13)
* Xウィンドウシステム:                   Window Systems.      (line  17)
* y-or-n-p:                              Yes-or-No Queries.   (line  24)
* y-or-n-p-with-timeout:                 Yes-or-No Queries.   (line  77)
* yank:                                  Yank Commands.       (line  10)
* yank-pop:                              Yank Commands.       (line  26)
* yes-or-no-p:                           Yes-or-No Queries.   (line  82)
* yes/noの問い合わせ:                    Yes-or-No Queries.   (line   6)
* zerop:                                 Predicates on Numbers.
                                                              (line  37)
* |、正規表現:                           Syntax of Regexps.   (line 186)
* たそがれの時刻:                        Sexp Diary Entries.  (line 139)
* つぎの入力:                            Event Input Misc.    (line  11)
* まえの完全な部分式:                    Parsing Expressions. (line  51)
* もっとも内側の括弧式:                  Parsing Expressions. (line  48)
* アイコンにしたフレーム:                Visibility of Frames.
                                                              (line   6)
* アイドル状態:                          Timers.              (line 101)
* アウトライン（outline）モード:         Substitution.        (line  13)
* アトム <1>:                            Cons Cell Type.      (line  32)
* アトム:                                List-related Predicates.
                                                              (line  18)
* アドバイス、事前:                      Defining Advice.     (line  22)
* アドバイス、事後:                      Defining Advice.     (line  22)
* アドバイス、包囲:                      Defining Advice.     (line  22)
* アドバイス、定義:                      Defining Advice.     (line   6)
* アドバイス、関数:                      Advising Functions.  (line   6)
* アドバイスの不活性化:                  Activation of Advice.
                                                              (line  33)
* アドバイスの予約活性:                  Preactivation.       (line   6)
* アドバイスの再活性化:                  Activation of Advice.
                                                              (line  56)
* アドバイスの有効化:                    Enabling Advice.     (line   6)
* アドバイスの活性化:                    Activation of Advice.
                                                              (line   6)
* アドバイスの無効化:                    Enabling Advice.     (line   6)
* アドバイスクラス:                      Defining Advice.     (line  22)
* アドバイス断片:                        Advising Functions.  (line  11)
* アブノーマルフック:                    Hooks.               (line  35)
* アルト文字:                            Character Type.      (line 119)
* アンドゥのオフ:                        Maintaining Undo.    (line  27)
* アンドゥの抑制:                        Substitution.        (line  13)
* アンロード:                            Unloading.           (line   6)
* イベント:                              Input Events.        (line   6)
* イベントdelete-frame:                  Misc Events.         (line   8)
* イベントdrag-n-drop:                   Misc Events.         (line  45)
* イベントiconify-frame:                 Misc Events.         (line  15)
* イベントmake-frame-visible:            Misc Events.         (line  23)
* イベントmouse-wheel:                   Misc Events.         (line  30)
* イベントによる停止:                    Global Break Condition.
                                                              (line   6)
* イベントの表示:                        Describing Characters.
                                                              (line  19)
* イベント型:                            Classifying Events.  (line   6)
* インタープリタ:                        Evaluation.          (line   6)
* インタープリタ、バイトコード:          Compilation Functions.
                                                              (line 125)
* インターン:                            Creating Symbols.    (line  23)
* インターンしてないシンボル:            Creating Symbols.    (line  37)
* インライン関数:                        Inline Functions.    (line   6)
* ウィンドウ:                            Basic Windows.       (line   6)
* ウィンドウ、正確に制御する:            Buffers and Windows. (line   6)
* ウィンドウのエクスカージョン:          Excursions.          (line  33)
* ウィンドウのポイント:                  Window Point.        (line   6)
* ウィンドウのリサイズ:                  Resizing Windows.    (line   6)
* ウィンドウの先頭行:                    Window Start.        (line  14)
* ウィンドウの内部:                      Window Internals.    (line   6)
* ウィンドウの内部ポイント:              Window Internals.    (line  22)
* ウィンドウの分割:                      Splitting Windows.   (line   6)
* ウィンドウの削除:                      Deleting Windows.    (line   6)
* ウィンドウの巡回順序:                  Cyclic Window Ordering.
                                                              (line   6)
* ウィンドウの最小サイズ:                Resizing Windows.    (line  68)
* ウィンドウの選択:                      Selecting Windows.   (line   6)
* ウィンドウを探す:                      Selecting Windows.   (line  38)
* ウィンドウを調べる:                    Buffers and Windows. (line   6)
* ウィンドウサイズ:                      Size of Window.      (line   6)
* ウィンドウサイズの変更:                Resizing Windows.    (line   6)
* ウィンドウフレーム:                    Frames.              (line  15)
* ウィンドウ内位置:                      Window Point.        (line   6)
* ウィンドウ情報の保存:                  Window Configurations.
                                                              (line   6)
* ウィンドウ構成:                        Window Configurations.
                                                              (line   6)
* ウィンドウ構成（edebug）:              Edebug Display Update.
                                                              (line  24)
* エクスカージョン:                      Excursions.          (line   6)
* エコー表示:                            The Echo Area.       (line   6)
* エコー領域:                            The Echo Area.       (line   6)
* エスケープ:                            Character Type.      (line  40)
* エスケープシーケンス:                  Character Type.      (line  55)
* エスケープ文字:                        Output Variables.    (line  11)
* エスケープ文字、表示:                  Output Functions.    (line   9)
* エスケープ（escape）:                  Syntax Class Table.  (line  72)
* エディタコマンドループ:                Command Loop.        (line   6)
* エラー:                                Errors.              (line   6)
* エラーpeculiar:                        Error Symbols.       (line  33)
* エラー、Lispの入れ子:                  Eval.                (line  78)
* エラー、ロード:                        How Programs Do Loading.
                                                              (line  69)
* エラー、自動ロード:                    Autoload.            (line  81)
* エラーのデバッグ:                      Error Debugging.     (line   6)
* エラーの後始末:                        Cleanups.            (line  12)
* エラーを処理する:                      Handling Errors.     (line   6)
* エラーシンボル:                        Error Symbols.       (line   6)
* エラーハンドラ:                        Handling Errors.     (line   6)
* エラーメッセージの表記法:              Error Messages.      (line   6)
* エラー名:                              Error Symbols.       (line   6)
* エラー記述:                            Handling Errors.     (line 114)
* エラー通知:                            Signaling Errors.    (line   6)
* オブジェクト:                          Lisp Data Types.     (line   6)
* オブジェクトから文字列へ:              Output Functions.    (line  94)
* オブジェクトの内部:                    Object Internals.    (line   6)
* オブジェクト配列（obarray）:           Creating Symbols.    (line  11)
* オプション、コマンド行:                Command Line Arguments.
                                                              (line  31)
* オプションの記述例:                    A Sample Variable Description.
                                                              (line   6)
* オペレーティングシステム環境:          System Environment.  (line   6)
* オーバフロー:                          Integer Basics.      (line   9)
* オーバレイ:                            Overlays.            (line   6)
* オーバレイ矢印:                        Overlay Arrow.       (line   6)
* オーメル（過ぎ越しの祝い）の回数:      Sexp Diary Entries.  (line 139)
* カスタマイズ、.emacs:                  Major Mode Conventions.
                                                              (line 153)
* カットバッファ:                        Window System Selections.
                                                              (line  44)
* カテゴリ、文字:                        Categories.          (line   6)
* カバレッジテスト:                      Coverage Testing.    (line   6)
* カレントスタックフレーム:              Using Debugger.      (line  26)
* カレントバッファ:                      Current Buffer.      (line   6)
* カレントバッファのエクスカージョン:    Excursions.          (line  18)
* カレントバッファのポイントとマーク（edebug）: Edebug Display Update.
                                                              (line  21)
* カレントバッファのマーク:              The Mark.            (line  51)
* カレントバッファ内の位置:              Point.               (line  35)
* ガベッジコレクション:                  Garbage Collection.  (line   6)
* ガベッジコレクションを抑制する:        Writing Emacs Primitives.
                                                              (line  15)
* キャピタライズ（先頭文字だけを大文字にする）: Case Conversion.
                                                              (line  52)
* キルされたテキストの挿入:              Yank Commands.       (line  10)
* キルコマンドの繰り返し:                Command Loop Info.   (line  34)
* キルリング:                            The Kill Ring.       (line   6)
* キー:                                  Keymap Terminology.  (line   6)
* キー、予約済み:                        Coding Conventions.  (line  81)
* キー、説明文字列:                      Keys in Documentation.
                                                              (line   6)
* キーのバインド:                        Keymap Terminology.  (line   6)
* キーバインディング:                    Keymap Terminology.  (line   6)
* キーバインディングの変更:              Changing Key Bindings.
                                                              (line   6)
* キーバインディングの解除:              Key Binding Commands.
                                                              (line  39)
* キーボードマクロ:                      Keyboard Macros.     (line   6)
* キーボードマクロの実行:                Interactive Call.    (line  52)
* キーボードマクロの終了 <1>:            Beeping.             (line  14)
* キーボードマクロの終了:                Event Input Misc.    (line  72)
* キーボードマクロ（edebug）:            Edebug Execution Modes.
                                                              (line  71)
* キーマップ:                            Keymaps.             (line   6)
* キーマップ、キーマップ:                Key Lookup.          (line  58)
* キーマップ、モード:                    Major Mode Conventions.
                                                              (line  45)
* キーマップ、文字:                      Special Properties.  (line  37)
* キーマップのバインディングの継承:      Inheritance and Keymaps.
                                                              (line   6)
* キーマップのプロンプト文字列:          Format of Keymaps.   (line  50)
* キーマップの作成:                      Creating Keymaps.    (line   6)
* キーマップの形式:                      Format of Keymaps.   (line   6)
* キーマップの継承:                      Inheritance and Keymaps.
                                                              (line   6)
* キーマップの項目:                      Key Lookup.          (line   6)
* キーマップ内のlambda:                  Key Lookup.          (line  67)
* キーマップ内のnil:                     Key Lookup.          (line  40)
* キーマップ内のundefined:               Key Lookup.          (line 100)
* キーマップ内のキーマップ:              Key Lookup.          (line  58)
* キーマップ内のコマンド:                Key Lookup.          (line  47)
* キーマップ内のシンボル:                Key Lookup.          (line  86)
* キーマップ内のリスト:                  Key Lookup.          (line  62)
* キーマップ内の文字列:                  Key Lookup.          (line  52)
* キー列:                                Key Sequence Input.  (line  13)
* キー列の入力:                          Key Sequence Input.  (line   6)
* キー列エラー:                          Changing Key Bindings.
                                                              (line  51)
* キー変換関数:                          Translating Input.   (line 138)
* キー探索:                              Key Lookup.          (line   6)
* クォート:                              Quoting.             (line   6)
* クォート、':                           Quoting.             (line  15)
* クォートした文字の入力:                Quoted Character Input.
                                                              (line   6)
* クォート文字:                          Parsing Expressions. (line  59)
* クォート文字、表示:                    Output Functions.    (line   9)
* クラス、アドバイス:                    Defining Advice.     (line  22)
* クリックイベント:                      Click Events.        (line   6)
* クリック可能なテキスト:                Clickable Text.      (line   6)
* クロージャは使えない:                  Extent.              (line  34)
* グローバルキーマップ:                  Active Keymaps.      (line   6)
* グローバルブレーク条件:                Global Break Condition.
                                                              (line   6)
* グローバル変数:                        Global Variables.    (line   6)
* グローバル束縛:                        Local Variables.     (line   6)
* コピー、シーケンス:                    Sequence Functions.  (line  57)
* コピー、ベクトル:                      Vector Functions.    (line  32)
* コピー、文字列:                        Creating Strings.    (line  88)
* コマンド:                              What Is a Function.  (line  54)
* コマンド、キーマップ:                  Key Lookup.          (line  47)
* コマンド、プレフィックス:              Prefix Keys.         (line  95)
* コマンドの定義:                        Defining Commands.   (line   6)
* コマンドの記述:                        A Sample Function Description.
                                                              (line   6)
* コマンドキー入力を待つ:                Event Input Misc.    (line  48)
* コマンドループ:                        Command Loop.        (line   6)
* コマンドループ、再帰:                  Recursive Editing.   (line   6)
* コマンド名の読み取り:                  Interactive Call.    (line  70)
* コマンド履歴:                          Command History.     (line   6)
* コマンド履歴の記録:                    Interactive Call.    (line  42)
* コマンド行のオプション:                Command Line Arguments.
                                                              (line  31)
* コマンド行引数:                        Command Line Arguments.
                                                              (line   6)
* コメント:                              Comments.            (line   6)
* コメントの内側:                        Parsing Expressions. (line  57)
* コメントの構文:                        Syntax Class Table.  (line 108)
* コメントを飛び越える:                  Parsing Expressions. (line 111)
* コメント終了（comment ender）:         Syntax Class Table.  (line 108)
* コメント開始（comment starter）:       Syntax Class Table.  (line 107)
* コラム:                                Columns.             (line   6)
* コラムを数える:                        Columns.             (line   6)
* コンスする:                            Building Lists.      (line  25)
* コンスセル:                            Building Lists.      (line   6)
* コンスセルの箱表示:                    Lists as Boxes.      (line   6)
* コントロール文字:                      Character Type.      (line  60)
* コントロール文字、読み取り:            Quoted Character Input.
                                                              (line  12)
* コントロール文字の表示 <1>:            Describing Characters.
                                                              (line  19)
* コントロール文字の表示:                Usual Display.       (line  48)
* コントロール文字キー定数:              Changing Key Bindings.
                                                              (line  18)
* コンパイル:                            Byte Compilation.    (line   6)
* コンパイル、マクロ:                    Compilation Functions.
                                                              (line  18)
* コンパイル、ライブラリ:                Compilation Functions.
                                                              (line 100)
* コンパイル済み関数:                    Byte-Code Objects.   (line   6)
* コンパイル関数:                        Compilation Functions.
                                                              (line   6)
* コーディングシステム:                  Coding Systems.      (line   6)
* コーディングスタイル:                  Tips.                (line   6)
* コーディングスタイルの標準:            Tips.                (line   6)
* コード、対話指定、記述子:              Interactive Codes.   (line   6)
* サイズ、ウィンドウ:                    Size of Window.      (line   6)
* サイズ、スクリーン:                    Size and Position.   (line   6)
* サイズ、フレーム:                      Size and Position.   (line   6)
* サブプロセス:                          Processes.           (line   6)
* サブプロセス、同期:                    Synchronous Processes.
                                                              (line   6)
* サブプロセスの環境変数:                Subprocess Creation. (line  52)
* シェルモードのmode-line-format:        Mode Line Data.      (line  79)
* シグナル:                              Signals to Processes.
                                                              (line   6)
* シグナルを送る:                        Signals to Processes.
                                                              (line   6)
* シンボリックリンク、ファイル:          Kinds of Files.      (line  11)
* シンボル:                              Symbols.             (line   6)
* シンボル、キーマップ:                  Key Lookup.          (line  86)
* シンボルの同値性:                      Creating Symbols.    (line  37)
* シンボルの構成要素:                    Symbol Components.   (line   6)
* シンボルの評価:                        Symbol Forms.        (line   6)
* シンボルの関数間接:                    Function Indirection.
                                                              (line   6)
* シンボルを定義する:                    Definitions.         (line   6)
* シンボルを読む:                        Creating Symbols.    (line   6)
* シンボル名のハッシュ化:                Creating Symbols.    (line  11)
* シンボル構成文字（symbol constituent）: Syntax Class Table. (line  22)
* シーケンス:                            Sequences Arrays Vectors.
                                                              (line   6)
* シーケンスのコピー:                    Sequence Functions.  (line  57)
* シーケンスの要素:                      Sequence Functions.  (line  35)
* シーケンスの長さ:                      Sequence Functions.  (line  16)
* ジオメトリ指定:                        Size and Position.   (line  79)
* スクリーン、端末:                      Basic Windows.       (line  69)
* スクリーンサイズ:                      Size and Position.   (line   6)
* スクロール、垂直:                      Vertical Scrolling.  (line   6)
* スコープ:                              Variable Scoping.    (line  10)
* スティッキテキスト属性:                Sticky Properties.   (line   6)
* ストリーム（表示）:                    Output Streams.      (line   6)
* ストリーム（読み取り）:                Input Streams.       (line   6)
* スペシャルフォーム:                    Primitive Function Type.
                                                              (line   6)
* スペシャルフォームの記述:              A Sample Function Description.
                                                              (line   6)
* スペシャルフォームの評価:              Special Forms.       (line   6)
* スペシャルフォーム（edebug）:          Instrumenting.       (line  41)
* スーパー文字:                          Character Type.      (line 119)
* セレクション（Xウィンドウシステム）:   Window System Selections.
                                                              (line   6)
* ソース上のブレークポイント:            Source Breakpoints.  (line   6)
* ソート、テキスト:                      Sorting.             (line   6)
* ソート、リスト:                        Rearrangement.       (line  98)
* タイマ:                                Timers.              (line   6)
* タイル型ウィンドウ:                    Basic Windows.       (line  69)
* タブ:                                  Character Type.      (line  40)
* タブの削除:                            Deletion.            (line  63)
* タームスクリプトファイル:              Terminal Output.     (line  50)
* ダブルクォート、文字列:                Syntax for Strings.  (line   6)
* ダブルクリックイベント:                Repeat Events.       (line   6)
* テキスト:                              Text.                (line   6)
* テキストのソート:                      Sorting.             (line   6)
* テキストのフェイスコード:              Special Properties.  (line  18)
* テキストの復号化:                      Explicit Encoding.   (line   6)
* テキストの挿入:                        Insertion.           (line   6)
* テキストの符号化:                      Explicit Encoding.   (line   6)
* テキストの解析:                        Syntax Tables.       (line   6)
* テキストファイルとバイナリファイル:    MS-DOS File Types.   (line   6)
* テキスト変更向けのフック:              Change Hooks.        (line   6)
* テキスト属性:                          Text Properties.     (line   6)
* テキスト属性、ファイル内:              Saving Properties.   (line   6)
* テキスト属性の保存:                    Saving Properties.   (line   6)
* テキスト属性の継承:                    Sticky Properties.   (line   6)
* テキスト文字のカテゴリ:                Special Properties.  (line  11)
* テキスト表現:                          Text Representations.
                                                              (line   6)
* ディスプレイ、複数:                    Multiple Displays.   (line   6)
* ディレクトリのファイル名:              Directory Names.     (line   6)
* ディレクトリ内のファイル名:            Contents of Directories.
                                                              (line   6)
* ディレクトリ名:                        Directory Names.     (line   6)
* ディレクトリ名の省略形:                Directory Names.     (line  42)
* ディレクトリ向け関数:                  Contents of Directories.
                                                              (line   6)
* ディレクトリ部分（ファイル名）:        File Name Components.
                                                              (line   6)
* デバッガ:                              Debugger.            (line   6)
* デバッガコマンド一覧:                  Debugger Commands.   (line   6)
* デバッグ、エラー:                      Error Debugging.     (line   6)
* デバッグ、特定の関数:                  Function Debugging.  (line   6)
* デバッグ、関数呼び出し:                Function Debugging.  (line   6)
* デバッグのerror:                       Invoking the Debugger.
                                                              (line  61)
* デバッグのlambda:                      Invoking the Debugger.
                                                              (line  31)
* デフォルトのキーバインディング:        Format of Keymaps.   (line  20)
* デフォルトの初期化ファイル:            Init File.           (line  15)
* デフォルト値:                          Default Value.       (line   6)
* デフォルト引数文字列:                  Interactive Codes.   (line  19)
* データ型:                              Lisp Data Types.     (line   6)
* トップレベルのフォーム:                Loading.             (line  16)
* トランザクションキュー:                Transaction Queues.  (line   6)
* トリプルクリックイベント:              Repeat Events.       (line   6)
* トレイリングコード:                    Text Representations.
                                                              (line  21)
* トレースバッファ:                      Trace Buffer.        (line   6)
* ドット対リスト（edebug）:              Specification List.  (line 134)
* ドット対記法:                          Dotted Pair Notation.
                                                              (line   6)
* ドラッグイベント:                      Drag Events.         (line   6)
* ドリブルファイル:                      Recording Input.     (line  17)
* ナロイング:                            Narrowing.           (line   6)
* ナロイング中のポイント:                Point.               (line  18)
* ネットワーク接続:                      Network.             (line   6)
* ノーマルフック:                        Hooks.               (line  13)
* ハイパー文字:                          Character Type.      (line 119)
* ハッシュ化:                            Creating Symbols.    (line  11)
* ハッシュ記法:                          Printed Representation.
                                                              (line  24)
* バイト:                                Strings and Characters.
                                                              (line   6)
* バイトと文字:                          Chars and Bytes.     (line   6)
* バイトコンパイル時のrequire:           Named Features.      (line  50)
* バイトコード:                          Byte Compilation.    (line   6)
* バイトコードの逆アセンブル:            Disassembly.         (line   6)
* バイトコードインタープリタ:            Compilation Functions.
                                                              (line 125)
* バイトコード関数:                      Byte-Code Objects.   (line   6)
* バイナリファイルとテキストファイル:    MS-DOS File Types.   (line   6)
* バインディングの置き換え:              Changing Key Bindings.
                                                              (line 104)
* バケット（オブジェクト配列）:          Creating Symbols.    (line  11)
* バックアップファイル:                  Backup Files.        (line   6)
* バックアップファイルの作成方法:        Rename or Copy.      (line   6)
* バッククォート（リストの置換）:        Backquote.           (line   6)
* バックスペース:                        Character Type.      (line  40)
* バックスラッシュ、シンボル内:          Symbol Type.         (line  20)
* バックスラッシュ、文字列:              Syntax for Strings.  (line   6)
* バックスラッシュ、文字定数:            Character Type.      (line 127)
* バックトラック:                        Backtracking.        (line   6)
* バックトラックの阻止:                  Specification List.  (line  93)
* バッチモード:                          Batch Mode.          (line   6)
* バッファ:                              Buffers.             (line   6)
* バッファ、ウィンドウで制御される:      Buffers and Windows. (line   6)
* バッファ、読み出し専用:                Read Only Buffers.   (line   6)
* バッファのファイル名:                  Buffer File Name.    (line   6)
* バッファの作成:                        Creating Buffers.    (line   6)
* バッファの内容:                        Text.                (line  23)
* バッファの内部:                        Buffer Internals.    (line   6)
* バッファの切り替え:                    Displaying Buffers.  (line   6)
* バッファの削除:                        Killing Buffers.     (line   6)
* バッファの変更:                        Buffer Modification. (line   6)
* バッファの末尾のマーカ:                Creating Markers.    (line  28)
* バッファの表示:                        Displaying Buffers.  (line   6)
* バッファを選ぶ:                        Current Buffer.      (line   6)
* バッファテキストの比較:                Comparing Text.      (line   6)
* バッファファイル名:                    Buffer File Name.    (line   6)
* バッファリスト:                        The Buffer List.     (line   6)
* バッファローカルな変数:                Buffer-Local Variables.
                                                              (line   6)
* バッファローカルな変数、モード:        Major Mode Conventions.
                                                              (line 103)
* バッファ入力ストリーム:                Input Streams.       (line  12)
* バッファ内での大文字小文字変換:        Case Changes.        (line   6)
* バッファ内のテキストの表記法:          Buffer Text Notation.
                                                              (line   6)
* バッファ内容の評価:                    Eval.                (line  68)
* バッファ出力ストリーム:                Output Streams.      (line  11)
* バッファ名:                            Buffer Names.        (line   6)
* パイプ:                                Asynchronous Processes.
                                                              (line  72)
* パディング:                            Formatting Strings.  (line 104)
* パラシャ、毎週:                        Sexp Diary Entries.  (line 139)
* パーセント記号、モード行:              Mode Line Data.      (line  31)
* パーミッション:                        File Attributes.     (line  12)
* ヒント:                                Tips.                (line   6)
* ビットごとの否定:                      Bitwise Operations.  (line 197)
* ビットごとの排他的論理和:              Bitwise Operations.  (line 179)
* ビットごとの論理和:                    Bitwise Operations.  (line 161)
* ビットごとの論理積:                    Bitwise Operations.  (line 127)
* ピュアメモリ:                          Pure Storage.        (line   6)
* ファイルのコピー:                      Changing Files.      (line   6)
* ファイルのシンボリックリンク:          Kinds of Files.      (line  11)
* ファイルのハードリンク:                Changing Files.      (line  22)
* ファイルのモードの設定:                Changing Files.      (line   6)
* ファイルのリンク:                      Changing Files.      (line   6)
* ファイルの削除:                        Changing Files.      (line   6)
* ファイルの参照可能性:                  Testing Accessibility.
                                                              (line   6)
* ファイルの古さ:                        Testing Accessibility.
                                                              (line  79)
* ファイルの実名:                        Truenames.           (line   6)
* ファイルの属性:                        File Attributes.     (line  12)
* ファイルの改名:                        Changing Files.      (line   6)
* ファイルを探す:                        Visiting Files.      (line   6)
* ファイルを訪問する:                    Visiting Files.      (line   6)
* ファイルオープンエラー:                Subroutines of Visiting.
                                                              (line  38)
* ファイルモードとMS-DOS:                Changing Files.      (line 134)
* ファイルモード指定のエラー:            Auto Major Mode.     (line  40)
* ファイルロック:                        File Locks.          (line   6)
* ファイル内のテキスト属性:              Saving Properties.   (line   6)
* ファイル名:                            File Names.          (line   6)
* ファイル名、バッファ:                  Buffer File Name.    (line   6)
* ファイル名の補完サブルーティン:        File Name Completion.
                                                              (line   6)
* ファイル名を展開する関数:              File Name Expansion. (line   6)
* ファイル型、MS-DOSとWindows:           MS-DOS File Types.   (line   6)
* ファイル更新時刻:                      Testing Accessibility.
                                                              (line  79)
* ファイル書式の復号化:                  Format Conversion.   (line   6)
* ファイル書式の符号化:                  Format Conversion.   (line   6)
* ファイル書式変換:                      Format Conversion.   (line   6)
* ファンクショナル:                      Calling Functions.   (line  83)
* ファンクションキー:                    Function Keys.       (line   6)
* フィルタ関数:                          Filter Functions.    (line   6)
* フィールド幅:                          Formatting Strings.  (line 104)
* フェイス:                              Faces.               (line   6)
* フェイス識別子:                        Faces.               (line  10)
* フォント:                              Some Terms.          (line  13)
* フォントロック（font-lock）モード:     Font Lock Mode.      (line   6)
* フォーカスイベント:                    Focus Events.        (line   6)
* フォーム:                              Intro Eval.          (line  16)
* フォーム、トップレベル:                Loading.             (line  16)
* フック:                                Hooks.               (line   6)
* フック、ロード:                        Hooks for Loading.   (line   6)
* フレーム:                              Frames.              (line   6)
* フレームのリサイズ:                    Size and Position.   (line   6)
* フレームの削除:                        Deleting Frames.     (line   6)
* フレームの可視性:                      Visibility of Frames.
                                                              (line   6)
* フレームを奥に置く:                    Raising and Lowering.
                                                              (line  15)
* フレームを手前に置く:                  Raising and Lowering.
                                                              (line  15)
* フレームサイズ:                        Size and Position.   (line   6)
* フレーム構成:                          Frame Configurations.
                                                              (line   6)
* フロー制御の例:                        Translating Input.   (line  59)
* フロー制御文字:                        Flow Control.        (line   6)
* ブレーク:                              Debugger.            (line   6)
* ブレークポイント:                      Breakpoints.         (line   6)
* ブールベクトル:                        Bool-Vectors.        (line   6)
* ブール値:                              nil and t.           (line   6)
* プレフィックスキー:                    Prefix Keys.         (line   6)
* プレフィックスキーの禁止:              Key Lookup.          (line 108)
* プレフィックスコマンド:                Prefix Keys.         (line  95)
* プログラミング向けの型:                Programming Types.   (line   6)
* プログラムの実行:                      Subprocess Creation. (line  17)
* プログラムの引数:                      Subprocess Creation. (line  40)
* プログラムを探すディレクトリ:          Subprocess Creation. (line  68)
* プログラムを計時する:                  Compilation Tips.    (line   8)
* プログラム補完:                        Programmed Completion.
                                                              (line   6)
* プロセス:                              Processes.           (line   6)
* プロセス、非同期:                      Asynchronous Processes.
                                                              (line   6)
* プロセスの入力:                        Input to Processes.  (line   6)
* プロセスの内部:                        Process Internals.   (line   6)
* プロセスの出力:                        Output from Processes.
                                                              (line   6)
* プロセスの削除:                        Deleting Processes.  (line   6)
* プロセスの番兵:                        Sentinels.           (line   6)
* プロセスシグナル:                      Signals to Processes.
                                                              (line   6)
* プロセスフィルタ:                      Filter Functions.    (line   6)
* プロファイル:                          Compilation Tips.    (line   8)
* プロンプト文字列、メニュー:            Defining Menus.      (line   6)
* ヘッダコメント:                        Library Headers.     (line   6)
* ヘルプ、メジャーモード:                Mode Help.           (line   6)
* ベクトル:                              Vectors.             (line   6)
* ベクトルのコピー:                      Vector Functions.    (line  32)
* ベクトルの評価:                        Self-Evaluating Forms.
                                                              (line   6)
* ベクトルの長さ:                        Sequence Functions.  (line  16)
* ベルを鳴らす:                          Beeping.             (line   6)
* ベル文字:                              Character Type.      (line  40)
* ページ送り:                            Character Type.      (line  40)
* ボタン押し下げイベント:                Button-Down Events.  (line   6)
* ポインタ:                              Cons Cell Type.      (line   6)
* ポインタの形状:                        Pointer Shapes.      (line   6)
* ポイント:                              Point.               (line   6)
* ポイント、ウィンドウ:                  Window Point.        (line   6)
* ポイントのまえへ挿入:                  Insertion.           (line   6)
* ポイントのエクスカージョン:            Excursions.          (line  18)
* ポイントを中央に揃える:                Vertical Scrolling.  (line 118)
* ポイント移動に対するフック:            Special Properties.  (line 100)
* マイナモード:                          Minor Modes.         (line   6)
* マイナモードの慣習:                    Minor Mode Conventions.
                                                              (line   6)
* マイナモードを書くための慣習:          Minor Mode Conventions.
                                                              (line   6)
* マウスの位置:                          Mouse Position.      (line   6)
* マウスの追跡:                          Mouse Tracking.      (line   6)
* マウスクリックイベント:                Click Events.        (line   6)
* マウスドラッグイベント:                Drag Events.         (line   6)
* マウスポインタの形状:                  Pointer Shapes.      (line   6)
* マウスモーションイベント:              Motion Events.       (line   6)
* マクロ <1>:                            What Is a Function.  (line  46)
* マクロ:                                Macros.              (line   6)
* マクロのコンパイル:                    Compilation Functions.
                                                              (line  18)
* マクロのバイトコンパイル:              Compiling Macros.    (line   6)
* マクロの展開:                          Expansion.           (line   6)
* マクロの記述:                          A Sample Function Description.
                                                              (line   6)
* マクロ呼び出し:                        Expansion.           (line   6)
* マクロ呼び出しの評価:                  Macro Forms.         (line   6)
* マクロ展開:                            Expansion.           (line  35)
* マクロ引数の評価:                      Argument Evaluation. (line  56)
* マジックファイル名:                    Magic File Names.    (line   6)
* マッチデータ:                          Match Data.          (line   6)
* マップ関数:                            Mapping Functions.   (line   6)
* マルチバイトテキスト:                  Text Representations.
                                                              (line  21)
* マルチバイト文字:                      Non-ASCII Characters.
                                                              (line   6)
* マーカ:                                Markers.             (line   6)
* マーカ、数:                            Overview of Markers. (line  35)
* マーカのエクスカージョン:              Excursions.          (line  18)
* マーカのガベッジコレクション:          Overview of Markers. (line  27)
* マーカの再配置:                        Overview of Markers. (line  20)
* マーカの挿入型:                        Marker Insertion Types.
                                                              (line   6)
* マーカ入力ストリーム:                  Input Streams.       (line  16)
* マーカ出力ストリーム:                  Output Streams.      (line  15)
* マーク:                                The Mark.            (line   6)
* マークリング:                          The Mark.            (line   6)
* マーク引数:                            Interactive Codes.   (line 120)
* ミニバッファ:                          Minibuffers.         (line   6)
* ミニバッファ、<SPC>:                   Text from Minibuffer.
                                                              (line 173)
* ミニバッファ、<TAB>:                   Text from Minibuffer.
                                                              (line 176)
* ミニバッファ、?:                       Text from Minibuffer.
                                                              (line 179)
* ミニバッファの履歴:                    Minibuffer History.  (line   6)
* ミニバッファ入力:                      Recursive Editing.   (line  26)
* ミニバッファ用ウィンドウ:              Cyclic Window Ordering.
                                                              (line  23)
* メジャーモード:                        Major Modes.         (line   6)
* メジャーモードについてのヘルプ:        Mode Help.           (line   6)
* メジャーモードのキーマップ:            Active Keymaps.      (line  49)
* メジャーモードの説明文:                Mode Help.           (line   6)
* メジャーモードフック:                  Major Mode Conventions.
                                                              (line 115)
* メタ文字:                              Character Type.      (line  92)
* メタ文字の探索:                        Format of Keymaps.   (line  56)
* メタ文字の表示:                        Describing Characters.
                                                              (line  19)
* メタ文字キー定数:                      Changing Key Bindings.
                                                              (line  18)
* メニューの定義:                        Defining Menus.      (line   6)
* メニューの定義例:                      Menu Example.        (line   6)
* メニューキーマップ:                    Menu Keymaps.        (line   6)
* メニューバー:                          Menu Bar.            (line   6)
* メニュープロンプト文字列:              Defining Menus.      (line   6)
* メモリ割り当て:                        Garbage Collection.  (line   6)
* モーションイベント:                    Motion Events.       (line   6)
* モード:                                Modes.               (line   6)
* モード、訪問したファイル:              Auto Major Mode.     (line  70)
* モードのキーマップ:                    Major Mode Conventions.
                                                              (line  45)
* モードのバッファローカルな変数:        Major Mode Conventions.
                                                              (line 103)
* モードのロード:                        Major Mode Conventions.
                                                              (line 156)
* モードの構文テーブル:                  Major Mode Conventions.
                                                              (line  75)
* モードの略語表:                        Major Mode Conventions.
                                                              (line  85)
* モードの関数群:                        Major Mode Conventions.
                                                              (line  40)
* モードフック:                          Major Mode Conventions.
                                                              (line 115)
* モードヘルプ:                          Mode Help.           (line   6)
* モード変数:                            Minor Mode Conventions.
                                                              (line  14)
* モード行のパーセント記号:              Mode Line Data.      (line  31)
* モード行の書式:                        Mode Line Format.    (line   6)
* モード行構成:                          Mode Line Data.      (line   6)
* ヤンクの抑制:                          Changing Key Bindings.
                                                              (line 153)
* ユニバイトテキスト:                    Text Representations.
                                                              (line  15)
* ユーザーへの問い合わせ:                Yes-or-No Queries.   (line   6)
* ユーザーオプション:                    Defining Variables.  (line 126)
* ユーザー定義エラー:                    Error Symbols.       (line   6)
* ライブラリ:                            Loading.             (line   6)
* ライブラリのコンパイル:                Compilation Functions.
                                                              (line 100)
* ライブラリヘッダコメント:              Library Headers.     (line   6)
* ラムダリスト:                          Lambda Components.   (line  13)
* ラムダリスト（edebug）:                Specification List.  (line 168)
* ラムダ式:                              Lambda Expressions.  (line   6)
* リサイズ、フレーム:                    Size and Position.   (line   6)
* リスト:                                Lists.               (line   6)
* リスト、キーマップ:                    Key Lookup.          (line  62)
* リストとコンスセル:                    Cons Cells.          (line   6)
* リストのコピー:                        Building Lists.      (line  57)
* リストのソート:                        Rearrangement.       (line  98)
* リストのメンバ:                        Sets And Lists.      (line  18)
* リストの図表示:                        Cons Cell Type.      (line  47)
* リストの変更:                          Rearrangement.       (line   6)
* リストの構築:                          Building Lists.      (line   6)
* リストの箱表示:                        Cons Cell Type.      (line  47)
* リストの要素:                          List Elements.       (line   6)
* リストの長さ:                          Sequence Functions.  (line  16)
* リストの順序の変更:                    Rearrangement.       (line   6)
* リストを接続する:                      Rearrangement.       (line  16)
* リストを逆順にする:                    Rearrangement.       (line  64)
* リストを連結する:                      Rearrangement.       (line  16)
* リストフォームの評価:                  Classifying Lists.   (line   6)
* リスト内の(...):                       Cons Cell Type.      (line  82)
* リスト内の.:                           Dotted Pair Notation.
                                                              (line   6)
* リスト内のnil:                         Cons Cell Type.      (line  82)
* リスト単位の移動:                      List Motion.         (line   6)
* リスト構造:                            Cons Cells.          (line  23)
* リテラルの評価:                        Self-Evaluating Forms.
                                                              (line   6)
* リドゥ:                                Undo.                (line   6)
* リージョン:                            The Region.          (line   6)
* リージョン内の行数:                    Text Lines.          (line  71)
* リージョン引数:                        Interactive Codes.   (line 142)
* リーディングコード:                    Text Representations.
                                                              (line  21)
* ループ、無限:                          Infinite Loops.      (line   6)
* レキシカル（テキスト上の）束縛（edebug）: Edebug Eval.      (line  23)
* レジスタ:                              Registers.           (line   6)
* レジスタの減数フィールド:              Cons Cell Type.      (line   6)
* レジスタの番地フィールド:              Cons Cell Type.      (line   6)
* ロック、ファイル:                      File Locks.          (line   6)
* ローカルキーマップ:                    Active Keymaps.      (line   6)
* ローカル変数:                          Local Variables.     (line   6)
* ローカル変数束縛:                      Local Variables.     (line   6)
* ローカル束縛:                          Local Variables.     (line   6)
* ロード:                                Loading.             (line   6)
* ロード、モード:                        Major Mode Conventions.
                                                              (line 156)
* ロードの繰り返し:                      Repeated Loading.    (line   6)
* ロードエラー:                          How Programs Do Loading.
                                                              (line  69)
* ロードフック:                          Hooks for Loading.   (line   6)
* ワイドニング:                          Narrowing.           (line  44)
* 三角関数:                              Math Functions.      (line   6)
* 不可視なテキスト:                      Invisible Text.      (line   6)
* 不可視なフレーム:                      Visibility of Frames.
                                                              (line   6)
* 不正なプレフィックスキーエラー:        Changing Key Bindings.
                                                              (line  51)
* 不正な関数:                            Function Indirection.
                                                              (line  23)
* 不活性化、アドバイス:                  Activation of Advice.
                                                              (line  33)
* 中断:                                  Quitting.            (line   6)
* 中断、無限ループ:                      Infinite Loops.      (line   6)
* 丸める:                                Rounding Operations. (line   6)
* 丸め変換:                              Numeric Conversions. (line   6)
* 乱数:                                  Random Numbers.      (line   6)
* 予約活性、アドバイス:                  Preactivation.       (line   6)
* 予約済みキー:                          Coding Conventions.  (line  81)
* 事前アドバイス（before-advice）:       Defining Advice.     (line  22)
* 事後アドバイス（after-advice）:        Defining Advice.     (line  22)
* 二重引用符、文字列:                    Syntax for Strings.  (line   6)
* 休止:                                  Waiting.             (line   6)
* 休止、Emacs:                           Suspending Emacs.    (line   6)
* 位置、ウィンドウ内:                    Window Point.        (line   6)
* 位置、マウス:                          Mouse Position.      (line   6)
* 位置引数:                              Interactive Codes.   (line  70)
* 位置（バッファ内）:                    Positions.           (line   6)
* 余り:                                  Arithmetic Operations.
                                                              (line 111)
* 作成、バッファ:                        Creating Buffers.    (line   6)
* 作成方法、バックアップファイル:        Rename or Copy.      (line   6)
* 例、commandp:                          High-Level Completion.
                                                              (line  83)
* 例、interactive:                       Interactive Examples.
                                                              (line   6)
* 例、print:                             Output Streams.      (line  46)
* 例、throw:                             Recursive Editing.   (line  33)
* 例、user-variable-p:                   High-Level Completion.
                                                              (line 112)
* 例、構文テーブル:                      Example Major Modes. (line  59)
* 保存、ウィンドウ情報:                  Window Configurations.
                                                              (line   6)
* 保存、テキスト属性:                    Saving Properties.   (line   6)
* 保護されたフォーム:                    Cleanups.            (line  12)
* 修飾ビット（入力文字）:                Keyboard Events.     (line  12)
* 値セル:                                Symbol Components.   (line  15)
* 停止、無限ループ:                      Infinite Loops.      (line   6)
* 停止位置:                              Using Edebug.        (line  37)
* 停止（no-redraw-on-reenterを参照 ）:   Refresh Screen.      (line  28)
* 偽（false）:                           nil and t.           (line   6)
* 入力、プロセス:                        Input to Processes.  (line   6)
* 入力の破棄:                            Event Input Misc.    (line  72)
* 入力を覗き見る:                        Event Input Misc.    (line  11)
* 入力イベント:                          Input Events.        (line   6)
* 入力イベントの変換:                    Translating Input.   (line   6)
* 入力ストリーム:                        Input Streams.       (line   6)
* 入力フォーカス:                        Input Focus.         (line   6)
* 入力方式 <1>:                          Input Modes.         (line   6)
* 入力方式:                              Input Methods.       (line   6)
* 入力構文:                              Printed Representation.
                                                              (line   6)
* 入力構文、文字:                        Character Type.      (line  22)
* 全面プロンプト文字列:                  Format of Keymaps.   (line  50)
* 内部、ウィンドウ:                      Window Internals.    (line   6)
* 内部、バッファ:                        Buffer Internals.    (line   6)
* 内部、プロセス:                        Process Internals.   (line   6)
* 再バインディング:                      Changing Key Bindings.
                                                              (line   6)
* 再帰:                                  Iteration.           (line   6)
* 再帰コマンドループ:                    Recursive Editing.   (line   6)
* 再帰的評価:                            Intro Eval.          (line  38)
* 再帰編集の終了:                        Recursive Editing.   (line  33)
* 再帰編集レベル:                        Recursive Editing.   (line   6)
* 再表示の強制:                          Waiting.             (line  29)
* 再開（no-redraw-on-reenterを参照 ）:   Refresh Screen.      (line  28)
* 出力、プロセス:                        Output from Processes.
                                                              (line   6)
* 出力ストリーム:                        Output Streams.      (line   6)
* 出力（edebug）:                        Printing in Edebug.  (line   6)
* 分割、ウィンドウ:                      Splitting Windows.   (line   6)
* 切り替え、バッファ:                    Current Buffer.      (line   6)
* 初期化:                                Start-up Summary.    (line   6)
* 初期化ファイル:                        Init File.           (line   6)
* 別のバッファへ切り替える:              Current Buffer.      (line   6)
* 制御構造:                              Control Structures.  (line   6)
* 制御構造向けのスペシャルフォーム:      Control Structures.  (line   6)
* 制限（バッファ）:                      Narrowing.           (line   6)
* 削除、バッファ:                        Killing Buffers.     (line   6)
* 削除、フレーム:                        Deleting Frames.     (line   6)
* 削除、要素:                            Sets And Lists.      (line  30)
* 削除とキル:                            Deletion.            (line   6)
* 前置引数:                              Prefix Command Arguments.
                                                              (line   6)
* 前置引数の読み戻し:                    Event Input Misc.    (line  19)
* 前置引数付きの実行:                    Interactive Call.    (line  75)
* 副作用:                                Intro Eval.          (line  57)
* 剰余:                                  Arithmetic Operations.
                                                              (line 136)
* 効率解析:                              Coverage Testing.    (line   6)
* 動的スコープ:                          Variable Scoping.    (line  10)
* 包囲アドバイス（around-advice）:       Defining Advice.     (line  22)
* 単語の探索:                            String Search.       (line  67)
* 単語構成文字（word constituent）:      Syntax Class Table.  (line  17)
* 参照、環境変数:                        System Environment.  (line  99)
* 参照可能性、ファイル:                  Testing Accessibility.
                                                              (line   6)
* 参照可能部分（バッファ）:              Narrowing.           (line   6)
* 反転表示:                              Inverse Video.       (line   6)
* 句読点文字（punctuation character）:   Syntax Class Table.  (line  31)
* 可視なフレーム:                        Visibility of Frames.
                                                              (line   6)
* 同値:                                  Equality Predicates. (line   6)
* 同値性、シンボル:                      Creating Symbols.    (line  37)
* 同値性、数:                            Comparison of Numbers.
                                                              (line   6)
* 同値性、文字列:                        Text Comparison.     (line   6)
* 同期サブプロセス:                      Synchronous Processes.
                                                              (line   6)
* 名前付き関数:                          Function Names.      (line   6)
* 呼び出しスタック:                      Internals of Debugger.
                                                              (line  18)
* 図表示、リスト:                        Cons Cell Type.      (line  47)
* 垂直スクロール:                        Vertical Scrolling.  (line   6)
* 垂直タブ:                              Character Type.      (line  40)
* 型:                                    Lisp Data Types.     (line   6)
* 型、プログラミング向け:                Programming Types.   (line   6)
* 型、編集向け:                          Editing Types.       (line   6)
* 型の検査:                              Type Predicates.     (line  20)
* 型検査:                                Type Predicates.     (line   6)
* 型検査の内部:                          Object Internals.    (line  23)
* 型述語:                                Type Predicates.     (line  20)
* 基底コーディングシステム:              Coding System Basics.
                                                              (line  25)
* 基底バッファ:                          Indirect Buffers.    (line   6)
* 基本コード（入力文字）:                Keyboard Events.     (line  12)
* 基本型:                                Lisp Data Types.     (line  17)
* 基本関数:                              What Is a Function.  (line  21)
* 基本関数の内部:                        Writing Emacs Primitives.
                                                              (line   6)
* 基本（fundamental）モード:             Major Modes.         (line   6)
* 変換、文字と文字列:                    String Conversion.   (line   6)
* 変換せずに丸める:                      Rounding Operations. (line   6)
* 変換表:                                Translation of Characters.
                                                              (line   6)
* 変数:                                  Variables.           (line   6)
* 変数、グローバル:                      Global Variables.    (line   6)
* 変数、バッファローカル:                Buffer-Local Variables.
                                                              (line   6)
* 変数、ローカル:                        Local Variables.     (line   6)
* 変数の記述例:                          A Sample Variable Description.
                                                              (line   6)
* 変数を隠す:                            Local Variables.     (line  19)
* 変数制限エラー:                        Local Variables.     (line 111)
* 変数定義:                              Defining Variables.  (line   6)
* 変更、ウィンドウサイズ:                Resizing Windows.    (line   6)
* 変更フック:                            Change Hooks.        (line   6)
* 変更フラグ、バッファ:                  Buffer Modification. (line   6)
* 変種コーディングシステム:              Coding System Basics.
                                                              (line  25)
* 夏時間:                                Daylight Savings.    (line   6)
* 大きさ、ウィンドウ:                    Size of Window.      (line   6)
* 大文字:                                Case Conversion.     (line   6)
* 大文字のキー列:                        Key Sequence Input.  (line  48)
* 大文字小文字:                          Case Conversion.     (line   6)
* 始動、Emacs:                           Start-up Summary.    (line   6)
* 子プロセス:                            Processes.           (line   6)
* 字下げ:                                Indentation.         (line   6)
* 字下げのためのタブストップ:            Indent Tabs.         (line   6)
* 字形:                                  Glyphs.              (line   6)
* 字形テーブル:                          Glyphs.              (line  10)
* 存続期間:                              Variable Scoping.    (line  10)
* 完全なキー:                            Keymap Terminology.  (line   6)
* 完全なキーマップ:                      Format of Keymaps.   (line   6)
* 定義、アドバイス:                      Defining Advice.     (line   6)
* 定義、コマンド:                        Defining Commands.   (line   6)
* 実名（ファイル）:                      Truenames.           (line   6)
* 実行、:                                Subprocess Creation. (line  17)
* 実行時スタック:                        Internals of Debugger.
                                                              (line  18)
* 実行時スタック上のタグ:                Catch and Throw.     (line  64)
* 実行速度:                              Compilation Tips.    (line   6)
* 対になった区切り（paired delimiter）:  Syntax Class Table.  (line  94)
* 対応する括弧:                          Blinking.            (line   6)
* 対話コード記述子:                      Interactive Codes.   (line   6)
* 対話ボックス:                          Dialog Boxes.        (line   6)
* 対話的コマンド（edebug）:              Instrumenting.       (line  41)
* 対話的呼び出し:                        Interactive Call.    (line   6)
* 対話的関数:                            Defining Commands.   (line   6)
* 専用ウィンドウ:                        Choosing Window.     (line 170)
* 導入列:                                Chars and Bytes.     (line   6)
* 小文字:                                Case Conversion.     (line   6)
* 展開、マクロ:                          Expansion.           (line   6)
* 属性mode-class:                        Major Mode Conventions.
                                                              (line 137)
* 属性、テキスト:                        Text Properties.     (line   6)
* 属性リストと連想リスト:                Plists and Alists.   (line   6)
* 属性リストセル:                        Symbol Components.   (line  31)
* 属性リスト（plist）:                   Property Lists.      (line   6)
* 履歴、コマンド:                        Command History.     (line   6)
* 履歴リスト:                            Minibuffer History.  (line   6)
* 巡回順序、ウィンドウ:                  Cyclic Window Ordering.
                                                              (line   6)
* 廃れたバッファ:                        Modification Time.   (line  56)
* 式:                                    Intro Eval.          (line  16)
* 式の値:                                Evaluation.          (line   6)
* 式前置子（expression prefix）:         Syntax Class Table.  (line 100)
* 引数、プログラム:                      Subprocess Creation. (line  40)
* 引数の読み取り:                        Minibuffers.         (line   6)
* 引数を束縛する:                        Argument List.       (line   6)
* 引数プロンプト:                        Using Interactive.   (line  54)
* 引数束縛:                              Argument List.       (line   6)
* 引数記述子:                            Using Interactive.   (line  10)
* 引数評価フォーム:                      Using Interactive.   (line  32)
* 強制終了:                              Recursive Editing.   (line  33)
* 強調表示:                              Inverse Video.       (line   7)
* 待機:                                  Waiting.             (line   6)
* 後始末フォーム:                        Cleanups.            (line  12)
* 復帰:                                  Character Type.      (line  40)
* 循環構造の出力:                        Printing in Edebug.  (line   6)
* 恒久的なローカル変数:                  Creating Buffer-Local.
                                                              (line 156)
* 打鍵:                                  Keymap Terminology.  (line   6)
* 打鍵コマンド:                          What Is a Function.  (line  69)
* 括弧 <1>:                              Cons Cell Type.      (line  36)
* 括弧:                                  Blinking.            (line   6)
* 括弧による字下げ:                      Parsing Expressions. (line  74)
* 括弧の構文:                            Syntax Class Table.  (line  39)
* 括弧の深さ:                            Parsing Expressions. (line  26)
* 挿入、テキスト:                        Insertion.           (line   6)
* 挿入、ポイントのまえ:                  Insertion.           (line   6)
* 排他的論理和:                          Bitwise Operations.  (line 179)
* 探索:                                  Searching and Matching.
                                                              (line   6)
* 探索、正規表現:                        Regexp Search.       (line   6)
* 探索と大文字小文字:                    Searching and Case.  (line   6)
* 接続、リスト:                          Rearrangement.       (line  16)
* 改行:                                  Character Type.      (line  40)
* 改行、文字列:                          Syntax for Strings.  (line  14)
* 改行、表示:                            Output Functions.    (line  86)
* 改行と自動詰め込み（auto-fill）モード: Commands for Insertion.
                                                              (line  40)
* 数:                                    Numbers.             (line   6)
* 数としてのマーカ:                      Overview of Markers. (line  35)
* 数の同値性:                            Comparison of Numbers.
                                                              (line   6)
* 数値前置引数:                          Prefix Command Arguments.
                                                              (line   6)
* 数値前置引数の使い方:                  Interactive Codes.   (line 136)
* 数前置子:                              Formatting Strings.  (line 104)
* 数学関数:                              Math Functions.      (line   6)
* 整数:                                  Numbers.             (line   6)
* 整数から文字列へ:                      String Conversion.   (line  42)
* 整数の10進表記:                        String Conversion.   (line  42)
* 整数の16進表記:                        Formatting Strings.  (line  68)
* 整数の8進表記:                         Formatting Strings.  (line  62)
* 文字:                                  Strings and Characters.
                                                              (line   6)
* 文字、対話指定のコード:                Interactive Codes.   (line   6)
* 文字から文字列へ:                      String Conversion.   (line  20)
* 文字と文字列の変換:                    String Conversion.   (line   6)
* 文字に対する変更フック:                Special Properties.  (line  80)
* 文字のカテゴリ:                        Categories.          (line   6)
* 文字のキーマップ:                      Special Properties.  (line  37)
* 文字のキーマップ（オーバレイ属性）:    Overlay Properties.  (line 125)
* 文字の入力構文:                        Character Type.      (line  22)
* 文字の挿入:                            Commands for Insertion.
                                                              (line  15)
* 文字の構文:                            Character Type.      (line  22)
* 文字の置換:                            Substitution.        (line  10)
* 文字の表示:                            Describing Characters.
                                                              (line  19)
* 文字の表示表現:                        Character Type.      (line  22)
* 文字クォート（character quote）:       Syntax Class Table.  (line  83)
* 文字コード:                            Character Codes.     (line   6)
* 文字コード変換:                        Coding System Basics.
                                                              (line   6)
* 文字テーブル:                          Char-Tables.         (line   6)
* 文字テーブルのサブタイプ:              Char-Tables.         (line  14)
* 文字テーブルのデフォルト値:            Char-Tables.         (line  31)
* 文字テーブルの親:                      Char-Tables.         (line  25)
* 文字テーブルの追加スロット:            Char-Tables.         (line   6)
* 文字列:                                Strings and Characters.
                                                              (line   6)
* 文字列、キーマップ:                    Key Lookup.          (line  52)
* 文字列、説明文字列を書く:              Documentation Basics.
                                                              (line   6)
* 文字列からオブジェクトへ:              Input Functions.     (line  21)
* 文字列から数へ:                        String Conversion.   (line  58)
* 文字列から文字へ:                      String Conversion.   (line  25)
* 文字列の":                             Syntax for Strings.  (line   6)
* 文字列の\:                             Syntax for Strings.  (line   6)
* 文字列のコピー:                        Creating Strings.    (line  88)
* 文字列のダブルクォート:                Syntax for Strings.  (line   6)
* 文字列のバックスラッシュ:              Syntax for Strings.  (line   6)
* 文字列の二重引用符:                    Syntax for Strings.  (line   6)
* 文字列の内側:                          Parsing Expressions. (line  53)
* 文字列の同値性:                        Text Comparison.     (line   6)
* 文字列の改行:                          Syntax for Strings.  (line  14)
* 文字列の書式付け:                      Formatting Strings.  (line   6)
* 文字列の連結:                          Creating Strings.    (line  88)
* 文字列の長さ:                          Sequence Functions.  (line  16)
* 文字列クォート（string quote）:        Syntax Class Table.  (line  54)
* 文字列入力ストリーム:                  Input Streams.       (line  22)
* 文字列探索:                            String Search.       (line   6)
* 文字変換表:                            Translation of Characters.
                                                              (line   6)
* 文字変更に対するフック:                Special Properties.  (line  80)
* 文字定数、8進数字:                     Character Type.      (line 127)
* 文字定数、?:                           Character Type.      (line 127)
* 文字定数、\:                           Character Type.      (line 127)
* 文字定数、バックスラッシュ:            Character Type.      (line 127)
* 文字定数、疑問符:                      Character Type.      (line 127)
* 文字群の飛び越し:                      Skipping Characters. (line   6)
* 文字選択（正規表現）:                  Syntax of Regexps.   (line  80)
* 文字配列:                              Strings and Characters.
                                                              (line   6)
* 文字集合:                              Character Sets.      (line   6)
* 新規ファイルメッセージ:                Subroutines of Visiting.
                                                              (line  38)
* 日誌用バッファ:                        Fancy Diary Display. (line  12)
* 日誌項目のソート:                      Fancy Diary Display. (line  30)
* 暗黙のprogn:                           Sequencing.          (line  20)
* 暫定マーク（transient-mark）モード:    The Mark.            (line 120)
* 更新時刻の比較:                        Modification Time.   (line   6)
* 書式付け、文字列:                      Formatting Strings.  (line   6)
* 書式付け指定:                          Formatting Strings.  (line  23)
* 書式定義:                              Format Conversion.   (line  15)
* 月始めの特別礼拝:                      Sexp Diary Entries.  (line 139)
* 有効化と無効化、アドバイス:            Enabling Advice.     (line   6)
* 未定義のアドバイス（forward advice）:  Defining Advice.     (line  75)
* 未定義キー:                            Keymap Terminology.  (line   6)
* 条件付き評価:                          Conditionals.        (line   6)
* 条件名:                                Error Symbols.       (line   6)
* 桁溢れ:                                Integer Basics.      (line   9)
* 構文エラー（edebug）:                  Backtracking.        (line   6)
* 構文クラス:                            Syntax Descriptors.  (line   6)
* 構文テーブル:                          Syntax Tables.       (line   6)
* 構文テーブル、モード:                  Major Mode Conventions.
                                                              (line  75)
* 構文テーブルの例:                      Example Major Modes. (line  59)
* 構文テーブルの内部:                    Syntax Table Internals.
                                                              (line   6)
* 構文フラグ:                            Syntax Flags.        (line   6)
* 構文解析:                              Syntax Tables.       (line   6)
* 構文記述子:                            Syntax Descriptors.  (line  21)
* 標準的な正規表現:                      Standard Regexps.    (line   6)
* 機能:                                  Named Features.      (line   6)
* 機能を提供する:                        Named Features.      (line   6)
* 機能を要求する:                        Named Features.      (line   6)
* 次元（文字集合）:                      Chars and Bytes.     (line   6)
* 正の無限大:                            Float Basics.        (line  16)
* 正規表現:                              Regular Expressions. (line   6)
* 正規表現による行頭:                    Syntax of Regexps.   (line 139)
* 正規表現の$:                           Syntax of Regexps.   (line 148)
* 正規表現の(:                           Syntax of Regexps.   (line 199)
* 正規表現の):                           Syntax of Regexps.   (line 199)
* 正規表現の*:                           Syntax of Regexps.   (line  34)
* 正規表現の+:                           Syntax of Regexps.   (line  67)
* 正規表現の.:                           Syntax of Regexps.   (line  29)
* 正規表現の?:                           Syntax of Regexps.   (line  74)
* 正規表現の[:                           Syntax of Regexps.   (line  80)
* 正規表現の\:                           Syntax of Regexps.   (line 155)
* 正規表現の\':                          Syntax of Regexps.   (line 270)
* 正規表現の\<:                          Syntax of Regexps.   (line 290)
* 正規表現の\=:                          Syntax of Regexps.   (line 274)
* 正規表現の\>:                          Syntax of Regexps.   (line 294)
* 正規表現の\`:                          Syntax of Regexps.   (line 266)
* 正規表現の\B:                          Syntax of Regexps.   (line 287)
* 正規表現の\b:                          Syntax of Regexps.   (line 278)
* 正規表現の\s:                          Syntax of Regexps.   (line 250)
* 正規表現の\S:                          Syntax of Regexps.   (line 259)
* 正規表現の\w:                          Syntax of Regexps.   (line 242)
* 正規表現の\W:                          Syntax of Regexps.   (line 247)
* 正規表現の]:                           Syntax of Regexps.   (line  80)
* 正規表現の^:                           Syntax of Regexps.   (line 125)
* 正規表現の|:                           Syntax of Regexps.   (line 186)
* 正規表現のグループ化:                  Syntax of Regexps.   (line 199)
* 正規表現の探索:                        Regexp Search.       (line   6)
* 正規表現の選択肢:                      Syntax of Regexps.   (line 186)
* 段落の詰め込み:                        Filling.             (line  37)
* 比較、更新時刻:                        Modification Time.   (line   6)
* 比較、辞書式順:                        Text Comparison.     (line  39)
* 水平スクロール:                        Horizontal Scrolling.
                                                              (line   6)
* 水平位置:                              Columns.             (line   6)
* 汎用コメント区切り（generic comment delimiter）: Syntax Class Table.
                                                              (line 122)
* 汎用文字:                              Splitting Characters.
                                                              (line  53)
* 汎用文字列区切り（generic string delimiter）: Syntax Class Table.
                                                              (line 135)
* 活性なキーマップ:                      Active Keymaps.      (line   6)
* 活性な表示テーブル:                    Active Display Table.
                                                              (line   6)
* 活性化、アドバイス:                    Activation of Advice.
                                                              (line   6)
* 浅い束縛（シャローバインディング、shallow binding）: Impl of Scope.
                                                              (line  26)
* 深い束縛（ディープバインディング、deep binding）: Impl of Scope.
                                                              (line   6)
* 無名ラムダ式（edebug）:                Instrumenting.       (line  41)
* 無名関数:                              Anonymous Functions. (line   6)
* 無限ループ:                            Infinite Loops.      (line   6)
* 無限ループの中断:                      Infinite Loops.      (line   6)
* 無限ループの停止:                      Infinite Loops.      (line   6)
* 無限再帰:                              Local Variables.     (line 111)
* 無限大:                                Float Basics.        (line  16)
* 版番号（ファイル名）:                  File Name Components.
                                                              (line   6)
* 特定の関数のデバッグ:                  Function Debugging.  (line   6)
* 特殊イベント:                          Special Events.      (line   6)
* 現在のコマンド:                        Command Loop Info.   (line  25)
* 現在の束縛:                            Local Variables.     (line  44)
* 環境:                                  Intro Eval.          (line  52)
* 環境変数EMACSLOADPATH:                 Library Search.      (line  10)
* 環境変数HOME:                          Subprocess Creation. (line  17)
* 環境変数PATH:                          Subprocess Creation. (line  17)
* 環境変数TERM:                          Terminal-Specific.   (line  39)
* 環境変数TMP:                           Unique File Names.   (line  38)
* 環境変数TMPDIR:                        Unique File Names.   (line  38)
* 環境変数、サブプロセス:                Subprocess Creation. (line  52)
* 環境変数の参照:                        System Environment.  (line  99)
* 生のバイト:                            Explicit Encoding.   (line  10)
* 生の前置引数:                          Prefix Command Arguments.
                                                              (line   6)
* 生の前置引数の使い方:                  Interactive Codes.   (line 132)
* 画面表示の$:                           Truncation.          (line   6)
* 画面表示の\:                           Truncation.          (line   6)
* 画面配置 <1>:                          Frame Configuration Type.
                                                              (line   6)
* 画面配置:                              Window Configuration Type.
                                                              (line   6)
* 略語:                                  Abbrevs.             (line   6)
* 略語表:                                Abbrevs.             (line   6)
* 略語表、モード:                        Major Mode Conventions.
                                                              (line  85)
* 番兵:                                  Sentinels.           (line   6)
* 疎なキーマップ:                        Format of Keymaps.   (line   6)
* 疑似端末PTY:                           Asynchronous Processes.
                                                              (line  72)
* 疑問符、文字定数:                      Character Type.      (line 127)
* 白文字:                                Character Type.      (line  40)
* 白文字の削除:                          User-Level Deletion. (line  10)
* 白文字（whitespace character）:        Syntax Class Table.  (line  10)
* 直前の文字を削除:                      Deletion.            (line  49)
* 相対ファイル名:                        Relative File Names. (line   6)
* 省略形、ディレクトリ名:                Directory Names.     (line  42)
* 真理値:                                nil and t.           (line   6)
* 真（true）:                            nil and t.           (line  24)
* 破壊的なリスト操作:                    Modifying Lists.     (line   6)
* 祝祭日形式:                            Holiday Customizing. (line  37)
* 禁止コマンド:                          Disabling Commands.  (line   6)
* 移動、Lisp式:                          List Motion.         (line   6)
* 移動、S式単位:                         List Motion.         (line   6)
* 移動、リスト単位:                      List Motion.         (line   6)
* 空の変数:                              Void Variables.      (line   6)
* 空の関数セル:                          Function Cells.      (line  29)
* 空リスト:                              Cons Cell Type.      (line  82)
* 空関数:                                Function Indirection.
                                                              (line   6)
* 端末スクリーン:                        Basic Windows.       (line  69)
* 端末フレーム:                          Frames.              (line  11)
* 端末入力 <1>:                          Input Modes.         (line   6)
* 端末入力:                              Terminal Input.      (line   6)
* 端末出力:                              Terminal Output.     (line   6)
* 端末固有の初期化:                      Terminal-Specific.   (line   6)
* 算術シフト:                            Bitwise Operations.  (line  80)
* 箱表示、リスト <1>:                    Lists as Boxes.      (line   6)
* 箱表示、リスト:                        Cons Cell Type.      (line  47)
* 箱表示によるリスト:                    Lists as Boxes.      (line   6)
* 範囲:                                  Not Intervals.       (line   6)
* 終了、Emacs <1>:                       Getting Out.         (line   6)
* 終了、Emacs:                           Killing Emacs.       (line   6)
* 組み込み関数:                          What Is a Function.  (line  21)
* 結果表示の表記法:                      Printing Notation.   (line   6)
* 絶対ファイル名:                        Relative File Names. (line   6)
* 継承、キーマップ:                      Inheritance and Keymaps.
                                                              (line   6)
* 継承、キーマップのバインディング:      Inheritance and Keymaps.
                                                              (line   6)
* 継承（inherit）:                       Syntax Class Table.  (line 117)
* 継続行:                                Truncation.          (line   6)
* 編集に用いられる標準的な正規表現:      Standard Regexps.    (line   6)
* 編集向けの型:                          Editing Types.       (line   6)
* 繋ぎ合わせ（バッククォートとの組み合わせ）: Backquote.      (line  39)
* 繰り返し:                              Iteration.           (line   6)
* 繰り返しイベント:                      Repeat Events.       (line   6)
* 置換:                                  Search and Replace.  (line   6)
* 置換、文字:                            Substitution.        (line  10)
* 置換の&:                               Replacing Match.     (line  44)
* 置換の\:                               Replacing Match.     (line  52)
* 置換の\N:                              Replacing Match.     (line  47)
* 置換時の大文字小文字:                  Replacing Match.     (line   8)
* 自動ロード:                            Autoload.            (line   6)
* 自動ロードする関数セル:                Autoload.            (line  61)
* 自動ロードエラー:                      Autoload.            (line  81)
* 自動保存:                              Auto-Saving.         (line   6)
* 自動的にバッファローカルにする:        Intro to Buffer-Local.
                                                              (line  44)
* 自動詰め込み（auto-filling）モード:    Auto Filling.        (line   6)
* 自己挿入:                              Commands for Insertion.
                                                              (line  15)
* 自己評価型フォーム:                    Self-Evaluating Forms.
                                                              (line   6)
* 自然数:                                Predicates on Numbers.
                                                              (line  29)
* 自由リスト:                            Garbage Collection.  (line  41)
* 行:                                    Text Lines.          (line   6)
* 行の折り返し:                          Truncation.          (line   6)
* 行末変換:                              Coding System Basics.
                                                              (line  18)
* 行頭:                                  Text Lines.          (line  56)
* 行頭、正規表現:                        Syntax of Regexps.   (line 139)
* 表示:                                  Streams Intro.       (line   6)
* 表示テーブル:                          Display Tables.      (line   6)
* 表示制限:                              Output Variables.    (line  58)
* 表示名:                                Symbol Components.   (line  10)
* 表示表現:                              Printed Representation.
                                                              (line   6)
* 表示表現、文字:                        Character Type.      (line  22)
* 表記法、エラーメッセージ:              Error Messages.      (line   6)
* 表記法、バッファ内のテキスト:          Buffer Text Notation.
                                                              (line   6)
* 表記法、結果表示:                      Printing Notation.   (line   6)
* 表記法、記述:                          Evaluation Notation. (line   6)
* 表記法、評価:                          Evaluation Notation. (line   6)
* 補完:                                  Completion.          (line   6)
* 補完、ファイル名:                      File Name Completion.
                                                              (line   6)
* 補完、対話指定:                        Interactive Codes.   (line  10)
* 補完におけるオブジェクト配列:          Basic Completion.    (line  27)
* 複数のXディスプレイ:                   Multiple Displays.   (line   6)
* 複数のウィンドウ:                      Basic Windows.       (line  55)
* 複数の名前のファイル:                  Changing Files.      (line  22)
* 複雑なコマンド:                        Command History.     (line   6)
* 複雑な引数:                            Minibuffers.         (line   6)
* 要素、シーケンス:                      Sequence Functions.  (line  35)
* 要素の削除:                            Sets And Lists.      (line  30)
* 要素（リスト）:                        Lists.               (line   6)
* 親プロセス:                            Processes.           (line   6)
* 解析状態:                              Parsing Expressions. (line  38)
* 記述、コマンド:                        A Sample Function Description.
                                                              (line   6)
* 記述、スペシャルフォーム:              A Sample Function Description.
                                                              (line   6)
* 記述、マクロ:                          A Sample Function Description.
                                                              (line   6)
* 記述、関数:                            A Sample Function Description.
                                                              (line   6)
* 記述の表記法:                          Evaluation Notation. (line   6)
* 記述例、オプション:                    A Sample Variable Description.
                                                              (line   6)
* 記述例、変数:                          A Sample Variable Description.
                                                              (line   6)
* 記述子、対話指定のコード:              Interactive Codes.   (line   6)
* 記述形式:                              Format of Descriptions.
                                                              (line   6)
* 訪問したファイルのモード:              Auto Major Mode.     (line  70)
* 訪問しているファイル:                  Buffer File Name.    (line   6)
* 評価:                                  Evaluation.          (line   6)
* 評価、シンボル:                        Symbol Forms.        (line   6)
* 評価、スペシャルフォーム:              Special Forms.       (line   6)
* 評価、バッファ内容:                    Eval.                (line  68)
* 評価、ベクトル:                        Self-Evaluating Forms.
                                                              (line   6)
* 評価、マクロ呼び出し:                  Macro Forms.         (line   6)
* 評価、マクロ引数:                      Argument Evaluation. (line  56)
* 評価、リストフォーム:                  Classifying Lists.   (line   6)
* 評価、リテラル:                        Self-Evaluating Forms.
                                                              (line   6)
* 評価、条件付き:                        Conditionals.        (line   6)
* 評価、関数フォーム:                    Function Forms.      (line   6)
* 評価の一時休止:                        Recursive Editing.   (line  66)
* 評価の表記法:                          Evaluation Notation. (line   6)
* 評価エラー:                            Local Variables.     (line 111)
* 評価リストグループ:                    Eval List.           (line  46)
* 評価済みの式引数:                      Interactive Codes.   (line 168)
* 詰め込み、明示的:                      Filling.             (line   6)
* 詰め込み、段落:                        Filling.             (line  37)
* 詰め込み、自動:                        Auto Filling.        (line   6)
* 説明文、キー:                          Keys in Documentation.
                                                              (line   6)
* 説明文、メジャーモード:                Mode Help.           (line   6)
* 説明文の慣習:                          Documentation Basics.
                                                              (line   6)
* 説明文内のキーの置換:                  Keys in Documentation.
                                                              (line   6)
* 説明文字列:                            Documentation.       (line   6)
* 説明文字列、関数:                      Function Documentation.
                                                              (line   6)
* 説明文字列の動的ロード:                Docs and Compilation.
                                                              (line   6)
* 説明文字列を書く:                      Documentation Basics.
                                                              (line   6)
* 説明文字列内のキー:                    Keys in Documentation.
                                                              (line   6)
* 読み出し専用バッファ:                  Read Only Buffers.   (line   6)
* 読み出し専用バッファ、対話指定:        Using Interactive.   (line  77)
* 読み出し専用文字:                      Special Properties.  (line  49)
* 読み取り:                              Streams Intro.       (line   6)
* 読み取り、パスワード:                  Reading a Password.  (line   6)
* 読み取り、対話引数:                    Interactive Codes.   (line  38)
* 論理シフト:                            Bitwise Operations.  (line  15)
* 論理否定:                              Bitwise Operations.  (line 197)
* 論理和:                                Bitwise Operations.  (line 161)
* 論理積:                                Bitwise Operations.  (line 127)
* 負の無限大:                            Float Basics.        (line  16)
* 辞書式順の比較:                        Text Comparison.     (line  39)
* 述語:                                  Type Predicates.     (line   6)
* 追悼記念祭:                            Sexp Diary Entries.  (line 139)
* 追跡、マウス:                          Mouse Tracking.      (line   6)
* 逆アセンブル、バイトコード:            Disassembly.         (line   6)
* 逆順、リスト:                          Rearrangement.       (line  64)
* 速度向上:                              Compilation Tips.    (line   6)
* 連想リストと属性リスト:                Plists and Alists.   (line   6)
* 連想リストのコピー:                    Association Lists.   (line 172)
* 連想リスト（alist）:                   Association Lists.   (line   6)
* 連結、リスト:                          Rearrangement.       (line  16)
* 連結、文字列:                          Creating Strings.    (line  88)
* 遅延ロード:                            Dynamic Loading.     (line   6)
* 適応型詰め込み（adaptive-fill）モード: Adaptive Fill.       (line   6)
* 選択されているウィンドウ:              Basic Windows.       (line   6)
* 選択されているフレーム:                Input Focus.         (line   6)
* 選択表示:                              Selective Display.   (line   6)
* 配列:                                  Arrays.              (line   6)
* 配列要素:                              Array Functions.     (line  21)
* 釣り合った括弧:                        Blinking.            (line   6)
* 長さ、シーケンス:                      Sequence Functions.  (line  16)
* 長さ、ベクトル:                        Sequence Functions.  (line  16)
* 長さ、リスト:                          Sequence Functions.  (line  16)
* 長さ、文字列:                          Sequence Functions.  (line  16)
* 閉じ括弧:                              Blinking.            (line   6)
* 閉じ括弧文字（close parenthesis character）: Syntax Class Table.
                                                              (line  39)
* 開き括弧文字（open parenthesis character）: Syntax Class Table.
                                                              (line  38)
* 間接:                                  Function Indirection.
                                                              (line   6)
* 間接バッファ:                          Indirect Buffers.    (line   6)
* 間接仕様:                              Specification List.  (line 101)
* 関数:                                  What Is a Function.  (line  15)
* 関数、対話的にする:                    Defining Commands.   (line   6)
* 関数の動的ロード:                      Dynamic Loading.     (line   6)
* 関数の記述:                            A Sample Function Description.
                                                              (line   6)
* 関数の説明文字列:                      Function Documentation.
                                                              (line   6)
* 関数の起動:                            Calling Functions.   (line   6)
* 関数をクォートする:                    Anonymous Functions. (line  85)
* 関数を定義する:                        Defining Functions.  (line   6)
* 関数セル:                              Symbol Components.   (line  22)
* 関数フォームの評価:                    Function Forms.      (line   6)
* 関数入力ストリーム:                    Input Streams.       (line  25)
* 関数出力ストリーム:                    Output Streams.      (line  21)
* 関数名:                                Function Names.      (line   6)
* 関数呼び出し <1>:                      Calling Functions.   (line   6)
* 関数呼び出し:                          Function Forms.      (line   6)
* 関数呼び出しのデバッグ:                Function Debugging.  (line   6)
* 関数定義:                              Function Names.      (line   6)
* 関数本体:                              Lambda Components.   (line  36)
* 関数群、モード:                        Major Mode Conventions.
                                                              (line  40)
* 関数間接、シンボル:                    Function Indirection.
                                                              (line   6)
* 除算のarith-error:                     Arithmetic Operations.
                                                              (line  88)
* 集合:                                  Sets And Lists.      (line   6)
* 集合としてのリスト:                    Sets And Lists.      (line   6)
* 非ASCII文字:                           Non-ASCII Characters.
                                                              (line   6)
* 非ディレクトリ部分（ファイル名）:      File Name Components.
                                                              (line   6)
* 非ローカル脱出:                        Nonlocal Exits.      (line   6)
* 非印字文字、読み取り:                  Quoted Character Input.
                                                              (line  12)
* 非同期プロセス:                        Asynchronous Processes.
                                                              (line   6)
* 非対話的使用:                          Batch Mode.          (line   6)
* 非数値、NaN:                           Float Basics.        (line  16)
* 順序、ウィンドウ:                      Cyclic Window Ordering.
                                                              (line   6)
* 順序を保ったソート:                    Rearrangement.       (line  98)
* 頻度数計測:                            Coverage Testing.    (line   6)


File: elisp-ja,  Node: New Symbols,  Prev: Index,  Up: Top

旧版以降の新しいシンボル
************************************

      [index ]
     * Menu:

     * access-file:                           Testing Accessibility.
                                                              (line  69)
* add-to-invisibility-spec:              Invisible Text.      (line  61)
* after-make-frame-hook:                 Creating Frames.     (line  28)
* assoc-default:                         Association Lists.   (line 154)
* assoc-ignore-case:                     Text Comparison.     (line 102)
* assoc-ignore-representation:           Text Comparison.     (line 108)
* auto-save-list-file-prefix:            Auto-Saving.         (line 196)
* backup-directory-alist:                Making Backups.      (line  65)
* backward-delete-char-untabify-method:  Deletion.            (line  82)
* before-make-frame-hook:                Creating Frames.     (line  25)
* bool-vector-p:                         Bool-Vectors.        (line  21)
* buffer-display-time:                   Buffers and Windows. (line  83)
* buffer-file-coding-system:             Encoding and I/O.    (line  23)
* buffer-name-history:                   Minibuffer History.  (line  58)
* caar:                                  List Elements.       (line 106)
* cadr:                                  List Elements.       (line 109)
* cdar:                                  List Elements.       (line 112)
* cddr:                                  List Elements.       (line 115)
* char-bytes:                            Splitting Characters.
                                                              (line  12)
* char-charset:                          Character Sets.      (line  28)
* char-table-extra-slot:                 Char-Tables.         (line  65)
* char-table-p:                          Char-Tables.         (line  45)
* char-table-parent:                     Char-Tables.         (line  58)
* char-table-range:                      Char-Tables.         (line  75)
* char-table-subtype:                    Char-Tables.         (line  49)
* char-width:                            Width.               (line  11)
* charset-dimension:                     Chars and Bytes.     (line  15)
* charset-list:                          Character Sets.      (line  25)
* charsetp:                              Character Sets.      (line  21)
* check-coding-system:                   Lisp and Coding Systems.
                                                              (line  18)
* checkdoc-minor-mode:                   Documentation Tips.  (line   6)
* coding-system-change-eol-conversion:   Lisp and Coding Systems.
                                                              (line  24)
* coding-system-change-text-conversion:  Lisp and Coding Systems.
                                                              (line  32)
* coding-system-for-read:                Specifying Coding Systems.
                                                              (line  10)
* coding-system-for-write:               Specifying Coding Systems.
                                                              (line  40)
* coding-system-get:                     Coding System Basics.
                                                              (line  47)
* coding-system-list:                    Lisp and Coding Systems.
                                                              (line   9)
* coding-system-p:                       Lisp and Coding Systems.
                                                              (line  15)
* combine-after-change-calls:            Change Hooks.        (line  33)
* compare-strings:                       Text Comparison.     (line  83)
* condition:                             Conditionals.        (line  44)
* current-input-method:                  Input Methods.       (line  19)
* current-message:                       The Echo Area.       (line  65)
* decode-coding-region:                  Explicit Encoding.   (line  55)
* decode-coding-string:                  Explicit Encoding.   (line  62)
* default-enable-multibyte-characters:   Text Representations.
                                                              (line  44)
* default-input-method:                  Input Methods.       (line  24)
* default-process-coding-system:         Default Coding Systems.
                                                              (line  73)
* defcustom:                             Variable Definitions.
                                                              (line   9)
* defface:                               Defining Faces.      (line  12)
* defgroup:                              Group Definitions.   (line  26)
* detect-coding-region:                  Lisp and Coding Systems.
                                                              (line  59)
* detect-coding-string:                  Lisp and Coding Systems.
                                                              (line  74)
* display-table-slot:                    Display Table Format.
                                                              (line  61)
* easy-mmode-define-minor-mode:          Easy-Mmode.          (line  11)
* echo-area-clear-hook:                  The Echo Area.       (line  78)
* enable-multibyte-characters:           Text Representations.
                                                              (line  35)
* encode-coding-region:                  Explicit Encoding.   (line  42)
* encode-coding-string:                  Explicit Encoding.   (line  49)
* face-bold-p:                           Face Functions.      (line  97)
* face-documentation:                    Face Functions.      (line 109)
* face-italic-p:                         Face Functions.      (line 100)
* file-coding-system-alist:              Default Coding Systems.
                                                              (line  18)
* fill-nobreak-predicate:                Margins.             (line  87)
* find-charset-region:                   Scanning Charsets.   (line  12)
* find-charset-string:                   Scanning Charsets.   (line  22)
* find-coding-systems-for-charsets:      Lisp and Coding Systems.
                                                              (line  55)
* find-coding-systems-region:            Lisp and Coding Systems.
                                                              (line  38)
* find-coding-systems-string:            Lisp and Coding Systems.
                                                              (line  47)
* find-operation-coding-system:          Default Coding Systems.
                                                              (line  83)
* focus-follows-mouse:                   Input Focus.         (line  88)
* frame-background-mode:                 Defining Faces.      (line  81)
* frame-update-face-colors:              Face Functions.      (line 133)
* functionp:                             What Is a Function.  (line  81)
* help-event-list:                       Help Functions.      (line  75)
* inhibit-eol-conversion:                Specifying Coding Systems.
                                                              (line  50)
* input-method-alist:                    Input Methods.       (line  45)
* insert-file-contents-literally:        Reading from Files.  (line  52)
* keyboard-coding-system:                Terminal I/O Encoding.
                                                              (line  13)
* keyword-symbols-constant-flag:         Constant Variables.  (line  21)
* last-coding-system-used:               Encoding and I/O.    (line  39)
* last-prefix-arg:                       Prefix Command Arguments.
                                                              (line  95)
* loadhist-special-hooks:                Unloading.           (line  69)
* make-backup-file-name-function:        Making Backups.      (line  87)
* make-bool-vector:                      Bool-Vectors.        (line  18)
* make-char:                             Splitting Characters.
                                                              (line  44)
* make-char-table:                       Char-Tables.         (line  36)
* map-char-table:                        Char-Tables.         (line 118)
* marker-insertion-type:                 Marker Insertion Types.
                                                              (line  22)
* menu-bar-mule-menu:                    Standard Keymaps.    (line 122)
* minor-mode-overriding-map-alist:       Active Keymaps.      (line 152)
* mode-line-frame-identification:        Mode Line Variables. (line  30)
* mode-line-mule-info:                   Mode Line Variables. (line  13)
* multibyte-string-p:                    Text Representations.
                                                              (line  55)
* network-coding-system-alist:           Default Coding Systems.
                                                              (line  65)
* next-char-property-change:             Property Search.     (line  81)
* nonascii-insert-offset:                Converting Representations.
                                                              (line  49)
* nonascii-translation-table:            Converting Representations.
                                                              (line  60)
* num-nonmacro-input-events:             Key Sequence Input.  (line  88)
* overlays-in:                           Managing Overlays.   (line  60)
* parse-sexp-lookup-properties:          Syntax Properties.   (line  25)
* previous-char-property-change:         Property Search.     (line  89)
* print-escape-multibyte:                Output Variables.    (line  46)
* print-escape-nonascii:                 Output Variables.    (line  35)
* process-coding-system:                 Process Information. (line 110)
* process-coding-system-alist:           Default Coding Systems.
                                                              (line  39)
* process-contact:                       Process Information. (line  49)
* read-coding-system:                    User-Chosen Coding Systems.
                                                              (line  30)
* read-input-method-name:                Input Methods.       (line  35)
* read-non-nil-coding-system:            User-Chosen Coding Systems.
                                                              (line  38)
* read-passwd:                           Reading a Password.  (line   9)
* real-last-command:                     Command Loop Info.   (line  20)
* redisplay-end-trigger-functions:       Window Hooks.        (line  55)
* regexp-opt:                            Syntax of Regexps.   (line 321)
* regexp-opt-depth:                      Syntax of Regexps.   (line 340)
* remove-from-invisibility-spec:         Invisible Text.      (line  65)
* ring-bell-function:                    Beeping.             (line  31)
* safe-length:                           List Elements.       (line  97)
* save-buffer-coding-system:             Encoding and I/O.    (line  32)
* scroll-conservatively:                 Vertical Scrolling.  (line  89)
* scroll-margin:                         Vertical Scrolling.  (line  82)
* scroll-preserve-screen-position:       Vertical Scrolling.  (line 106)
* select-safe-coding-system:             User-Chosen Coding Systems.
                                                              (line   6)
* selection-coding-system:               Window System Selections.
                                                              (line  58)
* set-buffer-multibyte:                  Selecting a Representation.
                                                              (line  11)
* set-char-table-default:                Char-Tables.         (line  52)
* set-char-table-extra-slot:             Char-Tables.         (line  69)
* set-char-table-parent:                 Char-Tables.         (line  62)
* set-char-table-range:                  Char-Tables.         (line  95)
* set-display-table-slot:                Display Table Format.
                                                              (line  70)
* set-face-bold-p:                       Face Functions.      (line  64)
* set-face-italic-p:                     Face Functions.      (line  68)
* set-input-method:                      Input Methods.       (line  28)
* set-keyboard-coding-system:            Terminal I/O Encoding.
                                                              (line  18)
* set-marker-insertion-type:             Marker Insertion Types.
                                                              (line  15)
* set-process-coding-system:             Process Information. (line 119)
* set-terminal-coding-system:            Terminal I/O Encoding.
                                                              (line  28)
* set-window-redisplay-end-trigger:      Window Hooks.        (line  63)
* shell-command-to-string:               Synchronous Processes.
                                                              (line 169)
* split-char:                            Splitting Characters.
                                                              (line  29)
* split-string:                          Creating Strings.    (line 126)
* store-substring:                       Modifying Strings.   (line  15)
* string:                                Creating Strings.    (line  23)
* string-as-multibyte:                   Selecting a Representation.
                                                              (line  33)
* string-as-unibyte:                     Selecting a Representation.
                                                              (line  26)
* string-make-multibyte:                 Converting Representations.
                                                              (line  72)
* string-make-unibyte:                   Converting Representations.
                                                              (line  67)
* string-width:                          Width.               (line  15)
* terminal-coding-system:                Terminal I/O Encoding.
                                                              (line  23)
* truncate-string-to-width:              Width.               (line  20)
* tty-erase-char:                        System Environment.  (line 173)
* when:                                  Conditionals.        (line  34)
* window-configuration-change-hook:      Window Hooks.        (line  69)
* window-redisplay-end-trigger:          Window Hooks.        (line  66)
* with-output-to-string:                 Output Functions.    (line 114)
* with-temp-file:                        Writing to Files.    (line  62)



Tag Table:
Node: Top1157
Node: Copying42777
Ref: Copying-Footnote-171781
Ref: Copying-Footnote-271973
Node: Introduction72162
Ref: Introduction-Footnote-174317
Ref: Introduction-Footnote-274442
Node: Caveats74554
Node: Lisp History76595
Node: Conventions78725
Node: Some Terms79525
Node: nil and t80393
Node: Evaluation Notation82383
Node: Printing Notation83468
Node: Error Messages84482
Node: Buffer Text Notation85033
Node: Format of Descriptions86078
Node: A Sample Function Description86966
Node: A Sample Variable Description91546
Node: Version Info92619
Node: Acknowledgements94206
Node: Lisp Data Types95630
Node: Printed Representation98726
Node: Comments101355
Node: Programming Types102534
Node: Integer Type104329
Node: Floating Point Type105494
Node: Character Type106239
Node: Symbol Type115281
Node: Sequence Type118891
Ref: Sequence Type-Footnote-1121083
Node: Cons Cell Type121134
Node: Dotted Pair Notation126936
Node: Association List Type129727
Node: Array Type130817
Node: String Type132991
Node: Syntax for Strings133809
Node: Non-ASCII in Strings135222
Node: Nonprinting Characters137382
Node: Text Props and Strings139001
Node: Vector Type140416
Node: Char-Table Type141254
Node: Bool-Vector Type142490
Node: Function Type143671
Node: Macro Type145014
Node: Primitive Function Type146071
Node: Byte-Code Type147827
Node: Autoload Type148646
Node: Editing Types149847
Node: Buffer Type150831
Node: Marker Type153707
Node: Window Type154583
Node: Frame Type156310
Node: Window Configuration Type157149
Node: Frame Configuration Type157801
Node: Process Type158468
Node: Stream Type159775
Node: Keymap Type161140
Node: Overlay Type161813
Node: Type Predicates162562
Node: Equality Predicates168083
Node: Numbers171975
Node: Integer Basics173402
Node: Float Basics176014
Node: Predicates on Numbers178278
Node: Comparison of Numbers180050
Node: Numeric Conversions184406
Node: Arithmetic Operations185971
Node: Rounding Operations191990
Node: Bitwise Operations193250
Node: Math Functions202513
Node: Random Numbers204397
Node: Strings and Characters206364
Node: String Basics207800
Node: Predicates for Strings211396
Node: Creating Strings212029
Node: Modifying Strings218402
Node: Text Comparison219637
Node: String Conversion224937
Node: Formatting Strings228954
Node: Case Conversion235280
Node: Case Tables239243
Node: Lists244624
Node: Cons Cells245676
Node: Lists as Boxes247445
Node: List-related Predicates250336
Node: List Elements252436
Node: Building Lists256805
Node: Modifying Lists263531
Node: Setcar264519
Node: Setcdr267349
Node: Rearrangement270214
Node: Sets And Lists277453
Node: Association Lists282430
Ref: Association Lists-Footnote-1291681
Node: Sequences Arrays Vectors291929
Node: Sequence Functions295568
Node: Arrays299468
Node: Array Functions302518
Node: Vectors305193
Node: Vector Functions306950
Node: Char-Tables309920
Node: Bool-Vectors316655
Node: Symbols317736
Node: Symbol Components318986
Node: Definitions324312
Node: Creating Symbols327373
Node: Property Lists336633
Node: Plists and Alists338238
Node: Symbol Plists340291
Node: Other Plists342208
Node: Evaluation343644
Node: Intro Eval344606
Ref: Intro Eval-Footnote-1348710
Node: Forms348855
Node: Self-Evaluating Forms350223
Node: Symbol Forms352010
Node: Classifying Lists353306
Node: Function Indirection354291
Node: Function Forms357974
Node: Macro Forms359133
Node: Special Forms361237
Node: Autoloading363939
Node: Quoting364612
Node: Eval366253
Node: Control Structures372028
Node: Sequencing374122
Node: Conditionals377469
Node: Combining Conditions381906
Node: Iteration385437
Node: Nonlocal Exits387482
Node: Catch and Throw388316
Node: Examples of Catch393106
Node: Errors395409
Node: Signaling Errors397377
Node: Processing of Errors400828
Node: Handling Errors402531
Node: Error Symbols411944
Node: Cleanups416244
Node: Variables420320
Node: Global Variables422558
Node: Constant Variables423947
Node: Local Variables425092
Node: Void Variables431468
Node: Defining Variables435493
Node: Tips for Defining443609
Node: Accessing Variables446302
Node: Setting Variables447805
Node: Variable Scoping452907
Node: Scope454997
Node: Extent457483
Node: Impl of Scope459363
Node: Using Scoping461663
Node: Buffer-Local Variables463740
Node: Intro to Buffer-Local465035
Node: Creating Buffer-Local470434
Node: Default Value479097
Node: Frame-Local Variables483013
Node: Future Local Variables487060
Node: Functions488261
Node: What Is a Function489419
Node: Lambda Expressions494506
Node: Lambda Components495497
Node: Simple Lambda497541
Node: Argument List499391
Node: Function Documentation503828
Node: Function Names506101
Node: Defining Functions509783
Node: Calling Functions512986
Node: Mapping Functions517713
Node: Anonymous Functions521031
Node: Function Cells525456
Node: Inline Functions531700
Node: Related Topics533941
Node: Macros535102
Node: Simple Macro536538
Node: Expansion537388
Node: Compiling Macros540907
Node: Defining Macros543571
Node: Backquote545175
Node: Problems with Macros548220
Node: Argument Evaluation548987
Node: Surprising Local Vars552178
Node: Eval During Expansion554564
Node: Repeated Expansion556570
Node: Customization559636
Node: Common Keywords560295
Node: Group Definitions563867
Node: Variable Definitions567937
Node: Customization Types573227
Node: Simple Types575013
Node: Composite Types577859
Node: Splicing into Lists584227
Node: Type Keywords586375
Node: Loading590277
Node: How Programs Do Loading592599
Node: Library Search598733
Node: Loading Non-ASCII604665
Node: Autoload607412
Node: Repeated Loading615357
Node: Named Features618314
Node: Unloading624543
Node: Hooks for Loading628723
Node: Byte Compilation630862
Node: Speed of Byte-Code633639
Node: Compilation Functions634825
Node: Docs and Compilation642191
Node: Dynamic Loading645766
Node: Eval During Compile649118
Node: Byte-Code Objects650651
Node: Disassembly653508
Node: Advising Functions662043
Node: Simple Advice664280
Node: Defining Advice667464
Node: Around-Advice674941
Node: Computed Advice676704
Node: Activation of Advice678480
Node: Enabling Advice683807
Node: Preactivation685838
Node: Argument Access in Advice689126
Node: Subr Arguments692511
Node: Combined Definition693564
Node: Debugging696548
Node: Debugger698345
Node: Error Debugging699608
Node: Infinite Loops704382
Node: Function Debugging705956
Node: Explicit Debug709404
Node: Using Debugger710363
Node: Debugger Commands712800
Node: Invoking the Debugger717192
Node: Internals of Debugger721521
Node: Edebug726589
Node: Using Edebug728888
Node: Instrumenting731916
Node: Edebug Execution Modes735662
Node: Jumping739846
Node: Edebug Misc743570
Node: Breakpoints745316
Node: Global Break Condition749458
Node: Source Breakpoints750625
Node: Trapping Errors751821
Node: Edebug Views753204
Node: Edebug Eval755560
Node: Eval List756650
Node: Printing in Edebug761205
Node: Trace Buffer763506
Node: Coverage Testing765821
Node: The Outside Context768910
Node: Checking Whether to Stop769740
Node: Edebug Display Update770593
Node: Edebug Recursive Edit773178
Node: Instrumenting Macro Calls775002
Node: Specification List777349
Node: Backtracking786335
Node: Specification Examples788908
Node: Edebug Options791211
Node: Syntax Errors796289
Node: Excess Open797954
Node: Excess Close800335
Node: Compilation Errors802031
Node: Read and Print803693
Node: Streams Intro804860
Node: Input Streams807577
Node: Input Functions813189
Node: Output Streams815480
Node: Output Functions820038
Node: Output Variables825373
Node: Minibuffers828511
Node: Intro to Minibuffers829775
Node: Text from Minibuffer832879
Node: Object from Minibuffer841717
Node: Minibuffer History845310
Node: Completion848564
Node: Basic Completion850754
Node: Minibuffer Completion856248
Node: Completion Commands860776
Node: High-Level Completion866018
Node: Reading File Names871818
Node: Programmed Completion875950
Node: Yes-or-No Queries878709
Node: Multiple Queries884507
Node: Reading a Password889451
Node: Minibuffer Misc890609
Node: Command Loop896089
Node: Command Overview897677
Node: Defining Commands901236
Node: Using Interactive902101
Node: Interactive Codes906997
Node: Interactive Examples915089
Node: Interactive Call916340
Node: Command Loop Info923064
Node: Input Events928137
Node: Keyboard Events930331
Node: Function Keys933756
Node: Mouse Events937329
Node: Click Events938856
Node: Drag Events941996
Node: Button-Down Events943938
Ref: Button-Down Events-Footnote-1945590
Node: Repeat Events945662
Node: Motion Events951232
Node: Focus Events952218
Node: Misc Events954535
Node: Event Examples957963
Node: Classifying Events959388
Node: Accessing Events963489
Node: Strings of Events966651
Node: Reading Input971398
Node: Key Sequence Input972587
Node: Reading One Event977328
Node: Quoted Character Input982598
Node: Event Input Misc984054
Node: Special Events988272
Node: Waiting989785
Node: Quitting993082
Node: Prefix Command Arguments998376
Node: Recursive Editing1004146
Node: Disabling Commands1010247
Node: Command History1012938
Node: Keyboard Macros1014920
Node: Keymaps1018039
Node: Keymap Terminology1019768
Node: Format of Keymaps1023953
Node: Creating Keymaps1028529
Node: Inheritance and Keymaps1030833
Node: Prefix Keys1033068
Node: Active Keymaps1038628
Node: Key Lookup1049698
Node: Functions for Key Lookup1057145
Node: Changing Key Bindings1063714
Node: Key Binding Commands1072980
Node: Scanning Keymaps1075602
Node: Menu Keymaps1081855
Node: Defining Menus1082494
Node: Simple Menu Items1084016
Node: Extended Menu Items1086909
Node: Alias Menu Items1091959
Node: Mouse Menus1093486
Node: Keyboard Menus1096668
Node: Menu Example1098127
Node: Menu Bar1101870
Node: Modifying Menus1106318
Node: Modes1108105
Node: Major Modes1109541
Node: Major Mode Conventions1113595
Node: Example Major Modes1122945
Node: Auto Major Mode1130530
Node: Mode Help1139939
Node: Derived Modes1141221
Node: Minor Modes1143774
Node: Minor Mode Conventions1145620
Node: Keymaps and Minor Modes1149497
Node: Easy-Mmode1150862
Node: Mode Line Format1153483
Node: Mode Line Data1155704
Node: Mode Line Variables1161163
Node: %-Constructs1167224
Node: Imenu1170508
Node: Font Lock Mode1177929
Node: Font Lock Basics1179404
Node: Search-based Fontification1182244
Node: Other Font Lock Variables1188030
Node: Levels of Font Lock1190797
Node: Faces for Font Lock1192249
Node: Syntactic Font Lock1194355
Node: Hooks1195566
Node: Documentation1204155
Node: Documentation Basics1205550
Node: Accessing Documentation1208839
Node: Keys in Documentation1214801
Node: Describing Characters1217683
Node: Help Functions1220646
Node: Files1229629
Node: Visiting Files1231584
Node: Visiting Functions1233664
Node: Subroutines of Visiting1240446
Node: Saving Buffers1242944
Node: Reading from Files1251712
Node: Writing to Files1254924
Node: File Locks1259039
Node: Information about Files1262960
Node: Testing Accessibility1263694
Node: Kinds of Files1268282
Node: Truenames1270299
Node: File Attributes1271306
Node: Changing Files1277307
Node: File Names1283735
Node: File Name Components1285694
Node: Directory Names1289201
Node: Relative File Names1293131
Node: File Name Expansion1294498
Node: Unique File Names1298856
Node: File Name Completion1301652
Node: Standard File Names1304721
Node: Contents of Directories1307444
Node: Create/Delete Dirs1311239
Node: Magic File Names1312260
Node: Format Conversion1319279
Node: Backups and Auto-Saving1326192
Node: Backup Files1327044
Node: Making Backups1329055
Node: Rename or Copy1334718
Node: Numbered Backups1338692
Node: Backup Names1341841
Node: Auto-Saving1346330
Node: Reverting1357977
Node: Buffers1363011
Node: Buffer Basics1364851
Node: Current Buffer1367609
Node: Buffer Names1376253
Node: Buffer File Name1381157
Node: Buffer Modification1387250
Node: Modification Time1390258
Node: Read Only Buffers1394633
Node: The Buffer List1398178
Node: Creating Buffers1404658
Node: Killing Buffers1407514
Node: Indirect Buffers1412320
Node: Buffer Gap1414883
Node: Windows1416206
Node: Basic Windows1418106
Node: Splitting Windows1422503
Node: Deleting Windows1430373
Node: Selecting Windows1434277
Node: Cyclic Window Ordering1438548
Node: Buffers and Windows1443752
Node: Displaying Buffers1448465
Node: Choosing Window1455868
Node: Window Point1466546
Node: Window Start1469545
Node: Vertical Scrolling1476008
Node: Horizontal Scrolling1485032
Node: Size of Window1489306
Ref: Size of Window-Footnote-11494261
Node: Resizing Windows1494432
Node: Coordinates and Windows1499566
Node: Window Configurations1501805
Node: Window Hooks1507213
Node: Frames1511911
Node: Creating Frames1515098
Node: Multiple Displays1516701
Node: Frame Parameters1520291
Node: Parameter Access1521317
Node: Initial Parameters1522177
Node: Window Frame Parameters1525864
Node: Size and Position1537619
Node: Frame Titles1544050
Node: Deleting Frames1545921
Node: Finding All Frames1547427
Node: Frames and Windows1549623
Node: Minibuffers and Frames1551557
Node: Input Focus1553305
Node: Visibility of Frames1558888
Node: Raising and Lowering1561120
Node: Frame Configurations1563390
Node: Mouse Tracking1564137
Node: Mouse Position1566276
Node: Pop-Up Menus1567849
Node: Dialog Boxes1571299
Node: Pointer Shapes1573534
Node: Window System Selections1574754
Node: Font Names1578666
Node: Fontsets1580089
Node: Color Names1584897
Node: Resources1587528
Node: Server Data1588952
Node: Positions1592078
Node: Point1593332
Node: Motion1596627
Node: Character Motion1597468
Node: Word Motion1600112
Node: Buffer End Motion1602043
Node: Text Lines1604068
Node: Screen Lines1609229
Node: List Motion1616638
Node: Skipping Characters1620236
Node: Excursions1623106
Node: Narrowing1626553
Node: Markers1632685
Node: Overview of Markers1633866
Node: Predicates on Markers1637477
Node: Creating Markers1638581
Node: Information from Markers1642383
Node: Marker Insertion Types1643503
Node: Moving Markers1644724
Node: The Mark1646448
Node: The Region1656433
Node: Text1657884
Node: Near Point1661078
Node: Buffer Contents1664896
Node: Comparing Text1668110
Node: Insertion1669935
Node: Commands for Insertion1675574
Node: Deletion1679641
Node: User-Level Deletion1684826
Node: The Kill Ring1689768
Node: Kill Ring Concepts1692486
Node: Kill Functions1693764
Node: Yank Commands1696629
Node: Low-Level Kill Ring1698983
Node: Internals of Kill Ring1702666
Node: Undo1706113
Node: Maintaining Undo1711927
Node: Filling1715181
Node: Margins1723767
Node: Adaptive Fill1729139
Node: Auto Filling1731704
Node: Sorting1733782
Node: Columns1746091
Node: Indentation1748903
Node: Primitive Indent1749722
Node: Mode-Specific Indent1751435
Node: Region Indent1754735
Node: Relative Indent1758534
Node: Indent Tabs1761453
Node: Motion by Indent1763239
Node: Case Changes1764291
Node: Text Properties1768484
Node: Examining Properties1770937
Node: Changing Properties1774154
Node: Property Search1778956
Node: Special Properties1785468
Node: Format Properties1792811
Node: Sticky Properties1793958
Node: Saving Properties1797850
Node: Lazy Properties1801828
Node: Clickable Text1804474
Node: Not Intervals1807898
Node: Substitution1811038
Node: Registers1813036
Node: Transposition1817076
Node: Change Hooks1818134
Node: Non-ASCII Characters1823432
Node: Text Representations1824069
Node: Converting Representations1827362
Node: Selecting a Representation1832084
Node: Character Codes1834178
Node: Character Sets1835392
Node: Chars and Bytes1836855
Node: Splitting Characters1838068
Node: Scanning Charsets1841061
Node: Translation of Characters1842458
Node: Coding Systems1845033
Node: Coding System Basics1845827
Node: Encoding and I/O1849476
Node: Lisp and Coding Systems1852749
Node: User-Chosen Coding Systems1857256
Node: Default Coding Systems1859716
Node: Specifying Coding Systems1866537
Node: Explicit Encoding1869663
Node: Terminal I/O Encoding1873929
Node: MS-DOS File Types1875689
Node: Input Methods1879054
Node: Searching and Matching1882698
Node: String Search1883989
Node: Regular Expressions1890057
Node: Syntax of Regexps1890735
Node: Regexp Example1909394
Node: Regexp Search1911969
Node: POSIX Regexps1918518
Node: Search and Replace1920586
Node: Match Data1924750
Node: Replacing Match1926044
Node: Simple Match Data1929340
Node: Entire Match Data1934451
Node: Saving Match Data1936610
Node: Searching and Case1938287
Node: Standard Regexps1940895
Node: Syntax Tables1943492
Node: Syntax Basics1944901
Node: Syntax Descriptors1947798
Node: Syntax Class Table1949948
Node: Syntax Flags1959145
Node: Syntax Table Functions1963058
Node: Syntax Properties1967558
Node: Motion and Syntax1968885
Node: Parsing Expressions1970344
Node: Standard Syntax Tables1978039
Node: Syntax Table Internals1979130
Node: Categories1981670
Node: Abbrevs1987249
Node: Abbrev Mode1989395
Node: Abbrev Tables1990349
Node: Defining Abbrevs1992370
Node: Abbrev Files1995129
Node: Abbrev Expansion1997660
Node: Standard Abbrev Tables2003801
Node: Processes2005296
Node: Subprocess Creation2007944
Node: Shell Arguments2012098
Node: Synchronous Processes2014122
Node: Asynchronous Processes2023000
Node: Deleting Processes2028542
Node: Process Information2031145
Node: Input to Processes2036773
Node: Signals to Processes2040274
Ref: Signals to Processes-Footnote-12045981
Node: Output from Processes2046058
Node: Process Buffers2048935
Node: Filter Functions2052615
Node: Accepting Output2059139
Node: Sentinels2061258
Node: Transaction Queues2065642
Node: Network2067805
Node: Display2070108
Node: Refresh Screen2071455
Node: Truncation2073099
Node: The Echo Area2076526
Node: Invisible Text2082251
Node: Selective Display2087877
Node: Overlay Arrow2092692
Node: Temporary Displays2094188
Node: Overlays2099632
Node: Overlay Properties2100427
Node: Managing Overlays2108504
Node: Width2112478
Node: Faces2114784
Node: Standard Faces2116292
Node: Defining Faces2117856
Node: Merging Faces2122676
Node: Face Functions2125090
Node: Blinking2132473
Node: Inverse Video2134654
Node: Usual Display2135719
Node: Display Tables2139433
Node: Display Table Format2140646
Node: Active Display Table2144071
Node: Glyphs2146403
Node: Beeping2148335
Node: Window Systems2150045
Node: Calendar2151752
Node: Calendar Customizing2152721
Node: Holiday Customizing2156815
Node: Date Display Format2163834
Node: Time Display Format2164984
Node: Daylight Savings2166020
Node: Diary Customizing2169311
Node: Hebrew/Islamic Entries2174375
Node: Fancy Diary Display2178317
Node: Sexp Diary Entries2181387
Ref: Sexp Diary Entries-Footnote-12188280
Node: Appt Customizing2188418
Node: System Interface2190125
Node: Starting Up2191691
Node: Start-up Summary2192352
Node: Init File2197295
Node: Terminal-Specific2201392
Node: Command Line Arguments2204594
Node: Getting Out2208880
Node: Killing Emacs2209512
Node: Suspending Emacs2211543
Node: System Environment2215329
Node: User Identification2223654
Node: Time of Day2227271
Ref: Time of Day-Footnote-12230485
Node: Time Conversion2230568
Node: Timers2238284
Ref: Timers-Footnote-12245533
Node: Terminal Input2245590
Node: Input Modes2246163
Node: Translating Input2249266
Node: Recording Input2258473
Node: Terminal Output2260295
Node: Special Keysyms2263822
Node: Flow Control2265168
Node: Batch Mode2269948
Node: Antinews2271262
Node: Antinews Emacs 202271989
Node: Antinews Emacs 2032282095
Node: Tips2284565
Node: Coding Conventions2285350
Node: Compilation Tips2301596
Node: Documentation Tips2303917
Node: Comment Tips2312853
Node: Library Headers2316387
Node: GNU Emacs Internals2321927
Node: Building Emacs2322782
Node: Pure Storage2328658
Node: Garbage Collection2332395
Node: Memory Usage2341457
Node: Writing Emacs Primitives2343145
Node: Object Internals2355783
Node: Buffer Internals2357442
Node: Window Internals2362780
Node: Process Internals2367409
Node: Standard Errors2370165
Node: Standard Buffer-Local Variables2375713
Node: Standard Keymaps2379345
Node: Standard Hooks2385441
Node: Index2389909
Node: New Symbols2665266

End Tag Table
